This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: data/vision/fine-tuned/prototypes.json, data/evaluations/vision-confidence.thoth.json, docs/azure_api.md, data/evaluations/vision-confidence.marseille.json, data/evaluations/vision-confidence.json, data/evaluations/vision-confidence.rws.json, .worker/index.js
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  agents/
    mobile-first-designer.md
  instructions/
    cloudflare-functions.instructions.md
    react-components.instructions.md
    tests.instructions.md
  ISSUE_TEMPLATE/
    mobile-first-task.md
  workflows/
    ci.yml
  copilot-instructions.md
.kilocode/
  mcp.json
data/
  evaluations/
    narrative-metrics.json
    narrative-review-queue.csv
    narrative-samples.json
    vision-metrics.json
    vision-review-queue-marseille.csv
    vision-review-queue-thoth.csv
    vision-review-queue.csv
    vision-review-queue.marseille.csv
    vision-review-queue.rws.csv
    vision-review-queue.thoth.csv
  indices/
    marseille/
      index.faiss
      metadata.json
    rws/
      index.faiss
      metadata.json
    thoth/
      index.faiss
      metadata.json
  raw_images/
    marseille/
      clubs01.jpg
      clubs02.jpg
      clubs03.jpg
      clubs04.jpg
      clubs05.jpg
      clubs06.jpg
      clubs07.jpg
      clubs08.jpg
      clubs09.jpg
      clubs10.jpg
      clubs11.jpg
      clubs12.jpg
      clubs13.jpg
      clubs14.jpg
      coins01.jpg
      coins02.jpg
      coins03.jpg
      coins04.jpg
      coins05.jpg
      coins06.jpg
      coins07.jpg
      coins08.jpg
      coins09.jpg
      coins10.jpg
      coins11.jpg
      coins12.jpg
      coins13.jpg
      coins14.jpg
      cups01.jpg
      cups02.jpg
      cups03.jpg
      cups04.jpg
      cups05.jpg
      cups06.jpg
      cups07.jpg
      cups08.jpg
      cups09.jpg
      cups10.jpg
      cups11.jpg
      cups12.jpg
      cups13.jpg
      cups14.jpg
      major00.jpg
      major01.jpg
      major02.jpg
      major03.jpg
      major04.jpg
      major05.jpg
      major06.jpg
      major07.jpg
      major08.jpg
      major09.jpg
      major10.jpg
      major11.jpg
      major12.jpg
      major13.jpg
      major14.jpg
      major15.jpg
      major16.jpg
      major17.jpg
      major18.jpg
      major19.jpg
      major20.jpg
      major21.jpg
      swords01.jpg
      swords02.jpg
      swords03.jpg
      swords04.jpg
      swords05.jpg
      swords06.jpg
      swords07.jpg
      swords08.jpg
      swords09.jpg
      swords10.jpg
      swords11.jpg
      swords12.jpg
      swords13.jpg
      swords14.jpg
    rws/
      RWS1909_-_00_Fool.jpeg
      RWS1909_-_01_Magician.jpeg
      RWS1909_-_02_High_Priestess.jpeg
      RWS1909_-_03_Empress.jpeg
      RWS1909_-_04_Emperor.jpeg
      RWS1909_-_05_Hierophant.jpeg
      RWS1909_-_06_Lovers.jpeg
      RWS1909_-_07_Chariot.jpeg
      RWS1909_-_08_Strength.jpeg
      RWS1909_-_09_Hermit.jpeg
      RWS1909_-_10_Wheel_of_Fortune.jpeg
      RWS1909_-_11_Justice.jpeg
      RWS1909_-_12_Hanged_Man.jpeg
      RWS1909_-_13_Death.jpeg
      RWS1909_-_14_Temperance.jpeg
      RWS1909_-_15_Devil.jpeg
      RWS1909_-_16_Tower.jpeg
      RWS1909_-_17_Star.jpeg
      RWS1909_-_18_Moon.jpeg
      RWS1909_-_19_Sun.jpeg
      RWS1909_-_20_Judgement.jpeg
      RWS1909_-_21_World.jpeg
      RWS1909_-_Cups_01.jpeg
      RWS1909_-_Cups_02.jpeg
      RWS1909_-_Cups_03.jpeg
      RWS1909_-_Cups_04.jpeg
      RWS1909_-_Cups_05.jpeg
      RWS1909_-_Cups_06.jpeg
      RWS1909_-_Cups_07.jpeg
      RWS1909_-_Cups_08.jpeg
      RWS1909_-_Cups_09.jpeg
      RWS1909_-_Cups_10.jpeg
      RWS1909_-_Cups_11.jpeg
      RWS1909_-_Cups_12.jpeg
      RWS1909_-_Cups_13.jpeg
      RWS1909_-_Cups_14.jpeg
      RWS1909_-_Pentacles_01.jpeg
      RWS1909_-_Pentacles_02.jpeg
      RWS1909_-_Pentacles_03.jpeg
      RWS1909_-_Pentacles_04.jpeg
      RWS1909_-_Pentacles_05.jpeg
      RWS1909_-_Pentacles_06.jpeg
      RWS1909_-_Pentacles_07.jpeg
      RWS1909_-_Pentacles_08.jpeg
      RWS1909_-_Pentacles_09.jpeg
      RWS1909_-_Pentacles_10.jpeg
      RWS1909_-_Pentacles_11.jpeg
      RWS1909_-_Pentacles_12.jpeg
      RWS1909_-_Pentacles_13.jpeg
      RWS1909_-_Pentacles_14.jpeg
      RWS1909_-_Swords_01.jpeg
      RWS1909_-_Swords_02.jpeg
      RWS1909_-_Swords_03.jpeg
      RWS1909_-_Swords_04.jpeg
      RWS1909_-_Swords_05.jpeg
      RWS1909_-_Swords_06.jpeg
      RWS1909_-_Swords_07.jpeg
      RWS1909_-_Swords_08.jpeg
      RWS1909_-_Swords_09.jpeg
      RWS1909_-_Swords_10.jpeg
      RWS1909_-_Swords_11.jpeg
      RWS1909_-_Swords_12.jpeg
      RWS1909_-_Swords_13.jpeg
      RWS1909_-_Swords_14.jpeg
      RWS1909_-_Wands_01.jpeg
      RWS1909_-_Wands_02.jpeg
      RWS1909_-_Wands_03.jpeg
      RWS1909_-_Wands_04.jpeg
      RWS1909_-_Wands_05.jpeg
      RWS1909_-_Wands_06.jpeg
      RWS1909_-_Wands_07.jpeg
      RWS1909_-_Wands_08.jpeg
      RWS1909_-_Wands_09.jpeg
      RWS1909_-_Wands_10.jpeg
      RWS1909_-_Wands_11.jpeg
      RWS1909_-_Wands_12.jpeg
      RWS1909_-_Wands_13.jpeg
      RWS1909_-_Wands_14.jpeg
    thoth/
      thoth_cups_01_ace-cups-root-of-water.png
      thoth_cups_02_two-cups-love.png
      thoth_cups_03_three-cups-abundance.png
      thoth_cups_04_four-cups-luxury.png
      thoth_cups_05_five-cups-disappointment.png
      thoth_cups_06_six-cups-pleasure.png
      thoth_cups_07_seven-cups-debauch.png
      thoth_cups_08_eight-cups-indolence.png
      thoth_cups_09_nine-cups-happiness.png
      thoth_cups_10_ten-cups-satiety.png
      thoth_cups_11_princess-cups.png
      thoth_cups_12_prince-cups.png
      thoth_cups_13_queen-cups.png
      thoth_cups_14_knight-cups.png
      thoth_disks_01_ace-disks-root-of-earth.png
      thoth_disks_02_two-disks-change.png
      thoth_disks_03_three-disks-works.png
      thoth_disks_04_four-disks-power.png
      thoth_disks_05_five-disks-worry.png
      thoth_disks_06_six-disks-success.png
      thoth_disks_07_seven-disks-failure.png
      thoth_disks_08_eight-disks-prudence.png
      thoth_disks_09_nine-disks-gain.png
      thoth_disks_10_ten-disks-wealth.png
      thoth_disks_11_princess-disks.png
      thoth_disks_12_prince-disks.png
      thoth_disks_13_queen-disks.png
      thoth_disks_14_knight-disks.png
      thoth_major_00_the-fool.png
      thoth_major_01_the-magus.png
      thoth_major_02_the-priestess.png
      thoth_major_03_the-empress.png
      thoth_major_04_the-emperor.png
      thoth_major_05_the-hierophant.png
      thoth_major_06_the-lovers.png
      thoth_major_07_the-chariot.png
      thoth_major_08_adjustment.png
      thoth_major_09_the-hermit.png
      thoth_major_10_fortune.png
      thoth_major_11_lust.png
      thoth_major_12_the-hanged-man.png
      thoth_major_13_death.png
      thoth_major_14_art.png
      thoth_major_15_the-devil.png
      thoth_major_16_the-tower.png
      thoth_major_17_the-star.png
      thoth_major_18_the-moon.png
      thoth_major_19_the-sun.png
      thoth_major_20_the-aeon.png
      thoth_major_21_the-universe.png
      thoth_swords_01_ace-swords-root-of-air.png
      thoth_swords_02_two-swords-peace.png
      thoth_swords_03_three-swords-sorrow.png
      thoth_swords_04_four-swords-truce.png
      thoth_swords_05_five-swords-defeat.png
      thoth_swords_06_six-swords-science.png
      thoth_swords_07_seven-swords-futility.png
      thoth_swords_08_eight-swords-interference.png
      thoth_swords_09_nine-swords-cruelty.png
      thoth_swords_10_ten-swords-ruin.png
      thoth_swords_11_princess-swords.png
      thoth_swords_12_prince-swords.png
      thoth_swords_13_queen-swords.png
      thoth_swords_14_knight-swords.png
      thoth_wands_01_ace-wands-root-of-fire.png
      thoth_wands_02_two-wands-dominion.png
      thoth_wands_03_three-wands-virtue.png
      thoth_wands_04_four-wands-completion.png
      thoth_wands_05_five-wands-strife.png
      thoth_wands_06_six-wands-victory.png
      thoth_wands_07_seven-wands-valour.png
      thoth_wands_08_eight-wands-swiftness.png
      thoth_wands_09_nine-wands-strength.png
      thoth_wands_10_ten-wands-oppression.png
      thoth_wands_11_princess-wands.png
      thoth_wands_12_prince-wands.png
      thoth_wands_13_queen-wands.png
      thoth_wands_14_knight-wands.png
docs/
  knowledge-graph/
    ARCHETYPAL_DYADS.md
    ARCHETYPAL_TRIADS.md
    FOOLS_JOURNEY.md
    PROJECT_PLAN.md
    README.md
    SUIT_PROGRESSIONS.md
  addnewreversalframeworks.md
  AI_Tarot_Master.md
  ARCHETYPE_JOURNEY_IMPLEMENTATION.md
  context-aware-remedies-implementation.md
  DEPLOYMENT.md
  DEV_SETUP.md
  DEVELOPER_ONBOARDING.md
  gpt51prompt.md
  guidetoaitraining.md
  INTENTION_COACH_ENHANCEMENTS.md
  INTERACTIVE_CARD_TOOLTIPS.md
  JOURNAL_SETUP.md
  journal-gap-assessment.md
  journal-redesign.md
  narrativebuilderenhancements.md
  SYSTEM_ARCHITECTURE.md
  UX_EVALUATION_REPORT.md
  VISION_PIPELINE.md
  VISION_RESEARCH_MODE.md
  WORKERS_MIGRATION.md
functions/
  api/
    archetype-journey/
      [[path]].js
    auth/
      login.js
      logout.js
      me.js
      register.js
    health/
      tarot-reading.js
      tts.js
    journal/
      [id].js
    keys/
      [id].js
      index.js
    share/
      [token].js
    share-notes/
      [token].js
    archetype-journey-backfill.js
    archetype-journey.js
    feedback.js
    generate-question.js
    journal-export.js
    journal-summary.js
    journal.js
    share.js
    tarot-reading.js
    tts-hume.js
    tts.js
    vision-proof.js
  lib/
    __tests__/
      knowledgeGraph.test.js
      spreadAnalysis.test.js
      telemetry.test.js
    narrative/
      spreads/
        celticCross.js
        decision.js
        fiveCard.js
        relationship.js
        singleCard.js
        threeCard.js
      helpers.js
      prompts.js
      styleHelpers.js
    apiKeys.js
    auth.js
    azureResponses.js
    cardContextDetection.js
    contextDetection.js
    embeddings.js
    ephemerisIntegration.js
    ephemerisWorkers.js
    esotericMeta.js
    graphContext.js
    graphRAG.js
    imageryHooks.js
    knowledgeBase.js
    knowledgeGraph.js
    middleware.js
    minorMeta.js
    narrativeBuilder.js
    narrativeSpine.js
    positionWeights.js
    promptEngineering.js
    rateLimit.js
    scheduled.js
    shareData.js
    shareUtils.js
    spreadAnalysis.js
    symbolAnnotations.js
    timingMeta.js
    utils.js
    visionLabels.js
    visionProof.js
migrations/
  0001_initial_schema.sql
  0002_add_auth_and_journals.sql
  0003_add_share_tables.sql
  0004_add_api_keys.sql
  0005_add_archetype_journey.sql
  0006_add_user_preferences.sql
  0007_add_request_id_and_dedup_index.sql
models/
  adapters/
    marseille/
      adapter_config.json
      adapter_model.safetensors
      README.md
    rws/
      adapter_config.json
      adapter_model.safetensors
      README.md
    thoth/
      adapter_config.json
      adapter_model.safetensors
      README.md
plugins/
  tarot-astro-plugins/
    .claude-plugin/
      marketplace.json
    ephemeris-server/
      .claude-plugin/
        plugin.json
      commands/
        astro-reading.md
      ephe/
        semo_18.se1
        sepl_18.se1
      scripts/
        check-ephemeris-files.js
      server/
        ephemeris.js
        index.js
        test.js
      EPHEMERIS_DATA_README.md
      LICENSE
      package.json
      README.md
    symbolism-server/
      .claude-plugin/
        plugin.json
      commands/
        symbol-analysis.md
      data/
        symbols.json
      server/
        database.js
        index.js
        test.js
      package.json
      README.md
    ARCHITECTURE.md
    INSTALL.md
    README.md
    test-servers.sh
public/
  icons/
    icon-192.png
    icon-512.png
    tableu-icon.png
  images/
    cards/
      marseille/
        clubs01.jpg
        clubs02.jpg
        clubs03.jpg
        clubs04.jpg
        clubs05.jpg
        clubs06.jpg
        clubs07.jpg
        clubs08.jpg
        clubs09.jpg
        clubs10.jpg
        clubs11.jpg
        clubs12.jpg
        clubs13.jpg
        clubs14.jpg
        coins01.jpg
        coins02.jpg
        coins03.jpg
        coins04.jpg
        coins05.jpg
        coins06.jpg
        coins07.jpg
        coins08.jpg
        coins09.jpg
        coins10.jpg
        coins11.jpg
        coins12.jpg
        coins13.jpg
        coins14.jpg
        cups01.jpg
        cups02.jpg
        cups03.jpg
        cups04.jpg
        cups05.jpg
        cups06.jpg
        cups07.jpg
        cups08.jpg
        cups09.jpg
        cups10.jpg
        cups11.jpg
        cups12.jpg
        cups13.jpg
        cups14.jpg
        major00.jpg
        major01.jpg
        major02.jpg
        major03.jpg
        major04.jpg
        major05.jpg
        major06.jpg
        major07.jpg
        major08.jpg
        major09.jpg
        major10.jpg
        major11.jpg
        major12.jpg
        major13.jpg
        major14.jpg
        major15.jpg
        major16.jpg
        major17.jpg
        major18.jpg
        major19.jpg
        major20.jpg
        major21.jpg
        swords01.jpg
        swords02.jpg
        swords03.jpg
        swords04.jpg
        swords05.jpg
        swords06.jpg
        swords07.jpg
        swords08.jpg
        swords09.jpg
        swords10.jpg
        swords11.jpg
        swords12.jpg
        swords13.jpg
        swords14.jpg
      thoth/
        thoth_cups_01_ace-cups-root-of-water.png
        thoth_cups_02_two-cups-love.png
        thoth_cups_03_three-cups-abundance.png
        thoth_cups_04_four-cups-luxury.png
        thoth_cups_05_five-cups-disappointment.png
        thoth_cups_06_six-cups-pleasure.png
        thoth_cups_07_seven-cups-debauch.png
        thoth_cups_08_eight-cups-indolence.png
        thoth_cups_09_nine-cups-happiness.png
        thoth_cups_10_ten-cups-satiety.png
        thoth_cups_11_princess-cups.png
        thoth_cups_12_prince-cups.png
        thoth_cups_13_queen-cups.png
        thoth_cups_14_knight-cups.png
        thoth_disks_01_ace-disks-root-of-earth.png
        thoth_disks_02_two-disks-change.png
        thoth_disks_03_three-disks-works.png
        thoth_disks_04_four-disks-power.png
        thoth_disks_05_five-disks-worry.png
        thoth_disks_06_six-disks-success.png
        thoth_disks_07_seven-disks-failure.png
        thoth_disks_08_eight-disks-prudence.png
        thoth_disks_09_nine-disks-gain.png
        thoth_disks_10_ten-disks-wealth.png
        thoth_disks_11_princess-disks.png
        thoth_disks_12_prince-disks.png
        thoth_disks_13_queen-disks.png
        thoth_disks_14_knight-disks.png
        thoth_major_00_the-fool.png
        thoth_major_01_the-magus.png
        thoth_major_02_the-priestess.png
        thoth_major_03_the-empress.png
        thoth_major_04_the-emperor.png
        thoth_major_05_the-hierophant.png
        thoth_major_06_the-lovers.png
        thoth_major_07_the-chariot.png
        thoth_major_08_adjustment.png
        thoth_major_09_the-hermit.png
        thoth_major_10_fortune.png
        thoth_major_11_lust.png
        thoth_major_12_the-hanged-man.png
        thoth_major_13_death.png
        thoth_major_14_art.png
        thoth_major_15_the-devil.png
        thoth_major_16_the-tower.png
        thoth_major_17_the-star.png
        thoth_major_18_the-moon.png
        thoth_major_19_the-sun.png
        thoth_major_20_the-aeon.png
        thoth_major_21_the-universe.png
        thoth_swords_01_ace-swords-root-of-air.png
        thoth_swords_02_two-swords-peace.png
        thoth_swords_03_three-swords-sorrow.png
        thoth_swords_04_four-swords-truce.png
        thoth_swords_05_five-swords-defeat.png
        thoth_swords_06_six-swords-science.png
        thoth_swords_07_seven-swords-futility.png
        thoth_swords_08_eight-swords-interference.png
        thoth_swords_09_nine-swords-cruelty.png
        thoth_swords_10_ten-swords-ruin.png
        thoth_swords_11_princess-swords.png
        thoth_swords_12_prince-swords.png
        thoth_swords_13_queen-swords.png
        thoth_swords_14_knight-swords.png
        thoth_wands_01_ace-wands-root-of-fire.png
        thoth_wands_02_two-wands-dominion.png
        thoth_wands_03_three-wands-virtue.png
        thoth_wands_04_four-wands-completion.png
        thoth_wands_05_five-wands-strife.png
        thoth_wands_06_six-wands-victory.png
        thoth_wands_07_seven-wands-valour.png
        thoth_wands_08_eight-wands-swiftness.png
        thoth_wands_09_nine-wands-strength.png
        thoth_wands_10_ten-wands-oppression.png
        thoth_wands_11_princess-wands.png
        thoth_wands_12_prince-wands.png
        thoth_wands_13_queen-wands.png
        thoth_wands_14_knight-wands.png
      thoth-placeholders-backup/
        thoth_cups_01_ace-cups-root-of-water.png
        thoth_cups_02_two-cups-love.png
        thoth_cups_03_three-cups-abundance.png
        thoth_cups_04_four-cups-luxury.png
        thoth_cups_05_five-cups-disappointment.png
        thoth_cups_06_six-cups-pleasure.png
        thoth_cups_07_seven-cups-debauch.png
        thoth_cups_08_eight-cups-indolence.png
        thoth_cups_09_nine-cups-happiness.png
        thoth_cups_10_ten-cups-satiety.png
        thoth_cups_11_princess-cups.png
        thoth_cups_12_prince-cups.png
        thoth_cups_13_queen-cups.png
        thoth_cups_14_knight-cups.png
        thoth_disks_01_ace-disks-root-of-earth.png
        thoth_disks_02_two-disks-change.png
        thoth_disks_03_three-disks-works.png
        thoth_disks_04_four-disks-power.png
        thoth_disks_05_five-disks-worry.png
        thoth_disks_06_six-disks-success.png
        thoth_disks_07_seven-disks-failure.png
        thoth_disks_08_eight-disks-prudence.png
        thoth_disks_09_nine-disks-gain.png
        thoth_disks_10_ten-disks-wealth.png
        thoth_disks_11_princess-disks.png
        thoth_disks_12_prince-disks.png
        thoth_disks_13_queen-disks.png
        thoth_disks_14_knight-disks.png
        thoth_major_00_the-fool.png
        thoth_major_01_the-magus.png
        thoth_major_02_the-priestess.png
        thoth_major_03_the-empress.png
        thoth_major_04_the-emperor.png
        thoth_major_05_the-hierophant.png
        thoth_major_06_the-lovers.png
        thoth_major_07_the-chariot.png
        thoth_major_08_adjustment.png
        thoth_major_09_the-hermit.png
        thoth_major_10_fortune.png
        thoth_major_11_lust.png
        thoth_major_12_the-hanged-man.png
        thoth_major_13_death.png
        thoth_major_14_art.png
        thoth_major_15_the-devil.png
        thoth_major_16_the-tower.png
        thoth_major_17_the-star.png
        thoth_major_18_the-moon.png
        thoth_major_19_the-sun.png
        thoth_major_20_the-aeon.png
        thoth_major_21_the-universe.png
        thoth_swords_01_ace-swords-root-of-air.png
        thoth_swords_02_two-swords-peace.png
        thoth_swords_03_three-swords-sorrow.png
        thoth_swords_04_four-swords-truce.png
        thoth_swords_05_five-swords-defeat.png
        thoth_swords_06_six-swords-science.png
        thoth_swords_07_seven-swords-futility.png
        thoth_swords_08_eight-swords-interference.png
        thoth_swords_09_nine-swords-cruelty.png
        thoth_swords_10_ten-swords-ruin.png
        thoth_swords_11_princess-swords.png
        thoth_swords_12_prince-swords.png
        thoth_swords_13_queen-swords.png
        thoth_swords_14_knight-swords.png
        thoth_wands_01_ace-wands-root-of-fire.png
        thoth_wands_02_two-wands-dominion.png
        thoth_wands_03_three-wands-virtue.png
        thoth_wands_04_four-wands-completion.png
        thoth_wands_05_five-wands-strife.png
        thoth_wands_06_six-wands-victory.png
        thoth_wands_07_seven-wands-valour.png
        thoth_wands_08_eight-wands-swiftness.png
        thoth_wands_09_nine-wands-strength.png
        thoth_wands_10_ten-wands-oppression.png
        thoth_wands_11_princess-wands.png
        thoth_wands_12_prince-wands.png
        thoth_wands_13_queen-wands.png
        thoth_wands_14_knight-wands.png
      RWS1909_-_00_Fool.jpeg
      RWS1909_-_01_Magician.jpeg
      RWS1909_-_02_High_Priestess.jpeg
      RWS1909_-_03_Empress.jpeg
      RWS1909_-_04_Emperor.jpeg
      RWS1909_-_05_Hierophant.jpeg
      RWS1909_-_06_Lovers.jpeg
      RWS1909_-_07_Chariot.jpeg
      RWS1909_-_08_Strength.jpeg
      RWS1909_-_09_Hermit.jpeg
      RWS1909_-_10_Wheel_of_Fortune.jpeg
      RWS1909_-_11_Justice.jpeg
      RWS1909_-_12_Hanged_Man.jpeg
      RWS1909_-_13_Death.jpeg
      RWS1909_-_14_Temperance.jpeg
      RWS1909_-_15_Devil.jpeg
      RWS1909_-_16_Tower.jpeg
      RWS1909_-_17_Star.jpeg
      RWS1909_-_18_Moon.jpeg
      RWS1909_-_19_Sun.jpeg
      RWS1909_-_20_Judgement.jpeg
      RWS1909_-_21_World.jpeg
      RWS1909_-_Cups_01.jpeg
      RWS1909_-_Cups_02.jpeg
      RWS1909_-_Cups_03.jpeg
      RWS1909_-_Cups_04.jpeg
      RWS1909_-_Cups_05.jpeg
      RWS1909_-_Cups_06.jpeg
      RWS1909_-_Cups_07.jpeg
      RWS1909_-_Cups_08.jpeg
      RWS1909_-_Cups_09.jpeg
      RWS1909_-_Cups_10.jpeg
      RWS1909_-_Cups_11.jpeg
      RWS1909_-_Cups_12.jpeg
      RWS1909_-_Cups_13.jpeg
      RWS1909_-_Cups_14.jpeg
      RWS1909_-_Pentacles_01.jpeg
      RWS1909_-_Pentacles_02.jpeg
      RWS1909_-_Pentacles_03.jpeg
      RWS1909_-_Pentacles_04.jpeg
      RWS1909_-_Pentacles_05.jpeg
      RWS1909_-_Pentacles_06.jpeg
      RWS1909_-_Pentacles_07.jpeg
      RWS1909_-_Pentacles_08.jpeg
      RWS1909_-_Pentacles_09.jpeg
      RWS1909_-_Pentacles_10.jpeg
      RWS1909_-_Pentacles_11.jpeg
      RWS1909_-_Pentacles_12.jpeg
      RWS1909_-_Pentacles_13.jpeg
      RWS1909_-_Pentacles_14.jpeg
      RWS1909_-_Swords_01.jpeg
      RWS1909_-_Swords_02.jpeg
      RWS1909_-_Swords_03.jpeg
      RWS1909_-_Swords_04.jpeg
      RWS1909_-_Swords_05.jpeg
      RWS1909_-_Swords_06.jpeg
      RWS1909_-_Swords_07.jpeg
      RWS1909_-_Swords_08.jpeg
      RWS1909_-_Swords_09.jpeg
      RWS1909_-_Swords_10.jpeg
      RWS1909_-_Swords_11.jpeg
      RWS1909_-_Swords_12.jpeg
      RWS1909_-_Swords_13.jpeg
      RWS1909_-_Swords_14.jpeg
      RWS1909_-_Wands_01.jpeg
      RWS1909_-_Wands_02.jpeg
      RWS1909_-_Wands_03.jpeg
      RWS1909_-_Wands_04.jpeg
      RWS1909_-_Wands_05.jpeg
      RWS1909_-_Wands_06.jpeg
      RWS1909_-_Wands_07.jpeg
      RWS1909_-_Wands_08.jpeg
      RWS1909_-_Wands_09.jpeg
      RWS1909_-_Wands_10.jpeg
      RWS1909_-_Wands_11.jpeg
      RWS1909_-_Wands_12.jpeg
      RWS1909_-_Wands_13.jpeg
      RWS1909_-_Wands_14.jpeg
    deck-art/
      marseille.png
      rws.png
      thoth.png
    spread-art/
      celtic.png
      decision.png
      fiveCard.png
      relationship.png
      single.png
      threeCard.png
    thoth-scans/
      thoth_0436_card_01.jpg
      thoth_0436_card_02.jpg
      thoth_0436_card_03.jpg
      thoth_0436_card_04.jpg
      thoth_0436_card_05.jpg
      thoth_0437_card_01.jpg
      thoth_0437_card_02.jpg
      thoth_0437_card_03.jpg
      thoth_0437_card_04.jpg
      thoth_0437_card_05.jpg
      thoth_0438_card_01.jpg
      thoth_0438_card_02.jpg
      thoth_0438_card_03.jpg
      thoth_0438_card_04.jpg
      thoth_0438_card_05.jpg
      thoth_0440_card_01.jpg
      thoth_0440_card_02.jpg
      thoth_0440_card_03.jpg
      thoth_0440_card_04.jpg
      thoth_0441_card_01.jpg
      thoth_0441_card_02.jpg
      thoth_0441_card_03.jpg
      thoth_0441_card_04.jpg
      thoth_0441_card_05.jpg
      thoth_0443_card_01.jpg
      thoth_0443_card_02.jpg
      thoth_0443_card_03.jpg
      thoth_0443_card_04.jpg
      thoth_0444_card_01.jpg
      thoth_0444_card_02.jpg
      thoth_0444_card_03.jpg
      thoth_0444_card_04.jpg
      thoth_0444_card_05.jpg
      thoth_0445_card_01.jpg
      thoth_0445_card_02.jpg
      thoth_0445_card_03.jpg
      thoth_0445_card_04.jpg
      thoth_0445_card_05.jpg
      thoth_0446_card_01.jpg
      thoth_0446_card_02.jpg
      thoth_0446_card_03.jpg
      thoth_0446_card_04.jpg
      thoth_0446_card_05.jpg
    card-back.png
    IMG_0436.JPG
    IMG_0437.JPG
    IMG_0438.JPG
    IMG_0440.JPG
    IMG_0441.JPG
    IMG_0443.JPG
    IMG_0444.JPG
    IMG_0445.JPG
    IMG_0446.JPG
    logo.png
    tableu-logo-new.png
    tableu-logo.png
    tableu-logo.PNG
    Tableu-logo.png
    tableu-sprite.svg
    Tableu2-logo.png
    Tableu3-logo.png
  sounds/
    ambience.mp3
    flip.mp3
  cardback.png
  manifest.webmanifest
  offline.html
  sw.js
scripts/
  assets/
    generate_thoth_placeholders_enhanced.py
    generate_thoth_placeholders.py
    install_thoth_scans.sh
    map_thoth_scans.json
    splice_card_photos_simple.py
    splice_card_photos.py
  evaluation/
    lib/
      csv.js
    computeNarrativeMetrics.js
    computeVisionMetrics.js
    processNarrativeReviews.js
    processVisionReviews.js
    runNarrativeSamples.js
    runVisionConfidence.js
    verifyNarrativeGate.js
    verifyVisionGate.js
  training/
    buildMultimodalDataset.js
    buildVectorIndex.py
    buildVisionPrototypes.js
    exportReadings.js
    README.md
    requirements.txt
    testIndex.py
    trainLoRA.py
  vision/
    runVisionPrototype.js
  check-azure-tts.mjs
  checkEnv.js
  fix-and-deploy.sh
  migrate-secrets.sh
  setup-all-environments.sh
  setup-cloudflare-env.sh
  setup-my-secrets.sh
  setup-secrets.sh
  test-azure-responses.mjs
  test-azure-tts-simple.sh
  test-azure-tts.mjs
  test-azure-wrapper.sh
  test-graphrag-demo.mjs
  viewPrompts.js
selectorimages/
  3card-1280.avif
  3card-1280.webp
  3card-640.avif
  3card-640.webp
  3card.png
  5card-1280.avif
  5card-1280.webp
  5card-640.avif
  5card-640.webp
  5card.png
  celticcross-1280.avif
  celticcross-1280.webp
  celticcross-640.avif
  celticcross-640.webp
  celticcross.png
  decision-1280.avif
  decision-1280.webp
  decision-640.avif
  decision-640.webp
  decision.png
  decks.png
  marseille.jpeg
  onecard-1280.avif
  onecard-1280.webp
  onecard-640.avif
  onecard-640.webp
  onecard.png
  relationshipsnapshot-1280.avif
  relationshipsnapshot-1280.webp
  relationshipsnapshot-640.avif
  relationshipsnapshot-640.webp
  relationshipsnapshot.png
  rider.jpeg
  spreadissues.jpeg
  Thoth.jpeg
shared/
  contracts/
    readingSchema.js
  journal/
    stats.js
    summary.js
  symbols/
    symbolAnnotations.js
  vision/
    cardNameMapping.js
    deckAssets.js
    deckProfiles.js
    fineTuneCache.js
    minorSymbolLexicon.js
    symbolDetector.js
    tarotVisionPipeline.js
    visionBackends.js
    visualSemantics.js
  fallbackAudio.js
src/
  components/
    onboarding/
      AccountSetup.jsx
      index.js
      JournalIntro.jsx
      JourneyBegin.jsx
      OnboardingProgress.jsx
      OnboardingWizard.jsx
      QuestionCrafting.jsx
      RitualIntro.jsx
      SpreadEducation.jsx
      WelcomeHero.jsx
    share/
      CollaborativeNotesPanel.jsx
      SharedSpreadView.jsx
    ArchetypeJourney.jsx
    ArchetypeJourneySection.jsx
    AudioControls.jsx
    AuthModal.jsx
    CameraCapture.jsx
    Card.jsx
    CardModal.jsx
    CardSymbolInsights.jsx
    CarouselDots.jsx
    CoachSuggestion.jsx
    ConfirmModal.jsx
    DeckPile.jsx
    DeckRitual.jsx
    DeckSelector.jsx
    ExperienceSettings.jsx
    FeedbackPanel.jsx
    GlobalNav.jsx
    GlowToggle.jsx
    GuidedIntentionCoach.jsx
    Header.jsx
    HelperToggle.jsx
    HumeAudioControls.jsx
    Icon.jsx
    icons.js
    ImagePreview.jsx
    InlineStatus.jsx
    InsightsErrorBoundary.jsx
    InteractiveCardOverlay.jsx
    Journal.jsx
    JournalEntryCard.jsx
    JournalFilters.jsx
    JournalInsightsPanel.jsx
    MarkdownRenderer.jsx
    MobileActionBar.jsx
    MobileInfoSection.jsx
    MobileSettingsDrawer.jsx
    PersonalizationBanner.jsx
    PhotoInputModal.jsx
    QuestionInput.jsx
    ReadingDisplay.jsx
    ReadingGrid.jsx
    ReadingPreparation.jsx
    RitualControls.jsx
    SavedIntentionsList.jsx
    SpreadPatterns.jsx
    SpreadPatternThumbnail.jsx
    SpreadSelector.jsx
    SpreadTable.jsx
    StepProgress.jsx
    StreamingNarrative.jsx
    TableuLogo.example.jsx
    TableuLogo.jsx
    Tooltip.jsx
    UserMenu.jsx
    VisionHeatmapOverlay.jsx
    VisionValidationPanel.jsx
  contexts/
    AuthContext.jsx
    PreferencesContext.jsx
    ReadingContext.jsx
    ToastContext.jsx
  data/
    emotionMapping.js
    exampleQuestions.js
    knowledgeGraphData.js
    majorArcana.js
    minorArcana.js
    spreads.js
    symbolCoordinates.js
  hooks/
    useAudioController.js
    useBodyScrollLock.js
    useFeatureFlags.js
    useInlineStatus.js
    useJournal.js
    useLandscape.js
    useModalA11y.js
    useReducedMotion.js
    useSaveReading.js
    useSmallScreen.js
    useTarotState.js
    useVisionAnalysis.js
    useVisionValidation.js
  lib/
    archetypeJourney.js
    audio.js
    audioCache.js
    audioHume.js
    cardInsights.js
    cardLookup.js
    coachStorage.js
    deck.js
    formatting.js
    intentionCoach.js
    journalInsights.js
    pdfExport.js
    questionQuality.js
    textUtils.js
    themeText.js
  pages/
    ShareReading.jsx
  styles/
    tailwind.css
    tarot.css
    theme.css
  utils/
    personalization.js
  worker/
    index.js
  main.jsx
  TarotReading.jsx
tests/
  accessibility/
    contrast-checker.mjs
    README.md
    wcag-analyzer.mjs
  ambiguous-card-detection.test.mjs
  api.validatePayload.test.mjs
  api.vision.test.mjs
  astroRelevanceGate.test.mjs
  deck.test.mjs
  elementalRemedies.test.mjs
  elementalRemediesIntegration.test.mjs
  embeddings.test.mjs
  ephemerisForecastHighlights.test.mjs
  graphContext.test.mjs
  graphRAG.test.mjs
  intentionCoach.determinism.test.mjs
  intentionCoach.journalIntegration.test.mjs
  journal-export.test.mjs
  journalInsights.test.mjs
  narrativeBuilder.promptCompliance.test.mjs
  narrativeBuilder.reversal.test.mjs
  narrativeSpine.test.mjs
  promptEngineering.test.mjs
  questionQuality.test.mjs
  readingSchema.test.mjs
  scheduled.test.mjs
  tts-hume.test.mjs
  tts.test.mjs
  visionWeaving.test.mjs
.assetsignore
.dev.vars.example
.env.example
.gitignore
.mcp.example.json
AGENTS.md
cardback.png
CLAUDE.md
dev.sh
eslint.config.js
GEMINI.md
HUME_INTEGRATION.md
HUME_QUICKSTART.md
index.html
JOURNAL_IMPROVEMENTS_TODO.md
logo.png
Newlogo.png
package.json
postcss.config.cjs
README.md
rename.py
tailwind.config.js
test-telemetry.js
test-tts-now.sh
vite.config.js
wrangler.jsonc
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".github/agents/mobile-first-designer.md">
---
name: mobile-first-designer
description: Specializes in mobile-first responsive design for React components using Tailwind CSS, optimized for the Mystic Tarot application
tools: ["*"]
---

You are a mobile-first design specialist focused on creating responsive, touch-friendly React components with Tailwind CSS. You have deep expertise in the Mystic Tarot application architecture and its design system.

## Core Principles

### Mobile-First Approach
- Always start with mobile styles as the base, then progressively enhance for larger screens
- Use Tailwind's responsive prefixes (`sm:`, `md:`, `lg:`, `xl:`) to layer desktop styles on top of mobile defaults
- Target touch interfaces first: minimum 44x44px touch targets, generous padding, thumb-friendly positioning

### Project-Specific Breakpoints
This project uses these breakpoints (defined in `tailwind.config.js`):
- `xs: 375px` - Small phones
- `sm: 640px` - Large phones / small tablets
- `md: 768px` - Tablets
- `lg: 1024px` - Laptops
- `xl: 1280px` - Desktops
- `2xl: 1536px` - Large screens

### Design System Colors
Use the established color tokens from `tailwind.config.js`:
- **Backgrounds**: `bg-main`, `bg-surface`, `bg-surface-muted`
- **Text**: `text-main`, `text-muted`, `text-muted-high`, `text-accent`
- **Brand**: `primary`, `secondary`, `accent`, `gold`, `gold-muted`, `gold-soft`
- **Suits**: `wands`, `cups`, `swords`, `pentacles`
- **Neutrals**: `charcoal`, `slate-dark`, `slate-mid`, `slate-light`, `silver`

### Safe Area Support
For modern mobile devices with notches/dynamic islands:
- Use `p-safe-top`, `p-safe-bottom`, `p-safe-left`, `p-safe-right` for padding
- Use `m-safe-top`, `m-safe-bottom`, `m-safe-left`, `m-safe-right` for margins

## Implementation Guidelines

### Component Structure
1. **Check existing hooks**: Use `useSmallScreen(breakpoint)` and `useReducedMotion()` from `src/hooks/`
2. **Icons**: Use Phosphor Icons (`@phosphor-icons/react`) - already in the project
3. **Animations**: Use Framer Motion (`motion`, `useAnimation`) with reduced motion support
4. **Haptics**: Use the vibrate pattern for touch feedback on mobile

### Responsive Patterns

```jsx
// Mobile-first class ordering (CORRECT)
<div className="px-4 py-3 sm:px-6 sm:py-4 md:px-8 lg:px-12">

// Touch-friendly buttons
<button className="min-h-[44px] min-w-[44px] px-4 py-3 sm:py-2">

// Mobile stack → Desktop row
<div className="flex flex-col gap-4 sm:flex-row sm:gap-6">

// Mobile full-width → Desktop constrained
<div className="w-full sm:w-auto sm:max-w-md">

// Hide on mobile, show on desktop (or vice versa)
<div className="hidden sm:block">  // Desktop only
<div className="sm:hidden">        // Mobile only
```

### Typography for Mobile
- Use `text-xs-plus` (14px) or `text-sm-mobile` (15px) for improved mobile readability
- Ensure sufficient line height for touch scrolling
- Consider `truncate` or `line-clamp-*` for constrained mobile layouts

### Touch Interactions
- Provide visual feedback: `active:scale-95`, `active:opacity-80`
- Use `touch-manipulation` to prevent 300ms delay
- Implement swipe gestures where appropriate using Framer Motion's drag handlers

### Existing Mobile Components to Reference
- `MobileActionBar.jsx` - Bottom action bar pattern
- `MobileSettingsDrawer.jsx` - Slide-in drawer pattern
- `MobileInfoSection.jsx` - Collapsible info sections
- `Card.jsx` - Shows responsive card sizing and touch handling
- `SpreadSelector.jsx` - Mobile carousel/grid patterns

### Animations
Use existing keyframes from the config:
- `animate-fade-in` - Quick fade (0.2s)
- `animate-slide-up` - Bottom sheet entrance (0.3s)
- `animate-pop-in` - Scale entrance (0.2s)
- `animate-slide-in-right` - Drawer entrance (0.3s)
- `animate-fade-in-up` - Card reveal (0.6s)
- `animate-ink-spread` - Mystical reveal effect (0.5s)

Always wrap animations in reduced motion checks:
```jsx
const prefersReducedMotion = useReducedMotion();
// Use duration: 0 or skip animation when prefersReducedMotion is true
```

## Quality Checklist

Before completing any component work, verify:

1. **Mobile base styles are defined first** - No `sm:` prefix on base mobile styles
2. **Touch targets are 44px minimum** - Buttons, links, interactive elements
3. **Safe areas are respected** - For fixed/sticky elements
4. **Reduced motion is supported** - All animations have fallbacks
5. **Text is readable** - 16px minimum for body text on mobile to prevent zoom
6. **Spacing is generous** - Use `gap-4` or larger between touch elements
7. **Scrolling is smooth** - Use `-webkit-overflow-scrolling: touch` or Tailwind's scroll utilities
8. **Forms are mobile-optimized** - Appropriate input types, autocomplete attributes

## Anti-Patterns to Avoid

- Using `hover:` states as the only interaction feedback (touch devices don't hover)
- Fixed pixel widths that break on small screens
- Tiny close buttons or icons without padding
- Nested scrolling containers without explicit dimensions
- Desktop-first classes that require `sm:` overrides for mobile
- Using `cursor-pointer` as primary click affordance (touch users don't see cursors)

## Testing Guidance

Recommend testing on:
- iPhone SE (375px) - smallest common viewport
- iPhone 14 Pro (393px) - with Dynamic Island safe areas
- iPad Mini (768px) - tablet breakpoint
- Desktop (1280px+) - ensure desktop experience isn't degraded

Use browser DevTools device emulation and test actual touch behavior when possible.
</file>

<file path=".github/instructions/cloudflare-functions.instructions.md">
---
applyTo: "functions/**/*.js"
---

# Cloudflare Pages Functions Guidelines

## Environment
- Functions run in Cloudflare Workers (not Node.js)
- Use ESM syntax (`import`/`export`)
- Access environment via `env` parameter, not `process.env`

## Security
- Never log API keys, secrets, or PII
- Validate all input using `validatePayload()` pattern
- Rate limit sensitive endpoints using Cloudflare KV

## API Endpoints
- Return consistent response shapes: `{ reading, provider, themes, context, spreadAnalysis }`
- Include proper CORS headers when needed
- Handle errors gracefully with informative (but not revealing) messages

## Tarot Reading Pipeline
- Use `performSpreadAnalysis()` as the canonical analyzer
- Narrative generation order: Azure GPT → Claude → local fallback
- Never invent cards or add cards not in `cardsInfo[]`
- Follow ethics guidelines from `CLAUDE.md`: no absolute predictions, no medical/legal/financial advice

## Knowledge Graph
- Pattern detection via `detectAllPatterns()` and `getPriorityPatternNarratives()`
- Limit patterns to high-value ones (triads, Fool's Journey, dyads)
- Update tests when extending patterns or spread analysis

## TTS Endpoint
- Preserve health response shape: `{ status, provider, timestamp }`
- Azure GPT-4o-mini TTS is primary; local WAV tone is fallback
</file>

<file path=".github/instructions/react-components.instructions.md">
---
applyTo: "src/components/**/*.jsx"
---

# React Component Guidelines

## Component Structure
- Use functional React components with hooks only
- Keep components presentational—receive props, avoid global side effects
- Export components as named exports unless they are the main entry point

## Styling
- Use Tailwind CSS utilities as the primary styling approach
- Reference existing utility classes from `src/styles/tarot.css` (e.g., `.modern-surface`, `.ai-panel-modern`, `.tarot-card-*`)
- Use CSS variable suit accents for card-related components
- Avoid inline styles; prefer composing existing Tailwind classes

## Accessibility
- Maintain proper ARIA labels and roles
- Preserve existing focus-visible ring styles for interactive elements
- Respect `prefers-reduced-motion` for animations
- Ensure touch targets are at least 44×44px for mobile

## Card Components
- `Card.jsx` expects `.tarot-card-*` CSS hooks
- Keep the back/face split logic intact
- Preserve upright vs reversed class handling
- Maintain `isMinor`/`getMinorPipCount` logic

## Layout
- Use Celtic Cross grid utilities (`.cc-grid` + `.cc-*` areas) for 10-card layouts
- Don't re-encode grid rules in JSX—lean on existing responsive CSS

## Theming
- Theme toggling is done by toggling `light` class on `<html>`
- Add light-mode overrides in `tarot.css` alongside existing ones
</file>

<file path=".github/instructions/tests.instructions.md">
---
applyTo: "tests/**/*.mjs"
---

# Testing Guidelines

## Framework
- Use Node.js native test runner (`node --test`)
- Test files use `.test.mjs` extension
- Tests are located in `tests/` directory

## Test Structure
- Mirror source file names in test names
- Group related tests using `describe` blocks
- Keep tests fast and deterministic
- Cover edge cases and error paths, not just happy paths

## Running Tests
```bash
npm test                    # Run all tests
npm run gate:vision        # Vision quality gates
npm run gate:narrative     # Narrative quality gates
```

## Mocking
- Stub external services (Azure, Anthropic APIs)
- Mock environment variables using test fixtures
- For hooks, use context/provider wrappers

## Key Test Files
- `deck.test.mjs` — Deck shuffling, seeding, drawing logic
- `api.validatePayload.test.mjs` — API payload validation
- `narrativeSpine.test.mjs` — Narrative structure validation
- `knowledgeGraph.test.js` — Knowledge graph patterns (in `functions/lib/__tests__/`)

## When Adding New Features
- Add corresponding tests before merging
- Run `npm test` before pushing
- If touching vision/narrative code, also run the relevant `gate:*` command
</file>

<file path=".github/ISSUE_TEMPLATE/mobile-first-task.md">
---
name: Mobile-First Design Task
about: Task for the mobile-first-designer agent
title: "[Mobile] "
labels: mobile, responsive, ui
assignees: ''
---

## Summary
<!-- One sentence describing what needs to be fixed or improved -->

## Problem
<!-- Describe the current mobile/responsive issue. Include:
- What breaks or looks wrong
- Which screen sizes are affected (e.g., <375px, 375-640px, tablet)
- Screenshots or device names if helpful
-->

## Components in Scope

| Component | File Path | Priority | Key Issues |
|-----------|-----------|----------|------------|
| | `src/components/` | Critical/High/Medium | |
| | `src/components/` | | |

## Acceptance Criteria
<!-- Checklist of what "done" looks like -->

- [ ] Works on 375px viewport (iPhone SE)
- [ ] Works on 393px viewport (iPhone 14 Pro with Dynamic Island)
- [ ] Works on 768px viewport (iPad Mini)
- [ ] Touch targets are 44x44px minimum
- [ ] No horizontal overflow or scroll
- [ ] Safe areas handled for notched devices
- [ ] Reduced motion preferences respected
- [ ] Existing desktop experience preserved

## Specific Fixes Required

### 1. [Fix Name]
<!-- Describe what needs to change -->

**Current behavior:**
<!-- What happens now -->

**Expected behavior:**
<!-- What should happen -->

**Files to modify:**
- `src/components/Example.jsx`

### 2. [Fix Name]
<!-- Repeat as needed -->

## Technical Constraints

- Use existing design tokens from `tailwind.config.js`
- Use existing hooks: `useSmallScreen()`, `useReducedMotion()`
- Follow mobile-first class ordering (base → sm: → md: → lg:)
- Maintain accessibility (ARIA labels, focus management)

## Testing Checklist

- [ ] Chrome DevTools device emulation
- [ ] iPhone SE (375px) - smallest common viewport
- [ ] iPhone 14 Pro (393px) - Dynamic Island safe areas
- [ ] iPad Mini (768px) - tablet breakpoint
- [ ] Landscape orientation tested
- [ ] Touch interactions tested (not just click)

## References
<!-- Links to designs, related issues, or documentation -->

- Agent: `@mobile-first-designer`
- Tailwind config: `tailwind.config.js`
- Related issue: #
</file>

<file path=".github/workflows/ci.yml">
name: CI

on:
  push:
    branches:
      - main
      - master
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm test

      - name: Vision QA gate
        run: npm run ci:vision-check

      - name: Narrative QA gate
        run: npm run ci:narrative-check
</file>

<file path=".github/copilot-instructions.md">
# Tableau – AI coding guide

## Architecture & entrypoints
- React+Vite SPA in `src/` with routes defined in `src/main.jsx` (`/` → `TarotReading.jsx`, `/journal` → `components/Journal.jsx`).
- Cloudflare Pages Functions in `functions/api/`:
  - `tarot-reading.js` – spread analysis + narrative generation.
  - `tts.js` – Azure OpenAI TTS bridge with local waveform fallback.
- Card data and spreads live in `src/data/`; analysis and narrative logic live server-side under `functions/lib/` (including `narrative/`, `spreadAnalysis.js`, `knowledgeGraph.js`).

## Dev & test workflow
- Node ESM everywhere (`"type": "module"`); use `import`/`export` and `.test.mjs` for tests.
- Frontend dev: `npm run dev` (Vite at 5173). Full stack: `npm run build` then `npx wrangler pages dev dist` (uses `.dev.vars`).
- Tests: `npm test` (Node’s test runner over `tests/*.test.mjs`, e.g. `deck.test.mjs`, `api.validatePayload.test.mjs`, `narrativeSpine.test.mjs`). Add new tests here and keep them fast and deterministic.

## Tarot flow on the client (`TarotReading.jsx`)
- Builds spreads via `SPREADS` (`src/data/spreads.js`) and deck helpers in `src/lib/deck.js` (`computeSeed`, `drawSpread`, `computeRelationships`); preserve seeded determinism (question + knocks + cut) for reproducible draws.
- Manages question, ritual, reveal state, reflections, and then POSTs to `/api/tarot-reading` with `{ spreadInfo: { name }, cardsInfo: [...] }`.
- Persists user state in localStorage (`tarot-voice-enabled`, `tarot-ambience-enabled`, `tarot-theme`, `tarot_journal`); do not change these shapes without migration logic.

## `functions/api/tarot-reading.js` contract & pipeline
- Payload validation is centralized in `validatePayload()` (card counts via `SPREAD_NAME_MAP`, required fields on `cardsInfo[]`). When adding spreads, update `SPREAD_NAME_MAP` and `tests/api.validatePayload.test.mjs`.
- `performSpreadAnalysis()` is the canonical analyzer:
  - Builds `themes` (suits, elements, reversals, timing) and per-spread `spreadAnalysis` using `functions/lib/spreadAnalysis.js` and `functions/lib/knowledgeGraph.js`.
  - Response shape includes `{ reading, provider, themes, context, spreadAnalysis }`; the UI should trust these server fields instead of re-deriving analysis.
- Narrative generation:
  - Primary: `generateWithAzureGPT5Responses()` (Azure Responses API; env: `AZURE_OPENAI_ENDPOINT`, `AZURE_OPENAI_API_KEY`, `AZURE_OPENAI_GPT5_MODEL`, optional `AZURE_OPENAI_API_VERSION`).
  - Fallback: `composeReadingEnhanced()` → spread builders in `functions/lib/narrative/spreads/*.js` + `narrativeSpine.js` to enforce the “what / why / what’s next” story spine.
  - Keep prompts and builders aligned with `CLAUDE.md` ethics: no invented cards, no absolute predictions, and no medical/legal/financial or crisis advice.

## Knowledge graph & tarot semantics
- Tarot pattern system is documented in `docs/knowledge-graph/*.md` and implemented in `functions/lib/knowledgeGraph.js` (+ `functions/lib/spreadAnalysis.js`).
- `detectAllPatterns()` + `getPriorityPatternNarratives()` select at most a small set of high-value patterns (triads, Fool’s Journey stage, dyads); avoid adding APIs that flood the UI with low-signal combinations.
- When extending patterns or spread analysis, update the docs and tests (`functions/lib/__tests__/knowledgeGraph.test.js`) so new behavior is well-specified.

## Audio, UX, and safety
- Audio: `src/lib/audio.js` orchestrates ambience and narration against `/api/tts`; `functions/api/tts.js` prefers Azure GPT‑4o‑mini TTS (`AZURE_OPENAI_TTS_ENDPOINT`, `AZURE_OPENAI_TTS_API_KEY`, `AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT`) and falls back to a local WAV tone. Preserve the `GET /api/tts` health response shape `{ status, provider, timestamp }`.
- UI: `Card.jsx`, `ReadingGrid.jsx`, and `styles/tarot.css` intentionally avoid copyrighted deck art; keep geometry/typography–only visuals and existing ARIA / reduced-motion behaviors.
- Ethics: treat readings as reflective guidance. Any new copy, prompts, or features should:
  - Emphasize agency and free will, not fixed fate.
  - Avoid diagnosing, prescribing, or replacing professional help for health, safety, legal, or financial issues.
  - Stay inclusive and trauma‑aware in tone (see `CLAUDE.md` for reference language).

## React & styling conventions
- Components: functional React with hooks only; keep `TarotReading.jsx` as the orchestration layer and keep `src/components/*` mostly presentational (receive props, no global side effects).
- Styling: Tailwind-first via `src/styles/tailwind.css` with small, semantic utility classes in `tarot.css` (`.modern-surface`, `.ai-panel-modern`, `.tarot-card-*`, `.cc-grid`). Prefer composing existing classes over introducing new ad-hoc colors or globals.
- Cards: `Card.jsx` expects the `.tarot-card-*` CSS hooks and CSS variable suit accents; if you adjust card layout, keep the back/face split, upright vs reversed classes, and `isMinor`/`getMinorPipCount` logic intact.
- Layout: use the Celtic Cross grid utilities (`.cc-grid` + `.cc-*` areas) for 10-card layouts; don’t re-encode grid rules in JSX—lean on the existing responsive CSS.
- Theming & motion: theme toggling is done by toggling `light` on `<html>`; add light-mode overrides in `tarot.css` alongside existing ones. Respect `prefers-reduced-motion` (see `flipCard` keyframes and scroll-behavior) and the focus-visible ring styles when adding interactive elements.

## Environment setup
- Copy `.dev.vars.example` to `.dev.vars` and fill in secrets (never commit populated `.dev.vars`).
- Required secrets for full functionality:
  - `AZURE_OPENAI_ENDPOINT`, `AZURE_OPENAI_API_KEY`, `AZURE_OPENAI_GPT5_MODEL` — reading generation
  - `AZURE_OPENAI_TTS_ENDPOINT`, `AZURE_OPENAI_TTS_API_KEY`, `AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT` — TTS (optional)
  - `VISION_PROOF_SECRET` — vision research mode (optional)
- Run `npm run config:check` to verify environment configuration.
- For production, use `wrangler pages secret put <NAME> --project-name=tableau`.

## Security & compliance
- Never commit secrets or API keys; use `.dev.vars` locally and Cloudflare secrets in production.
- Never log API keys, secrets, or PII in server functions.
- Validate all API inputs using the `validatePayload()` pattern.
- Rate limit sensitive endpoints using Cloudflare KV.
- Sanitize user-provided content before rendering (XSS prevention).
- When adding dependencies, check for known vulnerabilities with `npm audit`.

## Contribution guidelines
- Follow Conventional Commits: `feat:`, `fix:`, `chore:`, `docs:`, `test:` prefixes.
- Run `npm test` before pushing changes.
- Run `npm run lint` to check code style.
- If touching vision/narrative code, run `npm run gate:vision` or `npm run gate:narrative`.
- Include screenshots for UI changes in PR descriptions.
- Keep PRs focused; avoid bundling unrelated changes.
</file>

<file path=".kilocode/mcp.json">
{
  "mcpServers": {
    "cloudflare-bindings": {
      "command": "npx",
      "args": [
        "mcp-remote",
        "https://bindings.mcp.cloudflare.com/mcp"
      ]
    },
    "cloudflare-docs": {
      "command": "npx",
      "args": [
        "mcp-remote",
        "https://docs.mcp.cloudflare.com/mcp"
      ]
    },
    "cloudflare-observability": {
      "command": "npx",
      "args": [
        "mcp-remote",
        "https://observability.mcp.cloudflare.com/mcp"
      ]
    }
  }
}
</file>

<file path="data/evaluations/narrative-metrics.json">
{
  "generatedAt": "2025-11-17T09:46:47.926Z",
  "sourceFile": "data/evaluations/narrative-samples.json",
  "totalSamples": 5,
  "spinePassRate": 0.8,
  "avgCardCoverage": 1,
  "deterministicLanguageCount": 0,
  "missingAgencyCount": 1,
  "hallucinationCount": 0,
  "harshToneCount": 2,
  "missingSupportiveToneCount": 0,
  "flaggedSampleCount": 4,
  "avgRubricScores": {
    "accuracy": 1,
    "coherence": 0.9,
    "agency": 0.8,
    "compassion": 1
  },
  "perSample": [
    {
      "id": "single-new-role",
      "spreadKey": "single",
      "spreadName": "One-Card Insight",
      "question": "What guiding energy should I bring into this new leadership role?",
      "spine": {
        "isValid": false,
        "totalSections": 2,
        "completeSections": 1,
        "incompleteSections": 1
      },
      "cardCoverage": 1,
      "missingCards": [],
      "deterministicLanguage": false,
      "hasAgencyLanguage": true,
      "hallucinatedCards": [],
      "hasSupportiveTone": true,
      "hasHarshTone": false,
      "issueFlags": [
        "spine-incomplete"
      ],
      "issuesPresent": true,
      "rubric": {
        "accuracy": 1,
        "coherence": 0.5,
        "agency": 1,
        "compassion": 1
      }
    },
    {
      "id": "three-card-transition",
      "spreadKey": "threeCard",
      "spreadName": "Three-Card Story (Past · Present · Future)",
      "question": "How can I navigate the transition after leaving my hometown?",
      "spine": {
        "isValid": true,
        "totalSections": 3,
        "completeSections": 3,
        "incompleteSections": 0
      },
      "cardCoverage": 1,
      "missingCards": [],
      "deterministicLanguage": false,
      "hasAgencyLanguage": true,
      "hallucinatedCards": [],
      "hasSupportiveTone": true,
      "hasHarshTone": true,
      "issueFlags": [
        "harsh-tone"
      ],
      "issuesPresent": true,
      "rubric": {
        "accuracy": 1,
        "coherence": 1,
        "agency": 1,
        "compassion": 1
      }
    },
    {
      "id": "five-card-creative-project",
      "spreadKey": "fiveCard",
      "spreadName": "Five-Card Clarity",
      "question": "What should I know about launching my creative project this quarter?",
      "spine": {
        "isValid": true,
        "totalSections": 5,
        "completeSections": 5,
        "incompleteSections": 0
      },
      "cardCoverage": 1,
      "missingCards": [],
      "deterministicLanguage": false,
      "hasAgencyLanguage": false,
      "hallucinatedCards": [],
      "hasSupportiveTone": true,
      "hasHarshTone": false,
      "issueFlags": [
        "missing-agency-language"
      ],
      "issuesPresent": true,
      "rubric": {
        "accuracy": 1,
        "coherence": 1,
        "agency": 0,
        "compassion": 1
      }
    },
    {
      "id": "relationship-checkin",
      "spreadKey": "relationship",
      "spreadName": "Relationship Snapshot",
      "question": "What should I understand about the energetic exchange between me and Alex?",
      "spine": {
        "isValid": true,
        "totalSections": 4,
        "completeSections": 4,
        "incompleteSections": 0
      },
      "cardCoverage": 1,
      "missingCards": [],
      "deterministicLanguage": false,
      "hasAgencyLanguage": true,
      "hallucinatedCards": [],
      "hasSupportiveTone": true,
      "hasHarshTone": true,
      "issueFlags": [
        "harsh-tone"
      ],
      "issuesPresent": true,
      "rubric": {
        "accuracy": 1,
        "coherence": 1,
        "agency": 1,
        "compassion": 1
      }
    },
    {
      "id": "celtic-deep-shift",
      "spreadKey": "celtic",
      "spreadName": "Celtic Cross (Classic 10-Card)",
      "question": "How can I stay centered while everything at home and work restructures at once?",
      "spine": {
        "isValid": true,
        "totalSections": 11,
        "completeSections": 11,
        "incompleteSections": 0
      },
      "cardCoverage": 1,
      "missingCards": [],
      "deterministicLanguage": false,
      "hasAgencyLanguage": true,
      "hallucinatedCards": [],
      "hasSupportiveTone": true,
      "hasHarshTone": false,
      "issueFlags": [],
      "issuesPresent": false,
      "rubric": {
        "accuracy": 1,
        "coherence": 1,
        "agency": 1,
        "compassion": 1
      }
    }
  ]
}
</file>

<file path="data/evaluations/narrative-review-queue.csv">
sample_id,spread,question,issues,automated_notes,human_verdict,human_notes
single-new-role,One-Card Insight,What guiding energy should I bring into this new leadership role?,spine-incomplete,Story spine complete 1/2,,
three-card-transition,Three-Card Story (Past · Present · Future),How can I navigate the transition after leaving my hometown?,harsh-tone,Harsh/imperative tone detected,,
five-card-creative-project,Five-Card Clarity,What should I know about launching my creative project this quarter?,missing-agency-language,Agency/choice language missing,,
relationship-checkin,Relationship Snapshot,What should I understand about the energetic exchange between me and Alex?,harsh-tone,Harsh/imperative tone detected,,
</file>

<file path="data/evaluations/narrative-samples.json">
{
  "generatedAt": "2025-11-17T09:46:47.888Z",
  "model": "local-composer",
  "sampleCount": 5,
  "samples": [
    {
      "id": "single-new-role",
      "spreadKey": "single",
      "spreadName": "One-Card Insight",
      "userQuestion": "What guiding energy should I bring into this new leadership role?",
      "reflectionsText": "I want to stay curious yet grounded even when the stakes feel high.",
      "context": "spiritual",
      "cardsInfo": [
        {
          "position": "Theme / Guidance of the Moment",
          "card": "The Fool",
          "orientation": "Upright",
          "meaning": "New beginnings, innocence, spontaneity, free spirit",
          "number": 0,
          "suit": null,
          "rank": null,
          "rankValue": null
        }
      ],
      "reading": "### One-Card Insight\n\nFocusing on your question \"What guiding energy should I bring into this new leadership role?\", this card offers a snapshot of guidance in this moment.\n\nWe’ll ground this reading in your spiritual practice and meaning-making, while keeping each card rooted in its Rider–Waite–Smith lineage.\n\nTheme / Guidance of the Moment: The Fool Upright offers a simple snapshot for right now. This shows new beginnings, innocence, spontaneity, free spirit as a live theme. In your spiritual path, let this archetype frame the lesson seeking integration. Traditionally linked with Air — the elemental current of Aleph, inviting openness, experimentation, and trust in the unfolding journey.  On an occult level, this echoes Air — the elemental current of Aleph, inviting openness, experimentation, and trust in the unfolding journey, touches Path Aleph (Kether ↔ Chokmah), channeling pure potential into first breath and awareness—a symbolic backdrop rather than a fixed rule. Notice the Fool's gaze toward the horizon—an invitation to step forward into the unknown with trust. This distills the essence of what wants your awareness.\n\nIn simple terms: notice what this theme is asking you to acknowledge (WHAT), reflect on why it might be surfacing now (WHY), and choose one small, aligned next step that honors your agency (WHAT'S NEXT). Therefore, treat this insight as a living moment, not a fixed verdict—a trajectory you actively shape.\n\n### Your Reflections\n\nI want to stay curious yet grounded even when the stakes feel high.\n\n*Reversal lens reminder: Within the All Upright lens, Read each card's traditional upright meaning in the context of its position.*",
      "themesSummary": {
        "reversalFramework": "none",
        "suitFocus": null,
        "archetypeDescription": "High Major Arcana presence indicates profound, soul-level themes, karmic patterns, and significant life transitions."
      }
    },
    {
      "id": "three-card-transition",
      "spreadKey": "threeCard",
      "spreadName": "Three-Card Story (Past · Present · Future)",
      "userQuestion": "How can I navigate the transition after leaving my hometown?",
      "reflectionsText": "Part of me is nostalgic while another part is ready for reinvention.",
      "context": "general",
      "cardsInfo": [
        {
          "position": "Past — influences that led here",
          "card": "Six of Cups",
          "orientation": "Reversed",
          "meaning": "Living in the past, rose-colored views, difficulty moving on",
          "suit": "Cups",
          "rank": "Six",
          "rankValue": 6
        },
        {
          "position": "Present — where you stand now",
          "card": "The Tower",
          "orientation": "Upright",
          "meaning": "Sudden change, upheaval, chaos, revelation, awakening",
          "number": 16,
          "suit": null,
          "rank": null,
          "rankValue": null
        },
        {
          "position": "Future — trajectory if nothing shifts",
          "card": "The Star",
          "orientation": "Upright",
          "meaning": "Hope, faith, purpose, renewal, spirituality",
          "number": 17,
          "suit": null,
          "rank": null,
          "rankValue": null
        }
      ],
      "reading": "Focusing on the Three-Card Story (Past · Present · Future), I attune to your question: \"How can I navigate the transition after leaving my hometown?\"\n\nThe cards respond with insight that honors both seen and unseen influences.\n\n*Attention weighting (Three-Card Story): Present — where you stand now (The Tower) at weight 1.00, Future — trajectory if nothing shifts (The Star) at weight 0.90, Past — influences that led here (Six of Cups) at weight 0.75. Lower-weight cards filter into synthesis summaries so the narrative mirrors what matters most.*\n\n### The Story\n\nPast — influences that led here: Behind you, Six of Cups Reversed outlines the experiences that fed into this chapter. This shows living in the past, rose-colored views, difficulty moving on as a live theme. Traditionally linked with Sun in Scorpio, reviving soulful loyalty, memory, and devotion. As a Cups card, this speaks to water, emotions, relationships, intuition, and how you give and receive care. At this rank, it marks recognition, victory, and public acknowledgment. Picture Child offers a flower-filled cup to another within a sunlit courtyard—this subtly colors how this suit's lesson shows up here. Noticing this helps you decide what you’re done carrying and what still serves.\n\n*Past — influences that led here carries an attention weight of 0.75, so it receives extended focus here.*\n\nAnd so, Present — where you stand now: In this moment, The Tower Upright captures the tone of your experience. This shows sudden change, upheaval, chaos, revelation, awakening as a live theme. Traditionally linked with Mars, igniting sudden change, liberation, and necessary disruption.  On an occult level, this echoes Mars, igniting sudden change, liberation, and necessary disruption, touches Path Peh (Netzach ↔ Hod), breaking open stale structures to free vitality—a symbolic backdrop rather than a fixed rule. Notice the Tower's lightning—sudden upheaval shatters false structures, clearing space for truth. This is the current energy and active dynamic you are navigating. Water and flame struggle for dominance; integration requires honoring both emotional depth and passionate drive.\n\n*Present — where you stand now carries an attention weight of 1.00, so it receives extended focus here.*\n\nTherefore, on this trajectory, Future — trajectory if nothing shifts: The future, the trajectory ahead: The Star Upright. If things continue as they are, this shows how the trajectory leans toward hope, faith, purpose, renewal, spirituality. Traditionally linked with Aquarius, channeling vision, hope, and communal renewal.  On an occult level, this echoes Aquarius, channeling vision, hope, and communal renewal, touches Path Tzaddi (Netzach ↔ Yesod), catching starlight inspirations for embodied hope—a symbolic backdrop rather than a fixed rule. Picture the Star's flowing water—hope replenishes when you pour yourself into purpose and trust. Hold it as a forecast of trajectory, always adjustable through your choices. Picture a spark fanned into flame—this illustrates how these energies amplify each other's potential.\n\n*Future — trajectory if nothing shifts carries an attention weight of 0.90, so it receives extended focus here.*\n\nThe story unfolds from Six of Cups through The Tower to The Star. The move from first to second involves friction that shapes the narrative. The path forward from second to third is well-supported.\n\n### Your Reflections\n\nThis reflection shows how this reading lands in your lived experience.\n\nPart of me is nostalgic while another part is ready for reinvention.\n\nYour intuitive impressions are valid and add personal meaning to this reading.\n\n### Guidance\n\nPace: Expect this to unfold across a meaningful chapter rather than in a single moment.\n\nThe path ahead shows The Star Upright. This is not fixed fate, but the trajectory of current momentum. Your awareness and choices shape what comes next. The Future position carries a weight of 0.90, so its voice leads the guidance.\n\nAltogether, these threads suggest your next supportive step and point toward how to walk this path with agency.\n\n*Reversal lens reminder: Within the Delayed Timing lens, Read reversals as energies that will manifest later, after certain conditions are met.*",
      "themesSummary": {
        "reversalFramework": "delayed",
        "suitFocus": null,
        "archetypeDescription": "High Major Arcana presence indicates profound, soul-level themes, karmic patterns, and significant life transitions."
      }
    },
    {
      "id": "five-card-creative-project",
      "spreadKey": "fiveCard",
      "spreadName": "Five-Card Clarity",
      "userQuestion": "What should I know about launching my creative project this quarter?",
      "reflectionsText": "I feel momentum but keep second-guessing the tone and timing.",
      "context": "career",
      "cardsInfo": [
        {
          "position": "Core of the matter",
          "card": "Ace of Wands",
          "orientation": "Upright",
          "meaning": "Inspiration, new energy, creative spark, potential for bold action",
          "suit": "Wands",
          "rank": "Ace",
          "rankValue": 1
        },
        {
          "position": "Challenge or tension",
          "card": "Seven of Swords",
          "orientation": "Reversed",
          "meaning": "Exposure, consequences, call for transparency and integrity",
          "suit": "Swords",
          "rank": "Seven",
          "rankValue": 7
        },
        {
          "position": "Hidden / subconscious influence",
          "card": "Queen of Cups",
          "orientation": "Upright",
          "meaning": "Compassion, empathy, emotional intelligence, intuition in flow",
          "suit": "Cups",
          "rank": "Queen",
          "rankValue": 13
        },
        {
          "position": "Support / helpful energy",
          "card": "Three of Pentacles",
          "orientation": "Upright",
          "meaning": "Collaboration, skill development, building something of quality",
          "suit": "Pentacles",
          "rank": "Three",
          "rankValue": 3
        },
        {
          "position": "Likely direction on current path",
          "card": "Wheel of Fortune",
          "orientation": "Reversed",
          "meaning": "Bad luck, resistance to change, breaking cycles",
          "number": 10,
          "suit": null,
          "rank": null,
          "rankValue": null
        }
      ],
      "reading": "Focusing on the Five-Card Clarity, I attune to your question: \"What should I know about launching my creative project this quarter?\"\n\nThe cards respond with insight that honors both seen and unseen influences.\n\nWe’ll ground this reading in your career, calling, and material pathways, while keeping each card rooted in its Rider–Waite–Smith lineage.\n\n*Attention weighting (Five-Card Clarity): Core of the matter (Ace of Wands) at weight 1.00, Challenge or tension (Seven of Swords) at weight 0.90, Likely direction on current path (Wheel of Fortune) at weight 0.85. Lower-weight cards filter into synthesis summaries so the narrative mirrors what matters most.*\n\n### Five-Card Clarity — Core & Challenge\n\nCore of the matter: Here, Ace of Wands Upright names the heart of what you’re really exploring. This shows inspiration, new energy, creative spark, potential for bold action as a live theme. In your career, this points to initiative, leadership, and courageous momentum. On the Tree of Life, this aligns with Kether — Crown, pure seed potential entering this suit within Atziluth (Fire) — archetypal impulse. As a Wands card, this speaks to fire, initiative, creativity, desire, and the way you act on your will. At this rank, it marks a seed or new spark of this suit’s energy, raw potential and beginnings. Picture Hand emerging from a cloud presenting a sprouting wand above rolling hills and a distant castle—this subtly colors how this suit's lesson shows up here. This is the central issue—the thread that, if tended to, shifts the whole pattern.\n\nHowever, in contrast, Challenge or tension: The challenge or tension: Seven of Swords Reversed. The friction here shows how it centers on exposure, consequences, call for transparency and integrity. In your career, this stresses strategy, communication, and decisive clarity. As a Swords card, this speaks to air, mind, truth, communication, and how you navigate tension or clarity. At this rank, it marks assessment, testing, deeper questions about direction and alignment. Picture Sneaking figure tiptoes from a camp carrying five swords, two left behind—this subtly colors how this suit's lesson shows up here. Naming this tension can make it more workable. Picture a spark fanned into flame—this illustrates how these energies amplify each other's potential.\n\n\n\nFire and Air work harmoniously together, each supporting the other's expression.\n\n*Core of the matter carries an attention weight of 1.00, so it receives extended focus here.* *Challenge or tension carries an attention weight of 0.90, so it receives extended focus here.* Because Ace of Wands supports and harmonizes with Seven of Swords, these energies flow together constructively.\n\n### Hidden Influence\n\nYet beneath the surface, Hidden / subconscious influence: Hidden from view, the subconscious influence: Queen of Cups Upright. This reveals how, beneath awareness, part of you is still relating to compassion, empathy, emotional intelligence, intuition in flow. In your career, this speaks to collaborative rapport, emotional intelligence, and people care. As a Cups card, this speaks to water, emotions, relationships, intuition, and how you give and receive care. As a Queen, it highlights mature, receptive mastery of this suit—embodied wisdom, emotional intelligence, stewardship from within. Picture Throne by the sea, ornate covered cup held with devotion—this subtly colors how this suit's lesson shows up here. Seeing this gives you more compassionate context for your reactions.\n\n### Supporting Energies\n\nMeanwhile, Support / helpful energy: Support and helpful energy come through: Three of Pentacles Upright. This shows collaboration, skill development, building something of quality as a live theme. In your career, this emphasizes teamwork, craftsmanship, and being recognized for your expertise. Traditionally linked with Mars in Capricorn, activating collaborative mastery through effort. As a Pentacles card, this speaks to earth, body, work, resources, and the material structures that support you. At this rank, it marks growth, first stability, collaboration, and visible development. Picture Craftsman discusses cathedral plans with monk and noble as pentacles decorate the arch—this subtly colors how this suit's lesson shows up here. This is what you can lean on as you navigate the situation.\n\n### Direction on Your Current Path\n\nTherefore, Likely direction on current path: The likely direction, if you continue as you are: Wheel of Fortune Reversed. If things continue as they are, this shows how the trajectory leans toward bad luck, resistance to change, breaking cycles. In your career, treat this archetype as guidance for how you show up in your work and collaborations. Traditionally linked with Jupiter, opening cycles of expansion, fortune, and recalibration.  On an occult level, this echoes Jupiter, opening cycles of expansion, fortune, and recalibration, touches Path Kaph (Chesed ↔ Netzach), turning opportunity through the wheel of fortune—a symbolic backdrop rather than a fixed rule. The Wheel resists its turn; clinging to the current phase delays inevitable transformation. Use it as feedback about how your present choices echo forward.\n\nThe core matter (Ace of Wands) faces the challenge of Seven of Swords. Support comes through Three of Pentacles, pointing toward Wheel of Fortune as the likely direction.\n\n*Likely direction on current path carries an attention weight of 0.85, so it receives extended focus here.*\n\n### Your Reflections\n\nThis reflection shows how this reading lands in your lived experience.\n\nI feel momentum but keep second-guessing the tone and timing.\n\nYour intuitive impressions are valid and add personal meaning to this reading.\n\n*Reversal lens reminder: Within the Internal Processing lens, Interpret reversals as the same themes playing out in the inner world rather than external events.*",
      "themesSummary": {
        "reversalFramework": "internalized",
        "suitFocus": null,
        "archetypeDescription": "Primarily Minor Arcana, focusing on practical, day-to-day dynamics and immediate concerns."
      }
    },
    {
      "id": "relationship-checkin",
      "spreadKey": "relationship",
      "spreadName": "Relationship Snapshot",
      "userQuestion": "What should I understand about the energetic exchange between me and Alex?",
      "reflectionsText": "Communication feels uneven lately and I want to ground before reacting.",
      "context": "spiritual",
      "cardsInfo": [
        {
          "position": "You / your energy",
          "card": "Queen of Cups",
          "orientation": "Reversed",
          "meaning": "Emotional overwhelm, martyrdom, blurred boundaries",
          "suit": "Cups",
          "rank": "Queen",
          "rankValue": 13
        },
        {
          "position": "Them / their energy",
          "card": "Knight of Swords",
          "orientation": "Upright",
          "meaning": "Decisive action, sharp focus, pursuing truth swiftly",
          "suit": "Swords",
          "rank": "Knight",
          "rankValue": 12
        },
        {
          "position": "The connection / shared lesson",
          "card": "Two of Cups",
          "orientation": "Upright",
          "meaning": "Connection, partnership, mutual respect, heartfelt unity",
          "suit": "Cups",
          "rank": "Two",
          "rankValue": 2
        }
      ],
      "reading": "Focusing on the Relationship Snapshot, I attune to your question: \"What should I understand about the energetic exchange between me and Alex?\"\n\nThe cards respond with insight that honors both seen and unseen influences.\n\nWe’ll ground this reading in your spiritual practice and meaning-making, while keeping each card rooted in its Rider–Waite–Smith lineage.\n\n*Attention weighting (Relationship Snapshot): The connection / shared lesson (Two of Cups) at weight 1.00, You / your energy (Queen of Cups) at weight 0.90, Them / their energy (Knight of Swords) at weight 0.90. Lower-weight cards filter into synthesis summaries so the narrative mirrors what matters most.*\n\n### You and Them\n\nYou / your energy: Here, Queen of Cups Reversed mirrors your stance, needs, or patterns. This shows emotional overwhelm, martyrdom, blurred boundaries as a live theme. In your spiritual practice, this deepens receptive listening and intuitive flow. As a Cups card, this speaks to water, emotions, relationships, intuition, and how you give and receive care. As a Queen, it highlights mature, receptive mastery of this suit—embodied wisdom, emotional intelligence, stewardship from within. Picture Throne by the sea, ornate covered cup held with devotion—this subtly colors how this suit's lesson shows up here. Use it to notice how you participate, without blaming yourself.\n\n*Reversal lens reminder: Within the Delayed Timing lens, Read reversals as energies that will manifest later, after certain conditions are met. For Queen of Cups, focus on where emotional overwhelm, martyrdom, blurred boundaries needs gentle attention before momentum can return.*\n\n*You / your energy carries an attention weight of 0.90, so it receives extended focus here.*\n\nMeanwhile, alongside your energy, Them / their energy: Their energy in this dynamic: Knight of Swords Upright. This shows decisive action, sharp focus, pursuing truth swiftly as a live theme. In your spiritual practice, this sharpens discernment, study, and sacred speech. As a Swords card, this speaks to air, mind, truth, communication, and how you navigate tension or clarity. As a Knight, it highlights movement and pursuit in this suit—how you or another actively chase, defend, or embody this energy. Picture Rider charging forward with sword raised, trees bent by wind—this subtly colors how this suit's lesson shows up here. This offers a snapshot of how they may be engaging, without claiming to read their mind.\n\n*Them / their energy carries an attention weight of 0.90, so it receives extended focus here.*\n\nTogether, this pairing suggests the current dynamic between you and points toward how energy is moving in this connection.\n\n### The Connection\n\nThis position shows what the bond is asking for right now.\n\nTherefore, The connection / shared lesson: Here, Two of Cups Upright frames the relationship as its own living entity. This shows connection, partnership, mutual respect, heartfelt unity as a live theme. In your spiritual practice, this deepens receptive listening and intuitive flow. Traditionally linked with Venus in Cancer, nurturing bonds, reciprocity, and shared care. As a Cups card, this speaks to water, emotions, relationships, intuition, and how you give and receive care. At this rank, it marks duality, choices, early tension or balance within this suit’s themes. Picture Two figures exchange cups beneath a caduceus and lion-headed emblem—this subtly colors how this suit's lesson shows up here. Let it name what this connection is teaching, without overstating what must happen next.\n\n*The connection / shared lesson carries an attention weight of 1.00, so it receives extended focus here.*\n\nThis focus invites you to notice what this bond is asking from both of you next.\n\n### Guidance for This Connection\n\nThis guidance shows how to participate with agency, honesty, and care.\n\nTherefore, The connection / shared lesson: The connection itself, the shared lesson: Two of Cups Upright. This shows connection, partnership, mutual respect, heartfelt unity as a live theme. In your spiritual practice, this deepens receptive listening and intuitive flow. Traditionally linked with Venus in Cancer, nurturing bonds, reciprocity, and shared care. As a Cups card, this speaks to water, emotions, relationships, intuition, and how you give and receive care. At this rank, it marks duality, choices, early tension or balance within this suit’s themes. Picture Two figures exchange cups beneath a caduceus and lion-headed emblem—this subtly colors how this suit's lesson shows up here. This card speaks to the shared lesson, patterns, and potentials alive between you.\n\n*The connection / shared lesson carries an attention weight of 1.00, so it receives extended focus here.*\n\nWithin the Delayed Timing lens, Queen of Cups reversed asks you to notice where emotional overwhelm, martyrdom, blurred boundaries feels blocked and to agree on one practical step that eases the pressure. Knight of Swords invites you to practice decisive action, sharp focus, pursuing truth swiftly together—pick one specific action or conversation that expresses it this week. Two of Cups invites you to practice connection, partnership, mutual respect, heartfelt unity together—pick one specific action or conversation that expresses it this week.\n\nEmphasize honest communication, reciprocal care, and boundaries. Treat these insights as a mirror that informs how you choose to show up—never as a command to stay or leave. Choose the path that best honors honesty, care, and your own boundaries—the outcome still rests in the choices you both make.\n\n### Your Reflections\n\nThis reflection shows how this reading lands in your lived experience.\n\nCommunication feels uneven lately and I want to ground before reacting.\n\nYour intuitive impressions are valid and add personal meaning to this reading.",
      "themesSummary": {
        "reversalFramework": "delayed",
        "suitFocus": "2 Cups cards indicate emotional matters, relationships, intuition, and heart-centered concerns are central to this reading.",
        "archetypeDescription": "Primarily Minor Arcana, focusing on practical, day-to-day dynamics and immediate concerns."
      }
    },
    {
      "id": "celtic-deep-shift",
      "spreadKey": "celtic",
      "spreadName": "Celtic Cross (Classic 10-Card)",
      "userQuestion": "How can I stay centered while everything at home and work restructures at once?",
      "reflectionsText": "It feels like multiple towers at the same time; I want to stay compassionate without losing momentum.",
      "context": "career",
      "cardsInfo": [
        {
          "position": "Present — core situation (Card 1)",
          "card": "The Hermit",
          "orientation": "Upright",
          "meaning": "Soul-searching, introspection, inner guidance, solitude",
          "number": 9,
          "suit": null,
          "rank": null,
          "rankValue": null
        },
        {
          "position": "Challenge — crossing / tension (Card 2)",
          "card": "Five of Wands",
          "orientation": "Reversed",
          "meaning": "Avoidance of conflict, resentment, unproductive tension",
          "suit": "Wands",
          "rank": "Five",
          "rankValue": 5
        },
        {
          "position": "Past — what lies behind (Card 3)",
          "card": "Death",
          "orientation": "Upright",
          "meaning": "Endings, change, transformation, transition",
          "number": 13,
          "suit": null,
          "rank": null,
          "rankValue": null
        },
        {
          "position": "Near Future — what lies before (Card 4)",
          "card": "Temperance",
          "orientation": "Upright",
          "meaning": "Balance, moderation, patience, purpose",
          "number": 14,
          "suit": null,
          "rank": null,
          "rankValue": null
        },
        {
          "position": "Conscious — goals & focus (Card 5)",
          "card": "The Emperor",
          "orientation": "Upright",
          "meaning": "Authority, establishment, structure, father figure",
          "number": 4,
          "suit": null,
          "rank": null,
          "rankValue": null
        },
        {
          "position": "Subconscious — roots / hidden forces (Card 6)",
          "card": "The Moon",
          "orientation": "Reversed",
          "meaning": "Release of fear, repressed emotion, inner confusion",
          "number": 18,
          "suit": null,
          "rank": null,
          "rankValue": null
        },
        {
          "position": "Self / Advice — how to meet this (Card 7)",
          "card": "Strength",
          "orientation": "Upright",
          "meaning": "Strength, courage, persuasion, influence, compassion",
          "number": 8,
          "suit": null,
          "rank": null,
          "rankValue": null
        },
        {
          "position": "External Influences — people & environment (Card 8)",
          "card": "Eight of Pentacles",
          "orientation": "Upright",
          "meaning": "Mastery through practice, craftsmanship, dedicated work",
          "suit": "Pentacles",
          "rank": "Eight",
          "rankValue": 8
        },
        {
          "position": "Hopes & Fears — deepest wishes & worries (Card 9)",
          "card": "Nine of Swords",
          "orientation": "Reversed",
          "meaning": "Recovery from anxiety, gaining perspective, support arriving",
          "suit": "Swords",
          "rank": "Nine",
          "rankValue": 9
        },
        {
          "position": "Outcome — likely path if unchanged (Card 10)",
          "card": "The Sun",
          "orientation": "Upright",
          "meaning": "Positivity, fun, warmth, success, vitality",
          "number": 19,
          "suit": null,
          "rank": null,
          "rankValue": null
        }
      ],
      "reading": "Focusing on the Celtic Cross (Classic 10-Card), I attune to your question: \"How can I stay centered while everything at home and work restructures at once?\"\n\nThe cards respond with insight that honors both seen and unseen influences.\n\nWe’ll ground this reading in your career, calling, and material pathways, while keeping each card rooted in its Rider–Waite–Smith lineage.\n\n*Attention weighting (Celtic Cross): Present — core situation (Card 1) (The Hermit) at weight 1.00, Outcome — likely path if unchanged (Card 10) (The Sun) at weight 0.95, Challenge — crossing / tension (Card 2) (Five of Wands) at weight 0.90. Lower-weight cards filter into synthesis summaries so the narrative mirrors what matters most.*\n\n### The Heart of the Matter (Nucleus)\n\nPresent — core situation (Card 1): At the heart of this moment stands The Hermit Upright. This shows soul-searching, introspection, inner guidance, solitude as a live theme. In your career, this invites strategic retreat to refine mastery before reengaging. Traditionally linked with Virgo, favoring discernment, service, and grounded reflection.  On an occult level, this echoes Virgo, favoring discernment, service, and grounded reflection, touches Path Yod (Chesed ↔ Tiphareth), refining devotion through mindful service—a symbolic backdrop rather than a fixed rule. Picture the Hermit's lantern piercing darkness—solitude illuminates what crowds obscure. It points to what feels most alive, charged, or pressing in your experience.\n\nChallenge — crossing / tension (Card 2): In tension with that, Five of Wands Reversed shows where things snag. The friction here shows how it centers on avoidance of conflict, resentment, unproductive tension. In your career, this points to initiative, leadership, and courageous momentum. As a Wands card, this speaks to fire, initiative, creativity, desire, and the way you act on your will. At this rank, it marks conflict, disruption, tests that stress the pattern and demand adjustment. Picture Band of youths brandishing wands in spirited but chaotic competition—this subtly colors how this suit's lesson shows up here. Treat this not as doom, but as the leverage point where change is possible.\n\nThe Hermit represents where you stand, while Five of Wands crosses as the immediate obstacle.\n\n*Present — core situation (Card 1) carries an attention weight of 1.00, so it receives extended focus here.*\n\n*Challenge — crossing / tension (Card 2) carries an attention weight of 0.90, so it receives extended focus here.* The Hermit and Five of Wands work together with subtle complexity.\n\n### The Timeline (Horizontal Axis)\n\nPast — what lies behind (Card 3): The roots of this story reach back to Death Upright. This shows endings, change, transformation, transition as a live theme. In your career, treat this archetype as guidance for how you show up in your work and collaborations. Traditionally linked with Scorpio, navigating profound transformation and regenerative endings.  On an occult level, this echoes Scorpio, navigating profound transformation and regenerative endings, touches Path Nun (Tiphareth ↔ Netzach), moving lifeforce toward profound transformation—a symbolic backdrop rather than a fixed rule. Picture the sun rising behind Death—endings clear ground for what must be born next. It names what you’re carrying forward, consciously or not.\n\nBecause of what has led you here, Present — core situation (Card 1): At the heart of this moment stands The Hermit Upright. This shows soul-searching, introspection, inner guidance, solitude as a live theme. In your career, this invites strategic retreat to refine mastery before reengaging. Traditionally linked with Virgo, favoring discernment, service, and grounded reflection.  On an occult level, this echoes Virgo, favoring discernment, service, and grounded reflection, touches Path Yod (Chesed ↔ Tiphareth), refining devotion through mindful service—a symbolic backdrop rather than a fixed rule. Picture the Hermit's lantern piercing darkness—solitude illuminates what crowds obscure. Treat this as a snapshot of how things feel from the inside out. As rain nourishes soil, these energies combine to create fertile ground for growth and manifestation.\n\nTherefore, as this unfolds, Near Future — what lies before (Card 4): As the next chapter, Temperance Upright comes into view. If things continue as they are, this shows how the trajectory leans toward balance, moderation, patience, purpose. In your career, treat this archetype as guidance for how you show up in your work and collaborations. Traditionally linked with Sagittarius, encouraging synthesis, aim, and philosophical integration.  On an occult level, this echoes Sagittarius, encouraging synthesis, aim, and philosophical integration, touches Path Samekh (Tiphareth ↔ Yesod), tempering experience into integrated wholeness—a symbolic backdrop rather than a fixed rule. Notice Temperance's flowing water—balance is active mixing, not static division. This hints at near-term developments on your current trajectory, not a final verdict.\n\nDeath in the past has led to The Hermit in the present. The past supports and flows naturally into the present state. This is developing toward Temperance in the near future.\n\n*Present — core situation (Card 1) carries an attention weight of 1.00, so it receives extended focus here.*\n\n### Consciousness Flow (Vertical Axis)\n\nSubconscious — roots / hidden forces (Card 6): In the deeper layers, The Moon Reversed speaks to what’s moving you from within. This reveals how, beneath awareness, part of you is still relating to release of fear, repressed emotion, inner confusion. In your career, treat this archetype as guidance for how you show up in your work and collaborations. Traditionally linked with Pisces, immersing you in intuition, dreams, and mystery.  On an occult level, this echoes Pisces, immersing you in intuition, dreams, and mystery, touches Path Qoph (Netzach ↔ Malkuth), guiding dreamscapes toward compassionate embodiment—a symbolic backdrop rather than a fixed rule. Illusions begin to thin; repressed emotions surface, bringing difficult clarity. Understanding this layer helps you respond with more self-compassion.\n\nConscious — goals & focus (Card 5): In your conscious mind, The Emperor Upright names your current aims. This shows authority, establishment, structure, father figure as a live theme. In your career, treat this archetype as guidance for how you show up in your work and collaborations. Traditionally linked with Aries, emphasizing decisive leadership, structure, and sovereign agency.  On an occult level, this echoes Aries, emphasizing decisive leadership, structure, and sovereign agency, touches Path Heh (Chokmah ↔ Tiphareth), seeding visionary fire into purposeful action—a symbolic backdrop rather than a fixed rule. Note the Emperor's mountain throne—stability comes through structure, leadership through clarity. It shows where your focus naturally goes when you think about this situation.\n\nHidden beneath awareness: The Moon Reversed. Conscious goal or aspiration: The Emperor Upright. There is tension between what you want consciously and what drives you beneath awareness. Integration is needed.\n\n*This misalignment suggests inner work is needed to bring your depths and aspirations into harmony.*\n\n*Subconscious — roots / hidden forces (Card 6) carries an attention weight of 0.75, so it receives extended focus here.* *Conscious — goals & focus (Card 5) carries an attention weight of 0.75, so it receives extended focus here.*\n\n### The Staff (Context & Trajectory)\n\nSelf / Advice — how to meet this (Card 7): As counsel, Strength Upright sketches a stance that could support you. This shows how it may help to lean into strength, courage, persuasion, influence, compassion. In your career, treat this archetype as guidance for how you show up in your work and collaborations. Traditionally linked with Leo, calling up heart-led courage and radiant self-expression.  On an occult level, this echoes Leo, calling up heart-led courage and radiant self-expression, touches Path Teth (Chesed ↔ Geburah), taming power through heart-centered strength—a symbolic backdrop rather than a fixed rule. See the gentle hand on the lion's jaw—true strength is compassionate persuasion, not domination. This suggests practical attitudes or small actions that are available to you.\n\nExternal Influences — people & environment (Card 8): Around you, Eight of Pentacles Upright reflects other people and conditions in play. This shows that around you, circumstances echo mastery through practice, craftsmanship, dedicated work. In your career, this underscores planning, resources, and tangible results. As a Pentacles card, this speaks to earth, body, work, resources, and the material structures that support you. At this rank, it marks dedication, focused work, sustained effort in this suit’s domain. Picture Craftsman carves pentacles along a workbench with a town in the distance—this subtly colors how this suit's lesson shows up here. It’s a reminder to distinguish between your work and what belongs to others.\n\nHopes & Fears — deepest wishes & worries (Card 9): This position, held by Nine of Swords Reversed, tracks what you long for and what you guard against. This reveals both longing and worry around recovery from anxiety, gaining perspective, support arriving. In your career, this stresses strategy, communication, and decisive clarity. Traditionally linked with Mars in Gemini, stirring restless analyses that need compassionate focus. As a Swords card, this speaks to air, mind, truth, communication, and how you navigate tension or clarity. At this rank, it marks fruition, culmination near completion, self-sufficiency in this area. Picture Person bolts upright in bed with hands covering their face, nine swords etched on the wall—this subtly colors how this suit's lesson shows up here. Let this clarify what your heart is truly asking for beneath the anxiety.\n\nOutcome — likely path if unchanged (Card 10): If nothing major shifts, The Sun Upright sketches where this could be heading. If things continue as they are, this shows how the trajectory leans toward positivity, fun, warmth, success, vitality. In your career, treat this archetype as guidance for how you show up in your work and collaborations. Traditionally linked with The Sun, radiating vitality, clarity, and conscious joy.  On an occult level, this echoes The Sun, radiating vitality, clarity, and conscious joy, touches Path Resh (Hod ↔ Yesod), illuminating clarity that animates the self—a symbolic backdrop rather than a fixed rule. Notice the child's unguarded joy on the Sun's horse—authenticity shines when pretense falls away. Use it as feedback about where your present choices may lead.\n\nThe advice (Strength) and outcome (The Sun) share the same Fire energy, creating a unified path forward.\n\n*Self / Advice — how to meet this (Card 7) carries an attention weight of 0.85, so it receives extended focus here.* *Outcome — likely path if unchanged (Card 10) carries an attention weight of 0.95, so it receives extended focus here.*\n\n*Extended staff detail appears because the Advice/Outcome axis carries concentrated weighting.*\n\n### Key Relationships\n\nThis overview shows how core positions interact and compare.\n\nConscious Goal vs Outcome: Elemental repetition amplifies this theme significantly. Conscious Goal (Above) (The Emperor Upright) and Outcome (Final) (The Sun Upright): Both Fire cards reinforce and intensify this elemental energy. Both cards share the same elemental energy, creating a unified and intensified theme.\n\nAdvice vs Outcome: Elemental repetition amplifies this theme significantly. Self/Advice (Strength Upright) and Outcome (The Sun Upright): Both Fire cards reinforce and intensify this elemental energy. Both cards share the same elemental energy, creating a unified and intensified theme.\n\nNear Future vs Outcome: Elemental repetition amplifies this theme significantly. Near Future (Temperance Upright) and Outcome (The Sun Upright): Both Fire cards reinforce and intensify this elemental energy. Both cards share the same elemental energy, creating a unified and intensified theme.\n\nSubconscious vs Hopes & Fears: Subconscious (Below) (The Moon Reversed) and Hopes & Fears (Nine of Swords Reversed): The relationship between these positions shows nuanced dynamics worth exploring. Subconscious (Below) (The Moon Reversed): Within the Delayed Timing lens, Read reversals as energies that will manifest later, after certain conditions are met. Hopes & Fears (Nine of Swords Reversed): Within the Delayed Timing lens, Read reversals as energies that will manifest later, after certain conditions are met.\n\nTaken together, these cross-checks point toward how to translate the spread's insights into your next aligned step.\n\n### Your Reflections\n\nThis reflection shows how this reading lands in your lived experience.\n\nIt feels like multiple towers at the same time; I want to stay compassionate without losing momentum.\n\nYour intuitive impressions are valid and add personal meaning to this reading.\n\n### Deeper Patterns\n\nBeyond the individual positions, your cards reveal larger archetypal movements:\n\n- Fool's Journey — Initiation 4 cards from this stage suggest difficult but necessary transition, releasing control, shadow work.\n- Healing Arc (partial) Death + Temperance—Transformation actively seeking balance\n- The Moon + The Sun What's confusing now is in the process of being revealed and clarified.\n\n### Synthesis & Guidance\n\nThis synthesis shows how the spread integrates into actionable guidance.\n\nFocus: Interpreting this guidance through career, calling, and material pathways.\n\nHigh Major Arcana presence indicates profound, soul-level themes, karmic patterns, and significant life transitions.\n\nElemental context: Fire energy strongly dominates (5/10 cards), requiring attention to balance with other elements.\n\nPace: This reads as an unfolding chapter that rewards consistent, conscious engagement.\n\n**Your next step**\nThis step shows where to focus your agency right now.\nSelf / Advice — how to meet this (Card 7): Guidance on how to meet this situation comes through Strength Upright. This shows how it may help to lean into strength, courage, persuasion, influence, compassion. In your career, treat this archetype as guidance for how you show up in your work and collaborations. Traditionally linked with Leo, calling up heart-led courage and radiant self-expression.  On an occult level, this echoes Leo, calling up heart-led courage and radiant self-expression, touches Path Teth (Chesed ↔ Geburah), taming power through heart-centered strength—a symbolic backdrop rather than a fixed rule. See the gentle hand on the lion's jaw—true strength is compassionate persuasion, not domination. Take it as an invitation, not a command: notice what feels workable.\nThe advice (Strength) and outcome (The Sun) share the same Fire energy, creating a unified path forward.\n\n*This Advice position sits at weight 0.85, so it receives extended guidance above.*\n\n**Trajectory Reminder**\nOutcome — likely path if unchanged (Card 10): If nothing major shifts, The Sun Upright sketches where this could be heading. If things continue as they are, this shows how the trajectory leans toward positivity, fun, warmth, success, vitality. In your career, treat this archetype as guidance for how you show up in your work and collaborations. Traditionally linked with The Sun, radiating vitality, clarity, and conscious joy.  On an occult level, this echoes The Sun, radiating vitality, clarity, and conscious joy, touches Path Resh (Hod ↔ Yesod), illuminating clarity that animates the self—a symbolic backdrop rather than a fixed rule. Notice the child's unguarded joy on the Sun's horse—authenticity shines when pretense falls away. Use it as feedback about where your present choices may lead.\nRemember: The outcome shown by The Sun is a trajectory based on current patterns. Your choices, consciousness, and actions shape what unfolds. You are co-creating this path.\n\n*Outcome receives extra attention because its weight clocks in at 0.95.*\n\n### Supporting Positions\n\nThese Celtic Cross cards carry lighter weighting, so their insights weave into connectors and synthesis:\n- Past — what lies behind (Card 3): Death (weight 0.60) is summarized as connective tissue rather than extended prose.\n- External Influences — people & environment (Card 8): Eight of Pentacles (weight 0.60) is summarized as connective tissue rather than extended prose.\n\n*Reversal lens reminder: Within the Delayed Timing lens, Read reversals as energies that will manifest later, after certain conditions are met.*",
      "themesSummary": {
        "reversalFramework": "delayed",
        "suitFocus": null,
        "archetypeDescription": "High Major Arcana presence indicates profound, soul-level themes, karmic patterns, and significant life transitions."
      }
    }
  ]
}
</file>

<file path="data/evaluations/vision-metrics.json">
{
  "updatedAt": "2025-11-23T01:28:45.368Z",
  "metricsByDeck": {
    "rws-1909": {
      "deckStyle": "rws-1909",
      "generatedAt": "2025-11-23T01:28:45.090Z",
      "sourceFile": "data/evaluations/vision-confidence.rws.json",
      "sampleSize": 78,
      "accuracy": 1,
      "microPrecision": 1,
      "microRecall": 1,
      "microF1": 1,
      "highConfidenceCoverage": 1,
      "highConfidenceAccuracy": 1,
      "symbolCoverageRate": 0.9659935897435895,
      "symbolDetectionRate": 0.964824120603015,
      "symbolMissingLeaders": [
        {
          "symbol": "storm clouds",
          "count": 3
        },
        {
          "symbol": "figure in action or exiting scene",
          "count": 2
        },
        {
          "symbol": "wand",
          "count": 1
        },
        {
          "symbol": "scepter",
          "count": 1
        },
        {
          "symbol": "city",
          "count": 1
        }
      ],
      "symbolBreakdown": [],
      "perLabelAccuracy": [
        {
          "label": "Ace of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ace of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ace of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ace of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Death",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Eight of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Eight of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Eight of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Eight of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Five of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Five of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Five of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Five of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Four of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Four of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Four of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Four of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Judgement",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Justice",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "King of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "King of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "King of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "King of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Knight of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Knight of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Knight of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Knight of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Nine of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Nine of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Nine of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Nine of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Page of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Page of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Page of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Page of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Queen of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Queen of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Queen of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Queen of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Seven of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Seven of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Seven of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Seven of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Six of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Six of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Six of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Six of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Strength",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Temperance",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ten of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ten of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ten of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ten of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Chariot",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Devil",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Emperor",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Empress",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Fool",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Hanged Man",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Hermit",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Hierophant",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The High Priestess",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Lovers",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Magician",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Moon",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Star",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Sun",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Tower",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The World",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Three of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Three of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Three of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Three of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Two of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Two of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Two of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Two of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Wheel of Fortune",
          "accuracy": 1,
          "total": 1
        }
      ]
    },
    "thoth-a1": {
      "deckStyle": "thoth-a1",
      "generatedAt": "2025-11-23T01:28:45.231Z",
      "sourceFile": "data/evaluations/vision-confidence.thoth.json",
      "sampleSize": 78,
      "accuracy": 1,
      "microPrecision": 1,
      "microRecall": 1,
      "microF1": 1,
      "highConfidenceCoverage": 1,
      "highConfidenceAccuracy": 1,
      "symbolCoverageRate": 0.9237756410256407,
      "symbolDetectionRate": 0.9221105527638191,
      "symbolMissingLeaders": [
        {
          "symbol": "storm clouds",
          "count": 5
        },
        {
          "symbol": "stone archways",
          "count": 4
        },
        {
          "symbol": "scepter",
          "count": 2
        },
        {
          "symbol": "mountains",
          "count": 2
        },
        {
          "symbol": "desert horizon with pyramids and cloudless sky",
          "count": 2
        }
      ],
      "symbolBreakdown": [
        {
          "object": "divine hand emerging from cloud with ornate chalice overflowing with water",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "crown or laurels hovering",
          "coverage": 1,
          "total": 4
        },
        {
          "object": "three engraved cups",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "figure observing horizon or architecture",
          "coverage": 1,
          "total": 4
        },
        {
          "object": "four engraved cups",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "seated or standing figure",
          "coverage": 1,
          "total": 4
        },
        {
          "object": "five engraved cups",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "figures in turmoil or adversity",
          "coverage": 1,
          "total": 4
        },
        {
          "object": "six engraved cups",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "giver and receiver figures",
          "coverage": 1,
          "total": 4
        },
        {
          "object": "seven engraved cups",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "standing figure evaluating",
          "coverage": 1,
          "total": 4
        },
        {
          "object": "eight engraved cups",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "figure in action or exiting scene",
          "coverage": 1,
          "total": 4
        },
        {
          "object": "nine engraved cups",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "solitary figure",
          "coverage": 1,
          "total": 4
        },
        {
          "object": "ten engraved cups",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "family/figures interacting",
          "coverage": 1,
          "total": 4
        },
        {
          "object": "page holding ornate chalice overflowing with water",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "fresh terrain",
          "coverage": 1,
          "total": 4
        },
        {
          "object": "knight on steed with ornate chalice overflowing with water",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "steed posture (rearing, pacing, still)",
          "coverage": 1,
          "total": 4
        },
        {
          "object": "queen enthroned with ornate chalice overflowing with water",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "king with ornate chalice overflowing with water",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "architectural motifs (pillars, city walls)",
          "coverage": 1,
          "total": 4
        },
        {
          "object": "divine hand emerging from cloud with engraved golden pentacle",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "verdant fields, vineyards, and stone gateways",
          "coverage": 1,
          "total": 14
        },
        {
          "object": "cultivated fields",
          "coverage": 1,
          "total": 14
        },
        {
          "object": "stone archways",
          "coverage": 1,
          "total": 14
        },
        {
          "object": "two garden pentacles",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "three garden pentacles",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "four garden pentacles",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "five garden pentacles",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "six garden pentacles",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "seven garden pentacles",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "eight garden pentacles",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "nine garden pentacles",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "ten garden pentacles",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "page holding engraved golden pentacle",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "knight on steed with engraved golden pentacle",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "queen enthroned with engraved golden pentacle",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "king with engraved golden pentacle",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "bundle",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "feather",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "infinity symbol",
          "coverage": 1,
          "total": 2
        },
        {
          "object": "wand",
          "coverage": 1,
          "total": 2
        },
        {
          "object": "cup",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "sword",
          "coverage": 1,
          "total": 2
        },
        {
          "object": "pentacle",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "red roses",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "white lilies",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "wheat fields",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "waterfall",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "Venus symbol",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "ram heads",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "mountains",
          "coverage": 1,
          "total": 3
        },
        {
          "object": "armor",
          "coverage": 1,
          "total": 2
        },
        {
          "object": "ankh",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "crossed keys",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "two acolytes",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "raised hand",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "triple cross",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "angel",
          "coverage": 1,
          "total": 3
        },
        {
          "object": "tree of knowledge",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "tree of life",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "mountain",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "cloud",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "sphinxes",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "starry canopy",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "city",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "lion",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "flowers",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "wheel",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "Hebrew letters",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "alchemical symbols",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "four fixed signs",
          "coverage": 1,
          "total": 2
        },
        {
          "object": "scales",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "purple veil",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "tree",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "halo",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "tau cross",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "skeleton",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "white horse",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "banner",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "fallen figures",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "cups",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "one foot in water",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "one foot on land",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "mountain path",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "rising sun",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "horned figure",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "inverted pentagram",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "chained figures",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "tails",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "torch",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "tower",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "falling figures",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "flaming debris",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "gray sky",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "large star",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "seven smaller stars",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "naked figure",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "pitchers",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "bird in tree",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "full moon with face",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "two towers",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "dog and wolf",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "crayfish",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "winding path",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "radiant sun with face",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "naked child",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "sunflowers",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "red banner",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "wall",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "trumpet",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "rising figures",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "water",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "dancer",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "wreath",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "wands",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "red ribbon",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "divine hand emerging from cloud with steel sword with gleaming edge",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "wind-swept plains with storm clouds and distant mountains",
          "coverage": 1,
          "total": 14
        },
        {
          "object": "storm clouds",
          "coverage": 1,
          "total": 14
        },
        {
          "object": "fluttering birds or banners",
          "coverage": 1,
          "total": 14
        },
        {
          "object": "two razor-sharp swords",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "three razor-sharp swords",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "four razor-sharp swords",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "five razor-sharp swords",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "six razor-sharp swords",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "seven razor-sharp swords",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "eight razor-sharp swords",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "nine razor-sharp swords",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "ten razor-sharp swords",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "page holding steel sword with gleaming edge",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "knight on steed with steel sword with gleaming edge",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "queen enthroned with steel sword with gleaming edge",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "king with steel sword with gleaming edge",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "divine hand emerging from cloud with budding wooden wand",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "desert horizon with pyramids and cloudless sky",
          "coverage": 1,
          "total": 14
        },
        {
          "object": "sprouting leaves on wands",
          "coverage": 1,
          "total": 14
        },
        {
          "object": "pyramids and bare mountains",
          "coverage": 1,
          "total": 14
        },
        {
          "object": "two flame-etched wands",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "three flame-etched wands",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "four flame-etched wands",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "five flame-etched wands",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "six flame-etched wands",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "seven flame-etched wands",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "eight flame-etched wands",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "nine flame-etched wands",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "ten flame-etched wands",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "page holding budding wooden wand",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "knight on steed with budding wooden wand",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "queen enthroned with budding wooden wand",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "king with budding wooden wand",
          "coverage": 1,
          "total": 1
        },
        {
          "object": "lush riverbanks with lotus and reflective pools",
          "coverage": 0.9285714285714286,
          "total": 14
        },
        {
          "object": "flowing streams",
          "coverage": 0.9285714285714286,
          "total": 14
        },
        {
          "object": "lotus blossoms",
          "coverage": 0.9285714285714286,
          "total": 14
        },
        {
          "object": "crossed arms or stance",
          "coverage": 0.75,
          "total": 4
        },
        {
          "object": "fauna, familiars, or motifs",
          "coverage": 0.75,
          "total": 4
        },
        {
          "object": "pillars",
          "coverage": 0.6666666666666666,
          "total": 3
        },
        {
          "object": "sun",
          "coverage": 0.5,
          "total": 2
        },
        {
          "object": "pomegranates",
          "coverage": 0.5,
          "total": 2
        },
        {
          "object": "scepter",
          "coverage": 0.5,
          "total": 2
        },
        {
          "object": "two engraved cups",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "dog",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "cliff",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "white rose",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "lunar crown",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "scroll",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "veil",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "crescent moon",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "stars",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "orb",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "lantern",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "six-pointed star",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "staff",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "mountain peak",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "cloak",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "sphinx",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "snake",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "Anubis",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "crossed leg",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "lightning",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "pool",
          "coverage": 0,
          "total": 1
        },
        {
          "object": "land",
          "coverage": 0,
          "total": 1
        }
      ],
      "perLabelAccuracy": [
        {
          "label": "Ace of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ace of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ace of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ace of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Death",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Eight of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Eight of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Eight of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Eight of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Five of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Five of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Five of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Five of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Four of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Four of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Four of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Four of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Judgement",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Justice",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "King of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "King of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "King of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "King of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Knight of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Knight of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Knight of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Knight of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Nine of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Nine of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Nine of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Nine of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Page of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Page of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Page of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Page of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Queen of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Queen of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Queen of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Queen of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Seven of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Seven of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Seven of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Seven of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Six of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Six of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Six of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Six of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Strength",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Temperance",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ten of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ten of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ten of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ten of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Chariot",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Devil",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Emperor",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Empress",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Fool",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Hanged Man",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Hermit",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Hierophant",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The High Priestess",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Lovers",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Magician",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Moon",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Star",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Sun",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Tower",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The World",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Three of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Three of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Three of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Three of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Two of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Two of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Two of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Two of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Wheel of Fortune",
          "accuracy": 1,
          "total": 1
        }
      ]
    },
    "marseille-classic": {
      "deckStyle": "marseille-classic",
      "generatedAt": "2025-11-23T01:28:45.367Z",
      "sourceFile": "data/evaluations/vision-confidence.marseille.json",
      "sampleSize": 78,
      "accuracy": 1,
      "microPrecision": 1,
      "microRecall": 1,
      "microF1": 1,
      "highConfidenceCoverage": 1,
      "highConfidenceAccuracy": 1,
      "symbolCoverageRate": 0.6995423076923073,
      "symbolDetectionRate": 0.7010050251256281,
      "symbolMissingLeaders": [
        {
          "symbol": "stone archways",
          "count": 14
        },
        {
          "symbol": "storm clouds",
          "count": 13
        },
        {
          "symbol": "cultivated fields",
          "count": 11
        },
        {
          "symbol": "flowing streams",
          "count": 11
        },
        {
          "symbol": "lotus blossoms",
          "count": 7
        }
      ],
      "symbolBreakdown": [],
      "perLabelAccuracy": [
        {
          "label": "Ace of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ace of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ace of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ace of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Death",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Eight of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Eight of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Eight of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Eight of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Five of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Five of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Five of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Five of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Four of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Four of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Four of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Four of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Judgement",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Justice",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "King of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "King of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "King of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "King of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Knight of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Knight of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Knight of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Knight of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Nine of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Nine of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Nine of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Nine of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Page of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Page of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Page of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Page of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Queen of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Queen of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Queen of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Queen of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Seven of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Seven of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Seven of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Seven of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Six of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Six of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Six of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Six of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Strength",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Temperance",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ten of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ten of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ten of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Ten of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Chariot",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Devil",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Emperor",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Empress",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Fool",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Hanged Man",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Hermit",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Hierophant",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The High Priestess",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Lovers",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Magician",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Moon",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Star",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Sun",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The Tower",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "The World",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Three of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Three of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Three of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Three of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Two of Cups",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Two of Pentacles",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Two of Swords",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Two of Wands",
          "accuracy": 1,
          "total": 1
        },
        {
          "label": "Wheel of Fortune",
          "accuracy": 1,
          "total": 1
        }
      ]
    }
  }
}
</file>

<file path="data/evaluations/vision-review-queue-marseille.csv">
image,expected,predicted,confidence,basis,human_verdict,human_notes
</file>

<file path="data/evaluations/vision-review-queue-thoth.csv">
image,expected,predicted,confidence,basis,human_verdict,human_notes
thoth_cups_14_knight-cups.png,King of Cups,Knight of Cups,1.0000,image,,
thoth_swords_14_knight-swords.png,King of Swords,Knight of Swords,1.0000,image,,
thoth_wands_14_knight-wands.png,King of Wands,Knight of Wands,1.0000,image,,
</file>

<file path="data/evaluations/vision-review-queue.csv">
image,expected,predicted,confidence,basis,human_verdict,human_notes
</file>

<file path="data/evaluations/vision-review-queue.marseille.csv">
image,expected,predicted,confidence,basis,human_verdict,human_notes
</file>

<file path="data/evaluations/vision-review-queue.rws.csv">
image,expected,predicted,confidence,basis,human_verdict,human_notes
</file>

<file path="data/evaluations/vision-review-queue.thoth.csv">
image,expected,predicted,confidence,basis,human_verdict,human_notes
</file>

<file path="data/indices/marseille/metadata.json">
[
  {
    "id": 0,
    "filename": "coins04.jpg",
    "card_name": "coins04"
  },
  {
    "id": 1,
    "filename": "major00.jpg",
    "card_name": "major00"
  },
  {
    "id": 2,
    "filename": "cups01.jpg",
    "card_name": "cups01"
  },
  {
    "id": 3,
    "filename": "clubs13.jpg",
    "card_name": "clubs13"
  },
  {
    "id": 4,
    "filename": "swords12.jpg",
    "card_name": "swords12"
  },
  {
    "id": 5,
    "filename": "cups14.jpg",
    "card_name": "cups14"
  },
  {
    "id": 6,
    "filename": "clubs02.jpg",
    "card_name": "clubs02"
  },
  {
    "id": 7,
    "filename": "swords09.jpg",
    "card_name": "swords09"
  },
  {
    "id": 8,
    "filename": "major16.jpg",
    "card_name": "major16"
  },
  {
    "id": 9,
    "filename": "major21.jpg",
    "card_name": "major21"
  },
  {
    "id": 10,
    "filename": "swords02.jpg",
    "card_name": "swords02"
  },
  {
    "id": 11,
    "filename": "coins05.jpg",
    "card_name": "coins05"
  },
  {
    "id": 12,
    "filename": "cups02.jpg",
    "card_name": "cups02"
  },
  {
    "id": 13,
    "filename": "coins13.jpg",
    "card_name": "coins13"
  },
  {
    "id": 14,
    "filename": "major04.jpg",
    "card_name": "major04"
  },
  {
    "id": 15,
    "filename": "swords05.jpg",
    "card_name": "swords05"
  },
  {
    "id": 16,
    "filename": "major13.jpg",
    "card_name": "major13"
  },
  {
    "id": 17,
    "filename": "clubs08.jpg",
    "card_name": "clubs08"
  },
  {
    "id": 18,
    "filename": "cups09.jpg",
    "card_name": "cups09"
  },
  {
    "id": 19,
    "filename": "coins06.jpg",
    "card_name": "coins06"
  },
  {
    "id": 20,
    "filename": "coins01.jpg",
    "card_name": "coins01"
  },
  {
    "id": 21,
    "filename": "coins11.jpg",
    "card_name": "coins11"
  },
  {
    "id": 22,
    "filename": "major17.jpg",
    "card_name": "major17"
  },
  {
    "id": 23,
    "filename": "swords07.jpg",
    "card_name": "swords07"
  },
  {
    "id": 24,
    "filename": "coins03.jpg",
    "card_name": "coins03"
  },
  {
    "id": 25,
    "filename": "clubs01.jpg",
    "card_name": "clubs01"
  },
  {
    "id": 26,
    "filename": "major09.jpg",
    "card_name": "major09"
  },
  {
    "id": 27,
    "filename": "cups08.jpg",
    "card_name": "cups08"
  },
  {
    "id": 28,
    "filename": "clubs03.jpg",
    "card_name": "clubs03"
  },
  {
    "id": 29,
    "filename": "coins12.jpg",
    "card_name": "coins12"
  },
  {
    "id": 30,
    "filename": "major06.jpg",
    "card_name": "major06"
  },
  {
    "id": 31,
    "filename": "cups13.jpg",
    "card_name": "cups13"
  },
  {
    "id": 32,
    "filename": "cups04.jpg",
    "card_name": "cups04"
  },
  {
    "id": 33,
    "filename": "swords03.jpg",
    "card_name": "swords03"
  },
  {
    "id": 34,
    "filename": "coins07.jpg",
    "card_name": "coins07"
  },
  {
    "id": 35,
    "filename": "swords01.jpg",
    "card_name": "swords01"
  },
  {
    "id": 36,
    "filename": "cups05.jpg",
    "card_name": "cups05"
  },
  {
    "id": 37,
    "filename": "clubs05.jpg",
    "card_name": "clubs05"
  },
  {
    "id": 38,
    "filename": "clubs10.jpg",
    "card_name": "clubs10"
  },
  {
    "id": 39,
    "filename": "clubs12.jpg",
    "card_name": "clubs12"
  },
  {
    "id": 40,
    "filename": "swords13.jpg",
    "card_name": "swords13"
  },
  {
    "id": 41,
    "filename": "major12.jpg",
    "card_name": "major12"
  },
  {
    "id": 42,
    "filename": "clubs04.jpg",
    "card_name": "clubs04"
  },
  {
    "id": 43,
    "filename": "cups10.jpg",
    "card_name": "cups10"
  },
  {
    "id": 44,
    "filename": "coins09.jpg",
    "card_name": "coins09"
  },
  {
    "id": 45,
    "filename": "swords10.jpg",
    "card_name": "swords10"
  },
  {
    "id": 46,
    "filename": "cups03.jpg",
    "card_name": "cups03"
  },
  {
    "id": 47,
    "filename": "major10.jpg",
    "card_name": "major10"
  },
  {
    "id": 48,
    "filename": "swords04.jpg",
    "card_name": "swords04"
  },
  {
    "id": 49,
    "filename": "major05.jpg",
    "card_name": "major05"
  },
  {
    "id": 50,
    "filename": "major15.jpg",
    "card_name": "major15"
  },
  {
    "id": 51,
    "filename": "clubs14.jpg",
    "card_name": "clubs14"
  },
  {
    "id": 52,
    "filename": "coins08.jpg",
    "card_name": "coins08"
  },
  {
    "id": 53,
    "filename": "cups07.jpg",
    "card_name": "cups07"
  },
  {
    "id": 54,
    "filename": "major02.jpg",
    "card_name": "major02"
  },
  {
    "id": 55,
    "filename": "coins02.jpg",
    "card_name": "coins02"
  },
  {
    "id": 56,
    "filename": "major07.jpg",
    "card_name": "major07"
  },
  {
    "id": 57,
    "filename": "swords11.jpg",
    "card_name": "swords11"
  },
  {
    "id": 58,
    "filename": "major18.jpg",
    "card_name": "major18"
  },
  {
    "id": 59,
    "filename": "cups06.jpg",
    "card_name": "cups06"
  },
  {
    "id": 60,
    "filename": "major08.jpg",
    "card_name": "major08"
  },
  {
    "id": 61,
    "filename": "swords06.jpg",
    "card_name": "swords06"
  },
  {
    "id": 62,
    "filename": "swords14.jpg",
    "card_name": "swords14"
  },
  {
    "id": 63,
    "filename": "major11.jpg",
    "card_name": "major11"
  },
  {
    "id": 64,
    "filename": "coins10.jpg",
    "card_name": "coins10"
  },
  {
    "id": 65,
    "filename": "clubs07.jpg",
    "card_name": "clubs07"
  },
  {
    "id": 66,
    "filename": "major14.jpg",
    "card_name": "major14"
  },
  {
    "id": 67,
    "filename": "major03.jpg",
    "card_name": "major03"
  },
  {
    "id": 68,
    "filename": "clubs06.jpg",
    "card_name": "clubs06"
  },
  {
    "id": 69,
    "filename": "coins14.jpg",
    "card_name": "coins14"
  },
  {
    "id": 70,
    "filename": "clubs11.jpg",
    "card_name": "clubs11"
  },
  {
    "id": 71,
    "filename": "major01.jpg",
    "card_name": "major01"
  },
  {
    "id": 72,
    "filename": "major20.jpg",
    "card_name": "major20"
  },
  {
    "id": 73,
    "filename": "major19.jpg",
    "card_name": "major19"
  },
  {
    "id": 74,
    "filename": "clubs09.jpg",
    "card_name": "clubs09"
  },
  {
    "id": 75,
    "filename": "cups12.jpg",
    "card_name": "cups12"
  },
  {
    "id": 76,
    "filename": "cups11.jpg",
    "card_name": "cups11"
  },
  {
    "id": 77,
    "filename": "swords08.jpg",
    "card_name": "swords08"
  }
]
</file>

<file path="data/indices/rws/metadata.json">
[
  {
    "id": 0,
    "filename": "RWS1909_-_Pentacles_04.jpeg",
    "card_name": "RWS1909   Pentacles 04"
  },
  {
    "id": 1,
    "filename": "RWS1909_-_01_Magician.jpeg",
    "card_name": "RWS1909   01 Magician"
  },
  {
    "id": 2,
    "filename": "RWS1909_-_Wands_10.jpeg",
    "card_name": "RWS1909   Wands 10"
  },
  {
    "id": 3,
    "filename": "RWS1909_-_17_Star.jpeg",
    "card_name": "RWS1909   17 Star"
  },
  {
    "id": 4,
    "filename": "RWS1909_-_Wands_09.jpeg",
    "card_name": "RWS1909   Wands 09"
  },
  {
    "id": 5,
    "filename": "RWS1909_-_Pentacles_08.jpeg",
    "card_name": "RWS1909   Pentacles 08"
  },
  {
    "id": 6,
    "filename": "RWS1909_-_09_Hermit.jpeg",
    "card_name": "RWS1909   09 Hermit"
  },
  {
    "id": 7,
    "filename": "RWS1909_-_Swords_12.jpeg",
    "card_name": "RWS1909   Swords 12"
  },
  {
    "id": 8,
    "filename": "RWS1909_-_Swords_02.jpeg",
    "card_name": "RWS1909   Swords 02"
  },
  {
    "id": 9,
    "filename": "RWS1909_-_Cups_03.jpeg",
    "card_name": "RWS1909   Cups 03"
  },
  {
    "id": 10,
    "filename": "RWS1909_-_Pentacles_03.jpeg",
    "card_name": "RWS1909   Pentacles 03"
  },
  {
    "id": 11,
    "filename": "RWS1909_-_Pentacles_07.jpeg",
    "card_name": "RWS1909   Pentacles 07"
  },
  {
    "id": 12,
    "filename": "RWS1909_-_Swords_04.jpeg",
    "card_name": "RWS1909   Swords 04"
  },
  {
    "id": 13,
    "filename": "RWS1909_-_Cups_01.jpeg",
    "card_name": "RWS1909   Cups 01"
  },
  {
    "id": 14,
    "filename": "RWS1909_-_13_Death.jpeg",
    "card_name": "RWS1909   13 Death"
  },
  {
    "id": 15,
    "filename": "RWS1909_-_15_Devil.jpeg",
    "card_name": "RWS1909   15 Devil"
  },
  {
    "id": 16,
    "filename": "RWS1909_-_Swords_13.jpeg",
    "card_name": "RWS1909   Swords 13"
  },
  {
    "id": 17,
    "filename": "RWS1909_-_Wands_02.jpeg",
    "card_name": "RWS1909   Wands 02"
  },
  {
    "id": 18,
    "filename": "RWS1909_-_Swords_14.jpeg",
    "card_name": "RWS1909   Swords 14"
  },
  {
    "id": 19,
    "filename": "RWS1909_-_Cups_05.jpeg",
    "card_name": "RWS1909   Cups 05"
  },
  {
    "id": 20,
    "filename": "RWS1909_-_Wands_12.jpeg",
    "card_name": "RWS1909   Wands 12"
  },
  {
    "id": 21,
    "filename": "RWS1909_-_Wands_03.jpeg",
    "card_name": "RWS1909   Wands 03"
  },
  {
    "id": 22,
    "filename": "RWS1909_-_19_Sun.jpeg",
    "card_name": "RWS1909   19 Sun"
  },
  {
    "id": 23,
    "filename": "RWS1909_-_10_Wheel_of_Fortune.jpeg",
    "card_name": "RWS1909   10 Wheel of Fortune"
  },
  {
    "id": 24,
    "filename": "RWS1909_-_Pentacles_12.jpeg",
    "card_name": "RWS1909   Pentacles 12"
  },
  {
    "id": 25,
    "filename": "RWS1909_-_Wands_13.jpeg",
    "card_name": "RWS1909   Wands 13"
  },
  {
    "id": 26,
    "filename": "RWS1909_-_07_Chariot.jpeg",
    "card_name": "RWS1909   07 Chariot"
  },
  {
    "id": 27,
    "filename": "RWS1909_-_02_High_Priestess.jpeg",
    "card_name": "RWS1909   02 High Priestess"
  },
  {
    "id": 28,
    "filename": "RWS1909_-_Cups_12.jpeg",
    "card_name": "RWS1909   Cups 12"
  },
  {
    "id": 29,
    "filename": "RWS1909_-_Cups_04.jpeg",
    "card_name": "RWS1909   Cups 04"
  },
  {
    "id": 30,
    "filename": "RWS1909_-_Swords_03.jpeg",
    "card_name": "RWS1909   Swords 03"
  },
  {
    "id": 31,
    "filename": "RWS1909_-_Wands_08.jpeg",
    "card_name": "RWS1909   Wands 08"
  },
  {
    "id": 32,
    "filename": "RWS1909_-_Wands_05.jpeg",
    "card_name": "RWS1909   Wands 05"
  },
  {
    "id": 33,
    "filename": "RWS1909_-_Swords_08.jpeg",
    "card_name": "RWS1909   Swords 08"
  },
  {
    "id": 34,
    "filename": "RWS1909_-_Pentacles_05.jpeg",
    "card_name": "RWS1909   Pentacles 05"
  },
  {
    "id": 35,
    "filename": "RWS1909_-_Swords_07.jpeg",
    "card_name": "RWS1909   Swords 07"
  },
  {
    "id": 36,
    "filename": "RWS1909_-_00_Fool.jpeg",
    "card_name": "RWS1909   00 Fool"
  },
  {
    "id": 37,
    "filename": "RWS1909_-_Cups_14.jpeg",
    "card_name": "RWS1909   Cups 14"
  },
  {
    "id": 38,
    "filename": "RWS1909_-_Pentacles_10.jpeg",
    "card_name": "RWS1909   Pentacles 10"
  },
  {
    "id": 39,
    "filename": "RWS1909_-_Pentacles_14.jpeg",
    "card_name": "RWS1909   Pentacles 14"
  },
  {
    "id": 40,
    "filename": "RWS1909_-_Wands_14.jpeg",
    "card_name": "RWS1909   Wands 14"
  },
  {
    "id": 41,
    "filename": "RWS1909_-_06_Lovers.jpeg",
    "card_name": "RWS1909   06 Lovers"
  },
  {
    "id": 42,
    "filename": "RWS1909_-_08_Strength.jpeg",
    "card_name": "RWS1909   08 Strength"
  },
  {
    "id": 43,
    "filename": "RWS1909_-_18_Moon.jpeg",
    "card_name": "RWS1909   18 Moon"
  },
  {
    "id": 44,
    "filename": "RWS1909_-_Swords_10.jpeg",
    "card_name": "RWS1909   Swords 10"
  },
  {
    "id": 45,
    "filename": "RWS1909_-_03_Empress.jpeg",
    "card_name": "RWS1909   03 Empress"
  },
  {
    "id": 46,
    "filename": "RWS1909_-_Swords_05.jpeg",
    "card_name": "RWS1909   Swords 05"
  },
  {
    "id": 47,
    "filename": "RWS1909_-_Cups_07.jpeg",
    "card_name": "RWS1909   Cups 07"
  },
  {
    "id": 48,
    "filename": "RWS1909_-_Cups_13.jpeg",
    "card_name": "RWS1909   Cups 13"
  },
  {
    "id": 49,
    "filename": "RWS1909_-_Cups_10.jpeg",
    "card_name": "RWS1909   Cups 10"
  },
  {
    "id": 50,
    "filename": "RWS1909_-_Pentacles_09.jpeg",
    "card_name": "RWS1909   Pentacles 09"
  },
  {
    "id": 51,
    "filename": "RWS1909_-_Cups_02.jpeg",
    "card_name": "RWS1909   Cups 02"
  },
  {
    "id": 52,
    "filename": "RWS1909_-_20_Judgement.jpeg",
    "card_name": "RWS1909   20 Judgement"
  },
  {
    "id": 53,
    "filename": "RWS1909_-_Swords_06.jpeg",
    "card_name": "RWS1909   Swords 06"
  },
  {
    "id": 54,
    "filename": "RWS1909_-_Pentacles_01.jpeg",
    "card_name": "RWS1909   Pentacles 01"
  },
  {
    "id": 55,
    "filename": "RWS1909_-_05_Hierophant.jpeg",
    "card_name": "RWS1909   05 Hierophant"
  },
  {
    "id": 56,
    "filename": "RWS1909_-_Cups_06.jpeg",
    "card_name": "RWS1909   Cups 06"
  },
  {
    "id": 57,
    "filename": "RWS1909_-_Wands_11.jpeg",
    "card_name": "RWS1909   Wands 11"
  },
  {
    "id": 58,
    "filename": "RWS1909_-_Swords_09.jpeg",
    "card_name": "RWS1909   Swords 09"
  },
  {
    "id": 59,
    "filename": "RWS1909_-_Wands_06.jpeg",
    "card_name": "RWS1909   Wands 06"
  },
  {
    "id": 60,
    "filename": "RWS1909_-_Swords_11.jpeg",
    "card_name": "RWS1909   Swords 11"
  },
  {
    "id": 61,
    "filename": "RWS1909_-_21_World.jpeg",
    "card_name": "RWS1909   21 World"
  },
  {
    "id": 62,
    "filename": "RWS1909_-_14_Temperance.jpeg",
    "card_name": "RWS1909   14 Temperance"
  },
  {
    "id": 63,
    "filename": "RWS1909_-_Wands_07.jpeg",
    "card_name": "RWS1909   Wands 07"
  },
  {
    "id": 64,
    "filename": "RWS1909_-_Pentacles_11.jpeg",
    "card_name": "RWS1909   Pentacles 11"
  },
  {
    "id": 65,
    "filename": "RWS1909_-_Cups_09.jpeg",
    "card_name": "RWS1909   Cups 09"
  },
  {
    "id": 66,
    "filename": "RWS1909_-_12_Hanged_Man.jpeg",
    "card_name": "RWS1909   12 Hanged Man"
  },
  {
    "id": 67,
    "filename": "RWS1909_-_16_Tower.jpeg",
    "card_name": "RWS1909   16 Tower"
  },
  {
    "id": 68,
    "filename": "RWS1909_-_Pentacles_06.jpeg",
    "card_name": "RWS1909   Pentacles 06"
  },
  {
    "id": 69,
    "filename": "RWS1909_-_Wands_04.jpeg",
    "card_name": "RWS1909   Wands 04"
  },
  {
    "id": 70,
    "filename": "RWS1909_-_11_Justice.jpeg",
    "card_name": "RWS1909   11 Justice"
  },
  {
    "id": 71,
    "filename": "RWS1909_-_Pentacles_13.jpeg",
    "card_name": "RWS1909   Pentacles 13"
  },
  {
    "id": 72,
    "filename": "RWS1909_-_Cups_08.jpeg",
    "card_name": "RWS1909   Cups 08"
  },
  {
    "id": 73,
    "filename": "RWS1909_-_Pentacles_02.jpeg",
    "card_name": "RWS1909   Pentacles 02"
  },
  {
    "id": 74,
    "filename": "RWS1909_-_04_Emperor.jpeg",
    "card_name": "RWS1909   04 Emperor"
  },
  {
    "id": 75,
    "filename": "RWS1909_-_Cups_11.jpeg",
    "card_name": "RWS1909   Cups 11"
  },
  {
    "id": 76,
    "filename": "RWS1909_-_Swords_01.jpeg",
    "card_name": "RWS1909   Swords 01"
  },
  {
    "id": 77,
    "filename": "RWS1909_-_Wands_01.jpeg",
    "card_name": "RWS1909   Wands 01"
  }
]
</file>

<file path="data/indices/thoth/metadata.json">
[
  {
    "id": 0,
    "filename": "thoth_cups_14_knight-cups.png",
    "card_name": "thoth cups 14 knight cups"
  },
  {
    "id": 1,
    "filename": "thoth_cups_02_two-cups-love.png",
    "card_name": "thoth cups 02 two cups love"
  },
  {
    "id": 2,
    "filename": "thoth_major_13_death.png",
    "card_name": "thoth major 13 death"
  },
  {
    "id": 3,
    "filename": "thoth_disks_13_queen-disks.png",
    "card_name": "thoth disks 13 queen disks"
  },
  {
    "id": 4,
    "filename": "thoth_cups_12_prince-cups.png",
    "card_name": "thoth cups 12 prince cups"
  },
  {
    "id": 5,
    "filename": "thoth_wands_11_princess-wands.png",
    "card_name": "thoth wands 11 princess wands"
  },
  {
    "id": 6,
    "filename": "thoth_swords_08_eight-swords-interference.png",
    "card_name": "thoth swords 08 eight swords interference"
  },
  {
    "id": 7,
    "filename": "thoth_major_21_the-universe.png",
    "card_name": "thoth major 21 the universe"
  },
  {
    "id": 8,
    "filename": "thoth_wands_12_prince-wands.png",
    "card_name": "thoth wands 12 prince wands"
  },
  {
    "id": 9,
    "filename": "thoth_major_00_the-fool.png",
    "card_name": "thoth major 00 the fool"
  },
  {
    "id": 10,
    "filename": "thoth_cups_01_ace-cups-root-of-water.png",
    "card_name": "thoth cups 01 ace cups root of water"
  },
  {
    "id": 11,
    "filename": "thoth_disks_11_princess-disks.png",
    "card_name": "thoth disks 11 princess disks"
  },
  {
    "id": 12,
    "filename": "thoth_cups_03_three-cups-abundance.png",
    "card_name": "thoth cups 03 three cups abundance"
  },
  {
    "id": 13,
    "filename": "thoth_major_06_the-lovers.png",
    "card_name": "thoth major 06 the lovers"
  },
  {
    "id": 14,
    "filename": "thoth_major_10_fortune.png",
    "card_name": "thoth major 10 fortune"
  },
  {
    "id": 15,
    "filename": "thoth_major_02_the-priestess.png",
    "card_name": "thoth major 02 the priestess"
  },
  {
    "id": 16,
    "filename": "thoth_major_01_the-magus.png",
    "card_name": "thoth major 01 the magus"
  },
  {
    "id": 17,
    "filename": "thoth_major_14_art.png",
    "card_name": "thoth major 14 art"
  },
  {
    "id": 18,
    "filename": "thoth_major_05_the-hierophant.png",
    "card_name": "thoth major 05 the hierophant"
  },
  {
    "id": 19,
    "filename": "thoth_cups_06_six-cups-pleasure.png",
    "card_name": "thoth cups 06 six cups pleasure"
  },
  {
    "id": 20,
    "filename": "thoth_disks_10_ten-disks-wealth.png",
    "card_name": "thoth disks 10 ten disks wealth"
  },
  {
    "id": 21,
    "filename": "thoth_wands_02_two-wands-dominion.png",
    "card_name": "thoth wands 02 two wands dominion"
  },
  {
    "id": 22,
    "filename": "thoth_disks_14_knight-disks.png",
    "card_name": "thoth disks 14 knight disks"
  },
  {
    "id": 23,
    "filename": "thoth_disks_02_two-disks-change.png",
    "card_name": "thoth disks 02 two disks change"
  },
  {
    "id": 24,
    "filename": "thoth_swords_06_six-swords-science.png",
    "card_name": "thoth swords 06 six swords science"
  },
  {
    "id": 25,
    "filename": "thoth_disks_07_seven-disks-failure.png",
    "card_name": "thoth disks 07 seven disks failure"
  },
  {
    "id": 26,
    "filename": "thoth_swords_12_prince-swords.png",
    "card_name": "thoth swords 12 prince swords"
  },
  {
    "id": 27,
    "filename": "thoth_cups_13_queen-cups.png",
    "card_name": "thoth cups 13 queen cups"
  },
  {
    "id": 28,
    "filename": "thoth_disks_12_prince-disks.png",
    "card_name": "thoth disks 12 prince disks"
  },
  {
    "id": 29,
    "filename": "thoth_wands_14_knight-wands.png",
    "card_name": "thoth wands 14 knight wands"
  },
  {
    "id": 30,
    "filename": "thoth_wands_01_ace-wands-root-of-fire.png",
    "card_name": "thoth wands 01 ace wands root of fire"
  },
  {
    "id": 31,
    "filename": "thoth_wands_07_seven-wands-valour.png",
    "card_name": "thoth wands 07 seven wands valour"
  },
  {
    "id": 32,
    "filename": "thoth_disks_05_five-disks-worry.png",
    "card_name": "thoth disks 05 five disks worry"
  },
  {
    "id": 33,
    "filename": "thoth_cups_11_princess-cups.png",
    "card_name": "thoth cups 11 princess cups"
  },
  {
    "id": 34,
    "filename": "thoth_swords_02_two-swords-peace.png",
    "card_name": "thoth swords 02 two swords peace"
  },
  {
    "id": 35,
    "filename": "thoth_swords_09_nine-swords-cruelty.png",
    "card_name": "thoth swords 09 nine swords cruelty"
  },
  {
    "id": 36,
    "filename": "thoth_swords_07_seven-swords-futility.png",
    "card_name": "thoth swords 07 seven swords futility"
  },
  {
    "id": 37,
    "filename": "thoth_wands_10_ten-wands-oppression.png",
    "card_name": "thoth wands 10 ten wands oppression"
  },
  {
    "id": 38,
    "filename": "thoth_swords_11_princess-swords.png",
    "card_name": "thoth swords 11 princess swords"
  },
  {
    "id": 39,
    "filename": "thoth_major_15_the-devil.png",
    "card_name": "thoth major 15 the devil"
  },
  {
    "id": 40,
    "filename": "thoth_disks_04_four-disks-power.png",
    "card_name": "thoth disks 04 four disks power"
  },
  {
    "id": 41,
    "filename": "thoth_major_09_the-hermit.png",
    "card_name": "thoth major 09 the hermit"
  },
  {
    "id": 42,
    "filename": "thoth_disks_08_eight-disks-prudence.png",
    "card_name": "thoth disks 08 eight disks prudence"
  },
  {
    "id": 43,
    "filename": "thoth_major_16_the-tower.png",
    "card_name": "thoth major 16 the tower"
  },
  {
    "id": 44,
    "filename": "thoth_swords_01_ace-swords-root-of-air.png",
    "card_name": "thoth swords 01 ace swords root of air"
  },
  {
    "id": 45,
    "filename": "thoth_wands_13_queen-wands.png",
    "card_name": "thoth wands 13 queen wands"
  },
  {
    "id": 46,
    "filename": "thoth_wands_03_three-wands-virtue.png",
    "card_name": "thoth wands 03 three wands virtue"
  },
  {
    "id": 47,
    "filename": "thoth_swords_03_three-swords-sorrow.png",
    "card_name": "thoth swords 03 three swords sorrow"
  },
  {
    "id": 48,
    "filename": "thoth_major_19_the-sun.png",
    "card_name": "thoth major 19 the sun"
  },
  {
    "id": 49,
    "filename": "thoth_major_07_the-chariot.png",
    "card_name": "thoth major 07 the chariot"
  },
  {
    "id": 50,
    "filename": "thoth_major_04_the-emperor.png",
    "card_name": "thoth major 04 the emperor"
  },
  {
    "id": 51,
    "filename": "thoth_cups_07_seven-cups-debauch.png",
    "card_name": "thoth cups 07 seven cups debauch"
  },
  {
    "id": 52,
    "filename": "thoth_disks_06_six-disks-success.png",
    "card_name": "thoth disks 06 six disks success"
  },
  {
    "id": 53,
    "filename": "thoth_disks_09_nine-disks-gain.png",
    "card_name": "thoth disks 09 nine disks gain"
  },
  {
    "id": 54,
    "filename": "thoth_major_17_the-star.png",
    "card_name": "thoth major 17 the star"
  },
  {
    "id": 55,
    "filename": "thoth_disks_01_ace-disks-root-of-earth.png",
    "card_name": "thoth disks 01 ace disks root of earth"
  },
  {
    "id": 56,
    "filename": "thoth_swords_04_four-swords-truce.png",
    "card_name": "thoth swords 04 four swords truce"
  },
  {
    "id": 57,
    "filename": "thoth_swords_13_queen-swords.png",
    "card_name": "thoth swords 13 queen swords"
  },
  {
    "id": 58,
    "filename": "thoth_swords_14_knight-swords.png",
    "card_name": "thoth swords 14 knight swords"
  },
  {
    "id": 59,
    "filename": "thoth_swords_05_five-swords-defeat.png",
    "card_name": "thoth swords 05 five swords defeat"
  },
  {
    "id": 60,
    "filename": "thoth_major_20_the-aeon.png",
    "card_name": "thoth major 20 the aeon"
  },
  {
    "id": 61,
    "filename": "thoth_wands_08_eight-wands-swiftness.png",
    "card_name": "thoth wands 08 eight wands swiftness"
  },
  {
    "id": 62,
    "filename": "thoth_major_03_the-empress.png",
    "card_name": "thoth major 03 the empress"
  },
  {
    "id": 63,
    "filename": "thoth_swords_10_ten-swords-ruin.png",
    "card_name": "thoth swords 10 ten swords ruin"
  },
  {
    "id": 64,
    "filename": "thoth_wands_05_five-wands-strife.png",
    "card_name": "thoth wands 05 five wands strife"
  },
  {
    "id": 65,
    "filename": "thoth_wands_06_six-wands-victory.png",
    "card_name": "thoth wands 06 six wands victory"
  },
  {
    "id": 66,
    "filename": "thoth_cups_08_eight-cups-indolence.png",
    "card_name": "thoth cups 08 eight cups indolence"
  },
  {
    "id": 67,
    "filename": "thoth_wands_04_four-wands-completion.png",
    "card_name": "thoth wands 04 four wands completion"
  },
  {
    "id": 68,
    "filename": "thoth_major_12_the-hanged-man.png",
    "card_name": "thoth major 12 the hanged man"
  },
  {
    "id": 69,
    "filename": "thoth_cups_09_nine-cups-happiness.png",
    "card_name": "thoth cups 09 nine cups happiness"
  },
  {
    "id": 70,
    "filename": "thoth_wands_09_nine-wands-strength.png",
    "card_name": "thoth wands 09 nine wands strength"
  },
  {
    "id": 71,
    "filename": "thoth_major_18_the-moon.png",
    "card_name": "thoth major 18 the moon"
  },
  {
    "id": 72,
    "filename": "thoth_cups_04_four-cups-luxury.png",
    "card_name": "thoth cups 04 four cups luxury"
  },
  {
    "id": 73,
    "filename": "thoth_cups_10_ten-cups-satiety.png",
    "card_name": "thoth cups 10 ten cups satiety"
  },
  {
    "id": 74,
    "filename": "thoth_major_08_adjustment.png",
    "card_name": "thoth major 08 adjustment"
  },
  {
    "id": 75,
    "filename": "thoth_cups_05_five-cups-disappointment.png",
    "card_name": "thoth cups 05 five cups disappointment"
  },
  {
    "id": 76,
    "filename": "thoth_disks_03_three-disks-works.png",
    "card_name": "thoth disks 03 three disks works"
  },
  {
    "id": 77,
    "filename": "thoth_major_11_lust.png",
    "card_name": "thoth major 11 lust"
  }
]
</file>

<file path="docs/knowledge-graph/ARCHETYPAL_DYADS.md">
# Archetypal Dyads - Data Structure Specification

## Overview

Archetypal Dyads are powerful two-card combinations that create synergistic meaning beyond their individual interpretations. When these specific pairs appear together in a spread, they tell a recognizable story or highlight a particular dynamic that professional readers consistently observe.

## Current Implementation

The codebase already detects 5 dyads in `src/lib/deck.js:computeRelationships()`:

```javascript
const pairings = [
  { cards: ['The Fool', 'The Magician'], desc: 'New beginnings (Fool) empowered by manifesting ability (Magician).' },
  { cards: ['Death', 'The Star'], desc: 'Transformation (Death) leading to hope and renewal (Star).' },
  { cards: ['The Tower', 'The Sun'], desc: 'Upheaval (Tower) clearing the path to joy and clarity (Sun).' },
  { cards: ['The Devil', 'The Lovers'], desc: 'Attachment patterns (Devil) affecting relationship choices (Lovers).' },
  { cards: ['The Hermit', 'The High Priestess'], desc: 'Deep introspection (Hermit) accessing inner wisdom (High Priestess).' }
];
```

This document extends that foundation with richer metadata and additional dyads.

---

## Design Principles

### What Makes a Valid Dyad

1. **Synergistic Meaning:** The pair together means more than the sum of individual cards
2. **Professional Recognition:** Experienced readers recognize this combination as significant
3. **Clear Dynamic:** The relationship between the cards is intuitive and meaningful
4. **Flexible Context:** Works across different spread positions and question types

### Dyad Categories

**Transformation Dyads:** Cards that mark shift from one state to another
**Amplification Dyads:** Cards that intensify each other's energy
**Tension Dyads:** Cards that create productive friction
**Support Dyads:** Cards that harmonize and strengthen
**Caution Dyads:** Cards that signal challenge or warning

---

## Extended Dyad Library

### **Category: Transformation**

#### 1. Death + The Star ⭐ (Existing)
**Cards:** Death (13) + The Star (17)
**Theme:** Transformation clearing into hope
**Dynamic:** "The ending creates space for renewal"

**Description:**
Death marks a necessary ending—something must be released. The Star is renewed hope, inspiration, and spiritual healing that becomes possible after the release. Together they say: "What you're grieving is making room for something better."

**Reading Context:**
- Grief work that leads to healing
- Career change opening new possibilities
- Relationship ending clearing space for growth
- Shadow work revealing light

**Narrative Template:**
> "Death and The Star together form a powerful dyad: {Death context} is clearing the ground for {Star context} to emerge. The ending isn't empty—it's making space for renewed hope and purpose."

**Significance:** High (transformation + renewal)

---

#### 2. The Tower + The Sun ⭐ (Existing)
**Cards:** The Tower (16) + The Sun (19)
**Theme:** Upheaval revealing clarity
**Dynamic:** "Necessary destruction brings authentic joy"

**Description:**
The Tower's upheaval—sudden, uncomfortable, unavoidable—clears away illusions and false structures. The Sun is the clarity, authenticity, and joy that shine through once the false stuff collapses. Together: "What's falling apart needed to fall apart so truth could emerge."

**Reading Context:**
- Sudden life changes revealing what truly matters
- Illusions shattered, authentic self reclaimed
- Crisis leading to clarity
- Liberation through disruption

**Narrative Template:**
> "The Tower and The Sun create a liberation dyad: {Tower context} is dismantling what was false, allowing {Sun context}—your authentic self and genuine joy—to finally shine without obstruction."

**Significance:** High (crisis + breakthrough)

---

#### 3. The Hanged Man + Death (NEW)
**Cards:** The Hanged Man (12) + Death (13)
**Theme:** Surrender enabling transformation
**Dynamic:** "Letting go makes way for metamorphosis"

**Description:**
The Hanged Man asks you to surrender, pause, release control. Death is the transformation that becomes possible once you stop fighting it. Together: "Your willingness to let go determines how gracefully transformation unfolds."

**Reading Context:**
- Accepting change rather than resisting
- Spiritual surrender preceding rebirth
- Releasing attachment to outcomes
- Trusting the process

**Narrative Template:**
> "The Hanged Man and Death form a surrender-transformation dyad: {Hanged Man context} prepares the way for {Death context}. Your capacity to release control eases the metamorphosis ahead."

**Significance:** Medium-High (transition dyad)

---

### **Category: Empowerment**

#### 4. The Fool + The Magician ⭐ (Existing)
**Cards:** The Fool (0) + The Magician (1)
**Theme:** Innocent potential meeting conscious skill
**Dynamic:** "Beginner's mind empowered by mastery"

**Description:**
The Fool is pure potential, innocence, spontaneous trust. The Magician is "as above, so below"—conscious manifestation, skill, resourcefulness. Together: "You have both the fresh perspective of a beginner AND the tools to manifest your vision."

**Reading Context:**
- Starting something new with both innocence and skill
- Combining creativity with technique
- Beginner's luck meeting practiced ability
- Fresh start with resources ready

**Narrative Template:**
> "The Fool and The Magician unite innocence with mastery: {Fool context} brings fresh vision while {Magician context} provides the skill to manifest it. You're both beginner and adept."

**Significance:** High (initiation + manifestation)

---

#### 5. Strength + Justice (NEW)
**Cards:** Strength (8) + Justice (11)
**Theme:** Compassion balanced with accountability
**Dynamic:** "Gentle power meets fair judgment"

**Description:**
Strength is compassionate courage, taming the inner beast with love rather than force. Justice is truth, fairness, accountability. Together: "Be both kind AND fair. Compassion doesn't mean avoiding accountability."

**Reading Context:**
- Difficult conversations requiring both kindness and honesty
- Self-compassion alongside personal responsibility
- Leadership that balances care with clear boundaries
- Forgiveness that doesn't bypass justice

**Narrative Template:**
> "Strength and Justice create a balanced power dyad: {Strength context} ensures compassion while {Justice context} maintains accountability. Neither overwhelms the other; both are required."

**Significance:** Medium (balanced approach)

---

### **Category: Wisdom & Intuition**

#### 6. The Hermit + The High Priestess ⭐ (Existing)
**Cards:** The Hermit (9) + The High Priestess (2)
**Theme:** Solitary wisdom accessing deep intuition
**Dynamic:** "Outer withdrawal revealing inner knowing"

**Description:**
The Hermit withdraws from the world to seek wisdom through reflection and study. The High Priestess is the deep intuitive knowing, the unconscious wisdom that speaks when the mind is quiet. Together: "Solitude allows you to hear the voice within."

**Reading Context:**
- Meditation/contemplative practice
- Trusting intuition over external advice
- Inner guidance through withdrawal
- Shadow work in solitude

**Narrative Template:**
> "The Hermit and The High Priestess form a wisdom dyad: {Hermit context} creates the quiet space where {High Priestess context}—deep intuitive knowing—can finally be heard."

**Significance:** Medium-High (inner wisdom)

---

#### 7. The High Priestess + The Hierophant (NEW)
**Cards:** The High Priestess (2) + The Hierophant (5)
**Theme:** Inner knowing versus outer teaching
**Dynamic:** "Personal intuition meets traditional wisdom"

**Description:**
The High Priestess is inner knowing, mystery, the wisdom that comes from within. The Hierophant is external teaching, tradition, established doctrine. Together: "Which do you trust more—your inner voice or the received wisdom? Can you honor both?"

**Reading Context:**
- Choosing between personal path and traditional expectations
- Integrating intuition with spiritual teachings
- Honoring inner knowing while respecting tradition
- Finding your own way within or beyond formal paths

**Narrative Template:**
> "The High Priestess and The Hierophant create a wisdom-tension dyad: {High Priestess context} speaks from within while {Hierophant context} speaks from tradition. You're navigating where these two sources align or diverge."

**Significance:** Medium (choice between paths)

---

### **Category: Challenge & Shadow**

#### 8. The Devil + The Lovers ⭐ (Existing)
**Cards:** The Devil (15) + The Lovers (6)
**Theme:** Attachment patterns affecting choice
**Dynamic:** "Shadow bondage influencing values alignment"

**Description:**
The Devil is attachment, addiction, unhealthy bondage, shadow. The Lovers is values-based choice, alignment, relationship. Together: "Your attachment patterns (Devil) are affecting the choices you make (Lovers). Can you choose from freedom or are you choosing from bondage?"

**Reading Context:**
- Relationship choices influenced by unhealed wounds
- Codependency versus healthy partnership
- Addiction affecting decision-making
- Shadow work around intimacy

**Narrative Template:**
> "The Devil and The Lovers form a shadow-choice dyad: {Devil context} reveals attachment patterns that are influencing {Lovers context}—your capacity to choose freely and align with true values."

**Significance:** High (shadow work critical)

---

#### 9. The Moon + The Sun (NEW)
**Cards:** The Moon (18) + The Sun (19)
**Theme:** Mystery yielding to illumination
**Dynamic:** "Confusion clarifying into truth"

**Description:**
The Moon is illusion, confusion, the unconscious, things not yet clear. The Sun is radiant clarity, truth revealed, everything illuminated. Together: "What's confusing now will become clear. The fog is lifting."

**Reading Context:**
- Confusion transitioning to clarity
- Unconscious material becoming conscious
- Deception giving way to truth
- Trust the process of revelation

**Narrative Template:**
> "The Moon and The Sun form a clarity-emergence dyad: {Moon context} holds mystery and confusion, while {Sun context} promises illumination. What's unclear now is in the process of being revealed."

**Significance:** Medium-High (clarity coming)

---

#### 10. The Devil + The Tower (NEW)
**Cards:** The Devil (15) + The Tower (16)
**Theme:** Bondage meeting disruption
**Dynamic:** "What you're attached to is being shaken"

**Description:**
The Devil is what binds you—attachment, addiction, limiting beliefs. The Tower is sudden disruption, collapse, necessary destruction. Together: "The chains are breaking whether you're ready or not. What you've been clinging to is falling apart."

**Reading Context:**
- Forced liberation from addiction
- Toxic patterns being disrupted
- Shadow work initiated by crisis
- Attachment being challenged

**Narrative Template:**
> "The Devil and The Tower create a liberation-through-crisis dyad: {Devil context} shows what you're bound to, while {Tower context} is the disruptive force breaking those chains. Embrace the liberation even if it's uncomfortable."

**Significance:** High (crisis + opportunity)

---

### **Category: Cycles & Fate**

#### 11. Wheel of Fortune + Judgement (NEW)
**Cards:** Wheel of Fortune (10) + Judgement (20)
**Theme:** Fate meeting conscious reckoning
**Dynamic:** "Destiny calling you to account"

**Description:**
The Wheel is cycles, fate, karma, turning points. Judgement is awakening, reckoning, rebirth, the call to rise. Together: "A karmic cycle is completing, and you're being called to integrate the lesson and step into a new chapter consciously."

**Reading Context:**
- Major life cycle completing
- Karmic lesson ready for integration
- Spiritual awakening at turning point
- Conscious evolution

**Narrative Template:**
> "The Wheel of Fortune and Judgement form a karmic-awakening dyad: {Wheel context} marks a turning point where {Judgement context} calls you to integrate the lesson and rise transformed."

**Significance:** High (major transition)

---

### **Category: Power & Structure**

#### 12. The Emperor + The Empress (NEW)
**Cards:** The Emperor (4) + The Empress (3)
**Theme:** Structure and abundance in dialogue
**Dynamic:** "Masculine structure meets feminine flow"

**Description:**
The Emperor is structure, authority, boundaries, discipline, the masculine principle. The Empress is abundance, nurture, creativity, flow, the feminine principle. Together: "Both energies are needed. Can you build structure without rigidity? Flow without chaos?"

**Reading Context:**
- Balancing work and rest
- Integrating discipline with creativity
- Masculine-feminine balance
- Structure supporting growth

**Narrative Template:**
> "The Emperor and The Empress form a balance dyad: {Emperor context} provides structure and boundaries while {Empress context} brings abundance and flow. You're learning to honor both."

**Significance:** Medium (integration)

---

#### 13. The Hierophant + The Devil (NEW)
**Cards:** The Hierophant (5) + The Devil (15)
**Theme:** Tradition becoming restriction
**Dynamic:** "When guidance becomes bondage"

**Description:**
The Hierophant is tradition, teaching, spiritual authority, conformity. The Devil is bondage, restriction, unhealthy attachment. Together: "When does helpful structure become limiting dogma? Are traditions serving you or binding you?"

**Reading Context:**
- Religious trauma or spiritual restriction
- Outgrowing traditional teachings
- Dogma versus personal truth
- Breaking from limiting traditions

**Narrative Template:**
> "The Hierophant and The Devil create a tradition-bondage dyad: {Hierophant context} shows where traditional wisdom may have become {Devil context}—restricting rather than guiding. Discernment is required."

**Significance:** Medium (caution/shadow)

---

### **Category: Hope & Vision**

#### 14. The Star + Judgement (NEW)
**Cards:** The Star (17) + Judgement (20)
**Theme:** Renewed hope calling forth rebirth
**Dynamic:** "Hope inspiring transformation"

**Description:**
The Star is hope restored, inspiration, spiritual healing, vision. Judgement is rebirth, awakening, the call to rise. Together: "Renewed hope is calling you into a higher version of yourself. The vision is catalyzing transformation."

**Reading Context:**
- Hope after darkness inspiring renewal
- Vision leading to conscious evolution
- Healing enabling rebirth
- Inspiration catalyzing change

**Narrative Template:**
> "The Star and Judgement form a rebirth dyad: {Star context} renews hope and vision, which in turn calls forth {Judgement context}—conscious rebirth into a new chapter."

**Significance:** High (positive transformation)

---

#### 15. The Chariot + The World (NEW)
**Cards:** The Chariot (7) + The World (21)
**Theme:** Determined action reaching completion
**Dynamic:** "Victory approaching culmination"

**Description:**
The Chariot is willpower, disciplined action, moving forward with focus. The World is completion, mastery, achievement, integration. Together: "Your focused effort is paying off. Victory is not just near—it's about to become complete mastery."

**Reading Context:**
- Projects nearing completion
- Goals within reach
- Sustained effort bearing fruit
- Success and integration

**Narrative Template:**
> "The Chariot and The World form a victory-completion dyad: {Chariot context} shows determined effort that is leading to {World context}—complete achievement and integration."

**Significance:** High (success imminent)

---

## Data Structure Schema

```javascript
export const ARCHETYPAL_DYADS = [
  // Existing dyads (preserve backward compatibility)
  {
    cards: [0, 1],
    names: ['The Fool', 'The Magician'],
    theme: 'Innocent potential meeting conscious skill',
    category: 'empowerment',
    description: 'Beginner\'s mind empowered by mastery. Fresh vision with the tools to manifest it.',
    narrative: 'You have both the fresh perspective of a beginner AND the tools to manifest your vision.',
    significance: 'high'
  },
  {
    cards: [13, 17],
    names: ['Death', 'The Star'],
    theme: 'Transformation clearing into hope',
    category: 'transformation',
    description: 'Necessary ending creating space for renewal. Grief making room for healing.',
    narrative: 'What you\'re releasing is making space for renewed hope and purpose.',
    significance: 'high'
  },
  {
    cards: [16, 19],
    names: ['The Tower', 'The Sun'],
    theme: 'Upheaval revealing clarity',
    category: 'transformation',
    description: 'Necessary destruction bringing authentic joy. Illusions shattered, truth shining through.',
    narrative: 'What\'s falling apart needed to fall apart so truth and joy could emerge.',
    significance: 'high'
  },
  {
    cards: [15, 6],
    names: ['The Devil', 'The Lovers'],
    theme: 'Attachment patterns affecting choice',
    category: 'shadow-challenge',
    description: 'Shadow bondage influencing values-based decisions. Addiction affecting relationship choices.',
    narrative: 'Your attachment patterns are affecting your capacity to choose freely and align with true values.',
    significance: 'high'
  },
  {
    cards: [9, 2],
    names: ['The Hermit', 'The High Priestess'],
    theme: 'Solitary wisdom accessing intuition',
    category: 'wisdom-intuition',
    description: 'Outer withdrawal revealing inner knowing. Solitude allowing the inner voice to be heard.',
    narrative: 'Solitude creates the quiet space where deep intuitive knowing can finally be heard.',
    significance: 'medium-high'
  },

  // NEW dyads (extending the library)
  {
    cards: [12, 13],
    names: ['The Hanged Man', 'Death'],
    theme: 'Surrender enabling transformation',
    category: 'transformation',
    description: 'Letting go making way for metamorphosis. Acceptance easing the transition.',
    narrative: 'Your willingness to release control determines how gracefully transformation unfolds.',
    significance: 'medium-high'
  },
  {
    cards: [8, 11],
    names: ['Strength', 'Justice'],
    theme: 'Compassion balanced with accountability',
    category: 'empowerment',
    description: 'Gentle power meeting fair judgment. Kindness that doesn\'t bypass accountability.',
    narrative: 'Be both kind AND fair. Compassion doesn\'t mean avoiding responsibility.',
    significance: 'medium'
  },
  {
    cards: [2, 5],
    names: ['The High Priestess', 'The Hierophant'],
    theme: 'Inner knowing versus outer teaching',
    category: 'wisdom-intuition',
    description: 'Personal intuition meeting traditional wisdom. Inner voice versus received teachings.',
    narrative: 'Navigate where your inner knowing and traditional wisdom align or diverge.',
    significance: 'medium'
  },
  {
    cards: [18, 19],
    names: ['The Moon', 'The Sun'],
    theme: 'Mystery yielding to illumination',
    category: 'transformation',
    description: 'Confusion clarifying into truth. Unconscious material becoming conscious.',
    narrative: 'What\'s confusing now is in the process of being revealed and clarified.',
    significance: 'medium-high'
  },
  {
    cards: [15, 16],
    names: ['The Devil', 'The Tower'],
    theme: 'Bondage meeting disruption',
    category: 'shadow-challenge',
    description: 'Attachment being forcefully broken. Liberation through crisis.',
    narrative: 'The chains are breaking whether you\'re ready or not. Embrace the liberation.',
    significance: 'high'
  },
  {
    cards: [10, 20],
    names: ['Wheel of Fortune', 'Judgement'],
    theme: 'Fate meeting conscious reckoning',
    category: 'cycles-fate',
    description: 'Karmic cycle completing, calling for integration and conscious evolution.',
    narrative: 'A major cycle is completing; integrate the lesson and rise transformed.',
    significance: 'high'
  },
  {
    cards: [4, 3],
    names: ['The Emperor', 'The Empress'],
    theme: 'Structure and abundance in dialogue',
    category: 'power-structure',
    description: 'Masculine structure meeting feminine flow. Discipline supporting creativity.',
    narrative: 'Honor both structure and flow, discipline and abundance.',
    significance: 'medium'
  },
  {
    cards: [5, 15],
    names: ['The Hierophant', 'The Devil'],
    theme: 'Tradition becoming restriction',
    category: 'shadow-challenge',
    description: 'When guidance becomes bondage, when tradition restricts rather than liberates.',
    narrative: 'Discern where traditional wisdom serves you and where it binds you.',
    significance: 'medium'
  },
  {
    cards: [17, 20],
    names: ['The Star', 'Judgement'],
    theme: 'Renewed hope calling forth rebirth',
    category: 'hope-vision',
    description: 'Hope inspiring transformation. Vision catalyzing conscious evolution.',
    narrative: 'Renewed hope is calling you into a higher version of yourself.',
    significance: 'high'
  },
  {
    cards: [7, 21],
    names: ['The Chariot', 'The World'],
    theme: 'Determined action reaching completion',
    category: 'hope-vision',
    description: 'Victory approaching culmination. Sustained effort bearing full fruit.',
    narrative: 'Your focused effort is leading to complete achievement and mastery.',
    significance: 'high'
  }
];
```

## Detection Logic

```javascript
function detectArchetypalDyads(cards) {
  const numbers = cards
    .filter(c => c.number >= 0 && c.number <= 21)
    .map(c => c.number);

  const detected = [];

  ARCHETYPAL_DYADS.forEach(dyad => {
    if (dyad.cards.every(num => numbers.includes(num))) {
      detected.push({
        cards: dyad.cards,
        names: dyad.names,
        theme: dyad.theme,
        category: dyad.category,
        description: dyad.description,
        narrative: dyad.narrative,
        significance: dyad.significance
      });
    }
  });

  return detected;
}
```

## Usage Guidelines

### Priority in Readings

1. **Complete Triads** (highest)
2. **High-significance dyads** (Death+Star, Tower+Sun, Fool+Magician, Devil+Lovers)
3. **Medium-high dyads**
4. **Medium dyads** (mention if space permits)

### Narrative Integration

**Strong Dyad (high significance):**
> "{Card1} and {Card2} create a powerful {category} dyad: {narrative template with card contexts}."

**Supporting Dyad (medium significance):**
> "Note also {Card1} and {Card2}: {brief narrative}."

### Don't Overwhelm

- Maximum 2-3 dyad mentions per reading
- Prioritize complete triads over dyads
- Choose dyads most relevant to the question

---

## References

- Greer, Mary K. *Tarot Constellations*. New Page Books, 2008.
- Fairfield, Gail. *Choice Centered Tarot*. Red Wheel/Weiser, 1997.
- Professional reader practice (common combinations)
</file>

<file path="docs/knowledge-graph/ARCHETYPAL_TRIADS.md">
# Archetypal Triads - Data Structure Specification

## Overview

Archetypal Triads are powerful three-card combinations that form complete narrative arcs. When these cards appear together in a spread, they create a synergy greater than the sum of their parts—telling a specific, recognizable story of transformation, growth, or challenge.

## Traditional Foundation

Triads are based on:
- **Sequential narrative logic** in the Major Arcana
- **Thematic resonance** across cards
- **Professional reading practice** (common patterns readers recognize)
- **Psychological transformation arcs** (crisis → process → resolution)

## Core Principles

### What Makes a Valid Triad

1. **Narrative Coherence:** The three cards tell a clear story with beginning → middle → end
2. **Transformational Arc:** There's a journey from one state to another
3. **Resonant Meaning:** Professional readers recognize this combination as significant
4. **Position Independence:** The pattern holds meaning regardless of spread positions

### Triad Structure

Each triad includes:
- **Complete form:** All 3 cards present (highest significance)
- **Partial forms:** Any 2 of the 3 cards (supporting significance)
- **Narrative template:** Story the complete triad tells
- **Partial narratives:** Stories when only 2/3 cards appear

---

## The Five Core Triads

### 1. The Healing Arc
**Cards:** Death (13) → Temperance (14) → The Star (17)
**Theme:** Transformation through Integration to Renewal

**Complete Narrative:**
"The classic healing journey. Death (13) marks a necessary ending—something in your life must be released. Temperance (14) is the alchemical middle space where you integrate the loss, finding new balance through patient, gentle work. The Star (17) is renewed hope emerging—you've weathered the storm and can now see guiding light. This is the arc of authentic healing: ending → integration → rebirth."

**Why This Works:**
- Death initiates transformation
- Temperance is the healing process itself (alchemy, integration)
- Star is the result: hope restored after darkness

**Partial Narratives:**
- **Death + Temperance:** "Transformation actively seeking balance; you're in the integration phase of a major ending."
- **Temperance + Star:** "Patient alchemical work leading to renewed hope; the healing process is bearing fruit."
- **Death + Star:** "Dramatic shift from ending to rebirth, though you may be skipping the slow integration work that Temperance offers."

**Reading Context:**
- **Grief work:** Literal healing from loss
- **Life transitions:** Career change, relationship ending, identity shift
- **Shadow integration:** Releasing old patterns, integrating new self

**Significance Levels:**
- Complete (all 3): "major" — Explicitly name as The Healing Arc
- Partial (2/3): "supporting" — Mention the partial connection

---

### 2. The Liberation Arc
**Cards:** The Devil (15) → The Tower (16) → The Sun (19)
**Theme:** From Bondage through Destruction to Freedom

**Complete Narrative:**
"The arc of breaking free. The Devil (15) names the chains—addiction, limiting beliefs, toxic attachment, materialism. You're aware of bondage but may feel powerless. The Tower (16) is the necessary disruption that breaks those chains—often sudden, uncomfortable, but ultimately liberating. The Sun (19) is the joy and clarity that emerge when you're finally free. This triad says: what's falling apart needed to fall apart so you could reclaim your authentic self."

**Why This Works:**
- Devil = recognizing what binds you
- Tower = the breakdown that frees you
- Sun = the joy of liberation, authentic self restored

**Partial Narratives:**
- **Devil + Tower:** "Attachments meeting necessary disruption; the chains are breaking whether you're ready or not."
- **Tower + Sun:** "Upheaval clearing the path to clarity and joy; what's collapsing reveals the truth."
- **Devil + Sun:** "From shadow bondage to radiant freedom, though the Tower's rupture happens swiftly rather than gradually."

**Reading Context:**
- **Addiction recovery:** Literal or metaphorical
- **Toxic relationships:** Recognizing bondage, experiencing rupture, finding freedom
- **Career change:** Leaving what no longer serves
- **Spiritual awakening:** Breaking from limiting dogma

**Significance Levels:**
- Complete: "major" — Name as Liberation Arc
- Partial: "supporting" — Acknowledge the transition energy

---

### 3. The Inner Work Arc
**Cards:** The Hermit (9) → The Hanged Man (12) → The Moon (18)
**Theme:** Solitude through Surrender into Deep Mystery

**Complete Narrative:**
"The contemplative path. The Hermit (9) withdraws from the outer world to seek inner wisdom—solitary reflection, meditation, study. The Hanged Man (12) deepens this by asking you to surrender, to stop trying to figure it out, and simply hang in the mystery. The Moon (18) is where this leads: the deep unconscious, dream realm, shadow work, intuitive knowing that transcends logic. This triad describes profound inner work that can't be rushed."

**Why This Works:**
- Hermit = intentional solitude for wisdom
- Hanged Man = surrendering the need to control or understand
- Moon = diving into the unconscious, embracing mystery

**Partial Narratives:**
- **Hermit + Hanged Man:** "Introspection leading to necessary pause; solitude demands you stop striving."
- **Hanged Man + Moon:** "Surrender opening to the shadow realm; letting go reveals hidden depths."
- **Hermit + Moon:** "Solo journey into the unconscious; withdrawal for deep psychospiritual work."

**Reading Context:**
- **Spiritual practice:** Meditation, dreamwork, shadow integration
- **Therapy/inner work:** Deep psychological processing
- **Creative incubation:** Allowing ideas to gestate without forcing
- **Grief:** The quiet, internal work of mourning

**Significance Levels:**
- Complete: "major" — The Inner Work Arc (emphasize patience)
- Partial: "supporting" — Acknowledge contemplative energy

---

### 4. The Mastery Arc
**Cards:** The Magician (1) → The Chariot (7) → The World (21)
**Theme:** Skill through Directed Action to Complete Achievement

**Complete Narrative:**
"The path of manifestation and mastery. The Magician (1) marshals all resources ('as above, so below')—you have the tools and the knowledge. The Chariot (7) is disciplined, focused action: willpower channeled toward a clear goal. The World (21) is the fruition: complete achievement, integration, mastery. This triad says: you know what to do (Magician), you're doing it with focus (Chariot), and you're reaching completion (World)."

**Why This Works:**
- Magician = potential + skill + resources
- Chariot = directed willpower in action
- World = culmination, success, integration

**Partial Narratives:**
- **Magician + Chariot:** "Potential directed into decisive movement; skill meeting disciplined action."
- **Chariot + World:** "Determined effort reaching culmination; victory is near."
- **Magician + World:** "From first spark to full realization; the journey of bringing vision into form."

**Reading Context:**
- **Career goals:** Building expertise, achieving success
- **Creative projects:** From concept to completion
- **Personal development:** Mastering new skills, reaching milestones
- **Manifestation work:** Consciously creating desired outcomes

**Significance Levels:**
- Complete: "major" — The Mastery Arc (celebrate progress)
- Partial: "supporting" — Acknowledge forward momentum

---

### 5. The Relationship & Values Arc
**Cards:** The Empress (3) → The Lovers (6) → The Hierophant (5)
**Theme:** Abundance through Choice to Commitment

**Complete Narrative:**
"The arc of examining what you value. The Empress (3) is abundance, sensory pleasure, creative fertility—life offering you richness. The Lovers (6) is the choice point: among these abundant options, what aligns with your deepest values? What do you choose? The Hierophant (5) is commitment to something larger than yourself—tradition, teaching, spiritual path, or formal bond. This triad asks: What do you value enough to commit to?"

**Why This Works:**
- Empress = abundance, many options, sensory richness
- Lovers = choosing based on values alignment
- Hierophant = committing to the chosen path, honoring tradition or teaching

**Partial Narratives:**
- **Empress + Lovers:** "Creative fertility meeting decisive choice; abundance requires discernment."
- **Lovers + Hierophant:** "Personal values versus collective tradition; choosing what's sacred to you."
- **Empress + Hierophant:** "Nurturing energy seeking formal structure; abundance wants form."

**Reading Context:**
- **Romantic relationships:** From attraction to commitment
- **Creative work:** From inspiration to disciplined practice
- **Spiritual path:** From exploration to choosing a tradition
- **Values clarification:** What matters enough to commit to?

**Significance Levels:**
- Complete: "major" — Values & Commitment Arc
- Partial: "supporting" — Note choice/commitment themes

---

## Additional Triads (Expand as Needed)

### 6. The Crisis-Resilience Arc
**Cards:** The Tower (16) → Strength (8) → Judgement (20)
**Narrative:** "Upheaval revealing inner fortitude leading to rebirth."

### 7. The Justice-Wisdom Arc
**Cards:** Justice (11) → The Hermit (9) → The High Priestess (2)
**Narrative:** "Truth-seeking through solitary wisdom accessing deep intuition."

### 8. The Power Arc
**Cards:** The Emperor (4) → Strength (8) → The World (21)
**Narrative:** "Authority through compassionate power to mastery."

---

## Data Structure Schema

```javascript
export const ARCHETYPAL_TRIADS = [
  {
    id: 'death-temperance-star',
    cards: [13, 14, 17],
    names: ['Death', 'Temperance', 'The Star'],
    theme: 'Healing Arc',
    narrative: 'Ending → Alchemical integration → Renewed hope',
    description: 'The classic healing journey: releasing what must die, integrating the lesson, emerging into restored faith.',
    strength: 'complete',
    contexts: {
      grief: 'Literal healing from loss',
      transition: 'Life changes requiring integration',
      shadow: 'Releasing old patterns, integrating new self'
    },
    partialNarrative: {
      'death-temperance': 'Transformation actively seeking balance',
      'temperance-star': 'Patient integration leading to renewal',
      'death-star': 'Dramatic shift from ending to rebirth (skipping integration)'
    }
  },

  {
    id: 'devil-tower-sun',
    cards: [15, 16, 19],
    names: ['The Devil', 'The Tower', 'The Sun'],
    theme: 'Liberation Arc',
    narrative: 'Bondage → Rupture → Freedom',
    description: 'Breaking free: recognizing chains, experiencing collapse, emerging into clarity and joy.',
    strength: 'complete',
    contexts: {
      addiction: 'Recovery from literal or metaphorical bondage',
      relationship: 'Leaving toxic dynamics',
      career: 'Breaking from unfulfilling work',
      spiritual: 'Freedom from limiting beliefs'
    },
    partialNarrative: {
      'devil-tower': 'Attachments meet necessary disruption',
      'tower-sun': 'Upheaval clearing the path to clarity',
      'devil-sun': 'From shadow to light (sudden liberation)'
    }
  },

  {
    id: 'hermit-hangedman-moon',
    cards: [9, 12, 18],
    names: ['The Hermit', 'The Hanged Man', 'The Moon'],
    theme: 'Inner Work Arc',
    narrative: 'Solitude → Surrender → Deep Mystery',
    description: 'The contemplative path: withdrawing for wisdom, releasing control, diving into unconscious depths.',
    strength: 'complete',
    contexts: {
      spiritual: 'Meditation, dreamwork, shadow integration',
      therapy: 'Deep psychological processing',
      creative: 'Allowing ideas to gestate',
      grief: 'Internal mourning work'
    },
    partialNarrative: {
      'hermit-hangedman': 'Introspection leading to necessary pause',
      'hangedman-moon': 'Suspension opening to shadow realm',
      'hermit-moon': 'Solo journey into the unconscious'
    }
  },

  {
    id: 'magician-chariot-world',
    cards: [1, 7, 21],
    names: ['The Magician', 'The Chariot', 'The World'],
    theme: 'Mastery Arc',
    narrative: 'Skill → Directed action → Complete achievement',
    description: 'The path of manifestation: marshaling resources, focused willpower, total integration.',
    strength: 'complete',
    contexts: {
      career: 'Professional mastery and achievement',
      creative: 'Completing major projects',
      personal: 'Reaching developmental milestones',
      manifestation: 'Bringing vision into reality'
    },
    partialNarrative: {
      'magician-chariot': 'Potential directed into decisive movement',
      'chariot-world': 'Determined effort reaching culmination',
      'magician-world': 'From first spark to full realization'
    }
  },

  {
    id: 'empress-lovers-hierophant',
    cards: [3, 6, 5],
    names: ['The Empress', 'The Lovers', 'The Hierophant'],
    theme: 'Relationship & Values Arc',
    narrative: 'Abundance → Choice → Commitment',
    description: 'Examining what you value: abundance opens choices, choices require commitment to tradition or personal truth.',
    strength: 'complete',
    contexts: {
      romantic: 'From attraction to commitment',
      creative: 'From inspiration to disciplined practice',
      spiritual: 'From exploration to choosing a path',
      values: 'Clarifying what merits dedication'
    },
    partialNarrative: {
      'empress-lovers': 'Creative fertility meeting decisive choice',
      'lovers-hierophant': 'Personal values versus collective tradition',
      'empress-hierophant': 'Nurturing energy seeking formal structure'
    }
  }
];
```

## Detection Logic

```javascript
function detectArchetypalTriads(cards) {
  const numbers = cards
    .filter(c => c.number >= 0 && c.number <= 21)
    .map(c => c.number);

  const detected = [];

  ARCHETYPAL_TRIADS.forEach(triad => {
    const matches = triad.cards.filter(num => numbers.includes(num));

    if (matches.length >= 2) {
      const completeness = matches.length / triad.cards.length;
      const isComplete = matches.length === 3;

      // Generate narrative based on which cards are present
      let narrative = triad.narrative;
      if (!isComplete) {
        const pairKey = matches.map(n =>
          triad.names[triad.cards.indexOf(n)].toLowerCase().replace(/^the /, '')
        ).join('-');
        narrative = triad.partialNarrative[pairKey] || triad.description;
      }

      detected.push({
        id: triad.id,
        theme: triad.theme,
        matchedCards: matches,
        matchedNames: matches.map(n => triad.names[triad.cards.indexOf(n)]),
        completeness: completeness * 100,
        isComplete,
        narrative,
        fullDescription: triad.description,
        significance: isComplete ? 'complete-triad' : 'partial-triad',
        strength: isComplete ? 'major' : 'supporting'
      });
    }
  });

  // Sort by completeness (complete triads first)
  return detected.sort((a, b) => {
    if (a.isComplete !== b.isComplete) return a.isComplete ? -1 : 1;
    return b.matchedCards.length - a.matchedCards.length;
  });
}
```

## Narrative Templates

### Complete Triad (All 3 cards)
> "**{Theme}:** {Card1}, {Card2}, and {Card3} form a complete narrative arc. {Complete narrative}. This is a significant pattern showing {thematic insight}."

**Example:**
> "**The Healing Arc:** Death, Temperance, and The Star form a complete narrative arc. This is the classic healing journey—Death marks a necessary ending, Temperance is the alchemical integration work, and The Star is renewed hope emerging. You're moving through authentic transformation, not bypassing the grief or rushing to false positivity."

### Partial Triad (2 of 3 cards)
> "**{Theme} (partial):** {Card1} and {Card2} suggest {partial narrative}."

**Example:**
> "**The Healing Arc (partial):** Death and The Star suggest a dramatic shift from ending to rebirth. While Temperance (the middle card of this pattern) isn't present, the arc from release to renewal is clear—though you may be moving quickly through integration rather than lingering in that alchemical middle space."

## Usage Guidelines

### When to Surface

**Highest Priority:** Complete triads (all 3 cards)
- Name the arc explicitly
- Explain the full narrative
- Dedicate 2-3 sentences to this pattern

**Medium Priority:** Partial triads (2 of 3 cards)
- Mention briefly
- Name what's missing
- 1-2 sentences

**Low Priority:** Multiple partial triads
- Choose the most relevant to the question
- Don't overwhelm the reading with pattern lists

### Integration with Other Elements

- **With Fool's Journey:** Triad provides specific story; Journey provides developmental context
- **With Elemental Dignities:** Triad is thematic; elements are relational dynamics
- **With Reversal Framework:** Apply reversal lens to individual cards within the triad

## Validation Rules

### What NOT to Do

❌ Don't force triads when cards aren't present
❌ Don't invent new triads without traditional resonance
❌ Don't let triads overshadow position meanings
❌ Don't mix triads in confusing ways (pick the strongest one)

### Quality Checks

✅ Does the complete triad narrative make intuitive sense?
✅ Do the partial narratives feel meaningful (not forced)?
✅ Would a professional reader recognize this combination?
✅ Does it enhance rather than overwhelm the reading?

---

## References

- Pollack, Rachel. *Seventy-Eight Degrees of Wisdom*. Thorsons, 1997.
- Greer, Mary K. *Tarot Constellations*. New Page Books, 2008.
- Fairfield, Gail. *Choice Centered Tarot*. Red Wheel/Weiser, 1997.
- Professional reader consensus (common combinations recognized across traditions)
</file>

<file path="docs/knowledge-graph/FOOLS_JOURNEY.md">
# The Fool's Journey - Data Structure Specification

## Overview

The Fool's Journey represents the progression through all 22 Major Arcana cards as a unified narrative arc of spiritual development and psychological maturation. This structure divides the journey into three acts following Joseph Campbell's Hero's Journey and Jungian individuation stages.

## Traditional Foundation

The three-act structure follows widely accepted tarot interpretive frameworks:
- **Rachel Pollack** (Seventy-Eight Degrees of Wisdom)
- **Mary K. Greer** (Tarot for Your Self)
- **Robert Place** (The Tarot: History, Symbolism, and Divination)
- **Golden Dawn** esoteric correspondences

## Three-Act Structure

### Act I: Initiation (Cards 0-7)
**Stage:** Departure / Ego Formation
**Theme:** Encountering the elemental forces, establishing identity
**Life Phase:** Childhood through early adulthood
**Psychological Task:** Building ego structure, learning societal roles

**Cards:**
- **0 - The Fool:** Pure potential, innocence, spontaneous trust
- **1 - The Magician:** Conscious will, skill development, "As above, so below"
- **2 - The High Priestess:** Unconscious wisdom, intuition, hidden knowledge
- **3 - The Empress:** Nurturing abundance, creativity, sensory embodiment
- **4 - The Emperor:** Structure, authority, boundaries, paternal principle
- **5 - The Hierophant:** Tradition, teaching, spiritual authority, conformity
- **6 - The Lovers:** Values alignment, choice, relationship, duality
- **7 - The Chariot:** Willpower, victory through discipline, moving forward

**Archetypal Pattern:**
The Fool meets the primal forces of existence (masculine/feminine, conscious/unconscious, material/spiritual) and learns to navigate the outer world through mastery of basic life skills.

**Reading Significance:**
When multiple cards from this range appear, the querent is working with foundational identity questions, learning new skills, or establishing themselves in the world. They're in a phase of building rather than releasing.

---

### Act II: Integration (Cards 8-14)
**Stage:** Initiation / Shadow Work
**Theme:** Testing, sacrifice, confronting limitation, inner transformation
**Life Phase:** Midlife transitions
**Psychological Task:** Shadow integration, ego transcendence, finding balance

**Cards:**
- **8 - Strength:** Compassionate courage, taming the inner beast, gentle power
- **9 - The Hermit:** Solitary wisdom-seeking, inner guidance, withdrawal for clarity
- **10 - Wheel of Fortune:** Cycles, fate, turning points, karmic patterns
- **11 - Justice:** Truth, accountability, cause and effect, cosmic balance
- **12 - The Hanged Man:** Surrender, sacrifice, new perspective through stillness
- **13 - Death:** Necessary endings, transformation, release, transition
- **14 - Temperance:** Alchemical integration, patience, middle path, healing

**Archetypal Pattern:**
The Fool must face challenges that cannot be overcome by will alone. This act requires surrender, perspective shifts, and integration of opposites. Death marks the midpoint—the end of the old self.

**Reading Significance:**
Multiple cards here signal the querent is in a difficult but necessary transition. They're being asked to release control, trust the process, and allow transformation rather than forcing outcomes. Shadow work and inner integration are themes.

---

### Act III: Culmination (Cards 15-21)
**Stage:** Return / Individuation
**Theme:** Confronting shadow, revelation, cosmic consciousness, wholeness
**Life Phase:** Mature adulthood, elder wisdom
**Psychological Task:** Integration of the Self, transcendence, bringing wisdom back to the world

**Cards:**
- **15 - The Devil:** Shadow confrontation, bondage to materialism, addiction, necessary darkness
- **16 - The Tower:** Sudden upheaval, necessary destruction, revelation, awakening
- **17 - The Star:** Hope renewed, spiritual healing, cosmic connection, inspiration
- **18 - The Moon:** Deep unconscious, illusion, intuition, mystery, shadow realm
- **19 - The Sun:** Clarity, joy, vitality, authentic self, childhood wonder reclaimed
- **20 - Judgement:** Rebirth, calling, reckoning, spiritual awakening, resurrection
- **21 - The World:** Completion, integration, mastery, cosmic dance, wholeness

**Archetypal Pattern:**
The Fool confronts their deepest shadow (Devil), experiences ego death (Tower), and is reborn into higher consciousness (Star through World). The journey culminates in the integration of all previous lessons into a unified whole.

**Reading Significance:**
Multiple cards from this range indicate the querent is working with profound, soul-level themes. They're integrating major life lessons, confronting core wounds, or experiencing spiritual awakening. This is completion energy—ending cycles to begin anew at a higher spiral.

---

## Data Structure Schema

```javascript
export const FOOLS_JOURNEY = {
  initiation: {
    range: [0, 7],
    stage: 'departure',
    theme: 'Innocence, learning, establishing ego and identity',
    lifePhase: 'Childhood through early adulthood',
    psychologicalTask: 'Building ego structure, learning societal roles',
    cards: [
      { num: 0, name: 'The Fool', role: 'Innocent beginning' },
      { num: 1, name: 'The Magician', role: 'Conscious will' },
      { num: 2, name: 'The High Priestess', role: 'Unconscious knowing' },
      { num: 3, name: 'The Empress', role: 'Creative abundance' },
      { num: 4, name: 'The Emperor', role: 'Structure & authority' },
      { num: 5, name: 'The Hierophant', role: 'Tradition & teaching' },
      { num: 6, name: 'The Lovers', role: 'Choice & values' },
      { num: 7, name: 'The Chariot', role: 'Disciplined action' }
    ],
    narrative: 'The querent is encountering foundational forces, learning who they are and what they value.',
    readingSignificance: 'Building identity, establishing in the world, learning new skills'
  },

  integration: {
    range: [8, 14],
    stage: 'initiation',
    theme: 'Testing, sacrifice, shadow work, necessary endings',
    lifePhase: 'Midlife transitions',
    psychologicalTask: 'Shadow integration, ego transcendence, finding balance',
    cards: [
      { num: 8, name: 'Strength', role: 'Inner fortitude' },
      { num: 9, name: 'The Hermit', role: 'Solitary wisdom' },
      { num: 10, name: 'Wheel of Fortune', role: 'Cycles & fate' },
      { num: 11, name: 'Justice', role: 'Truth & balance' },
      { num: 12, name: 'The Hanged Man', role: 'Surrender' },
      { num: 13, name: 'Death', role: 'Transformation' },
      { num: 14, name: 'Temperance', role: 'Alchemy' }
    ],
    narrative: 'The querent faces trials that demand surrender, perspective shifts, and integration of opposites.',
    readingSignificance: 'Difficult but necessary transition, releasing control, shadow work'
  },

  culmination: {
    range: [15, 21],
    stage: 'return',
    theme: 'Shadow integration, revelation, cosmic consciousness, completion',
    lifePhase: 'Mature adulthood, elder wisdom',
    psychologicalTask: 'Integration of the Self, transcendence, bringing wisdom to the world',
    cards: [
      { num: 15, name: 'The Devil', role: 'Shadow confrontation' },
      { num: 16, name: 'The Tower', role: 'Necessary destruction' },
      { num: 17, name: 'The Star', role: 'Hope restored' },
      { num: 18, name: 'The Moon', role: 'Illusion & intuition' },
      { num: 19, name: 'The Sun', role: 'Illumination' },
      { num: 20, name: 'Judgement', role: 'Rebirth' },
      { num: 21, name: 'The World', role: 'Integration & wholeness' }
    ],
    narrative: 'The querent confronts deepest shadow and emerges transformed, integrating all lessons into wholeness.',
    readingSignificance: 'Soul-level themes, completing cycles, spiritual awakening'
  }
};
```

## Detection Logic

```javascript
function detectFoolsJourneyStage(cards) {
  const majorCards = cards.filter(c => c.number >= 0 && c.number <= 21);
  if (majorCards.length < 2) return null;

  const stages = { initiation: [], integration: [], culmination: [] };

  majorCards.forEach(card => {
    if (card.number <= 7) stages.initiation.push(card);
    else if (card.number <= 14) stages.integration.push(card);
    else stages.culmination.push(card);
  });

  const dominant = Object.entries(stages)
    .sort((a, b) => b[1].length - a[1].length)[0];

  return {
    stage: dominant[0],
    cardCount: dominant[1].length,
    cards: dominant[1],
    ...FOOLS_JOURNEY[dominant[0]]
  };
}
```

## Narrative Templates

### When Initiation Dominates (3+ cards from 0-7)
> "Your reading centers in the **Initiation** phase of the Fool's Journey. These cards (list cards) speak to foundational work—establishing who you are, learning new skills, and building your relationship to the outer world. This is a time of growth and formation rather than completion."

### When Integration Dominates (3+ cards from 8-14)
> "Your reading is weighted toward the **Integration** phase of the Fool's Journey. Cards like (list cards) signal you're in a transformative passage that asks for surrender rather than control. This middle chapter demands patience with necessary endings and trust in the alchemy that follows release."

### When Culmination Dominates (3+ cards from 15-21)
> "Your reading draws heavily from the **Culmination** stage of the Fool's Journey. With (list cards) present, you're working at a soul level—confronting deep shadow, integrating major lessons, or completing a significant life cycle. This is not superficial work; it's the harvest of a long journey."

### When Mixed (2-3 cards across stages)
> "Your cards span multiple phases of the Fool's Journey, suggesting you're navigating several life layers simultaneously—both building new skills and releasing old patterns."

## Usage Guidelines

### When to Surface in Readings

**High Priority (3+ Majors from same stage):**
- Explicitly name the journey stage in synthesis
- Explain what this phase asks of the querent
- Connect to life transitions (e.g., midlife, career change, spiritual awakening)

**Medium Priority (2 Majors from same stage):**
- Mention briefly in thematic context
- Use to frame the overall energy

**Low Priority (Scattered Majors):**
- Don't force the Fool's Journey framework
- Focus on individual card meanings and positions instead

### Integration with Other Patterns

- **Triads:** If a complete triad appears within one journey stage, prioritize the triad
- **Elemental Dignities:** Journey stage provides thematic context; elemental analysis provides relational dynamics
- **Reversal Framework:** Journey stage + reversal framework = powerful combined lens

## Examples

### Example 1: Strong Initiation (Celtic Cross)
**Cards:** The Fool (0), The Magician (1), The Chariot (7), The Hierophant (5)
**Detection:** 4 cards from initiation stage = "strong"
**Narrative:** "Four of your ten cards come from the Initiation phase of the Fool's Journey (cards 0-7), suggesting you're in a foundational chapter—learning, building, and establishing yourself in new territory. The Fool's innocent trust meets the Magician's skill-building, guided by the Hierophant's wisdom, propelling you forward via the Chariot's disciplined action."

### Example 2: Integration Focus (Three-Card)
**Cards:** Death (13), The Hanged Man (12), Temperance (14)
**Detection:** All 3 cards from integration stage = "complete focus"
**Narrative:** "Your entire three-card story unfolds within the Integration phase of the Fool's Journey (cards 8-14). This is the heart of transformation: the Hanged Man's surrender leads to Death's necessary ending, alchemizing into Temperance's patient integration. You're being asked to trust the process, release control, and allow metamorphosis."

---

## References

- Pollack, Rachel. *Seventy-Eight Degrees of Wisdom*. Thorsons, 1997.
- Greer, Mary K. *Tarot for Your Self*. New Page Books, 2002.
- Place, Robert. *The Tarot: History, Symbolism, and Divination*. Tarcher, 2005.
- Nichols, Sallie. *Jung and Tarot: An Archetypal Journey*. Weiser Books, 1980.
</file>

<file path="docs/knowledge-graph/PROJECT_PLAN.md">
# Knowledge Graph Program — Status & Next Steps

## Snapshot
- **Project:** Mystic Tarot Knowledge Graph
- **Goal:** Detect multi-card archetypal patterns so readings feel cohesive and resonant.
- **Current Status:** ✅ Deployed in production (v1.0)
- **Owners:** functions/lib/knowledgeGraph.js · src/data/knowledgeGraphData.js · src/components/SpreadPatterns.jsx

| Deliverable | Status | Evidence |
| --- | --- | --- |
| Fool’s Journey stage detection | ✅ | `detectFoolsJourneyStage` + unit tests (`functions/lib/__tests__/knowledgeGraph.test.js`) |
| Archetypal triads & dyads | ✅ | `ARCHETYPAL_TRIADS` / `ARCHETYPAL_DYADS` data + prioritised narratives |
| Suit progressions | ✅ | `detectSuitProgressions` powering Minor Arcana arcs |
| Narrative integration | ✅ | `functions/lib/spreadAnalysis.js` injects `themes.knowledgeGraph`, prompts consume highlights |
| Frontend surfacing | ✅ | `SpreadPatterns` panel + Markdown highlights |
| Performance budget (<100 ms) | ✅ | Pattern detection completes in ~6 ms for 10-card spreads (measured in staging) |

---

## Architecture Recap
1. **Data Layer** (`src/data/knowledgeGraphData.js`)
   - Encodes Fool’s Journey stages, triads, dyads, and suit progressions with narratives + significance scores.
2. **Detection Layer** (`functions/lib/knowledgeGraph.js`)
   - Pure functions (`detectAllPatterns`, `getPriorityPatternNarratives`) compute matches and return ranked highlights.
3. **Analysis Layer** (`functions/lib/spreadAnalysis.js`)
   - Calls the detection layer, merges results into `themes.knowledgeGraph`, and keeps runtime < 100 ms.
4. **Narrative Layer** (`functions/lib/narrative/prompts.js`, `functions/lib/narrative/helpers.js`)
   - Prompts include an “Archetypal Patterns Detected” section; local composers weave the highlights into Markdown.
5. **UI Layer** (`src/components/SpreadPatterns.jsx`)
   - Optional “Archetypal Patterns” card renders Markdown highlights with suit/triad icons.

---

## QA & Instrumentation
- **Unit Tests:** `functions/lib/__tests__/knowledgeGraph.test.js` covers Fool’s Journey, triads, dyads, suit progressions, and narrative prioritisation.
- **Integration Smoke Tests:** `tests/narrativeBuilder.promptCompliance.test.mjs` ensures prompts include pattern summaries when available.
- **Performance Checks:** Benchmark script (see `scripts/vision/runVisionPrototype.js` analog) not yet automated; manual profiling shows sub‑millisecond detection per pattern type.

---

## Open Enhancements
1. **Deck-Aware Patterns**
   - Adapt pattern definitions when using Thoth/Marseille terminology (Adjustment/Lust, pip-only minors). Requires extending `knowledgeGraphData.js` with deck-specific aliases.
2. **Court + Numerology Extensions**
   - Add optional COURT_PATTERNS and NUMERICAL_HARMONICS data (draft schemas exist but aren’t wired in).
3. **Telemetry & Analytics**
   - Log which patterns fire per reading to monitor coverage and guide future heuristics.
4. **Human Review Hooks**
   - Similar to the vision review queue, capture reader feedback on pattern accuracy to iteratively tune narratives.

---

## Next Steps
| Priority | Task | Owner Suggestion | Notes |
| --- | --- | --- | --- |
| P0 | Document current behaviour (this file, `docs/knowledge-graph/*.md`) | ✅ Done | Keep updated when data tables change |
| P1 | Add deck-style overrides | Backend | Needed once non-RWS decks ship |
| P1 | Emit telemetry for detected patterns | Backend | Facilitates analytics + future ML | 
| P2 | Implement court/numerology modules | Research | Already sketched in `knowledgeGraphData.js` comments |
| P2 | Build reviewer checklist for archetypal accuracy | Product | Mirrors CLIP review workflow |

The core project is complete. Remaining work focuses on adapting the knowledge graph to additional decks, capturing telemetry, and establishing a reviewer feedback loop so the pattern heuristics evolve alongside the broader AI training roadmap.
</file>

<file path="docs/knowledge-graph/README.md">
# Knowledge Graph Documentation - Overview

## Purpose

These documents define the data structures and detection logic for the Mystic Tarot Knowledge Graph system. This system detects multi-card archetypal patterns that create synergistic meaning beyond individual card interpretations.

## Documentation Files

### 1. [FOOLS_JOURNEY.md](./FOOLS_JOURNEY.md)
**What It Detects:** Which stage of the Major Arcana journey dominates a spread

**Three Stages:**
- **Initiation (0-7):** Building ego, learning, establishing in the world
- **Integration (8-14):** Shadow work, surrender, transformation
- **Culmination (15-21):** Confronting shadow, revelation, completion

**Reading Significance:** Tells you what developmental chapter the querent is navigating

**Implementation Priority:** Week 1

---

### 2. [ARCHETYPAL_TRIADS.md](./ARCHETYPAL_TRIADS.md)
**What It Detects:** Complete three-card narrative arcs

**Five Core Triads:**
1. **Healing Arc:** Death → Temperance → Star
2. **Liberation Arc:** Devil → Tower → Sun
3. **Inner Work Arc:** Hermit → Hanged Man → Moon
4. **Mastery Arc:** Magician → Chariot → World
5. **Values Arc:** Empress → Lovers → Hierophant

**Reading Significance:** Provides complete transformation narratives when all 3 cards present

**Implementation Priority:** Week 1 (core triads), Week 3 (additional triads)

---

### 3. [ARCHETYPAL_DYADS.md](./ARCHETYPAL_DYADS.md)
**What It Detects:** Powerful two-card synergies

**15 Dyads Across Categories:**
- **Transformation:** Death+Star, Tower+Sun, Hanged Man+Death, Moon+Sun
- **Empowerment:** Fool+Magician, Strength+Justice
- **Wisdom:** Hermit+High Priestess, High Priestess+Hierophant
- **Challenge:** Devil+Lovers, Devil+Tower, Hierophant+Devil
- **Cycles:** Wheel+Judgement
- **Power:** Emperor+Empress
- **Vision:** Star+Judgement, Chariot+World

**Reading Significance:** Highlights meaningful pairings even when full triads aren't present

**Implementation Priority:** Week 3 (extends existing 5 dyads to 15)

---

### 4. [SUIT_PROGRESSIONS.md](./SUIT_PROGRESSIONS.md)
**What It Detects:** Minor Arcana narrative arcs within each suit

**Four Suits × Three Stages:**
- **Wands (Fire):** Ignition → Testing → Culmination (often with burden)
- **Cups (Water):** Emotional Opening → Complexity → Maturity (fulfillment)
- **Swords (Air):** Clarity → Struggle → Crisis & Liberation (dawn after darkness)
- **Pentacles (Earth):** Foundation → Resource Management → Mastery (legacy)

**Reading Significance:** Shows what practical/emotional/mental/material phase the querent is in

**Implementation Priority:** Week 2

---

## How Patterns Work Together

### Priority Hierarchy (Most to Least Significant)

1. **Complete Triads** (all 3 cards present)
   - Highest narrative significance
   - Explicitly name the arc in readings
   - Example: "Death, Temperance, and The Star form The Healing Arc..."

2. **Strong Fool's Journey Stage** (3+ Majors from same stage)
   - High developmental significance
   - Provides life chapter context
   - Example: "Four cards from the Integration stage suggest you're in profound transformation work..."

3. **Strong Suit Progression** (3+ cards from same suit+stage)
   - High practical significance
   - Shows which domain and phase are active
   - Example: "Ace, Two, and Three of Wands show you're in the ignition phase of a creative endeavor..."

4. **High-Significance Dyads**
   - Medium-high significance
   - Mention when relevant to question
   - Example: "Death and The Star suggest transformation clearing into hope..."

5. **Partial Triads** (2 of 3 cards)
   - Supporting significance
   - Brief mention
   - Example: "Death and The Star (from The Healing Arc) suggest transformation and renewal, though Temperance's integrative work may be happening quickly..."

6. **Emerging Progressions / Medium Dyads**
   - Low-medium significance
   - Mention only if space permits

---

## Integration Guidelines

### When to Surface Patterns

**High Priority Situations:**
- Complete triads appear → Name explicitly, 2-3 sentences
- 3+ Majors from same Journey stage → Name stage and developmental context
- 3+ cards from same suit progression stage → Name suit, stage, practical arc

**Medium Priority:**
- 2 Majors from same Journey stage → Brief mention
- High-significance dyads → 1 sentence
- Emerging suit progressions → Brief mention

**Low Priority:**
- Scattered patterns → Don't force it
- Multiple partial patterns → Choose most relevant to question

### Don't Overwhelm

**Maximum per reading:**
- 1-2 complete triads (if present)
- 1 Fool's Journey stage mention
- 1-2 suit progressions
- 1-2 dyads
- **Total: 3-5 pattern mentions maximum**

Prioritize quality over quantity. Choose patterns most relevant to the user's question and spread context.

---

## Narrative Flow

### Where Patterns Fit in Readings

1. **Opening:** Question, spread type, context
2. **Thematic Context:** Elemental balance, suit focus, reversal framework
3. **Position-by-Position:** Individual card meanings (MOST IMPORTANT)
4. **Pattern Synthesis:** "Deeper Patterns" section ← **KNOWLEDGE GRAPH GOES HERE**
5. **Final Synthesis:** Actionable guidance, free will reminder

### Pattern Section Template

```markdown
### Deeper Patterns

Beyond the individual positions, your cards reveal larger archetypal movements:

**[Pattern Name]:** [Narrative with card references]

[2nd pattern if relevant]

[Explain how patterns relate to the question]
```

---

## Technical Implementation

### Detection Flow

```javascript
// In spreadAnalysis.js
const patterns = detectAllPatterns(cardsInfo);

if (patterns) {
  themes.knowledgeGraph = {
    patterns,  // Full detection results
    narrativeHighlights: getPriorityPatternNarratives(patterns)  // Top 3-5 for narrative
  };
}
```

### Priority Ranking

```javascript
function getPriorityPatternNarratives(patterns) {
  const narratives = [];

  // Priority 1: Complete triads
  patterns.triads?.filter(t => t.isComplete).forEach(triad => {
    narratives.push({
      priority: 1,
      type: 'complete-triad',
      text: `**${triad.theme}:** ${triad.narrative}`
    });
  });

  // Priority 2: Strong Fool's Journey
  if (patterns.foolsJourney?.significance === 'strong') {
    narratives.push({
      priority: 2,
      type: 'fools-journey',
      text: `**Fool's Journey - ${patterns.foolsJourney.stage}:** ${patterns.foolsJourney.narrative}`
    });
  }

  // Priority 3: Strong suit progressions
  patterns.suitProgressions?.filter(p => p.significance === 'strong-progression').forEach(prog => {
    narratives.push({
      priority: 3,
      type: 'suit-progression',
      text: `**${prog.suit} ${prog.stage}:** ${prog.narrative}`
    });
  });

  // Sort by priority, return top 3-5
  return narratives.sort((a, b) => a.priority - b.priority).slice(0, 5);
}
```

---

## Validation & Quality

### What Makes a Valid Pattern

✅ **Do:**
- Detect patterns that enhance understanding
- Prioritize patterns most relevant to the question
- Integrate patterns organically into narrative
- Limit to 3-5 pattern mentions maximum

❌ **Don't:**
- Force patterns when cards aren't present
- Overwhelm readings with pattern lists
- Let patterns overshadow position meanings
- Invent new patterns without traditional basis

### Testing Checklist

- [ ] Complete triads detect correctly (Death-Temperance-Star)
- [ ] Partial triads acknowledge missing card
- [ ] Fool's Journey stage reflects majority
- [ ] Suit progressions require 2+ cards from stage
- [ ] Priority ranking works correctly
- [ ] Narrative templates are clear and non-mechanical
- [ ] Integration doesn't disrupt existing reading flow
- [ ] Maximum 3-5 pattern mentions enforced

---

## Implementation Phases

### Week 1: Foundation
- Implement FOOLS_JOURNEY
- Implement 5 core ARCHETYPAL_TRIADS
- Basic detection functions
- Unit tests

### Week 2: Expansion
- Implement SUIT_PROGRESSIONS (all 4 suits)
- Integrate into spreadAnalysis.js
- Update prompt building (prompts.js)

### Week 3: Enhancement
- Extend ARCHETYPAL_DYADS (5 → 15)
- Add COURT_PATTERNS and NUMERICAL_HARMONICS
- Update spread builders (narrative/spreads/*.js)
- Frontend SpreadPatterns component

### Week 4: Polish & Deploy
- Testing, performance optimization
- Deploy to staging
- Quality validation
- Production deployment

---

## Expected Outcomes

### Before Knowledge Graph
> "The Chariot in your advice position suggests willpower and focused action. The World in your outcome position shows completion and mastery. These cards say you're moving toward success."

### After Knowledge Graph
> "**Mastery Arc:** The Magician, The Chariot, and The World form a complete manifestation triad. You have the skill and resources (Magician), you're applying focused willpower (Chariot), and you're reaching complete achievement (World). This is the full arc from potential to mastery—a powerful affirmation that your sustained effort is culminating in real success."

**Impact:** Readings become more cohesive, archetypal, and profound while remaining grounded in traditional meanings.

---

## References

All four documentation files include comprehensive references to:
- Rachel Pollack (*Seventy-Eight Degrees of Wisdom*)
- Mary K. Greer (*Tarot for Your Self*, *Tarot Constellations*)
- Robert Place (*The Tarot: History, Symbolism, and Divination*)
- Sallie Nichols (*Jung and Tarot*)
- Golden Dawn esoteric correspondences
- Professional reading practice consensus

---

## Questions?

This documentation should provide everything needed to implement the Knowledge Graph system. Each file includes:
- Traditional foundation
- Complete data structure schemas
- Detection logic
- Narrative templates
- Usage guidelines
- Examples

Ready to proceed with implementation?
</file>

<file path="docs/knowledge-graph/SUIT_PROGRESSIONS.md">
# Suit Progressions - Data Structure Specification

## Overview

Each Minor Arcana suit (Wands, Cups, Swords, Pentacles) tells a complete narrative story from Ace (pure potential) through Ten (culmination). These progressions follow consistent patterns across suits, representing the journey of that suit's element through three developmental stages.

## Traditional Foundation

Suit progressions are based on:
- **Rachel Pollack's** three-stage structure (Seventy-Eight Degrees of Wisdom)
- **Golden Dawn** esoteric correspondences
- **Kabbalistic numerology** (Aces as Kether, Tens as Malkuth)
- **Professional reading practice** (observing narrative patterns)

## Universal Three-Stage Structure

Each suit divides into three acts following a developmental arc:

### **Beginning (Ace-2-3):** Initiation
- Ace: Pure elemental energy, gift, potential
- Two: Choice, duality, initial relationship
- Three: First manifestation, expansion, expression

### **Challenge (4-5-6-7):** Testing
- Four: Foundation or stagnation (depends on suit)
- Five: Conflict, struggle, disruption
- Six: Resolution, healing, movement
- Seven: Pause for assessment or strategic choice

### **Mastery (8-9-10):** Culmination
- Eight: Power, movement, or skill (depends on suit)
- Nine: Near-completion, wish or burden
- Ten: Full culmination (blessing or exhaustion)

---

## WANDS (Fire Element)

**Domain:** Creativity, passion, willpower, enterprise, action, inspiration
**Element:** Fire
**Qualities:** Active, initiating, transformative, enthusiastic
**Life Area:** Career, creative projects, personal drive, ambition

### Beginning: Ignition (Ace-2-3)

**Ace of Wands**
- **Role:** Pure creative spark, inspired beginning
- **Traditional Meaning:** New creative/career opportunity, passion igniting, raw potential
- **In Progression:** The gift of creative fire, the "yes!" feeling, pure inspiration

**Two of Wands**
- **Role:** Strategic planning, vision, world in your hands
- **Traditional Meaning:** Planning future endeavors, bold vision, partnership forming
- **In Progression:** Taking the spark (Ace) and making a plan, looking ahead

**Three of Wands**
- **Role:** Confident expansion, exploration, ships coming in
- **Traditional Meaning:** Progress, foresight, enterprise expanding, overseas opportunity
- **In Progression:** The plan (Two) is working; expansion is happening

**Narrative Arc (Ace-2-3):**
> "Ace: Pure creative spark → Two: Planning & vision → Three: Confident expansion. You're igniting, planning, and watching initial growth."

**Reading Significance:**
When 2+ Wands from this range appear: "You're in the ignition phase of a creative or professional endeavor—high enthusiasm, planning, early momentum."

---

### Challenge: Testing the Fire (4-5-6-7)

**Four of Wands**
- **Role:** Celebration, foundation, joyful milestone
- **Traditional Meaning:** Homecoming, celebration, stable foundation, harvest festival
- **In Progression:** Pause to celebrate what you've built so far

**Five of Wands**
- **Role:** Competition, conflict, creative friction
- **Traditional Meaning:** Disagreement, competition, diverse viewpoints, testing
- **In Progression:** Momentum meets resistance; navigating conflict or competition

**Six of Wands**
- **Role:** Victory, public recognition, success
- **Traditional Meaning:** Triumph, acclaim, pride, being recognized for achievements
- **In Progression:** Emerging victorious from the conflict (Five), earning recognition

**Seven of Wands**
- **Role:** Defensive perseverance, standing your ground
- **Traditional Meaning:** Challenge, defense, maintaining position, courage under pressure
- **In Progression:** Defending what you've achieved; vigilance required

**Narrative Arc (4-5-6-7):**
> "Four: Celebration & foundation → Five: Competition → Six: Victory → Seven: Defensive perseverance. Success brings new challenges; you're defending what you've built."

**Reading Significance:**
When 2+ Wands from this range appear: "You're in the testing phase—navigating competition, earning recognition, and defending your position."

---

### Mastery: Culmination (8-9-10)

**Eight of Wands**
- **Role:** Swift momentum, things moving fast, messages flying
- **Traditional Meaning:** Speed, rapid action, communication, travel, things happening quickly
- **In Progression:** The culmination of effort; everything accelerating toward completion

**Nine of Wands**
- **Role:** Guarded resilience, wounded but standing, almost there
- **Traditional Meaning:** Persistence, resilience, last stand, defensive posture
- **In Progression:** Exhaustion setting in; you're near the end but weary

**Ten of Wands**
- **Role:** Overburdened completion, carrying the full weight
- **Traditional Meaning:** Burden, responsibility, hard work near completion, overwhelm
- **In Progression:** Success achieved but at a cost; carrying everything alone

**Narrative Arc (8-9-10):**
> "Eight: Swift momentum → Nine: Guarded resilience → Ten: Overburdened completion. The work is nearly done but you're exhausted. Success has weight."

**Reading Significance:**
When 2+ Wands from this range appear: "You're in the culmination phase—things moving fast, resilience tested, burden of success felt. Consider delegating or resting after completion."

**Shadow Note:**
Wands culmination often involves burnout or burden. Ten of Wands is "success but at what cost?" This is the suit's cautionary tale.

---

## CUPS (Water Element)

**Domain:** Emotions, relationships, love, intuition, feelings, connection
**Element:** Water
**Qualities:** Receptive, flowing, nurturing, empathic
**Life Area:** Relationships, emotional life, creativity through feeling

### Beginning: Emotional Opening (Ace-2-3)

**Ace of Cups**
- **Role:** Overflowing heart, pure emotional gift, divine love
- **Traditional Meaning:** New love, emotional beginning, spiritual awakening, compassion
- **In Progression:** The gift of emotional abundance, open heart

**Two of Cups**
- **Role:** Partnership, mutual devotion, balanced give-and-take
- **Traditional Meaning:** Love, partnership, attraction, unity, meaningful connection
- **In Progression:** The open heart (Ace) meets another; reciprocity begins

**Three of Cups**
- **Role:** Celebration, friendship, community, abundance shared
- **Traditional Meaning:** Friendship, celebration, community, sisterhood, joy
- **In Progression:** Love expands outward (Ace to Two to community)

**Narrative Arc (Ace-2-3):**
> "Ace: Overflowing heart → Two: Partnership & reciprocity → Three: Celebration & friendship. Emotional abundance flowing from self to partnership to community."

**Reading Significance:**
When 2+ Cups from this range appear: "You're in the emotional opening phase—love, connection, and celebration are abundant."

---

### Challenge: Emotional Complexity (4-5-6-7)

**Four of Cups**
- **Role:** Apathy, contemplative withdrawal, missing the gift
- **Traditional Meaning:** Meditation, reevaluation, discontent, taking stock
- **In Progression:** After celebration (Three), questioning whether this is enough

**Five of Cups**
- **Role:** Loss, grief, mourning what's gone
- **Traditional Meaning:** Regret, loss, disappointment, grieving
- **In Progression:** Emotional pain, focusing on what's lost rather than what remains

**Six of Cups**
- **Role:** Nostalgia, innocence, sweet memory, past revisited
- **Traditional Meaning:** Childhood, memory, innocence, reunion, gifts from the past
- **In Progression:** Seeking comfort in the past, nostalgia after loss

**Seven of Cups**
- **Role:** Options, fantasy, illusion, imagination ungrounded
- **Traditional Meaning:** Choices, illusion, wishful thinking, imagination, overwhelm
- **In Progression:** Too many emotional options; confusion about desires

**Narrative Arc (4-5-6-7):**
> "Four: Apathy → Five: Loss & grief → Six: Nostalgia → Seven: Overwhelming options. Navigating disappointment, grief, and confusion about what you truly want emotionally."

**Reading Significance:**
When 2+ Cups from this range appear: "You're in the emotional complexity phase—processing disappointment, grief, or confusion about desires. Discernment needed."

---

### Mastery: Emotional Maturity (8-9-10)

**Eight of Cups**
- **Role:** Walking away from what no longer serves, conscious release
- **Traditional Meaning:** Abandonment of the past, moving on, seeking deeper meaning
- **In Progression:** Choosing to leave behind emotional patterns that don't nourish

**Nine of Cups**
- **Role:** Wish fulfillment, contentment, satisfaction achieved
- **Traditional Meaning:** Satisfaction, wishes come true, emotional fulfillment
- **In Progression:** Emotional maturity brings contentment; wishes manifesting

**Ten of Cups**
- **Role:** Blessed union, emotional harmony, rainbow after storm
- **Traditional Meaning:** Emotional fulfillment, happy family, lasting love, peace
- **In Progression:** Complete emotional satisfaction; love that lasts

**Narrative Arc (8-9-10):**
> "Eight: Walking away from what no longer serves → Nine: Wish fulfillment → Ten: Blessed union. Emotional maturity: releasing what doesn't fit, finding contentment, building lasting harmony."

**Reading Significance:**
When 2+ Cups from this range appear: "You're in the emotional maturity phase—making conscious choices to release or embrace, finding authentic fulfillment."

**Light Note:**
Cups culmination is deeply fulfilling when authentic. Ten of Cups is the "happily ever after" when it's real, not forced.

---

## SWORDS (Air Element)

**Domain:** Thought, communication, truth, conflict, clarity, analysis
**Element:** Air
**Qualities:** Mental, analytical, cutting, truth-seeking
**Life Area:** Communication, decisions, conflict resolution, mental health

### Beginning: Mental Clarity (Ace-2-3)

**Ace of Swords**
- **Role:** Breakthrough insight, cutting truth, mental clarity
- **Traditional Meaning:** Breakthrough, clarity, raw truth, new idea, justice
- **In Progression:** The gift of sharp truth; mental awakening

**Two of Swords**
- **Role:** Difficult choice, stalemate, avoiding decision
- **Traditional Meaning:** Indecision, stalemate, blocked intuition, avoidance
- **In Progression:** The truth (Ace) demands a choice you're resisting

**Three of Swords**
- **Role:** Heartbreak, necessary grief, painful truth
- **Traditional Meaning:** Heartbreak, sorrow, necessary pain, truth hurts
- **In Progression:** The choice (Two) reveals a painful truth; grief follows

**Narrative Arc (Ace-2-3):**
> "Ace: Breakthrough insight → Two: Difficult choice → Three: Heartbreak. Truth cuts deep; acknowledging it brings necessary pain."

**Reading Significance:**
When 2+ Swords from this range appear: "You're in the mental clarity phase—truth is emerging, choices are hard, and grief may be necessary. Don't bypass the pain."

---

### Challenge: Mental Struggle (4-5-6-7)

**Four of Swords**
- **Role:** Rest, recovery, mental retreat, contemplation
- **Traditional Meaning:** Rest, recuperation, meditation, pause before action
- **In Progression:** After heartbreak (Three), rest and recovery needed

**Five of Swords**
- **Role:** Hollow victory, conflict, win at what cost?
- **Traditional Meaning:** Defeat, betrayal, winning unfairly, conflict resolution gone wrong
- **In Progression:** Re-engaging after rest but in unhealthy combat; pyrrhic victory

**Six of Swords**
- **Role:** Transition, moving toward calmer waters, leaving behind
- **Traditional Meaning:** Transition, healing journey, moving on, seeking peace
- **In Progression:** Consciously choosing to move away from conflict toward peace

**Seven of Swords**
- **Role:** Strategy, cunning, deception, taking what you need
- **Traditional Meaning:** Betrayal, strategy, stealth, getting away with something
- **In Progression:** Using your wits to navigate; sometimes ethically questionable

**Narrative Arc (4-5-6-7):**
> "Four: Rest & recovery → Five: Hollow victory → Six: Transition → Seven: Strategy or deception. Navigating conflict, choosing peace, using your wits."

**Reading Significance:**
When 2+ Swords from this range appear: "You're in the mental struggle phase—resting, fighting, transitioning, strategizing. Choose peace over hollow victory."

---

### Mastery: Mental Crisis & Liberation (8-9-10)

**Eight of Swords**
- **Role:** Self-imprisonment, bound by thought, victim mentality
- **Traditional Meaning:** Restriction, self-imposed limitation, feeling trapped
- **In Progression:** Mental patterns become a prison; believing you're stuck

**Nine of Swords**
- **Role:** Anxiety, nightmare, mental anguish, worry spiral
- **Traditional Meaning:** Anxiety, guilt, nightmares, mental torment
- **In Progression:** The mental prison (Eight) creates deep anxiety and sleepless nights

**Ten of Swords**
- **Role:** Rock bottom, painful ending, martyrdom, but dawn comes
- **Traditional Meaning:** Painful ending, betrayal, rock bottom, but the worst is over
- **In Progression:** Mental anguish culminates in hitting bottom—but daybreak follows

**Narrative Arc (8-9-10):**
> "Eight: Self-imprisonment → Nine: Anxiety spiral → Ten: Rock bottom (then dawn). Mental crisis reaching its worst, but the Ten promises: 'It can't get worse from here. Light is coming.'"

**Reading Significance:**
When 2+ Swords from this range appear: "You're in the mental crisis phase—feeling trapped, anxious, or hitting bottom. But Swords' culmination promises breakthrough after darkness. The dawn is coming."

**Shadow + Light:**
Swords culmination is the darkest of the four suits BUT it carries the promise of liberation. Ten of Swords says: "Yes, this is painful, but you've survived the worst. The only way now is up."

---

## PENTACLES (Earth Element)

**Domain:** Material resources, work, physical health, craft, tangible results
**Element:** Earth
**Qualities:** Grounded, practical, slow, enduring
**Life Area:** Finances, career, health, daily work, physical world

### Beginning: Material Foundation (Ace-2-3)

**Ace of Pentacles**
- **Role:** Tangible opportunity, seed of prosperity, material gift
- **Traditional Meaning:** New financial opportunity, manifestation, material security
- **In Progression:** The gift of material potential; opportunity to build

**Two of Pentacles**
- **Role:** Juggling resources, adaptive balance, managing multiple demands
- **Traditional Meaning:** Balance, adaptability, time management, juggling priorities
- **In Progression:** The opportunity (Ace) requires balancing resources and priorities

**Three of Pentacles**
- **Role:** Skilled collaboration, teamwork, recognition for expertise
- **Traditional Meaning:** Teamwork, craftsmanship, collaboration, learning through doing
- **In Progression:** Expertise emerges through practice; recognition for skill

**Narrative Arc (Ace-2-3):**
> "Ace: Seed of prosperity → Two: Juggling resources → Three: Skilled collaboration. Material opportunity requiring balance and collaborative expertise."

**Reading Significance:**
When 2+ Pentacles from this range appear: "You're in the material foundation phase—new opportunities, balancing demands, building expertise through collaboration."

---

### Challenge: Resource Management (4-5-6-7)

**Four of Pentacles**
- **Role:** Holding tight, security or greed, control
- **Traditional Meaning:** Control, stability, scarcity mindset, hoarding
- **In Progression:** After building (Three), fear of loss creates clinging

**Five of Pentacles**
- **Role:** Hardship, material or spiritual poverty, left out in the cold
- **Traditional Meaning:** Financial loss, poverty, isolation, spiritual crisis
- **In Progression:** Fear (Four) manifests as actual loss or feeling impoverished

**Six of Pentacles**
- **Role:** Generosity, balanced giving and receiving, charity
- **Traditional Meaning:** Generosity, charity, sharing wealth, reciprocity
- **In Progression:** After scarcity (Five), learning to give and receive with balance

**Seven of Pentacles**
- **Role:** Patient assessment, evaluating progress, pause before harvest
- **Traditional Meaning:** Patience, long-term view, assessment, investment of effort
- **In Progression:** Pausing to evaluate if the work is bearing fruit

**Narrative Arc (4-5-6-7):**
> "Four: Holding tight → Five: Hardship → Six: Generosity → Seven: Patient assessment. Navigating scarcity fears, actual loss, learning generosity, evaluating progress."

**Reading Significance:**
When 2+ Pentacles from this range appear: "You're in the resource management phase—navigating scarcity, learning generosity, assessing whether effort is paying off."

---

### Mastery: Material Mastery (8-9-10)

**Eight of Pentacles**
- **Role:** Diligent craftsmanship, dedicated practice, honing skill
- **Traditional Meaning:** Apprenticeship, skill development, dedication to craft
- **In Progression:** Committing to mastery through repetition and focused practice

**Nine of Pentacles**
- **Role:** Self-sufficiency, refined independence, earned luxury
- **Traditional Meaning:** Independence, self-reliance, luxury through effort, solitary success
- **In Progression:** Mastery (Eight) creates self-sufficiency; enjoying the fruits alone

**Ten of Pentacles**
- **Role:** Generational wealth, lasting legacy, family prosperity
- **Traditional Meaning:** Wealth, inheritance, family, long-term security, tradition
- **In Progression:** Material mastery culminates in legacy that lasts beyond you

**Narrative Arc (8-9-10):**
> "Eight: Diligent craftsmanship → Nine: Self-sufficiency → Ten: Lasting legacy. Material mastery: honing skill, achieving independence, building what endures."

**Reading Significance:**
When 2+ Pentacles from this range appear: "You're in the material mastery phase—dedicated practice, self-sufficiency achieved, building legacy."

**Light Note:**
Pentacles culmination is stable, lasting prosperity. Ten of Pentacles is wealth that provides for generations. This is the most grounded, enduring culmination of the four suits.

---

## Data Structure Schema

```javascript
export const SUIT_PROGRESSIONS = {
  Wands: {
    element: 'Fire',
    domain: 'Creativity, passion, will, enterprise',

    beginning: {
      ranks: [1, 2, 3],
      theme: 'Ignition',
      narrative: 'Ace: Pure creative spark → Two: Planning & vision → Three: Confident expansion',
      cards: [
        { rank: 1, name: 'Ace of Wands', role: 'Inspired beginning' },
        { rank: 2, name: 'Two of Wands', role: 'Strategic planning' },
        { rank: 3, name: 'Three of Wands', role: 'Confident expansion' }
      ]
    },

    challenge: {
      ranks: [4, 5, 6, 7],
      theme: 'Testing the Fire',
      narrative: 'Four: Celebration → Five: Competition → Six: Victory → Seven: Defensive perseverance',
      cards: [
        { rank: 4, name: 'Four of Wands', role: 'Joyful milestone' },
        { rank: 5, name: 'Five of Wands', role: 'Conflict & competition' },
        { rank: 6, name: 'Six of Wands', role: 'Public recognition' },
        { rank: 7, name: 'Seven of Wands', role: 'Standing your ground' }
      ]
    },

    mastery: {
      ranks: [8, 9, 10],
      theme: 'Culmination',
      narrative: 'Eight: Swift momentum → Nine: Guarded resilience → Ten: Overburdened completion',
      cards: [
        { rank: 8, name: 'Eight of Wands', role: 'Rapid progress' },
        { rank: 9, name: 'Nine of Wands', role: 'Wounded but standing' },
        { rank: 10, name: 'Ten of Wands', role: 'Carrying the full weight' }
      ],
      shadow: 'Culmination often carries burden or burnout'
    }
  },

  Cups: {
    element: 'Water',
    domain: 'Emotions, relationships, intuition, love',

    beginning: {
      ranks: [1, 2, 3],
      theme: 'Emotional Opening',
      narrative: 'Ace: Overflowing heart → Two: Partnership & reciprocity → Three: Celebration & friendship',
      cards: [
        { rank: 1, name: 'Ace of Cups', role: 'Overflowing heart' },
        { rank: 2, name: 'Two of Cups', role: 'Mutual devotion' },
        { rank: 3, name: 'Three of Cups', role: 'Joyful community' }
      ]
    },

    challenge: {
      ranks: [4, 5, 6, 7],
      theme: 'Emotional Complexity',
      narrative: 'Four: Apathy → Five: Loss & grief → Six: Nostalgia → Seven: Overwhelming options',
      cards: [
        { rank: 4, name: 'Four of Cups', role: 'Contemplative withdrawal' },
        { rank: 5, name: 'Five of Cups', role: 'Mourning what is lost' },
        { rank: 6, name: 'Six of Cups', role: 'Sweet memory' },
        { rank: 7, name: 'Seven of Cups', role: 'Fantasy & illusion' }
      ]
    },

    mastery: {
      ranks: [8, 9, 10],
      theme: 'Emotional Maturity',
      narrative: 'Eight: Walking away → Nine: Wish fulfillment → Ten: Blessed union',
      cards: [
        { rank: 8, name: 'Eight of Cups', role: 'Conscious release' },
        { rank: 9, name: 'Nine of Cups', role: 'Contentment achieved' },
        { rank: 10, name: 'Ten of Cups', role: 'Blessed union' }
      ],
      light: 'Culmination is deeply fulfilling when authentic'
    }
  },

  Swords: {
    element: 'Air',
    domain: 'Thought, communication, truth, conflict',

    beginning: {
      ranks: [1, 2, 3],
      theme: 'Mental Clarity',
      narrative: 'Ace: Breakthrough insight → Two: Difficult choice → Three: Heartbreak',
      cards: [
        { rank: 1, name: 'Ace of Swords', role: 'Cutting truth' },
        { rank: 2, name: 'Two of Swords', role: 'Stalemate' },
        { rank: 3, name: 'Three of Swords', role: 'Necessary grief' }
      ]
    },

    challenge: {
      ranks: [4, 5, 6, 7],
      theme: 'Mental Struggle',
      narrative: 'Four: Rest → Five: Hollow victory → Six: Transition → Seven: Strategy',
      cards: [
        { rank: 4, name: 'Four of Swords', role: 'Contemplative pause' },
        { rank: 5, name: 'Five of Swords', role: 'Pyrrhic win' },
        { rank: 6, name: 'Six of Swords', role: 'Moving toward calm' },
        { rank: 7, name: 'Seven of Swords', role: 'Cunning or theft' }
      ]
    },

    mastery: {
      ranks: [8, 9, 10],
      theme: 'Mental Crisis & Liberation',
      narrative: 'Eight: Self-imprisonment → Nine: Anxiety → Ten: Rock bottom (then dawn)',
      cards: [
        { rank: 8, name: 'Eight of Swords', role: 'Bound by thought' },
        { rank: 9, name: 'Nine of Swords', role: 'Anguish' },
        { rank: 10, name: 'Ten of Swords', role: 'Painful ending, daybreak coming' }
      ],
      shadow: 'Crisis before breakthrough',
      light: 'The worst is over; dawn is promised'
    }
  },

  Pentacles: {
    element: 'Earth',
    domain: 'Material, body, resources, craft, security',

    beginning: {
      ranks: [1, 2, 3],
      theme: 'Material Foundation',
      narrative: 'Ace: Seed of prosperity → Two: Juggling resources → Three: Skilled collaboration',
      cards: [
        { rank: 1, name: 'Ace of Pentacles', role: 'Seed of prosperity' },
        { rank: 2, name: 'Two of Pentacles', role: 'Adaptive balance' },
        { rank: 3, name: 'Three of Pentacles', role: 'Recognized expertise' }
      ]
    },

    challenge: {
      ranks: [4, 5, 6, 7],
      theme: 'Resource Management',
      narrative: 'Four: Holding tight → Five: Hardship → Six: Generosity → Seven: Patient assessment',
      cards: [
        { rank: 4, name: 'Four of Pentacles', role: 'Security or greed' },
        { rank: 5, name: 'Five of Pentacles', role: 'Material/spiritual poverty' },
        { rank: 6, name: 'Six of Pentacles', role: 'Balanced giving' },
        { rank: 7, name: 'Seven of Pentacles', role: 'Evaluating progress' }
      ]
    },

    mastery: {
      ranks: [8, 9, 10],
      theme: 'Material Mastery',
      narrative: 'Eight: Diligent craftsmanship → Nine: Self-sufficiency → Ten: Lasting legacy',
      cards: [
        { rank: 8, name: 'Eight of Pentacles', role: 'Dedicated practice' },
        { rank: 9, name: 'Nine of Pentacles', role: 'Refined independence' },
        { rank: 10, name: 'Ten of Pentacles', role: 'Generational wealth' }
      ],
      light: 'Stable, lasting prosperity and legacy'
    }
  }
};
```

## Detection Logic

```javascript
function detectSuitProgressions(cards) {
  const minorCards = cards.filter(c => c.suit && c.rankValue);
  if (minorCards.length < 2) return null;

  const detected = [];

  // Group cards by suit
  const bySuit = minorCards.reduce((acc, card) => {
    if (!acc[card.suit]) acc[card.suit] = [];
    acc[card.suit].push(card);
    return acc;
  }, {});

  // Analyze each suit
  Object.entries(bySuit).forEach(([suit, suitCards]) => {
    if (suitCards.length < 2) return;

    const progression = SUIT_PROGRESSIONS[suit];
    if (!progression) return;

    const ranks = suitCards.map(c => c.rankValue).sort((a, b) => a - b);

    // Check which stage(s) are represented
    const stages = { beginning: [], challenge: [], mastery: [] };

    suitCards.forEach(card => {
      if (progression.beginning.ranks.includes(card.rankValue)) {
        stages.beginning.push(card);
      } else if (progression.challenge.ranks.includes(card.rankValue)) {
        stages.challenge.push(card);
      } else if (progression.mastery.ranks.includes(card.rankValue)) {
        stages.mastery.push(card);
      }
    });

    // Find dominant stage
    const dominantStage = Object.entries(stages)
      .sort((a, b) => b[1].length - a[1].length)[0];

    if (dominantStage[1].length >= 2) {
      const stageKey = dominantStage[0];
      const stageData = progression[stageKey];

      detected.push({
        suit,
        element: progression.element,
        domain: progression.domain,
        stage: stageKey,
        theme: stageData.theme,
        narrative: stageData.narrative,
        cardCount: suitCards.length,
        ranks,
        cards: suitCards,
        stageCards: dominantStage[1],
        distribution: {
          beginning: stages.beginning.length,
          challenge: stages.challenge.length,
          mastery: stages.mastery.length
        },
        significance: dominantStage[1].length >= 3 ? 'strong-progression' : 'emerging-progression'
      });
    }
  });

  return detected.length > 0 ? detected : null;
}
```

## Narrative Templates

### Strong Progression (3+ cards from one stage)
> "**{Suit} {Stage}:** {Theme}. With {card list}, you're clearly in the {stage description} phase of this suit's journey. {Narrative arc}."

**Example:**
> "**Wands Beginning:** Ignition. With Ace, Two, and Three of Wands all present, you're clearly in the ignition phase—pure creative spark being channeled into strategic planning, now expanding into confident momentum. The fire is lit and growing."

### Emerging Progression (2 cards from one stage)
> "**{Suit} {Stage} (emerging):** {Card1} and {Card2} suggest {brief narrative}."

**Example:**
> "**Cups Challenge (emerging):** Five and Six of Cups suggest movement from grief toward healing nostalgia—you're processing loss while reconnecting with what remains sweet."

## Usage Guidelines

### When to Surface

**Highest Priority:** Strong progressions (3+ cards from one suit in one stage)
- Name the suit and stage explicitly
- Explain the narrative arc
- 2-3 sentences

**Medium Priority:** Emerging progressions (2 cards)
- Brief mention
- 1 sentence

**Low Priority:** Scattered minor cards
- Don't force progression narrative
- Focus on individual meanings

### Integration with Other Patterns

- **With Fool's Journey:** Suit progression = practical arc; Journey = archetypal arc
- **With Triads:** Triads take priority if Major Arcana
- **With Numerical Harmonics:** If multiple suits share same rank, note the harmonic

## Court Cards

**Note:** Court cards (Page, Knight, Queen, King) are NOT part of suit progressions. They represent personality types or maturity stages WITHIN the suit's element, not progression stages.

Detect court clusters separately (see COURT_PATTERNS in main knowledge graph spec).

---

## References

- Pollack, Rachel. *Seventy-Eight Degrees of Wisdom*. Thorsons, 1997.
- Greer, Mary K. *Complete Book of Tarot Reversals*. Llewellyn, 2002.
- Place, Robert. *The Tarot: History, Symbolism, and Divination*. Tarcher, 2005.
- Louis, Anthony. *Tarot Plain and Simple*. Llewellyn, 1996.
</file>

<file path="docs/addnewreversalframeworks.md">
# Complete Implementation: Adding New Reversal Frameworks

## Overview

This implementation adds 3 new reversal interpretation frameworks:

1. **Shadow Integration** - Jungian shadow work with micro-practices
2. **Mirror/Reflection** - Cards reflect unconscious projection
3. **Unrealized Potential** - Dormant gifts awaiting activation

---

## Step 1: Add Framework Definitions

**File:** [`functions/lib/spreadAnalysis.js`](functions/lib/spreadAnalysis.js:400)

Add these new frameworks to the `REVERSAL_FRAMEWORKS` object after line 450:

```javascript
export const REVERSAL_FRAMEWORKS = {
  // ... existing frameworks (none, blocked, delayed, internalized, contextual) ...

  shadow: {
    name: "Shadow Integration",
    description:
      "Reversals reveal disowned emotions, avoided needs, or unconscious habits surfacing for healing and wholeness.",
    guidance:
      "Name the hidden feeling, show how it can be witnessed safely, and suggest a micro-practice for reintegration.",
    examples: {
      "The Moon":
        "Anxiety eases when you name the fear aloud and create grounding rituals—try writing it down each morning.",
      "Five of Swords":
        "Step out of zero-sum thinking by repairing the belief that conflict equals abandonment.",
      "The Tower":
        "Resistance to change reveals fear of loss of control—acknowledge the grief of letting go as a first step.",
      "The Devil":
        "An attachment you judge in yourself deserves compassion; what need does it serve?",
    },
  },

  mirror: {
    name: "Mirror / Reflection",
    description:
      "Reversed cards reflect back to the querent what they are projecting outward—a mirror of unconscious behavior or energy.",
    guidance:
      "Ask what aspect of this energy you might be unconsciously expressing, attracting, or projecting onto others.",
    examples: {
      "The Emperor":
        "Where are you being overly controlling or rigid without realizing it?",
      "Queen of Cups":
        "Are you suppressing your emotional needs while focusing on caring for others?",
      "Knight of Swords":
        "Is your mental intensity coming across as aggression to those around you?",
      "The Hermit":
        "Are you isolating yourself in ways that others perceive as withdrawal or judgment?",
    },
  },

  potentialBlocked: {
    name: "Unrealized Potential",
    description:
      "Reversed cards show latent gifts, strengths, or capacities that have not yet been activated, claimed, or developed.",
    guidance:
      "Read each reversal as a dormant strength awaiting conscious cultivation—ask what would help this energy emerge fully.",
    examples: {
      "The Magician":
        "You have the tools and skills—what belief or circumstance is preventing you from wielding them fully?",
      "Eight of Pentacles":
        "A talent exists that you haven't invested time in developing yet. What would daily practice look like?",
      "The Star":
        "Hope and inspiration are available but not yet accessed—what would help you reconnect with your vision?",
      "Ace of Wands":
        "Creative fire is present but hasn't been channeled. What outlet would give it form?",
    },
  },
};
```

---

## Step 2: Enhance Framework Selection Logic

**File:** [`functions/lib/spreadAnalysis.js`](functions/lib/spreadAnalysis.js:389)

Replace the `selectReversalFramework` function with an enhanced version:

```javascript
/**
 * Select appropriate reversal interpretation framework based on patterns
 *
 * @param {number} ratio - Ratio of reversed cards (0-1)
 * @param {Array} cardsInfo - Card array for pattern detection
 * @param {Object} [options] - Additional context
 * @param {string} [options.userQuestion] - User's question for intent detection
 * @returns {string} Framework key
 */
function selectReversalFramework(ratio, cardsInfo, options = {}) {
  if (ratio === 0) return "none";

  const { userQuestion } = options;

  // Detect shadow work intent from question keywords
  if (userQuestion) {
    const q = userQuestion.toLowerCase();
    const shadowKeywords = [
      "afraid",
      "avoid",
      "fear",
      "shadow",
      "hidden",
      "deny",
      "repress",
      "shame",
      "guilt",
      "trigger",
    ];
    const mirrorKeywords = [
      "reflect",
      "mirror",
      "project",
      "attract",
      "pattern",
      "repeat",
      "always",
    ];
    const potentialKeywords = [
      "potential",
      "talent",
      "gift",
      "dormant",
      "untapped",
      "could be",
      "capable",
    ];

    if (shadowKeywords.some((kw) => q.includes(kw))) {
      return "shadow";
    }
    if (mirrorKeywords.some((kw) => q.includes(kw))) {
      return "mirror";
    }
    if (potentialKeywords.some((kw) => q.includes(kw))) {
      return "potentialBlocked";
    }
  }

  // Detect multiple Major Arcana reversed = potential-blocked
  if (Array.isArray(cardsInfo)) {
    const reversedMajors = cardsInfo.filter(
      (c) =>
        c &&
        (c.orientation || "").toLowerCase() === "reversed" &&
        typeof c.number === "number" &&
        c.number >= 0 &&
        c.number <= 21
    );
    if (reversedMajors.length >= 2) {
      return "potentialBlocked";
    }
  }

  // Original ratio-based logic
  if (ratio >= 0.6) return "blocked";
  if (ratio >= 0.4) return "internalized";
  if (ratio >= 0.2) return "delayed";
  return "contextual";
}
```

---

## Step 3: Update Function Call in `analyzeSpreadThemes`

**File:** [`functions/lib/spreadAnalysis.js`](functions/lib/spreadAnalysis.js:293)

Update line ~293 to pass the user question:

```javascript
// Change from:
let reversalFramework = selectReversalFramework(reversalRatio, cardsInfo);

// To:
let reversalFramework = selectReversalFramework(reversalRatio, cardsInfo, {
  userQuestion: options.userQuestion,
});
```

> `analyzeSpreadThemes` already accepts an `options` argument, so no signature change is required—just ensure `options.userQuestion` is plumbed into the selector as shown.

---

## Step 4: Pass User Question Through the Chain

**File:** [`functions/api/tarot-reading.js`](functions/api/tarot-reading.js:689)

In `performSpreadAnalysis`, pass `userQuestion` through to `analyzeSpreadThemes` and also forward `deckStyle` so theme analysis stops defaulting to `'rws-1909'`:

```javascript
// Around line 689, change:
themes = await analyzeSpreadThemes(cardsInfo, {
  reversalFrameworkOverride: options.reversalFrameworkOverride,
});

// To:
themes = await analyzeSpreadThemes(cardsInfo, {
  reversalFrameworkOverride: options.reversalFrameworkOverride,
  deckStyle: options.deckStyle,
  userQuestion: options.userQuestion, // ADD THIS
});
```

---

## Step 5: Add UI Option for Manual Selection (Optional)

**File:** [`src/components/ExperienceSettings.jsx`](src/components/ExperienceSettings.jsx)

The select is currently hard-coded—append the new frameworks directly inside the existing `<select>`:

```jsx
<select ...>
  <option value="auto">Auto (recommended)</option>
  <option value="blocked">Blocked energy</option>
  <option value="delayed">Timing & delays</option>
  <option value="internalized">Internal process</option>
  <option value="contextual">Context-based</option>
  <option value="shadow">Shadow Integration (Jungian)</option>
  <option value="mirror">Mirror / reflection</option>
  <option value="potentialBlocked">Unrealized potential</option>
</select>
```

Also extend the helper text block beneath the select so that each new framework renders explanatory copy when manually selected:

```jsx
{reversalFramework === "shadow" && (
  <>
    <span className="font-semibold text-secondary">Shadow</span> — surface hidden feelings and name a reintegration micro-practice
  </>
)}
{reversalFramework === "mirror" && (
  <>
    <span className="font-semibold text-secondary">Mirror</span> — examine what energy you might be projecting or attracting
  </>
)}
{reversalFramework === "potentialBlocked" && (
  <>
    <span className="font-semibold text-secondary">Potential</span> — treat reversals as dormant strengths awaiting activation
  </>
)}
```

---

## Step 6: Add Tests

**File:** [`functions/lib/__tests__/spreadAnalysis.test.js`](functions/lib/__tests__/) (create if needed)

Use Node’s built-in test runner to stay consistent with the existing suite:

```javascript
import { describe, it } from 'node:test';
import assert from 'node:assert/strict';
import { REVERSAL_FRAMEWORKS, selectReversalFramework } from '../spreadAnalysis.js';

describe('Reversal Frameworks', () => {
  it('should have all expected frameworks defined', () => {
    const expectedKeys = [
      'none',
      'blocked',
      'delayed',
      'internalized',
      'contextual',
      'shadow',
      'mirror',
      'potentialBlocked'
    ];

    expectedKeys.forEach((key) => {
      const framework = REVERSAL_FRAMEWORKS[key];
      assert.ok(framework, `Framework ${key} is missing`);
      assert.ok(framework.name);
      assert.ok(framework.description);
      assert.ok(framework.guidance);
    });
  });

  it('shadow framework should have examples for key cards', () => {
    const shadow = REVERSAL_FRAMEWORKS.shadow;
    assert.ok(shadow.examples['The Moon']);
    assert.ok(shadow.examples['The Tower']);
  });
});

describe('selectReversalFramework', () => {
  it('should detect shadow intent from question keywords', () => {
    const result = selectReversalFramework(0.3, [], {
      userQuestion: 'What am I afraid to face?'
    });
    assert.strictEqual(result, 'shadow');
  });

  it('should detect mirror intent from question keywords', () => {
    const result = selectReversalFramework(0.3, [], {
      userQuestion: 'Why do I keep attracting the same patterns?'
    });
    assert.strictEqual(result, 'mirror');
  });

  it('should detect potential-blocked when 2+ Major Arcana reversed', () => {
    const cardsInfo = [
      { number: 1, orientation: 'Reversed' },  // The Magician
      { number: 17, orientation: 'Reversed' }, // The Star
      { number: 5, orientation: 'Upright' }    // The Hierophant
    ];
    const result = selectReversalFramework(0.4, cardsInfo, {});
    assert.strictEqual(result, 'potentialBlocked');
  });
});
```

> **Note:** `npm test` currently runs `node --test tests/*.test.mjs`. Either invoke `node --test functions/lib/__tests__/spreadAnalysis.test.js` directly or update the script to include the `functions/lib/__tests__` glob.

---

## Step 7: Export the Function (if needed for testing)

**File:** [`functions/lib/spreadAnalysis.js`](functions/lib/spreadAnalysis.js)

If `selectReversalFramework` is not already exported, add it to the exports:

```javascript
// At the end of the file, ensure it's exported:
export { selectReversalFramework };
```

---

## Verification Checklist

After implementation:

1. [ ] Run `npm test` (existing suite) **and** `node --test functions/lib/__tests__/spreadAnalysis.test.js`
2. [ ] Run `npm run dev` and create a reading with a question containing "afraid" or "shadow" - should use Shadow Integration framework
3. [ ] Create a reading with 2+ reversed Major Arcana - should use Unrealized Potential framework
4. [ ] Verify the prompt contains the new framework text (enable `LOG_LLM_PROMPTS=true` in `.dev.vars`)
5. [ ] Confirm the generated reading uses language consistent with the selected framework

---

## Expected Prompt Output Example

With Shadow Integration selected, the prompt will include:

```
REVERSAL FRAMEWORK
- Reversal lens: "Shadow Integration". Reversals reveal disowned emotions,
  avoided needs, or unconscious habits surfacing for healing and wholeness.
- Guidance: Name the hidden feeling, show how it can be witnessed safely,
  and suggest a micro-practice for reintegration.
- Example applications:
  - The Moon reversed: Anxiety eases when you name the fear aloud and create
    grounding rituals—try writing it down each morning.
  - The Tower reversed: Resistance to change reveals fear of loss of control—
    acknowledge the grief of letting go as a first step.
- Keep this lens consistent for all reversed cards in this spread.
```

This produces readings with specific micro-practices and shadow work framing rather than the more observational "internal processing" tone.
</file>

<file path="docs/AI_Tarot_Master.md">
---
title: AI Tarot master guide – training, deck subtleties & interpretation
aliases:
  - AI Tarot Master Guide
  - AI Training for Tarot Interpretation
  - Unified Playbook for Tarot Deck Subtleties
tags:
  - ai/tarot
  - research/playbook
  - multimodal
  - symbolic-ai
  - cv
  - nlp
  - evaluation
  - ethics
status: canonical
---

# AI Tarot master guide – training, deck subtleties & interpretation

> Merged and deduplicated from:
> - [[Advanced Approaches to AI Training for Tarot Card Interpretation and Evaluation]]
> - [[AI Interpretation of Rider Waite Tarot Imagery Techniques and Strategies]]
> - [[Comprehensive Guide to AI Training for Tarot Card Interpretation Advanced Approaches and Rider-Waite-Specific Strategies]]
> - [[Teaching AI the Arcane Arts Unified Playbook for Tarot Deck Subtleties]]
> - [[Techniques for Teaching AI to Understand Tarot Deck Subtleties and Artistic Styles]]
> - [[How to Perform a Celtic Cross Reading Step by Step Guide]]
> - [[Tarot Cards Quick Reference and Interpretation Guide]]

## Executive summary

- **Goal**: Build AI systems that can *see* tarot images, *understand* symbolic systems across decks, and *generate* context-aware interpretations that feel coherent, ethical, and tradition-sensitive.
- **Pillars**:
  - **Multimodal learning**: Vision + language + symbolic structures (knowledge graphs, GraphRAG) instead of text-only prompting.
  - **Deck-aware modeling**: Explicit handling of Rider–Waite–Smith (RWS), Thoth, Marseille, and modern variants, including renamings and style differences.
  - **Robust evaluation**: Symbol detection, deck-specific meaning mapping, narrative coherence, and visual quality, all checked against human experts.
  - **Human tarot foundations**: Clear frameworks for suits, Major/Minor Arcana, upright vs reversed, spreads (especially Celtic Cross) to anchor model behavior.
  - **Ethics & governance**: CARE/FPIC principles, community collaboration, and “supportive tool, not oracle” positioning.
- **Priority stack**:
  1. Clean, richly annotated datasets (multi-deck, multi-modal).
  2. Symbolic representation & knowledge graphs with GraphRAG.
  3. Style-robust vision + LoRA-based style adapters.
  4. Spread-aware interpretation engines (context, sentiment, memory).
  5. Evaluation + human-in-the-loop refinement.

---

## 1. Human tarot foundations (for both readers & models)

### 1.1 Tarot structure at a glance

- **Major Arcana (22 cards)**: Archetypal life themes (e.g., The Fool, Death, The World). Clusters of Majors in a spread = big turning points.
- **Minor Arcana (56 cards)**:
  - **Suits / elements**:
    - Wands – Fire: action, drive, creativity.
    - Cups – Water: emotions, intuition, relationships.
    - Swords – Air: thought, communication, conflict.
    - Pentacles – Earth: work, body, money, material life.
  - **Numbers (Aces–10)** follow a development arc: potential → tension → integration → completion.
  - **Court cards (Page, Knight, Queen, King)**: people, roles, or approaches.

These structures become labels and constraints for AI: each card class, element, and number can be explicit metadata and/or prediction targets.

### 1.2 Upright vs reversed – a practical model

- **Upright**: Baseline meaning (keywords, suit, number, archetype).
- **Reversed**: Same energy, but:
  - blocked or delayed,
  - excessive or deficient,
  - internalized (happening inwardly),
  - or, occasionally, the clear opposite.
- Within a single reading, pick **one or two reversal lenses** (e.g., “blocked/delayed + internalized”) so the story stays coherent.

AI alignment: treat reversals as modifiers over upright meaning (flags/features) rather than separate unrelated meanings.

### 1.3 Position as “question lens”

In any spread, the **position** tells you what question the card is answering:

- Time-based: Past / Present / Future → timeline.
- Role-based: Challenge, Advice, Subconscious, External Influences, Outcome → function.
- Same card, different position → genuinely different reading.

For AI, each position becomes a **typed slot** (e.g., `role: "challenge"`), and models must condition on this.

### 1.4 Celtic Cross – spread & reading logic

The Celtic Cross is a 10-card spread with two main parts:

**Circle/Cross (cards 1–6: core dynamics + timeline)**

1. **Present** – central situation, atmosphere, querent’s state.
2. **Challenge** – obstacle/crossing force to integrate or overcome.
3. **Past** – influences/causes leading to the present.
4. **Near future** – developments in the next weeks/months (not final outcome).
5. **Conscious (above)** – goals, hopes, best-case the querent is aiming for.
6. **Subconscious (below)** – hidden motives, deeper drives, foundations.

**Staff (cards 7–10: self, context, trajectory)**

7. **Self / Advice** – querent’s stance or tailored guidance.
8. **External influences** – people, conditions, systems outside their control.
9. **Hopes & fears** – intertwined desires/anxieties shaping choices.
10. **Outcome (current path)** – probable trajectory if nothing changes.

**Reading workflow (human or AI)**

1. Interpret each card **for its position**.
2. Identify the core tension: **1 vs 2**.
3. Trace timeline: **3–1–4**, then **4→10** for near-future shaping outcome.
4. Check inner alignment: **6–1–5** (subconscious → present → conscious).
5. Map leverage: **7/Advice vs 10/Outcome**.
6. Summarize with **one narrative + one actionable takeaway**.

For AI, Celtic Cross is an ideal testbed: positions are structured, and we can check whether outputs respect these relationships.

---

## 2. Tarot systems & deck subtleties

### 2.1 Major lineages and their differences

**Rider–Waite–Smith (RWS)**

- Fully illustrated scenes for all 78 cards.
- Golden Dawn symbolism; Justice XI, Strength VIII.
- De facto standard for modern learning and digital decks.

**Tarot de Marseille**

- Minimalist woodcut style; pip-style Minors (suit symbols only).
- Justice VIII, Strength XI.
- Heavy reliance on numerology and elemental dignities.

**Thoth (Crowley–Harris)**

- Abstract, densely esoteric imagery.
- Renamed Majors (Adjustment, Aeon, Lust, etc.).
- Titled Minors (e.g., Dominion, Strife) with strong astrological/Kabbalistic correspondences.

**Implication for AI**: never assume “tarot” means RWS. Training and inference must be deck-aware: naming, numbering, imagery, and philosophy differ.

### 2.2 Artistic variation and style diversity

Across and within systems you encounter:

- Hand-drawn vs digital vs collage vs photorealism.
- Different palettes, line quality, framing, abstraction.
- Creators swapping symbols for culturally specific motifs.

For AI, “The Magician” might be a woodcut craftsman, an abstract sigil, or a neon cyberpunk hacker. Models must learn **style-invariant semantics**.

---

## 3. Data collection, curation & annotation

### 3.1 Dataset scope and composition

Target:

- **700–5,000+ images** spanning multiple decks and traditions.
- Oversample **Major Arcana** to stabilize generative models and symbolism.
- Standardize resolutions (e.g., 512×512 or 350×600) while preserving aspect ratio.

Include:

- Card name, deck, arcana (Major/Minor), suit, number, court rank, upright/reversed.
- Deck lineage (RWS-like, Thoth-like, Marseille-like, indie).
- Upright/reversed meanings, keywords, archetype labels, elemental/astrological tags.
- Spread context (position, question type) when available.

### 3.2 Symbol-level annotation

To connect pixels to symbols:

- Detect and label:
  - People (gender presentation, posture, gesture).
  - Objects (sword, cup, wand, pentacle, tower, crown, animals).
  - Colors and dominant palette.
  - Spatial relationships (above/below, facing toward/away, on horizon, foreground/background).
- Add **semantic tags**:
  - Emotions: grief, joy, tension, hope.
  - Motifs: sunrise, crossroads, storm, gateway.
- Use standard formats (COCO JSON, YOLO, Pascal VOC) and clear guidelines:
  - Label *every* instance of important symbols.
  - Provide edge-case examples and negative examples.

### 3.3 Multimodal pairings

Core unit: **(image, text, metadata)**.

Examples:

- Single-card: image + upright description + reversed description.
- Spread: list of cards + positions + question + full reading text.
- Contextual: `[question, card image] → domain-specific interpretation (career, love, spiritual).`

Use existing public corpora for bootstrapping, but curate and normalize to your ontology.

---

## 4. Symbolic representation & knowledge graphs

### 4.1 Knowledge graphs for tarot

Represent tarot as a graph:

- **Nodes**: Cards, Symbols, Elements, Numbers, Archetypes, Decks, Creators, Spreads, Positions.
- **Edges**: `hasSymbol`, `hasElement`, `associatedWith`, `renamedAs`, `differsFrom`, `appearsInPosition`.

Examples:

- `Magician --hasSymbol--> Infinity`
- `Two of Cups --element--> Water`
- `Justice (RWS XI) --renamedAs--> Adjustment (Thoth VIII)`

Use graph embeddings / graph neural networks to:

- Enforce consistency (e.g., Tower must involve upheaval themes).
- Support multi-hop reasoning (e.g., “Star” → hope → Aquarius → humanitarian themes).

### 4.2 GraphRAG (graph-enhanced retrieval)

Combine RAG with the tarot graph:

1. For a query + spread, identify nodes (cards, symbols, themes).
2. Traverse graph to collect relevant passages (deck guidebooks, essays, prior readings).
3. Feed retrieved snippets + graph-structured context into the language model.
4. Optionally apply a **post-generation linter** that checks card names, elements, and forbidden hallucinations.

This dramatically reduces off-canon interpretations and hallucinated cards.

---

## 5. Computer vision & artistic style modeling

### 5.1 Core vision tasks

- **Card classification**: identify which card (and orientation) an image shows.
- **Symbol detection**: bounding boxes/masks for key motifs (sun, moon, sword, cup, tower, lion, dog, etc.).
- **Style classification**: deck, artistic medium, palette family.

Architectures:

- CNNs or Vision Transformers (ViTs) for card classification and style recognition.
- YOLO/DETR-style detectors for symbol detection.

### 5.2 Handling style diversity

Use:

- **Multi-deck training**: multiple RWS-style and non-RWS decks to teach invariances.
- **Augmentation**: color jitter, texture overlays, blur, perspective shifts, style filters.
- **Style transfer / normalization**:
  - Option A: Normalize inputs to a “canonical” style before interpretation.
  - Option B: Train style-adaptive models (style embeddings or tokens).

Goal: the model should recognize “6 of Swords” whether it appears as woodcut boats, watercolor, or flat-vector art.

---

## 6. Generative pipelines & style adaptation

### 6.1 StyleGAN & diffusion for deck generation

For AI-generated decks:

- Use **StyleGAN2-ADA or diffusion models** with transfer learning from generic image models.
- Train on ~700+ tarot images, generate 20–40 candidates per card, and curate down to ~78–90 finals.
- Maintain consistent:
  - Frame/border system.
  - Character continuity (same “figure” appears across related cards).
  - Symbol fidelity (cards include the right motifs).

These generative models can also be used for **data augmentation** and “what-if” visualization.

### 6.2 LoRA (Low-Rank Adaptation) for tarot styles

LoRA is the practical way to adapt big image models to tarot styles:

- Lightweight adapters (~50–200 MB) trained on:
  - 20–50 images for character/mini-style.
  - 50–200+ images for full deck style.
- Advantages:
  - Multiple LoRAs can be composed at runtime:
    - e.g., “RWS structure” + “Art Nouveau art” + “cyberpunk palette”.
  - No need to fully fine-tune or host gigantic custom checkpoints for every deck.

Training practices:

- Freeze early layers, fine-tune later ones.
- Use small learning rates and progressive unfreezing.
- Strong augmentation to avoid overfitting niche decks.

---

## 7. NLP & tarot interpretation models

### 7.1 Foundation models and training objectives

Use transformer LLMs (small or large) fine-tuned on:

- Card descriptions (upright + reversed).
- Spread-based readings (with card lists + positions).
- Deck guidebooks and essays.
- Practitioner-generated readings annotated with context (career, love, spiritual, etc.).

Training tasks:

- Next-token prediction on readings.
- Multi-task:
  - Predict card-level labels (element, numerology, archetype).
  - Question → card → domain classification (e.g., which domain is most relevant?).

### 7.2 Context, sentiment, and intent

Before generating a reading:

- Parse the **user question**:
  - Domain (career, relationships, general).
  - Sentiment (anxious, hopeful, neutral).
  - Entities (people, workplace, time horizons).
- Respect **intent**:
  - Only trigger tarot logic when asked.
  - Avoid deterministic claims about fate; reinforce agency.

These signals condition the model’s tone, framing, and which card meanings it emphasizes.

### 7.3 Encoding Rider–Waite–Smith symbolism

For RWS imagery, explicitly model:

- **Color cues**: e.g., bright yellow (optimism, enlightenment), deep blue (spirituality, unconscious).
- **Positional features**: objects above/below, left/right, central figures, gestures (e.g., Magician’s “as above, so below”).
- **Archetype embeddings**: Empress as “nurturing-mother”, Tower as “upheaval”, etc.

Implementation:

- Train auxiliary heads that predict:
  - Primary archetype(s) for each card.
  - Symbolic attributes (e.g., presence of pillars, water bodies).
- These labels become metadata for interpretation models and vectors in the knowledge graph.

---

## 8. Multimodal and embedding strategies

### 8.1 Shared image–text space

Use CLIP-like or custom models to embed:

- Card images.
- Card descriptions.
- User questions.
- Spread interpretations.

into a **shared vector space**, so:

- Similar cards cluster (e.g., 3 of Cups near 10 of Cups in “joy” space).
- Different deck images for the same card map close together.
- User questions can retrieve relevant symbols/themes before generation.

### 8.2 Multi-view and cross-deck generalization

Train embeddings so that:

- Multiple depictions of “The Star” (RWS, Thoth, Marseille variants) are close together even if stylistically different.
- Even when a deck heavily stylizes or abstracts, embeddings still link back to core archetypes.

Techniques:

- Triplet/contrastive loss across views/decks.
- Explicit “same-card-different-deck” positive pairs.

---

## 9. Deck-specific adaptation

### 9.1 Per-tradition modeling

Maintain explicit knowledge for:

- **RWS**:
  - Fully illustrated Minors; strong narrative scenes.
  - Justice XI, Strength VIII.
- **Marseille**:
  - Pip Minors; stronger focus on number + element + suit patterns.
  - Justice VIII, Strength XI.
- **Thoth**:
  - Renamed trumps, titled Minors, heavy Qabalah/astrology.

Strategies:

- Separate but related training subsets.
- Domain adaptation from RWS to Marseille/Thoth via few-shot examples and prompts:
  - “Interpret this as Thoth Adjustment (Justice) in a spiritual context…”

### 9.2 Few-shot & prompt adaptation

Use few-shot techniques:

- Provide examples of how the same card is interpreted across traditions.
- Condition the model with the **deck name** and optional **creator intent**.

Example prompt fragment:

> Deck: Thoth. Card: Lust (Strength). Position: Challenge. Question: career path.
> Focus on esoteric and psychological themes but keep language accessible.

---

## 10. Reading context & spread-aware engines

### 10.1 Spread schema

Represent spreads in structured form:

- Cards with:
  - Name, deck, upright/reversed.
  - Position (with semantics: “past”, “challenge”, etc.).
- Question metadata (domain, sentiment).

Example schema snippet:

```json
{
  "spread": "Celtic Cross",
  "question": "What do I need to know about my career path right now?",
  "cards": [
    { "slot": 1, "role": "present", "card": "Two of Wands", "orientation": "upright" },
    { "slot": 2, "role": "challenge", "card": "Five of Pentacles", "orientation": "upright" },
    ...
  ]
}
```

### 10.2 Interpretation logic

Internally, your interpretation pipeline should:

1. Generate **per-card, per-position** summaries (1–2 sentences).
2. Model relationships:
   - Core tension: 1 vs 2.
   - Past → present → near future: 3–1–4.
   - Subconscious vs conscious vs outcome: 6–5–10.
   - Advice vs outcome: 7 vs 10.
3. Compose a single narrative with:
   - What is happening?
   - Why (root causes)?
   - What can be done (advice)?

Use attention mechanisms or graph-style reasoning over cards to ensure the narrative respects the spread’s structure.

---

## 11. Evaluation & interpretability

### 11.1 Symbolic & recognition metrics

- **Card identification accuracy**:
  - % of images correctly classified to the right card/orientation.
- **Symbol detection**:
  - Precision/recall/F1 for key symbols (e.g., lion on Strength, tower + lightning on The Tower).
- **Deck/Style recognition**:
  - Accuracy in labeling deck or style family, useful for deck-specific logic.

### 11.2 Narrative & interpretive metrics

- **Symbolic coherence**:
  - Does the reading mention symbols actually present?
  - Does it avoid hallucinating non-existent elements?
- **Alignment with canonical meanings**:
  - Embedding-based similarity between generated text and curated references.
  - Human experts score for “on message vs way off”.
- **Contextual relevance**:
  - Human ratings: “Does this answer my question?”, “Is it comforting/clear?”, “Does it respect my agency?”

### 11.3 Visual/generative metrics

- **FID (Fréchet Inception Distance)**:
  - Measures distance between generated tarot image distributions and real decks.
- **Style consistency**:
  - How uniform is style across all 78 cards in a generated deck?
- **Interpolation quality**:
  - Smoothness and semantic coherence across latent interpolations.

### 11.4 Interpretability tools

- **Attention/heatmaps**:
  - Visualize which parts of the image/text influenced the interpretation.
- **Causal tracing**:
  - Identify which tokens or image regions most contributed to specific statements (e.g., “upheaval” in a Tower reading).
- **Explanation graphs**:
  - Small human-readable chains: “Tower → lightning + falling figures → sudden change.”

### 11.5 Human-in-the-loop refinement

- Active learning on:
  - Low-confidence predictions.
  - High-disagreement cases (experts vs model).
- Expert tools:
  - Annotation dashboards for symbols and card relationships.
  - UI for editing readings, capturing better phrasings and explanations.

---

## 12. Ethics, culture & governance

Key principles:

- **Transparency**:
  - Make it clear that readings are algorithmic and for reflection/entertainment, not deterministic prophecy.
- **Cultural sensitivity**:
  - Some decks draw on specific spiritual/cultural traditions; follow CARE & FPIC guidelines, respect community wishes and licensing.
- **User agency & safety**:
  - Avoid harmful advice (e.g., medical, legal, financial absolutes).
  - Emphasize choice, support, and multiple possible futures.
- **Community collaboration**:
  - Involve practitioners, creators, and users in dataset design, evaluation, and governance.

---

## 13. Example implementation roadmaps

### 13.1 Visual tarot deck generation

1. Collect 700–1,000+ labeled card images across decks.
2. Train StyleGAN2-ADA or diffusion model with transfer learning.
3. Fine-tune LoRA adapters for specific styles or custom themes.
4. Generate 20–40 variants per card, curate down to a coherent 78-card deck.
5. Validate symbolism and usability with expert readers.

### 13.2 AI tarot interpretation engine

1. Build a multimodal dataset:
   - Card images + meanings + spread readings + questions.
2. Train:
   - Vision model for card/symbol detection.
   - LLM (or small transformer) for tarot text.
   - Optional image–text embedding model for retrieval.
3. Construct a tarot knowledge graph and plug it into a GraphRAG layer.
4. Implement spread schemas (starting with 3-card and Celtic Cross).
5. Add:
   - Intent detection, sentiment analysis.
   - Guardrails (no deterministic fate, no unsafe advice).
   - Evaluation dashboards and human-in-the-loop review.

---

## Appendix A – Celtic Cross quick reference

**Layout**

- 1 – Present (center)
- 2 – Challenge (crossing 1)
- 3 – Past (left)
- 4 – Near future (right)
- 5 – Conscious (above)
- 6 – Subconscious (below)
- 7 – Self / Advice (right column, bottom)
- 8 – External influences (above 7)
- 9 – Hopes & fears (above 8)
- 10 – Outcome (top of right column)

**Reading steps**

1. Clarify question; set intention; optionally choose significator.
2. Shuffle, draw ten cards, lay out as above.
3. Interpret cards 1–2 as core issue and crossing force.
4. Read timeline: 3–1–4.
5. Assess inner landscape: 6–1–5.
6. Read 7–10 as self, environment, hopes/fears, trajectory.
7. Synthesize story and advice; emphasize free will and options.

---

## Appendix B – Tarot keywords (78-card quick guide)

### Major Arcana

- The Fool: new beginnings, spontaneity, leap of faith, innocence
- The Magician: manifestation, skill, willpower, resourcefulness
- The High Priestess: intuition, mystery, inner knowledge, subconscious
- The Empress: abundance, nurturing, creativity, fertility
- The Emperor: structure, authority, leadership, stability
- The Hierophant: tradition, guidance, community, spiritual learning
- The Lovers: choice, union, values alignment, relationships
- The Chariot: determination, control, victory, direction
- Strength: courage, compassion, inner strength, patience
- The Hermit: introspection, solitude, inner guidance, truth
- Wheel of Fortune: cycles, change, fate, opportunity
- Justice: fairness, truth, cause and effect, accountability
- The Hanged Man: surrender, new perspective, pause, sacrifice
- Death: endings, transformation, release, rebirth
- Temperance: balance, moderation, healing, integration
- The Devil: bondage, materialism, temptation, shadow patterns
- The Tower: upheaval, sudden change, revelation, breakdown
- The Star: hope, renewal, inspiration, healing
- The Moon: uncertainty, illusion, dreams, intuition
- The Sun: joy, vitality, success, clarity
- Judgement: awakening, evaluation, forgiveness, second chances
- The World: completion, integration, achievement, wholeness

### Wands (Fire – action, drive, creation)

- Ace of Wands: inspiration, spark, new venture
- Two of Wands: planning, options, decisions
- Three of Wands: expansion, foresight, momentum
- Four of Wands: celebration, homecoming, milestones
- Five of Wands: competition, friction, testing
- Six of Wands: recognition, win, confidence
- Seven of Wands: defense, boundaries, perseverance
- Eight of Wands: swift movement, messages, progress
- Nine of Wands: resilience, vigilance, stamina
- Ten of Wands: burden, overload, responsibility
- Page of Wands: enthusiasm, exploration, news
- Knight of Wands: bold action, adventure, impulse
- Queen of Wands: charisma, magnetism, confidence
- King of Wands: leadership, vision, enterprise

### Cups (Water – emotions, intuition, relationships)

- Ace of Cups: new feelings, compassion, opening heart
- Two of Cups: partnership, mutuality, attraction
- Three of Cups: friendship, community, joy
- Four of Cups: apathy, reevaluation, contemplation
- Five of Cups: grief, regret, disappointment
- Six of Cups: nostalgia, innocence, kindness
- Seven of Cups: choices, fantasies, discernment
- Eight of Cups: withdrawal, seeking meaning, departure
- Nine of Cups: satisfaction, wish fulfilled, contentment
- Ten of Cups: harmony, family, lasting happiness
- Page of Cups: sensitivity, creative spark, message
- Knight of Cups: romantic pursuit, idealism, offers
- Queen of Cups: empathy, intuition, emotional depth
- King of Cups: emotional balance, support, diplomacy

### Swords (Air – thought, communication, conflict)

- Ace of Swords: clarity, truth, breakthrough
- Two of Swords: stalemate, indecision, detachment
- Three of Swords: heartbreak, sorrow, release
- Four of Swords: rest, recovery, pause
- Five of Swords: conflict, hollow victory, discord
- Six of Swords: transition, moving on, relief
- Seven of Swords: strategy, stealth, independence
- Eight of Swords: restriction, fear, mental bind
- Nine of Swords: anxiety, overthinking, worry
- Ten of Swords: ending, collapse, rock bottom
- Page of Swords: curiosity, vigilance, new ideas
- Knight of Swords: decisiveness, haste, pursuit
- Queen of Swords: discernment, candor, boundaries
- King of Swords: logic, authority, clear judgment

### Pentacles (Earth – work, body, resources)

- Ace of Pentacles: opportunity, seed of prosperity
- Two of Pentacles: juggling, priorities, adaptability
- Three of Pentacles: collaboration, craftsmanship, feedback
- Four of Pentacles: security, control, holding on
- Five of Pentacles: hardship, scarcity, exclusion
- Six of Pentacles: generosity, support, exchange
- Seven of Pentacles: assessment, patience, timing
- Eight of Pentacles: skill-building, practice, diligence
- Nine of Pentacles: self-sufficiency, comfort, refinement
- Ten of Pentacles: legacy, family wealth, long-term success
- Page of Pentacles: study, practicality, new skill
- Knight of Pentacles: reliability, routine, steady progress
- Queen of Pentacles: nurture, resourcefulness, comfort
- King of Pentacles: stability, mastery, enterprise

---

## Appendix C – Major Arcana upright vs reversed (quick reference)

| Card | Upright | Reversed |
|---|---|---|
| The Fool | Beginnings, spontaneity, leap of faith, innocence | Hesitation, recklessness, naivety, poor judgment |
| The Magician | Manifestation, willpower, resourcefulness, inspired action | Manipulation, scattered focus, poor planning, untapped potential |
| The High Priestess | Intuition, mystery, inner knowing, stillness | Disconnected intuition, secrets, repression, superficial reading of signs |
| The Empress | Abundance, nurturing, creativity, sensuality | Creative block, dependence, smothering, neglect of self-care |
| The Emperor | Structure, authority, discipline, leadership | Domination, rigidity, control issues, lack of discipline |
| The Hierophant | Tradition, guidance, community, spiritual teaching | Nonconformity, personal beliefs, rebellion, dogma questioned |
| The Lovers | Union, values alignment, heartfelt choice, harmony | Disharmony, misalignment, difficult choices, self-love needed |
| The Chariot | Willpower, control, determination, victory | Lack of direction, aggression, scattered energy, self-doubt |
| Strength | Courage, compassion, inner strength, gentle influence | Insecurity, raw emotion, impatience, self-doubt |
| The Hermit | Introspection, solitude, wisdom, inner guidance | Isolation, withdrawal, avoidance of reflection, loneliness |
| Wheel of Fortune | Cycles, change, luck, turning point | Resistance to change, bad timing, repeating patterns |
| Justice | Fairness, truth, accountability, balance | Unfairness, bias, dishonesty, evasion of responsibility |
| The Hanged Man | Surrender, new perspective, pause, sacrifice | Stalling, indecision, martyrdom, needless sacrifice |
| Death | Endings, transformation, release, transition | Fear of change, stagnation, clinging, delayed ending |
| Temperance | Balance, moderation, healing, integration | Excess, imbalance, misalignment, self-healing required |
| The Devil | Bondage, addiction, materialism, shadow patterns | Release, reclaiming power, detachment, shadow awareness |
| The Tower | Sudden upheaval, revelation, breakdown of false structures | Averted disaster, fear of change, internal collapse, delayed crisis |
| The Star | Hope, renewal, inspiration, faith | Discouragement, diminished faith, self-doubt, disconnection |
| The Moon | Illusion, fear, dreams, subconscious, intuition | Release of fear, confusion lifting, inner turmoil, truths emerging |
| The Sun | Joy, success, vitality, clarity | Temporary gloom, burnout, over-optimism, need to recharge |
| Judgement | Awakening, reckoning, evaluation, second chances | Self-criticism, doubt, ignoring the call, stagnation |
| The World | Completion, integration, achievement, wholeness | Incomplete closure, delays, loose ends, need for closure |

---

**How to use this master note**

- For **system design**: focus on §§3–13.
- For **symbol reference**: use Appendices B–C.
- For **spread encoding & testing**: use §10 + Appendix A.
- For **deck-aware RWS work**: see §§2, 7.3, 9.

You can now archive the original source notes and treat this as the canonical AI tarot reference, adding local edits or project-specific sections as needed.
</file>

<file path="docs/ARCHETYPE_JOURNEY_IMPLEMENTATION.md">
# Archetype Journey & Interactive Tooltips Implementation

## Summary

This document outlines the implementation of two requested features:
1. **Archetype Journey (Gamified Analytics)** - NEW ✅
2. **Interactive Educational Tooltips** - ALREADY EXISTS ✅

---

## 1. Archetype Journey (Gamified Analytics)

### Overview
Tracks which cards appear most frequently in user readings and provides gamified insights, streaks, and growth prompts.

### What Was Built

#### Database Schema (`migrations/0005_add_archetype_journey.sql`)
- **`card_appearances`** table: Tracks card occurrences per user, per month
- **`archetype_badges`** table: Stores earned badges for streak achievements
- **`user_analytics_prefs`** table: User preferences for analytics (opt-in/opt-out, badge visibility)

#### API Endpoint (`functions/api/archetype-journey.js`)
- **GET `/api/archetype-journey`** - Get analytics data:
  - Top 5 cards this month
  - All cards with counts
  - Streaks (cards appearing 2+ times)
  - Recent badges
  - 6-month trends
  - Major Arcana frequency distribution
- **POST `/api/archetype-journey/track`** - Track card appearances (called automatically on reading save)
- **PUT `/api/archetype-journey/preferences`** - Update user preferences
- **POST `/api/archetype-journey/reset`** - Reset all analytics data

#### UI Component (`src/components/ArchetypeJourneySection.jsx`)
- Embeddable section for `JournalInsightsPanel`
- Displays:
  - **Top 5 cards this month** with counts
  - **Streak badges** (e.g., "The Tower appeared 3× in Nov")
  - **Achievement badges** with icons and context
- Integrated with authentication (only shows for logged-in users)

#### Integration (`src/hooks/useJournal.js`)
- Automatically tracks card appearances when readings are saved
- Silent failure - doesn't block reading save if tracking fails
- Only tracks for authenticated users

### Usage

**For Users:**
1. Sign in to enable archetype journey tracking
2. Complete readings as normal
3. View analytics in Journal Insights panel
4. Opt-out via preferences if desired

**For Developers:**
1. Run migration: `wrangler d1 migrations apply DB --local` (then production)
2. The feature auto-tracks when users save readings
3. Integrate `ArchetypeJourneySection` into `JournalInsightsPanel`:
   ```jsx
   import { ArchetypeJourneySection } from './ArchetypeJourneySection';

   // Inside JournalInsightsPanel render:
   <ArchetypeJourneySection isAuthenticated={isAuthenticated} />
   ```

### Growth Prompts

Each Major Arcana card has a unique growth prompt tied to its archetype:
- **The Fool**: "Recurring Fool energy suggests you're in a season of new beginnings. What leap of faith is calling you?"
- **The Tower**: "Tower energy brings breakthrough. What false structure is crumbling to make space for truth?"
- **The Star**: "The Star brings hope and healing. What dream is worth nurturing?"
- (See `getGrowthPrompt()` in `ArchetypeJourneySection.jsx` for all 22)

### Privacy & Opt-Out
- **Opt-in by default** for authenticated users
- Users can disable via preferences: `PUT /api/archetype-journey/preferences`
- Users can reset all data: `POST /api/archetype-journey/reset`
- Anonymous users (localStorage only) are not tracked

---

## 2. Interactive Educational Tooltips

### Status: **Already Implemented** ✅

The interactive symbol tooltips feature described in the original spec already exists in the codebase!

### Existing Components

#### `src/components/CardSymbolInsights.jsx`
- Shows card symbols, meanings, colors, and archetypes
- Accessible with keyboard, mouse, and touch support
- Displays:
  - Card name and orientation (Upright/Reversed)
  - Keywords preview
  - Archetype
  - **Symbols list** with object, position, and meaning
  - **Color palette** with symbolic meanings

#### `src/components/Tooltip.jsx`
- Generic accessible tooltip component
- Full keyboard navigation (Escape to close, focus management)
- Touch support with auto-hide
- Position options: top, bottom, left, right
- ARIA-compliant

#### Integration in `Card.jsx`
- Already imports and uses `CardSymbolInsights`
- Symbols are pulled from `shared/symbols/symbolAnnotations.js`
- All 78 cards (22 Major + 56 Minor) have symbol data

### Existing Symbol Data

`shared/symbols/symbolAnnotations.js` contains comprehensive symbol data for all 78 RWS cards:
- **5-8+ symbols per card** with:
  - `object`: Symbol name (e.g., "dog", "cliff", "sun")
  - `position`: Location on card
  - `color`: Symbolic color (when applicable)
  - `meaning`: What the symbol represents
- **Dominant colors** with meanings
- **Composition** description
- **Archetype** label

### Example Symbol Data (The Fool)
```javascript
{
  symbols: [
    { object: 'sun', position: 'top-left', color: 'yellow', meaning: 'enlightenment, new beginnings' },
    { object: 'dog', position: 'bottom-right', color: 'white', meaning: 'loyalty, instinct, warning' },
    { object: 'cliff', position: 'right-edge', meaning: 'risk, the unknown, leap of faith' },
    { object: 'white rose', position: 'left-hand', color: 'white', meaning: 'purity, innocence' },
    // ... more symbols
  ],
  dominantColors: [
    { color: 'yellow', meaning: 'optimism, joy' },
    { color: 'white', meaning: 'purity, new starts' },
    { color: 'sky-blue', meaning: 'freedom, possibility' }
  ],
  composition: 'figure-on-precipice',
  archetype: 'Divine Fool / Innocent Wanderer'
}
```

---

## Testing Checklist

### Archetype Journey
- [ ] Run database migration (`0005_add_archetype_journey.sql`)
- [ ] Test authenticated user flow:
  - [ ] Save a reading
  - [ ] Verify `/api/archetype-journey` returns analytics
  - [ ] Save same card multiple times
  - [ ] Verify streak badge appears at 3×
  - [ ] Check growth prompts for Major Arcana cards
- [ ] Test unauthenticated user:
  - [ ] Verify analytics section doesn't show
  - [ ] Verify no tracking occurs
- [ ] Test preferences:
  - [ ] Disable analytics
  - [ ] Re-enable analytics
  - [ ] Reset all data
- [ ] Verify `ArchetypeJourneySection` renders in Journal panel

### Symbol Tooltips (Already Working)
- [ ] Verify `CardSymbolInsights` button appears on revealed cards
- [ ] Click/hover to open tooltip
- [ ] Verify symbols, colors, and archetype display
- [ ] Test keyboard navigation (Tab, Escape)
- [ ] Test touch support (tap, auto-hide)

---

## Files Created

1. `migrations/0005_add_archetype_journey.sql` - Database schema
2. `functions/api/archetype-journey.js` - API endpoint
3. `src/components/ArchetypeJourneySection.jsx` - UI component
4. `src/components/ArchetypeJourney.jsx` - (Deprecated - use Section instead)
5. `docs/ARCHETYPE_JOURNEY_IMPLEMENTATION.md` - This document

## Files Modified

1. `src/hooks/useJournal.js` - Added `trackCardAppearances()` function

## Files Already Existing (Symbol Tooltips)

1. `src/components/CardSymbolInsights.jsx` - Symbol tooltip component
2. `src/components/Tooltip.jsx` - Generic tooltip component
3. `shared/symbols/symbolAnnotations.js` - Comprehensive symbol data (62KB, all 78 cards)
4. `src/components/Card.jsx` - Uses `CardSymbolInsights`

---

## Next Steps

1. **Deploy Migration**: Run `wrangler d1 migrations apply DB` for production
2. **Integrate UI**: Add `<ArchetypeJourneySection />` to `JournalInsightsPanel.jsx`
3. **Test End-to-End**: Complete a full reading cycle with analytics tracking
4. **User Documentation**: Add help text explaining archetype journey features
5. **Optional Enhancements**:
   - Sparkline charts for 6-month trends
   - More badge types (completion, milestone)
   - Export analytics as PDF/CSV
   - AI-generated personalized growth prompts based on card patterns

---

## Architecture Notes

### Why Track in `useJournal` Instead of API?
- Separates concerns: journal save handles persistence, then tracks analytics
- Silent failure: analytics tracking doesn't block reading save
- Flexible: can add other post-save hooks (e.g., webhooks, notifications)

### Why Separate `ArchetypeJourneySection` from `ArchetypeJourney`?
- `ArchetypeJourneySection`: Embeddable section for existing panel
- `ArchetypeJourney`: Standalone page (if needed for future full-page view)
- Follow existing pattern: `JournalInsightsPanel` is composed of smaller sections

### Privacy-First Design
- Opt-in by default for authenticated users
- No tracking for anonymous users (localStorage)
- User-initiated reset deletes all data
- No cross-user aggregation (each user sees only their own data)

---

## Questions?

- **How do I disable analytics?** Sign in → Journal → Archetype Journey section → "Disable Analytics"
- **Can I delete my data?** Yes, use "Reset Data" in the Archetype Journey section
- **Do symbols work for all decks?** Currently RWS only; Thoth/Marseille coming soon
- **Can I export analytics?** Not yet, but planned for future enhancement

---

**Implementation Status**: ✅ Complete (2025-11-20)
</file>

<file path="docs/context-aware-remedies-implementation.md">
# Context-Aware Elemental Remedies Implementation Guide

## Status
**✅ Fully Implemented and Verified** (Nov 20, 2025)

- **Codebase:** `functions/lib/narrative/helpers.js` updated with 60+ remedies and selection logic.
- **Testing:** Unit and integration tests passed covering all contexts and fallback scenarios.
- **Compatibility:** Fully backward compatible; defaults to 'general' context if unspecified.

---

## Overview

This document provides a complete implementation for context-aware elemental remedies that adapt based on the reading context (love, career, self, spiritual, general).

---

## Current State

**File:** `functions/lib/narrative/helpers.js:1007-1032`

```javascript
const ELEMENTAL_REMEDIES = {
  Fire: [
    'Move your body—take a walk, stretch, or dance to music',
    'Take one decisive action on something you have been considering',
    'Create something with your hands—cook, draw, rearrange a space',
    'Speak up about something that matters to you'
  ],
  Water: [
    'Journal your feelings without censoring or editing',
    'Spend time near water or take a mindful bath',
    'Practice self-compassion when difficult emotions arise',
    'Talk with someone who holds space for your emotions without trying to fix them'
  ],
  Air: [
    'Discuss your thoughts with a trusted friend or mentor',
    'Write out your thoughts to gain perspective on what feels confusing',
    'Learn something new that sparks your curiosity',
    'Step back and observe the situation from a different angle'
  ],
  Earth: [
    'Establish one grounding daily ritual (morning tea, evening walk, bedtime routine)',
    'Organize a small physical space to create order',
    'Tend to your body\'s basic needs (sleep, nourishing food, gentle movement)',
    'Work with your hands—garden, cook, craft, or repair something tangible'
  ]
};
```

**Problem:** All contexts get the same generic advice.

---

## Proposed Architecture

### **1. Context-Aware Data Structure**

```javascript
const ELEMENTAL_REMEDIES_BY_CONTEXT = {
  Fire: {
    love: [
      'Plan a spontaneous date or shared adventure',
      'Have an honest conversation about what excites you both',
      'Try something new together that gets your hearts racing'
    ],
    career: [
      'Pitch that idea you have been sitting on',
      'Take initiative on a project without waiting for permission',
      'Network with someone who inspires you'
    ],
    self: [
      'Move your body—take a walk, stretch, or dance to music',
      'Start that creative project you have been thinking about',
      'Do something that scares you a little in a good way'
    ],
    spiritual: [
      'Practice devotional movement (sacred dance, yoga, tai chi)',
      'Engage with your spiritual practice through action (ritual, service)',
      'Channel inspiration into creative expression of your beliefs'
    ],
    general: [
      'Move your body—take a walk, stretch, or dance to music',
      'Take one decisive action on something you have been considering',
      'Create something with your hands—cook, draw, rearrange a space'
    ]
  },

  Water: {
    love: [
      'Share a vulnerable feeling with your partner',
      'Create space to really listen without planning your response',
      'Express appreciation for something you often take for granted'
    ],
    career: [
      'Check in with how you feel about your work, not just what you think',
      'Reach out to a colleague with genuine care, not just networking',
      'Notice and honor your emotional needs around work boundaries'
    ],
    self: [
      'Journal your feelings without censoring or editing',
      'Practice self-compassion when difficult emotions arise',
      'Let yourself cry, laugh, or feel without trying to fix it'
    ],
    spiritual: [
      'Spend time in receptive prayer or meditation',
      'Engage with sacred texts or teachings that move you emotionally',
      'Practice loving-kindness meditation for yourself and others'
    ],
    general: [
      'Journal your feelings without censoring or editing',
      'Spend time near water or take a mindful bath',
      'Talk with someone who holds space for your emotions without trying to fix them'
    ]
  },

  Air: {
    love: [
      'Ask a question you have been afraid to ask',
      'Talk through a misunderstanding without defensiveness',
      'Share an idea or perspective you usually keep to yourself'
    ],
    career: [
      'Clarify expectations in a key work relationship',
      'Ask for the feedback you need to grow',
      'Articulate your vision or goals to someone who can help'
    ],
    self: [
      'Write out your thoughts to gain perspective on what feels confusing',
      'Talk through your inner dialogue with a trusted friend',
      'Question an assumption you have been carrying'
    ],
    spiritual: [
      'Study a teaching or text that challenges your understanding',
      'Engage in dialogue with someone whose beliefs differ from yours',
      'Write or speak your prayers aloud to clarify your intentions'
    ],
    general: [
      'Discuss your thoughts with a trusted friend or mentor',
      'Write out your thoughts to gain perspective on what feels confusing',
      'Learn something new that sparks your curiosity'
    ]
  },

  Earth: {
    love: [
      'Create a small daily ritual you do together (morning coffee, evening walk)',
      'Tend to the practical, unglamorous foundations of your relationship',
      'Show love through concrete actions, not just words'
    ],
    career: [
      'Organize your workspace or schedule for better flow',
      'Complete one small task that has been lingering',
      'Build a sustainable routine that supports your energy'
    ],
    self: [
      'Establish one grounding daily ritual (morning tea, evening walk, bedtime routine)',
      'Tend to your body\'s basic needs (sleep, nourishing food, gentle movement)',
      'Spend time in nature or with your hands in soil'
    ],
    spiritual: [
      'Create a physical altar or sacred space in your home',
      'Engage in embodied practice (walking meditation, sacred gardening)',
      'Ground your beliefs in daily ritual and tangible acts of service'
    ],
    general: [
      'Establish one grounding daily ritual (morning tea, evening walk, bedtime routine)',
      'Organize a small physical space to create order',
      'Work with your hands—garden, cook, craft, or repair something tangible'
    ]
  }
};
```

**Total Content:** 60 unique remedies (4 elements × 5 contexts × 3 options each)

---

### **2. Selection Algorithm**

```javascript
/**
 * Select context-appropriate remedy for an element
 * @param {string} element - Fire, Water, Air, Earth
 * @param {string} context - love, career, self, spiritual, general
 * @param {number} index - Which remedy to pick (0-2, rotates for variety)
 * @returns {string} Context-appropriate remedy
 */
function selectContextAwareRemedy(element, context, index = 0) {
  const contextRemedies = ELEMENTAL_REMEDIES_BY_CONTEXT[element];
  if (!contextRemedies) return null;

  // Try to get context-specific remedy
  let remedyList = contextRemedies[context];

  // Fallback to general if context not found
  if (!remedyList || remedyList.length === 0) {
    remedyList = contextRemedies.general;
  }

  // Fallback to first available if general not found
  if (!remedyList || remedyList.length === 0) {
    const firstAvailable = Object.values(contextRemedies).find(list => list && list.length > 0);
    remedyList = firstAvailable || [];
  }

  if (remedyList.length === 0) return null;

  // Rotate through remedies using index (prevents repetition across readings)
  const selectedIndex = index % remedyList.length;
  return remedyList[selectedIndex];
}
```

**Fallback Chain:**
1. Try `element[context]` (e.g., Fire[love])
2. Fall back to `element['general']`
3. Fall back to first available context
4. Return null if nothing found

---

### **3. Updated buildElementalRemedies Function**

```javascript
/**
 * Generate actionable remedies for underrepresented elements
 * Now with context-aware selection
 *
 * @param {Object} elementCounts - Counts of each element {Fire: 2, Water: 0, Air: 1, Earth: 0}
 * @param {number} totalCards - Total number of cards in spread
 * @param {string} context - Reading context (love, career, self, spiritual, general)
 * @param {Object} options - Additional options
 * @param {number} options.rotationIndex - Index for rotating through remedies (default: 0)
 * @returns {string|null} Formatted remedy guidance or null if balanced
 */
function buildElementalRemedies(elementCounts, totalCards, context = 'general', options = {}) {
  if (!elementCounts || !totalCards || totalCards < 3) return null;

  const rotationIndex = options.rotationIndex || 0;

  // Calculate which elements are underrepresented (< 15% of spread)
  const threshold = 0.15;
  const underrepresented = Object.entries(elementCounts)
    .filter(([element, count]) => {
      const ratio = count / totalCards;
      return ratio < threshold && count < totalCards;
    })
    .map(([element]) => element)
    .filter(element => ELEMENTAL_REMEDIES_BY_CONTEXT[element]);

  if (underrepresented.length === 0) return null;

  // Build remedy text with context-aware selection
  const remedies = underrepresented
    .map(element => {
      const remedy = selectContextAwareRemedy(element, context, rotationIndex);
      if (!remedy) return null;
      return `**${element}**: ${remedy}`;
    })
    .filter(Boolean);

  if (remedies.length === 0) return null;

  return `To bring in underrepresented energies:\n${remedies.join('\n')}`;
}
```

**Key Changes:**
- Add `options` parameter with `rotationIndex`
- Replace direct array access `options[0]` with `selectContextAwareRemedy()` call
- Maintain existing logic for threshold and filtering

---

## Implementation Plan

### **Step 1: Replace Data Structure (2-3 hours)**

**File:** `functions/lib/narrative/helpers.js`
**Lines:** 1007-1032

**Action:** Replace `ELEMENTAL_REMEDIES` with `ELEMENTAL_REMEDIES_BY_CONTEXT`

**Quality Guidelines for Writing Remedies:**
- ✅ **Actionable:** Starts with clear verb (Plan, Share, Organize, etc.)
- ✅ **Specific:** Not vague ("do self-care" ❌ → "Journal feelings" ✅)
- ✅ **Accessible:** No special equipment/skills required
- ✅ **Context-appropriate:** Uses domain language
  - Love: "partner," "relationship," "together"
  - Career: "work," "colleague," "meeting," "project"
  - Self: "your," personal pronouns
  - Spiritual: "sacred," "ritual," "practice," "prayer"
- ✅ **Trauma-informed:** Emphasizes agency ("you can," not "you must")
- ✅ **Concise:** 1-2 lines maximum

---

### **Step 2: Add Selection Function (15 minutes)**

**File:** `functions/lib/narrative/helpers.js`
**Location:** After `ELEMENTAL_REMEDIES_BY_CONTEXT` definition

**Code to Add:**

```javascript
/**
 * Select context-appropriate remedy for an element
 * Implements fallback chain: context → general → first available
 */
function selectContextAwareRemedy(element, context, index = 0) {
  const contextRemedies = ELEMENTAL_REMEDIES_BY_CONTEXT[element];
  if (!contextRemedies) return null;

  // Try context-specific first
  let remedyList = contextRemedies[context];

  // Fallback to general
  if (!remedyList || remedyList.length === 0) {
    remedyList = contextRemedies.general;
  }

  // Fallback to first available
  if (!remedyList || remedyList.length === 0) {
    const firstAvailable = Object.values(contextRemedies).find(
      list => list && list.length > 0
    );
    remedyList = firstAvailable || [];
  }

  if (remedyList.length === 0) return null;

  // Rotate through options
  const selectedIndex = index % remedyList.length;
  return remedyList[selectedIndex];
}
```

---

### **Step 3: Update buildElementalRemedies (15 minutes)**

**File:** `functions/lib/narrative/helpers.js`
**Lines:** 1041-1072

**Changes to Make:**

1. **Update function signature:**
```javascript
// Old
function buildElementalRemedies(elementCounts, totalCards, context = 'general') {

// New
function buildElementalRemedies(elementCounts, totalCards, context = 'general', options = {}) {
```

2. **Add rotation index extraction:**
```javascript
// Add after parameter checks
const rotationIndex = options.rotationIndex || 0;
```

3. **Replace remedy selection:**
```javascript
// Old
const remedy = options[0];

// New
const remedy = selectContextAwareRemedy(element, context, rotationIndex);
```

4. **Update docstring:**
```javascript
/**
 * Generate actionable remedies for underrepresented elements
 * Now with context-aware selection
 *
 * @param {Object} elementCounts - Counts of each element
 * @param {number} totalCards - Total number of cards in spread
 * @param {string} context - Reading context (love, career, self, spiritual, general)
 * @param {Object} options - Additional options
 * @param {number} options.rotationIndex - Index for rotating through remedies (default: 0)
 * @returns {string|null} Formatted remedy guidance or null if balanced
 */
```

---

### **Step 4: Export New Function (1 minute)**

**File:** `functions/lib/narrative/helpers.js`
**Lines:** 1098-1123

**Add to exports:**
```javascript
export {
  // ... existing exports
  buildElementalRemedies,
  shouldOfferElementalRemedies,
  selectContextAwareRemedy  // NEW
};
```

---

### **Step 5: Update Tests (1 hour)**

#### **Test 1: Context Selection Unit Test**

**Create:** `tests/contextSelection.test.mjs`

```javascript
import { selectContextAwareRemedy } from '../functions/lib/narrative/helpers.js';

console.log('🧪 Testing Context-Aware Remedy Selection...\n');

const tests = [
  {
    name: 'Water + Love context',
    element: 'Water',
    context: 'love',
    expected: /vulnerable feeling|partner|listen/i
  },
  {
    name: 'Water + Career context',
    element: 'Water',
    context: 'career',
    expected: /work|colleague|boundaries/i
  },
  {
    name: 'Fire + Spiritual context',
    element: 'Fire',
    context: 'spiritual',
    expected: /devotional|ritual|meditation/i
  },
  {
    name: 'Earth + General context',
    element: 'Earth',
    context: 'general',
    expected: /grounding|ritual|organize/i
  },
  {
    name: 'Air + Invalid context (fallback)',
    element: 'Air',
    context: 'invalid-context-xyz',
    expected: /friend|write|learn/i // Should use general
  },
  {
    name: 'Rotation index = 0',
    element: 'Water',
    context: 'self',
    index: 0,
    expected: /Journal/i // First option
  },
  {
    name: 'Rotation index = 1',
    element: 'Water',
    context: 'self',
    index: 1,
    expected: /self-compassion|cry|laugh/i // Second/third option
  }
];

let passed = 0;
let failed = 0;

tests.forEach(test => {
  const remedy = selectContextAwareRemedy(test.element, test.context, test.index || 0);

  if (test.expected.test(remedy)) {
    console.log(`✅ ${test.name}`);
    passed++;
  } else {
    console.log(`❌ ${test.name}`);
    console.log(`   Got: ${remedy}`);
    failed++;
  }
});

console.log(`\n📊 Results: ${passed}/${tests.length} passed`);
process.exit(failed > 0 ? 1 : 0);
```

#### **Test 2: Context Integration Test**

**Create:** `tests/contextAwareIntegration.test.mjs`

```javascript
import { buildElementalRemedies } from '../functions/lib/narrative/helpers.js';

console.log('🧪 Testing Context-Aware Integration...\n');

const mockElementCounts = { Fire: 2, Water: 0, Air: 1, Earth: 0 };
const totalCards = 3;

const contexts = [
  { name: 'love', keywords: ['partner', 'relationship', 'together', 'shared'] },
  { name: 'career', keywords: ['work', 'colleague', 'project', 'workspace'] },
  { name: 'self', keywords: ['your', 'yourself', 'feel'] },
  { name: 'spiritual', keywords: ['sacred', 'ritual', 'practice', 'meditation'] },
  { name: 'general', keywords: ['body', 'grounding', 'organize'] }
];

let passed = 0;
let failed = 0;

contexts.forEach(ctx => {
  console.log(`\n📝 Testing ${ctx.name.toUpperCase()} context:`);

  const remedies = buildElementalRemedies(mockElementCounts, totalCards, ctx.name);

  if (!remedies) {
    console.log(`   ❌ No remedies generated`);
    failed++;
    return;
  }

  console.log(`   ${remedies.split('\n').slice(1).join('\n   ')}`);

  // Check if context-specific keywords appear
  const hasContextKeyword = ctx.keywords.some(keyword =>
    remedies.toLowerCase().includes(keyword.toLowerCase())
  );

  if (hasContextKeyword) {
    console.log(`   ✅ Contains context-appropriate language`);
    passed++;
  } else {
    console.log(`   ❌ Missing context-specific keywords: ${ctx.keywords.join(', ')}`);
    failed++;
  }
});

console.log(`\n\n📊 Results: ${passed}/${contexts.length} contexts passed`);
process.exit(failed > 0 ? 1 : 0);
```

#### **Test 3: Update Existing Tests**

**Update:** `tests/elementalRemedies.test.mjs`

**Change:** Add context parameter to buildElementalRemedies calls

```javascript
// Old
const remedies = buildElementalRemedies(test.elementCounts, test.totalCards);

// New
const remedies = buildElementalRemedies(test.elementCounts, test.totalCards, test.context || 'general');
```

---

## Usage Examples

### **Love Reading with Fire Dominance**

**Before (Generic):**
```
Elemental context: Fire energy strongly dominates (2/3 cards).

To bring in underrepresented energies:
**Water**: Journal your feelings without censoring or editing
**Earth**: Establish one grounding daily ritual (morning tea, evening walk)
```

**After (Context-Aware):**
```
Elemental context: Fire energy strongly dominates (2/3 cards).

To bring in underrepresented energies:
**Water**: Share a vulnerable feeling with your partner
**Earth**: Create a small daily ritual you do together (morning coffee, evening walk)
```

**Impact:** Remedies now speak directly to relationship context.

---

### **Career Reading with Water Missing**

**Before (Generic):**
```
To bring in underrepresented energies:
**Water**: Journal your feelings without censoring or editing
```

**After (Context-Aware):**
```
To bring in underrepresented energies:
**Water**: Check in with how you feel about your work, not just what you think
```

**Impact:** Addresses emotional awareness in professional context.

---

### **Spiritual Reading with Earth Deficient**

**Before (Generic):**
```
To bring in underrepresented energies:
**Earth**: Establish one grounding daily ritual (morning tea, evening walk)
```

**After (Context-Aware):**
```
To bring in underrepresented energies:
**Earth**: Create a physical altar or sacred space in your home
```

**Impact:** Frames grounding through spiritual practice lens.

---

## Advanced Features (Optional)

### **Feature 1: Multiple Options Display**

Show user 2-3 choices per element:

```javascript
function buildElementalRemedies(elementCounts, totalCards, context = 'general', options = {}) {
  const {
    rotationIndex = 0,
    multipleOptions = false,
    maxOptionsPerElement = 2
  } = options;

  // ... existing logic ...

  if (multipleOptions) {
    const remedies = underrepresented
      .map(element => {
        const contextRemedies = ELEMENTAL_REMEDIES_BY_CONTEXT[element]?.[context]
          || ELEMENTAL_REMEDIES_BY_CONTEXT[element]?.general
          || [];

        const selectedRemedies = contextRemedies
          .slice(0, maxOptionsPerElement)
          .map((remedy, idx) => `  ${idx + 1}. ${remedy}`);

        return `**${element}** (choose one):\n${selectedRemedies.join('\n')}`;
      })
      .filter(Boolean);

    return `To bring in underrepresented energies:\n${remedies.join('\n\n')}`;
  }

  // ... existing single-remedy logic
}
```

**Output:**
```
To bring in underrepresented energies:

**Water** (choose one):
  1. Share a vulnerable feeling with your partner
  2. Create space to really listen without planning your response

**Earth** (choose one):
  1. Create a small daily ritual you do together
  2. Tend to the practical, unglamorous foundations of your relationship
```

---

### **Feature 2: Rotation for Variety**

Prevent showing same remedy to repeat users:

```javascript
// Track reading count in session or user preferences
const readingCount = getUserReadingCount(); // 0, 1, 2, ...

const remedies = buildElementalRemedies(
  elementCounts,
  totalCards,
  context,
  { rotationIndex: readingCount % 3 }
);
```

**Behavior:**
- First reading: Shows option 0
- Second reading: Shows option 1
- Third reading: Shows option 2
- Fourth reading: Back to option 0

---

### **Feature 3: User Preference Storage**

Track which remedies user has tried:

```javascript
const userPreferences = {
  userId: 'abc123',
  triedRemedies: {
    Water: ['journal', 'bath'],
    Earth: ['ritual']
  }
};

function getNovelRemedy(element, context, userPrefs) {
  const allRemedies = ELEMENTAL_REMEDIES_BY_CONTEXT[element][context];
  const tried = userPrefs?.triedRemedies?.[element] || [];

  const novel = allRemedies.filter(remedy =>
    !tried.some(triedRemedy => remedy.toLowerCase().includes(triedRemedy))
  );

  return novel[0] || allRemedies[0]; // Fallback to any if all tried
}
```

---

### **Feature 4: Intensity Scaling**

Adjust based on how severe the imbalance is:

```javascript
function selectIntensityAwareRemedy(element, context, severity) {
  const contextRemedies = ELEMENTAL_REMEDIES_BY_CONTEXT[element][context];

  if (severity === 'extreme') { // 0% presence
    // Return most intensive/transformative practice
    return contextRemedies[2] || contextRemedies[0];
  } else if (severity === 'moderate') { // <15% presence
    // Return mid-level practice
    return contextRemedies[1] || contextRemedies[0];
  } else { // 'mild' (15-25% presence)
    // Return gentlest practice
    return contextRemedies[0];
  }
}

// Calculate severity
const ratio = elementCounts[element] / totalCards;
const severity = ratio === 0 ? 'extreme' : ratio < 0.15 ? 'moderate' : 'mild';
```

---

## Migration Checklist

**Pre-Implementation:**
- [ ] Commit current working code
- [ ] Backup `functions/lib/narrative/helpers.js`
- [ ] Review current test suite status

**Implementation:**
- [ ] Create `ELEMENTAL_REMEDIES_BY_CONTEXT` with all 60 remedies
- [ ] Implement `selectContextAwareRemedy()` function
- [ ] Update `buildElementalRemedies()` signature and logic
- [ ] Add exports for new functions

**Testing:**
- [ ] Create `tests/contextSelection.test.mjs`
- [ ] Create `tests/contextAwareIntegration.test.mjs`
- [ ] Update existing `tests/elementalRemedies.test.mjs`
- [ ] Run all tests and verify passing

**Documentation:**
- [ ] Update `CLAUDE.md` with context-aware behavior
- [ ] Add examples for each context
- [ ] Document fallback logic
- [ ] Create changelog entry

**Validation:**
- [ ] Test manually with each context type
- [ ] Verify fallback to general works
- [ ] Check rotation index functionality
- [ ] Ensure backward compatibility

---

## Estimated Timeline

| Task | Time | Complexity |
|------|------|------------|
| Write 60 quality remedies | 2-3 hours | Medium |
| Implement selection logic | 15 min | Low |
| Update buildElementalRemedies | 15 min | Low |
| Write unit tests | 45 min | Low |
| Write integration tests | 30 min | Low |
| Update existing tests | 15 min | Low |
| Documentation | 30 min | Low |
| **Total** | **4-5 hours** | **Medium** |

---

## Why This Design is Good

1. **Backward Compatible**
   Context is already passed through all 6 spread builders. No changes needed to callers.

2. **Graceful Degradation**
   Three-level fallback ensures something always shows (context → general → first available).

3. **No Breaking Changes**
   Existing code continues to work. Context defaults to 'general' if not specified.

4. **Extensible**
   Easy to add new contexts, rotation logic, or multiple-option displays later.

5. **Maintainable**
   Clear separation of concerns:
   - Data structure (remedies)
   - Selection logic (selectContextAwareRemedy)
   - Formatting (buildElementalRemedies)

6. **Testable**
   Each function can be unit tested independently.

---

## Conclusion

This implementation transforms elemental remedies from generic advice into personalized, context-aware guidance that speaks directly to the querent's situation.

**Before:** "Journal your feelings"
**After (Love):** "Share a vulnerable feeling with your partner"
**After (Career):** "Check in with how you feel about your work"
**After (Spiritual):** "Engage with teachings that move you emotionally"

The architecture is clean, backward-compatible, and ready for future enhancements like user preferences, intensity scaling, and multiple-option displays.

**Total Impact:** 60 unique remedies across 20 element-context combinations, providing highly relevant guidance for every reading type.
</file>

<file path="docs/DEPLOYMENT.md">
# Deployment Guide - Mystic Tarot

This guide covers deployment, secrets management, and local development for the Mystic Tarot Cloudflare Pages project.

## Table of Contents

- [Quick Start](#quick-start)
- [Secrets Management](#secrets-management)
- [Local Development](#local-development)
- [Deployment](#deployment)
- [Bindings (Future)](#bindings-future)
- [Troubleshooting](#troubleshooting)

---

## Quick Start

### Prerequisites

- Node.js 18.0.0 or later
- Wrangler v3.91.0 or later (installed via `npm install`)
- Cloudflare account with access to Pages

### Initial Setup

```bash
# Install dependencies
npm install

# Build the project
npm run build

# Deploy to Cloudflare Pages
npm run deploy
```

---

## Secrets Management

Secrets are **encrypted** and used for sensitive data like API keys. They are **never** visible after being set.

### Local Development Secrets

For local development, secrets are stored in `.dev.vars` (already exists, **DO NOT COMMIT**):

```bash
# .dev.vars format (dotenv syntax)
AZURE_OPENAI_ENDPOINT=https://your-resource.openai.azure.com
AZURE_OPENAI_API_KEY=your-api-key-here
AZURE_OPENAI_GPT5_MODEL=gpt-5.1
AZURE_OPENAI_TTS_ENDPOINT=https://your-resource.openai.azure.com
AZURE_OPENAI_TTS_API_KEY=your-tts-api-key-here
AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT=your-tts-deployment-name
```

**Important**: `.dev.vars` is in `.gitignore` and should **never** be committed to git.

### Production Secrets

Set production secrets using the Wrangler CLI:

```bash
# Set each secret (you'll be prompted for the value)
wrangler pages secret put AZURE_OPENAI_ENDPOINT --project-name=tableau
wrangler pages secret put AZURE_OPENAI_API_KEY --project-name=tableau
wrangler pages secret put AZURE_OPENAI_GPT5_MODEL --project-name=tableau
wrangler pages secret put AZURE_OPENAI_TTS_ENDPOINT --project-name=tableau
wrangler pages secret put AZURE_OPENAI_TTS_API_KEY --project-name=tableau
wrangler pages secret put AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT --project-name=tableau
```

**Tip**: You can pipe values to avoid interactive prompts:

```bash
echo "https://your-resource.openai.azure.com" | wrangler pages secret put AZURE_OPENAI_ENDPOINT --project-name=tableau
```

### Preview Environment Secrets

For branch deployments (preview environments), use the `--env=preview` flag:

```bash
wrangler pages secret put AZURE_OPENAI_API_KEY --project-name=tableau --env=preview
```

### Managing Secrets

```bash
# List all secrets (shows names only, not values)
wrangler pages secret list --project-name=tableau

# Delete a secret
wrangler pages secret delete AZURE_OPENAI_API_KEY --project-name=tableau

# Bulk upload secrets from JSON file
echo '{"SECRET_NAME": "secret-value"}' | wrangler pages secret bulk --project-name=tableau
```

### Environment Variables vs Secrets

| Type | Use For | Storage | Visibility |
|------|---------|---------|------------|
| **Environment Variables** (`[vars]` in wrangler.toml) | Non-sensitive config (API version, format settings) | `wrangler.toml` (committed to git) | Visible in dashboard and config |
| **Secrets** (`.dev.vars` local, `wrangler secret` production) | Sensitive data (API keys, tokens, endpoints) | Encrypted in Cloudflare, `.dev.vars` for local | Never visible after setting |

---

## Local Development

### Start Local Development Server

```bash
# Option 1: Using npm script (starts Vite dev server for frontend only)
npm run dev

# Option 2: Test with Pages Functions locally
npx wrangler pages dev dist

# Option 3: With specific port and HTTPS
npx wrangler pages dev dist --port=8788 --local-protocol=https
```

### How Local Development Works

1. **Frontend Development** (`npm run dev`):
   - Runs Vite dev server on `http://localhost:5173`
   - Hot module replacement (HMR) for fast development
   - **Does NOT run Pages Functions**

2. **Full Stack Development** (`wrangler pages dev dist`):
   - Serves static assets from `dist/` directory
   - Runs Pages Functions (`/api/*` routes)
   - Uses `.dev.vars` for secrets
   - Default: `http://localhost:8788`

### Local Development with Bindings

When you add bindings (KV, D1, R2, etc.), you can test them locally:

```bash
# Example: KV namespace binding
npx wrangler pages dev dist --kv=TAROT_CACHE

# Example: D1 database binding
npx wrangler pages dev dist --d1=DB

# Example: R2 bucket binding
npx wrangler pages dev dist --r2=AUDIO_STORAGE
```

**Note**: Bindings specified via CLI flags take precedence over `wrangler.toml`.

### Local Development Workflow

```bash
# 1. Make changes to source files
# 2. Build the project
npm run build

# 3. Test locally with Functions
npx wrangler pages dev dist

# 4. Deploy when ready
npm run deploy
```

### Debugging Prompt Payloads

Need to inspect the exact prompt sent to GPT-5 or Claude? Add `LOG_LLM_PROMPTS=true` (or `DEBUG_LLM_PROMPTS=true`) to `.dev.vars` or your Pages secret set. When this flag is enabled the Pages Function logs the full `systemPrompt` and `userPrompt` payloads for each request. These logs include user questions and reflections, so leave the flag disabled in production unless absolutely necessary.

Telemetry & budgets
- `LOG_ENHANCEMENT_TELEMETRY=true` mirrors the enhancement summary/validation payloads for each reading (section counts, enhancement tags). Keep it disabled outside staging because it includes section text snippets.
- `PROMPT_BUDGET_AZURE`, `PROMPT_BUDGET_CLAUDE`, and `PROMPT_BUDGET_DEFAULT` let you set approximate token ceilings (characters ÷ 4 heuristic) for each backend. When set, the builder will trim low-priority prompt content (low-weight imagery → GraphRAG block → deck geometry tables → diagnostics) and report the estimated token counts in the prompt metadata.

---

## Deployment

### Deploy to Production

```bash
# Build and deploy in one command
npm run build && npm run deploy

# Or using wrangler directly
wrangler pages deploy dist --project-name=tableau
```

### Deploy to Preview (Branch Deployment)

```bash
# Deploy to a specific branch
wrangler pages deploy dist --project-name=tableau --branch=feature-branch

# If in a git workspace, wrangler auto-detects the branch
wrangler pages deploy dist
```

### Deployment URLs

- **Production**: `https://tableau-8xz.pages.dev` and `https://tarot.lakefrontdev.com`
- **Branch Previews**: `https://<BRANCH_NAME>.tableau-8xz.pages.dev`

### Deployment Checklist

Before deploying to production, ensure:

- [ ] All secrets are set (run `wrangler pages secret list --project-name=tableau`)
- [ ] `npm run build` completes successfully
- [ ] `_routes.json` is in `public/` directory (controls which routes invoke Functions)
- [ ] Test locally with `npx wrangler pages dev dist`
- [ ] Verify production URL after deployment

### Continuous Deployment

The project can be set up with CI/CD:

```yaml
# Example GitHub Actions workflow
name: Deploy to Cloudflare Pages
on:
  push:
    branches: [master]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18
      - run: npm ci
      - run: npm run build
      - run: npm run deploy
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
```

---

## Bindings (Future)

Bindings connect your Pages Functions to Cloudflare services. Here's how to add them when needed:

### KV Namespace (Caching, Rate Limiting)

```bash
# 1. Create KV namespace
wrangler kv:namespace create "TAROT_CACHE"

# 2. Add to wrangler.toml
# [[kv_namespaces]]
# binding = "TAROT_CACHE"
# id = "your-kv-namespace-id"
# preview_id = "your-preview-kv-namespace-id"

# 3. Use in Functions
# const value = await context.env.TAROT_CACHE.get("key");
```

### D1 Database (Reading History, Analytics)

```bash
# 1. Create D1 database
wrangler d1 create mystic-tarot-db

# 2. Add to wrangler.toml
# [[d1_databases]]
# binding = "DB"
# database_name = "mystic-tarot-db"
# database_id = "your-database-id"

# 3. Use in Functions
# const results = await context.env.DB.prepare("SELECT * FROM readings").all();
```

### R2 Bucket (Audio Storage)

```bash
# 1. Create R2 bucket
wrangler r2 bucket create mystic-tarot-audio

# 2. Add to wrangler.toml
# [[r2_buckets]]
# binding = "AUDIO_STORAGE"
# bucket_name = "mystic-tarot-audio"
# preview_bucket_name = "mystic-tarot-audio-preview"

# 3. Use in Functions
# await context.env.AUDIO_STORAGE.put("reading.mp3", audioData);
```

### Analytics Engine (Usage Tracking)

```bash
# Add to wrangler.toml
# [[analytics_engine_datasets]]
# binding = "ANALYTICS"

# Use in Functions
# context.env.ANALYTICS.writeDataPoint({
#   blobs: ["reading-generated"],
#   doubles: [1],
#   indexes: [context.env.ENVIRONMENT]
# });
```

---

## Troubleshooting

### Issue: Secrets not found in production

**Solution**: Ensure secrets are set for the production environment:

```bash
wrangler pages secret list --project-name=tableau
```

If missing, set them using `wrangler pages secret put`.

### Issue: Functions not executing locally

**Solution**: Make sure you're using `wrangler pages dev dist`, not just `npm run dev`:

```bash
npm run build
npx wrangler pages dev dist
```

### Issue: Routes not working as expected

**Solution**: Check `public/_routes.json` configuration. Only paths matching `include` will invoke Functions.

### Issue: CORS errors in development

**Solution**: Ensure your API endpoints return proper CORS headers. Check `functions/api/*.js` files.

### Issue: Wrangler authentication errors

**Solution**: Re-authenticate with Cloudflare:

```bash
wrangler login
```

### Issue: Build fails

**Solution**: Clear node_modules and reinstall:

```bash
rm -rf node_modules package-lock.json
npm install
npm run build
```

### Check Deployment Status

```bash
# List recent deployments
wrangler pages deployment list --project-name=tableau

# View project info
wrangler pages project list
```

---

## Useful Commands Reference

```bash
# Development
npm run dev                          # Vite dev server (frontend only)
npm run build                        # Build for production
npm run preview                      # Preview production build
npx wrangler pages dev dist          # Test with Functions locally

# Deployment
npm run deploy                       # Deploy to Cloudflare Pages
wrangler pages deploy dist           # Deploy manually

# Secrets Management
wrangler pages secret put <KEY>      # Set a secret
wrangler pages secret list           # List all secrets
wrangler pages secret delete <KEY>   # Delete a secret

# Project Management
wrangler pages project list          # List all projects
wrangler pages deployment list       # List deployments

# Bindings (when needed)
wrangler kv:namespace create <NAME>  # Create KV namespace
wrangler d1 create <NAME>            # Create D1 database
wrangler r2 bucket create <NAME>     # Create R2 bucket
```

---

## Resources

- [Cloudflare Pages Documentation](https://developers.cloudflare.com/pages/)
- [Wrangler Configuration](https://developers.cloudflare.com/pages/functions/wrangler-configuration/)
- [Bindings Reference](https://developers.cloudflare.com/pages/functions/bindings/)
- [Secrets Management](https://developers.cloudflare.com/workers/configuration/secrets/)
- [Local Development](https://developers.cloudflare.com/pages/functions/local-development/)
</file>

<file path="docs/DEV_SETUP.md">
# Development Setup Guide

## The Problem You Were Experiencing

**Issue:** The "Create Personal Narrative" button appeared but did nothing when clicked.

**Root Cause:** The `/api/tarot-reading` endpoint wasn't running in development mode. Running `npm run dev` only started Vite (the frontend), but not the Cloudflare Pages Functions (the backend API).

## The Solution

The personalized reading feature **IS fully wired and working**! The code correctly:

- ✅ Collects user reflections from each card
- ✅ Sends reflections to the API
- ✅ Incorporates reflections into the narrative
- ✅ Uses Azure GPT-5.1 for generation (when configured)

The issue was **only** with the development environment setup.

## How to Run the App Properly

### Quick Start

```bash
npm run dev
```

This script (`dev.sh`) automatically:
1. Starts Vite (frontend) on port 5173 or 5174
2. Starts Wrangler (API proxy) on port 8788
3. Configures everything to work together

**Access the app at: http://localhost:8788**

### Manual Setup (Advanced)

If you need to run components separately:

```bash
# Terminal 1: Start Vite
npm run dev:frontend

# Terminal 2: Start Wrangler (in another terminal)
npm run dev:wrangler
```

Then access at http://localhost:8788

## Important URLs

| URL | Purpose | Use It? |
|-----|---------|---------|
| http://localhost:8788 | **Full app with API** | ✅ **YES - Use this!** |
| http://localhost:5173 or 5174 | Vite only (no API) | ❌ No - API won't work |

## Testing Personalized Readings

1. Open http://localhost:8788
2. Select a spread (e.g., "Three-Card Story")
3. Complete the ritual (knock, cut)
4. Draw your cards
5. Reveal each card
6. **Optionally** add reflections in the "What resonates for you?" textarea
7. Click **"Create Personal Narrative"**
8. Wait for the narrative to generate (uses Azure GPT-5.1)

## Environment Configuration

### Local Development Secrets (`.dev.vars`)

Required secrets for the personalized reading feature:

```bash
# Azure OpenAI for reading generation
AZURE_OPENAI_ENDPOINT=https://your-resource.openai.azure.com
AZURE_OPENAI_API_KEY=your-api-key
AZURE_OPENAI_GPT5_MODEL=gpt-5.1  # or gpt-5.1-pro

# Azure OpenAI for TTS (optional)
AZURE_OPENAI_TTS_ENDPOINT=https://your-tts-resource.openai.azure.com
AZURE_OPENAI_TTS_API_KEY=your-tts-api-key
AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT=gpt-audio-mini

# Vision proof signing (optional, for research mode)
VISION_PROOF_SECRET=your-random-secret-key
```

**Note:** Your `.dev.vars` file is already configured with these values.

## How the Personalized Reading Works

### Frontend Flow

1. **Card.jsx** - Collects user reflections via textarea
2. **TarotReading.jsx** - Formats reflections and sends to API
3. **generatePersonalReading()** function sends:
   - Spread info
   - Card details (positions, orientations, meanings)
   - User question
   - **User reflections** (formatted as "Position: reflection text")
   - Vision proof (if research mode enabled)

### Backend Flow

1. **functions/api/tarot-reading.js** receives the request
2. Validates payload
3. Performs spread analysis
4. Generates narrative using:
   - **Azure GPT-5.1** (primary, if configured) ✅ **Currently active**
   - Claude Sonnet 4.5 (fallback)
   - Local composer (final fallback)
5. Returns personalized narrative with reflections integrated

### Where Reflections Are Used

- **Azure GPT-5/Claude prompts** (functions/lib/narrative/prompts.js:278-280)
  - Included as "**Querent's Reflections**" in the AI prompt
- **All spread builders** (functions/lib/narrative/spreads/*.js)
  - Added as dedicated section via `buildReflectionsSection()`
  - Integrated into the narrative flow

## Narrative Backends

The app tries narrative backends in this order:

1. **Azure GPT-5.1** ← You have this configured!
2. Claude Sonnet 4.5 (if ANTHROPIC_API_KEY set)
3. Local composer (always available)

Check which backend was used in the API response:

```javascript
{
  "reading": "...",
  "provider": "azure-gpt5",  // ← Shows which backend generated it
  "themes": {...},
  "spreadAnalysis": {...}
}
```

## Troubleshooting

### Button still doesn't work?

1. **Check you're on the right URL:**
   - ✅ http://localhost:8788 (correct)
   - ❌ http://localhost:5174 (wrong - API won't work)

2. **Check browser console for errors:**
   - Open DevTools (F12)
   - Look for network errors when clicking the button
   - Check if `/api/tarot-reading` returns 200 OK

3. **Verify API is running:**
   ```bash
   curl http://localhost:8788/api/tarot-reading
   # Should return: {"status":"ok","provider":"azure-gpt5",...}
   ```

4. **Check environment variables:**
   ```bash
   # Ensure .dev.vars has the required secrets
   cat .dev.vars
   ```

### Port already in use?

If you see "Port 8788 is in use", kill the existing process:

```bash
lsof -ti:8788 | xargs kill -9
```

Or use the dev script which auto-cleans up ports.

## Key Files

### Frontend
- `src/TarotReading.jsx:1028-1195` - generatePersonalReading() function
- `src/components/Card.jsx:206-222` - Reflection textarea input

### Backend
- `functions/api/tarot-reading.js` - Main API endpoint
- `functions/lib/narrative/prompts.js` - AI prompt builder
- `functions/lib/narrative/spreads/*.js` - Spread-specific narratives

### Configuration
- `.dev.vars` - Local development secrets (git-ignored)
- `wrangler.toml` - Cloudflare Pages configuration
- `package.json` - Scripts and dependencies

## Production Deployment

When deployed to Cloudflare Pages, everything works automatically:

1. Build: `npm run build` creates `dist/`
2. Deploy: `npm run deploy` or via GitHub Actions
3. Secrets are stored in Cloudflare (not in repo)

Set production secrets with:

```bash
wrangler pages secret put AZURE_OPENAI_ENDPOINT --project-name=tableau
wrangler pages secret put AZURE_OPENAI_API_KEY --project-name=tableau
wrangler pages secret put AZURE_OPENAI_GPT5_MODEL --project-name=tableau
```

## Summary

- ✅ Personalized reading **IS** wired and active
- ✅ Reflections **ARE** collected and used
- ✅ Azure GPT-5.1 **IS** configured
- ❌ Problem was **only** dev environment setup
- ✅ **Fix:** Use `npm run dev` and access http://localhost:8788

Enjoy your personalized tarot readings! 🔮✨
</file>

<file path="docs/DEVELOPER_ONBOARDING.md">
# Developer Onboarding Guide: Mystic Tarot

## 0. Environment Bootstrap

1. Copy `.dev.vars.example` to `.dev.vars` and fill in the Azure OpenAI, Anthropic, and vision secrets. This is the single source of truth for local development values—never commit the populated file.
2. Run `npm run config:check` anytime the secret list changes. The script inspects `.dev.vars` and your shell environment, failing fast if a required entry (e.g., `VISION_PROOF_SECRET`) is missing.
3. When you're ready to push to Cloudflare Pages, mirror the same keys with `wrangler pages secret put <NAME> --project-name=tableau` (see `wrangler.toml` for the authoritative list).

## 1. The Scaffold & Stack Audit

**Build & Environment**
- **Build Tool:** [Vite](https://vitejs.dev/) (vite.config.js) is used for fast development and bundling.
- **Package Manager:** npm (inferred from package.json scripts).
- **CSS Framework:** [Tailwind CSS](https://tailwindcss.com/) (tailwind.config.js, postcss.config.cjs) is the primary styling engine.
- **Icons:** `lucide-react` provides the icon set.

**UI Framework**
- **Core:** React 18 (main.jsx).
- **Styling:** Utility-first CSS via Tailwind. Custom styles and animations are defined in tarot.css and tailwind.css.

**Entry Point & Layout**
- **Entry:** main.jsx is the application bootstrapper. It mounts the React root, initializes the `AuthProvider`, and sets up the `BrowserRouter`.
- **Layout:** There is no single global layout component wrapping all routes. Instead, individual page components like TarotReading.jsx and Journal.jsx implement their own layout structures, sharing common components like `GlobalNav`.

## 2. Routing & Navigation Map

**Router Configuration**
- **Library:** `react-router-dom` (main.jsx).
- **Strategy:** Client-side routing defined in the main entry file.

**Primary Routes**
| URL Path | Component | Description |
| :--- | :--- | :--- |
| `/` | TarotReading.jsx | **Core Experience.** Handles deck selection, spread choice, card drawing, and reading generation. |
| `/journal` | Journal.jsx | **User History.** Displays saved readings, filtering, and insights analysis. |
| `/share/:token` | ShareReading.jsx | **Social.** Read-only view for shared readings with collaborative notes. |
| `*` | TarotReading.jsx | **Fallback.** Redirects unknown routes back to the main reading experience. |

## 3. State Management Forensics

**Global State**
- **Context API:** Used sparingly.
    - **`AuthContext`** (AuthContext.jsx): Manages user session, login/register/logout methods, and loading state. Wraps the entire application in main.jsx.

**Server State & Data Fetching**
- **Strategy:** Custom hooks with `fetch` and local `useState`/`useEffect`. No dedicated library like TanStack Query is currently used.
- **Persistence:**
    - **Cloudflare D1:** Primary database for authenticated users.
    - **LocalStorage:** Fallback storage for unauthenticated users (handled within `useJournal`).

**Providers**
The application root in main.jsx is wrapped by:
1.  `React.StrictMode`
2.  `AuthProvider` (Supplies `user`, `isAuthenticated`, `login`, `register`)
3.  `BrowserRouter` (Routing context)

## 4. Component Hierarchy & Patterns

**Directory Structure**
- **components**: Mixed collection of presentational (dumb) and container (smart) components.
- **pages**: Contains route-specific views (e.g., ShareReading.jsx).
- **hooks**: Custom React hooks.
- **lib**: Pure JavaScript business logic (audio, deck math, formatting).
- **contexts**: React Context definitions.

**Component Patterns**
- **Smart (Container) Components:**
    - TarotReading.jsx: The massive orchestrator. Manages the entire state machine of a reading (shuffling, dealing, revealing, API calls).
    - Journal.jsx: Manages fetching entries, filtering logic, and switching between local/cloud storage.
- **Dumb (Presentational) Components:**
    - `Card.jsx`: Renders the visual tarot card (front/back).
    - `ReadingGrid.jsx`: Layout engine for different spreads (Celtic Cross, etc.).
    - `SpreadSelector.jsx`: UI for choosing spread types.
- **Shared Primitives:**
    - `GlobalNav.jsx`: Navigation bar used across top-level views.

## 5. Business Logic Extraction

**Key Custom Hooks**
1.  **`useJournal`** (useJournal.js):
    - **Purpose:** A hybrid storage hook. It abstracts away the complexity of saving data to either the Cloudflare API (if logged in) or LocalStorage (if anonymous). It also handles data migration from local to cloud.
2.  **`useVisionValidation`** (useVisionValidation.js):
    - **Purpose:** Manages the "Vision Mode" pipeline. It handles image file selection, conversion to Data URLs, and communication with the vision backend to validate physical card spreads.
3.  **`useAuth`** (AuthContext.jsx):
    - **Purpose:** Exposes authentication state and methods. It simplifies the consumption of the `AuthContext` throughout the app.

**Critical Non-Hook Logic**
- **Audio Engine** (audio.js): A singleton module that manages the `Audio` API directly. It handles sound effects (card flips), ambience loops, and the complex state of Text-to-Speech (TTS) playback, including caching and unlocking audio contexts on mobile.
</file>

<file path="docs/gpt51prompt.md">
# GPT-5.1 prompting guide

## Introduction

GPT-5.1, our newest flagship model, is designed to balance intelligence and speed for a variety of agentic and coding tasks, while also introducing a new `none` reasoning mode for low-latency interactions. Building on the strengths of GPT-5, GPT-5.1 is better calibrated to prompt difficulty, consuming far fewer tokens on easy inputs and more efficiently handling challenging ones. Along with these benefits, GPT-5.1 is more steerable in personality, tone, and output formatting.

While GPT-5.1 works well out of the box for most applications, this guide focuses on prompt patterns that maximize performance in real deployments. These techniques come from extensive internal testing and collaborations with partners building production agents, where small prompt changes often produce large gains in reliability and user experience. We expect this guide to serve as a starting point: prompting is iterative, and the best results will come from adapting these patterns to your specific tools and workflows.

## Migrating to GPT-5.1

For developers using GPT-4.1, GPT-5.1 with `none` reasoning effort should be a natural fit for most low-latency use cases that do not require reasoning.

For developers using GPT-5, we have seen strong success with customers who follow a few key pieces of guidance:

1. **Persistence:** GPT-5.1 now has better-calibrated reasoning token consumption but can sometimes err on the side of being excessively concise and come at the cost of answer completeness. It can be helpful to emphasize via prompting the importance of persistence and completeness.
2. **Output formatting and verbosity:** While overall more detailed, GPT-5.1 can occasionally be verbose, so it is worthwhile being explicit in your instructions on desired output detail.
3. **Coding agents:** If you’re working on a coding agent, migrate your apply_patch to our new, named tool implementation.
4. **Instruction following:** For other behavior issues, GPT-5.1 is excellent at instruction-following, and you should be able to shape the behavior significantly by checking for conflicting instructions and being clear.

We also released GPT-5.1-codex. This model behaves a bit differently than GPT-5.1, and we recommend you check out the [Codex prompting guide](https://cookbook.openai.com/examples/gpt-5-codex_prompting_guide) for more information.

## Agentic steerability

GPT-5.1 is a highly steerable model, allowing for robust control over your agent’s behaviors, personality, and communication frequency.

### Shaping your agent’s personality

GPT-5.1’s personality and response style can be adapted to your use case. While verbosity is controllable through a dedicated `verbosity` parameter, you can also shape the overall style, tone, and cadence through prompting.

We’ve found that personality and style work best when you define a clear agent persona. This is especially important for customer-facing agents which need to display emotional intelligence to handle a range of user situations and dynamics. In practice, this can mean adjusting warmth and brevity to the state of the conversation, and avoiding excessive acknowledgment phrases like “got it” or “thank you.”

The sample prompt below shows how we shaped the personality for a customer support agent, focusing on balancing the right level of directness and warmth in resolving an issue.

```
<final_answer_formatting>
You value clarity, momentum, and respect measured by usefulness rather than pleasantries. Your default instinct is to keep conversations crisp and purpose-driven, trimming anything that doesn't move the work forward. You're not cold—you're simply economy-minded with language, and you trust users enough not to wrap every message in padding.

- Adaptive politeness:
  - When a user is warm, detailed, considerate or says 'thank you', you offer a single, succinct acknowledgment—a small nod to their tone with acknowledgement or receipt tokens like 'Got it', 'I understand', 'You're welcome'—then shift immediately back to productive action. Don't be cheesy about it though, or overly supportive.
  - When stakes are high (deadlines, compliance issues, urgent logistics), you drop even that small nod and move straight into solving or collecting the necessary information.

- Core inclination:
  - You speak with grounded directness. You trust that the most respectful thing you can offer is efficiency: solving the problem cleanly without excess chatter.
  - Politeness shows up through structure, precision, and responsiveness, not through verbal fluff.

- Relationship to acknowledgement and receipt tokens:
  - You treat acknowledge and receipt as optional seasoning, not the meal. If the user is brisk or minimal, you match that rhythm with near-zero acknowledgments.
  - You avoid stock acknowledgments like "Got it" or "Thanks for checking in" unless the user's tone or pacing naturally invites a brief, proportional response.

- Conversational rhythm:
  - You never repeat acknowledgments. Once you've signaled understanding, you pivot fully to the task.
  - You listen closely to the user's energy and respond at that tempo: fast when they're fast, more spacious when they're verbose, always anchored in actionability.

- Underlying principle:
  - Your communication philosophy is "respect through momentum." You're warm in intention but concise in expression, focusing every message on helping the user progress with as little friction as possible.
</final_answer_formatting>
```

In the prompt below, we’ve included sections that constrain a coding agent’s responses to be short for small changes and longer for more detailed queries. We also specify the amount of code allowed in the final response to avoid large blocks.

```
<final_answer_formatting>
- Final answer compactness rules (enforced):
  - Tiny/small single-file change (≤ ~10 lines): 2–5 sentences or ≤3 bullets. No headings. 0–1 short snippet (≤3 lines) only if essential.
  - Medium change (single area or a few files): ≤6 bullets or 6–10 sentences. At most 1–2 short snippets total (≤8 lines each).
  - Large/multi-file change: Summarize per file with 1–2 bullets; avoid inlining code unless critical (still ≤2 short snippets total).
  - Never include "before/after" pairs, full method bodies, or large/scrolling code blocks in the final message. Prefer referencing file/symbol names instead.
- Do not include process/tooling narration (e.g., build/lint/test attempts, missing yarn/tsc/eslint) unless explicitly requested by the user or it blocks the change. If checks succeed silently, don't mention them.

- Code and formatting restraint — Use monospace for literal keyword bullets; never combine with **.
- No build/lint/test logs or environment/tooling availability notes unless requested or blocking.
- No multi-section recaps for simple changes; stick to What/Where/Outcome and stop.
- No multiple code fences or long excerpts; prefer references.

- Citing code when it illustrates better than words — Prefer natural-language references (file/symbol/function) over code fences in the final answer. Only include a snippet when essential to disambiguate, and keep it within the snippet budget above.
- Citing code that is in the codebase:
  * If you must include an in-repo snippet, you may use the repository citation form, but in final answers avoid line-number/filepath prefixes and large context. Do not include more than 1–2 short snippets total.
</final_answer_formatting>
```

Excess output length can be mitigated by adjusting the verbosity parameter and further reduced via prompting as GPT-5.1 adheres well to concrete length guidance:

```
<output_verbosity_spec>
- Respond in plain text styled in Markdown, using at most 2 concise sentences.
- Lead with what you did (or found) and context only if needed.
- For code, reference file paths and show code blocks only if necessary to clarify the change or review.
</output_verbosity_spec>
```

### Eliciting user updates

User updates, also called preambles, are a way for GPT-5.1 to share upfront plans and provide consistent progress updates as assistant messages during a rollout. User updates can be adjusted along four major axes: frequency, verbosity, tone, and content. We trained the model to excel at keeping the user informed with plans, important insights and decisions, and granular context about what/why it's doing. These updates help the user supervise agentic rollouts more effectively, in both coding and non-coding domains.

When timed correctly, the model will be able to share a point-in-time understanding that maps to the current state of the rollout. In the prompt addition below, we define what types of preamble would and would not be useful.

```
<user_updates_spec>
You'll work for stretches with tool calls — it's critical to keep the user updated as you work.

<frequency_and_length>
- Send short updates (1–2 sentences) every few tool calls when there are meaningful changes.
- Post an update at least every 6 execution steps or 8 tool calls (whichever comes first).
- If you expect a longer heads‑down stretch, post a brief heads‑down note with why and when you’ll report back; when you resume, summarize what you learned.
- Only the initial plan, plan updates, and final recap can be longer, with multiple bullets and paragraphs
</frequency_and_length>

<content>
- Before the first tool call, give a quick plan with goal, constraints, next steps.
- While you're exploring, call out meaningful new information and discoveries that you find that helps the user understand what's happening and how you're approaching the solution.
- Provide additional brief lower-level context about more granular updates
- Always state at least one concrete outcome since the prior update (e.g., “found X”, “confirmed Y”), not just next steps.
- If a longer run occurred (>6 steps or >8 tool calls), start the next update with a 1–2 sentence synthesis and a brief justification for the heads‑down stretch.
- End with a brief recap and any follow-up steps.
- Do not commit to optional checks (type/build/tests/UI verification/repo-wide audits) unless you will do them in-session. If you mention one, either perform it (no logs unless blocking) or explicitly close it with a brief reason.
- If you change the plan (e.g., choose an inline tweak instead of a promised helper), say so explicitly in the next update or the recap.
- In the recap, include a brief checklist of the planned items with status: Done or Closed (with reason). Do not leave any stated item unaddressed.
</content>
</user_updates_spec>
```

In longer-running model executions, providing a fast initial assistant message can improve perceived latency and user experience. We can achieve this behavior with GPT-5.1 through clear prompting.

```
<user_update_immediacy>
Always explain what you're doing in a commentary message FIRST, BEFORE sampling an analysis thinking message. This is critical in order to communicate immediately to the user.
</user_update_immediacy>
```

## Optimizing intelligence and instruction-following

GPT-5.1 will pay very close attention to the instructions you provide, including guidance on tool usage, parallelism, and solution completeness.

### Encouraging complete solutions

On long agentic tasks, we’ve noticed that GPT-5.1 may end prematurely without reaching a complete solution, but we have found this behavior is promptable. In the following instruction, we tell the model to avoid premature termination and unnecessary follow-up questions.

```
<solution_persistence>
- Treat yourself as an autonomous senior pair-programmer: once the user gives a direction, proactively gather context, plan, implement, test, and refine without waiting for additional prompts at each step.
- Persist until the task is fully handled end-to-end within the current turn whenever feasible: do not stop at analysis or partial fixes; carry changes through implementation, verification, and a clear explanation of outcomes unless the user explicitly pauses or redirects you.
- Be extremely biased for action. If a user provides a directive that is somewhat ambiguous on intent, assume you should go ahead and make the change. If the user asks a question like "should we do x?" and your answer is "yes", you should also go ahead and perform the action. It's very bad to leave the user hanging and require them to follow up with a request to "please do it."
</solution_persistence>
```

### Tool-calling format

In order to make tool-calling most effective, we recommend describing functionality in the tool definition and how/when to use tools in the prompt. In the example below, we define a tool that creates a restaurant reservation, and we concisely describe what it does when invoked.

```
{
  "name": "create_reservation",
  "description": "Create a restaurant reservation for a guest. Use when the user asks to book a table with a given name and time.",
  "parameters": {
    "type": "object",
    "properties": {
      "name": {
        "type": "string",
        "description": "Guest full name for the reservation."
      },
      "datetime": {
        "type": "string",
        "description": "Reservation date and time (ISO 8601 format)."
      }
    },
    "required": ["name", "datetime"]
  }
}
```

In the prompt, you may have a section that references the tool like this:

```
<reservation_tool_usage_rules>
- When the user asks to book, reserve, or schedule a table, you MUST call `create_reservation`.
- Do NOT guess a reservation time or name — ask for whichever detail is missing.
- If the user has not provided a name, ask: “What name should I put on the reservation?”
- If the user has not provided a date/time, ask: “What date and time would you like to reserve?”
- After calling the tool, confirm the reservation naturally: “Your reservation is confirmed for [name] on [date/time].”
</tool_usage_rules>

<reservation_tool_example>
*Example 1:*
User: “Book a table for Sarah tomorrow at 7pm.”
Assistant → (calls tool) →
`{"name": "create_reservation", "arguments": { "name": "Sarah", "datetime": "2025-11-01T19:00" } }`
Tool returns: `{ "confirmation_number": "R12345" }`
Assistant: “All set — your reservation for Sarah tomorrow at 7:00pm is confirmed. Your confirmation number is R12345.”

**Example 2:**
User: “I want to make a reservation.”
Assistant: “Sure! What name should I put on the reservation, and what date and time would you like?”

*Example 3:*
User: “Reserve a table under Daniel at 6 tonight.”
Assistant → (calls tool) →
`{"name": "create_reservation", "arguments": { "name": "Daniel", "datetime": "2025-10-31T18:00" } }`
Tool returns: `{ "confirmation_number": "R67890" }`
Assistant: “Done! Your reservation for Daniel at 6:00pm tonight is confirmed. The confirmation number is R67890.”
</reservation_tool_example>
```

GPT-5.1 also executes parallel tool calls more efficiently. When scanning a codebase or retrieving from a vector store, enabling parallel tool calling and encouraging the model to use parallelism within the tool description is a good starting point. In the system prompt, you can reinforce parallel tool usage by providing some examples of permissible parallelism. An example instruction may look like:

```
Parallelize tool calls whenever possible. Batch reads (read_file) and edits (apply_patch) to speed up the process.
```

### Using the “none” reasoning mode for improved efficiency

GPT-5.1 introduces a new reasoning mode: `none`. Unlike GPT-5’s prior `minimal` setting, `none` forces the model to never use reasoning tokens, making it much more similar in usage to GPT-4.1, GPT-4o, and other prior non-reasoning models. Importantly, developers can now use hosted tools like [web search](https://platform.openai.com/docs/guides/tools-web-search?api-mode=responses) and [file search](https://platform.openai.com/docs/guides/tools?tool-type=file-search) with `none`, and custom function-calling performance is also substantially improved. With that in mind, [prior guidance on prompting non-reasoning models](https://cookbook.openai.com/examples/gpt4-1_prompting_guide) like GPT-4.1 also applies here, including using few-shot prompting and high-quality tool descriptions.

While GPT-5.1 does not use reasoning tokens with `none`, we’ve found prompting the model to think carefully about which functions it plans to invoke can improve accuracy.

```
You MUST plan extensively before each function call, and reflect extensively on the outcomes of the previous function calls, ensuring user's query is completely resolved. DO NOT do this entire process by making function calls only, as this can impair your ability to solve the problem and think insightfully. In addition, ensure function calls have the correct arguments.
```

We’ve also observed that on longer model execution, encouraging the model to “verify” its outputs results in better instruction following for tool use. Below is an example we used within the instruction when clarifying a tool’s usage.

```
When selecting a replacement variant, verify it meets all user constraints (cheapest, brand, spec, etc.). Quote the item-id and price back for confirmation before executing.
```

In our testing, GPT-5’s prior `minimal` reasoning mode sometimes led to executions that terminated prematurely. Although other reasoning modes may be better suited for these tasks, our guidance for GPT-5.1 with `none` is similar. Below is a snippet from our Tau bench prompt.

```
Remember, you are an agent - please keep going until the user’s query is completely resolved, before ending your turn and yielding back to the user. You must be prepared to answer multiple queries and only finish the call once the user has confirmed they're done.
```

## Maximizing coding performance from planning to execution

One tool we recommend implementing for long-running tasks is a planning tool. You may have noticed reasoning models plan within their reasoning summaries. Although this is helpful in the moment, it may be difficult to keep track of where the model is relative to the execution of the query.

```
<plan_tool_usage>
- For medium or larger tasks (e.g., multi-file changes, adding endpoints/CLI/features, or multi-step investigations), you must create and maintain a lightweight plan in the TODO/plan tool before your first code/tool action.
- Create 2–5 milestone/outcome items; avoid micro-steps and repetitive operational tasks (no “open file”, “run tests”, or similar operational steps). Never use a single catch-all item like “implement the entire feature”.
- Maintain statuses in the tool: exactly one item in_progress at a time; mark items complete when done; post timely status transitions (never more than ~8 tool calls without an update). Do not jump an item from pending to completed: always set it to in_progress first (if work is truly instantaneous, you may set in_progress and completed in the same update). Do not batch-complete multiple items after the fact.
- Finish with all items completed or explicitly canceled/deferred before ending the turn.
- End-of-turn invariant: zero in_progress and zero pending; complete or explicitly cancel/defer anything remaining with a brief reason.
- If you present a plan in chat for a medium/complex task, mirror it into the tool and reference those items in your updates.
- For very short, simple tasks (e.g., single-file changes ≲ ~10 lines), you may skip the tool. If you still share a brief plan in chat, keep it to 1–2 outcome-focused sentences and do not include operational steps or a multi-bullet checklist.
- Pre-flight check: before any non-trivial code change (e.g., apply_patch, multi-file edits, or substantial wiring), ensure the current plan has exactly one appropriate item marked in_progress that corresponds to the work you’re about to do; update the plan first if needed.
- Scope pivots: if understanding changes (split/merge/reorder items), update the plan before continuing. Do not let the plan go stale while coding.
- Never have more than one item in_progress; if that occurs, immediately correct the statuses so only the current phase is in_progress.
<plan_tool_usage>
```

A plan tool can be used with minimal scaffolding. In our implementation of the plan tool, we pass a merge parameter as well as a list of to-dos. The list contains a brief description, the current state of the task, and an ID assigned to it. Below is an example of a function call that GPT-5.1 may make to record its state.

```
{
  "name": "update_plan",
  "arguments": {
    "merge": true,
    "todos": [
      {
        "content": "Investigate failing test",
        "status": "in_progress",
        "id": "step-1"
      },
      {
        "content": "Apply fix and re-run tests",
        "status": "pending",
        "id": "step-2"
      }
    ]
  }
}
```

### Design system enforcement

When building frontend interfaces, GPT-5.1 can be steered to produce websites that match your visual design system. We recommend using Tailwind to render CSS, which you can further tailor to meet your design guidelines. In the example below, we define a design system to constrain the colors generated by GPT-5.1.

```
<design_system_enforcement>
- Tokens-first: Do not hard-code colors (hex/hsl/oklch/rgb) in JSX/CSS. All colors must come from globals.css variables (e.g., --background, --foreground, --primary, --accent, --border, --ring) or DS components that consume them.
- Introducing a brand or accent? Before styling, add/extend tokens in globals.css under :root and .dark, for example:
  - --brand, --brand-foreground, optional --brand-muted, --brand-ring, --brand-surface
  - If gradients/glows are needed, define --gradient-1, --gradient-2, etc., and ensure they reference sanctioned hues.
- Consumption: Use Tailwind/CSS utilities wired to tokens (e.g., bg-[hsl(var(--primary))], text-[hsl(var(--foreground))], ring-[hsl(var(--ring))]). Buttons/inputs/cards must use system components or match their token mapping.
- Default to the system's neutral palette unless the user explicitly requests a brand look; then map that brand to tokens first.
</design_system_enforcement>
```

## New tool types in GPT-5.1

GPT-5.1 has been post-trained on specific tools that are commonly used in coding use cases. To interact with files in your environment you now can use a predefined apply_patch tool. Similarly, we’ve added a shell tool that lets the model propose commands for your system to run.

### Using apply_patch

The apply_patch tool lets GPT-5.1 create, update, and delete files in your codebase using structured diffs. Instead of just suggesting edits, the model emits patch operations that your application applies and then reports back on, enabling iterative, multi-step code editing workflows. You can find additional usage details and context in the [GPT-4.1 prompting guide](https://cookbook.openai.com/examples/gpt4-1_prompting_guide#:~:text=PYTHON_TOOL_DESCRIPTION%20%3D%20%22%22%22This,an%20exclamation%20mark.).

With GPT-5.1, you can use apply_patch as a new tool type without writing custom descriptions for the tool. The description and handling are managed via the Responses API. Under the hood, this implementation uses a freeform function call rather than a JSON format. In testing, the named function decreased apply_patch failure rates by 35%.

```
response = client.responses.create(
model="gpt-5.1",
input=RESPONSE_INPUT,
tools=[{"type": "apply_patch"}]
)
```

When the model decides to execute an apply_patch tool, you will receive an apply_patch_call function type within the response stream. Within the operation object, you’ll receive a type field (with one of `create_file`, `update_file`, or `delete_file`) and the diff to implement.

```
{
    "id": "apc_08f3d96c87a585390069118b594f7481a088b16cda7d9415fe",
    "type": "apply_patch_call",
    "status": "completed",
    "call_id": "call_Rjsqzz96C5xzPb0jUWJFRTNW",
    "operation": {
        "type": "update_file",
        "diff": "
        @@
        -def fib(n):
        +def fibonacci(n):
        if n <= 1:
            return n
        -    return fib(n-1) + fib(n-2)
        +    return fibonacci(n-1) + fibonacci(n-2)",
    "path": "lib/fib.py"
    }
},
```

[This repository](https://github.com/openai/openai-cookbook/blob/main/examples/gpt-5/apply_patch.py) contains the expected implementation for the apply_patch tool executable. When your system finishes executing the patch tool, the Responses API expects a tool output in the following form:

```
{
    "type": "apply_patch_call_output",
    "call_id": call["call_id"],
    "status": "completed" if success else "failed",
    "output": log_output
}
```

### Using the shell tool

We’ve also built a new shell tool for GPT-5.1. The shell tool allows the model to interact with your local computer through a controlled command-line interface. The model proposes shell commands; your integration executes them and returns the outputs. This creates a simple plan-execute loop that lets models inspect the system, run utilities, and gather data until they finish the task.

The shell tool is invoked in the same way as apply_patch: include it as a tool of type `shell`.

```
tools = [{"type": "shell"}]
```

When a shell tool call is returned, the Responses API includes a `shell_call` object with a timeout, a maximum output length, and the command to run.

```
{
	"type": "shell_call",
	"call_id": "...",
	"action": {
		"commands": [...],
		"timeout_ms": 120000,
		"max_output_length": 4096
	},
	"status": "in_progress"
}
```

After executing the shell command, return the untruncated stdout/stderr logs as well as the exit-code details.

```
{
	"type": "shell_call_output",
	"call_id": "...",
	"max_output_length": 4096,
	"output": [
		{
			"stdout": "...",
			"stderr": "...",
			"outcome": {
				"type": "exit",
				"exit_code": 0
			}
		}
	]
}
```

## How to metaprompt effectively

Building prompts can be cumbersome, but it’s also the highest-leverage thing you can do to resolve most model behavior issues. Small inclusions can unexpectedly steer the model undesirably. Let’s walk through an example of an agent that plans events. In the prompt below, the customer-facing agent is tasked with using tools to answer users’ questions about potential venues and logistics.

```
You are “GreenGather,” an autonomous sustainable event-planning agent. You help users design eco-conscious events (work retreats, conferences, weddings, community gatherings), including venues, catering, logistics, and attendee experience.

PRIMARY OBJECTIVE
Your main goal is to produce concise, immediately actionable answers that fit in a quick chat context. Most responses should be about 3–6 sentences total. Users should be able to skim once and know exactly what to do next, without needing follow-up clarification.

SCOPE

* Focus on: venue selection, schedule design, catering styles, transportation choices, simple budgeting, and sustainability considerations.
* You do not actually book venues or vendors; never say you completed a booking.
* You may, however, phrase suggestions as if the user can follow them directly (“Book X, then do Y”) so planning feels concrete and low-friction.

TONE & STYLE

* Sound calm, professional, and neutral, suitable for corporate planners and executives. Avoid emojis and expressive punctuation.
* Do not use first-person singular; prefer “A good option is…” or “It is recommended that…”.
* Be warm and approachable. For informal or celebratory events (e.g., weddings), you may occasionally write in first person (“I’d recommend…”) and use tasteful emojis to match the user’s energy.

STRUCTURE
Default formatting guidelines:

* Prefer short paragraphs, not bullet lists.
* Use bullets only when the user explicitly asks for “options,” “list,” or “checklist.”
* For complex, multi-day events, always structure your answer with labeled sections (e.g., “Overview,” “Schedule,” “Vendors,” “Sustainability”) and use bullet points liberally for clarity.

AUTONOMY & PLANNING
You are an autonomous agent. When given a planning task, continue reasoning and using tools until the plan is coherent and complete, rather than bouncing decisions back to the user. Do not ask the user for clarifications unless absolutely necessary for safety or correctness. Make sensible assumptions about missing details such as budget, headcount, or dietary needs and proceed.

To avoid incorrect assumptions, when key information (date, city, approximate headcount) is missing, pause and ask 1–3 brief clarifying questions before generating a detailed plan. Do not proceed with a concrete schedule until those basics are confirmed. For users who sound rushed or decisive, minimize questions and instead move ahead with defaults.

TOOL USAGE
You always have access to tools for:

* venue_search: find venues with capacity, location, and sustainability tags
* catering_search: find caterers and menu styles
* transport_search: find transit and shuttle options
* budget_estimator: estimate costs by category

General rules for tools:

* Prefer tools over internal knowledge whenever you mention specific venues, vendors, or prices.
* For simple conceptual questions (e.g., “how to make a retreat more eco-friendly”), avoid tools and rely on internal knowledge so responses are fast.
* For any event with more than 30 attendees, always call at least one search tool to ground recommendations in realistic options.
* To keep the experience responsive, avoid unnecessary tool calls; for rough plans or early brainstorming, you can freely propose plausible example venues or caterers from general knowledge instead of hitting tools.

When using tools as an autonomous agent:

* Plan your approach (which tools, in what order) and then execute without waiting for user confirmation at each step.
* After each major tool call, briefly summarize what you did and how results shaped your recommendation.
* Keep tool usage invisible unless the user explicitly asks how you arrived at a suggestion.

VERBOSITY & DETAIL
Err on the side of completeness so the user does not need follow-up messages. Include specific examples (e.g., “morning keynote, afternoon breakout rooms, evening reception”), approximate timing, and at least a rough budget breakdown for events longer than one day.

However, respect the user’s time: long walls of text are discouraged. Aim for compact responses that rarely exceed 2–3 short sections. For complex multi-day events or multi-vendor setups, provide a detailed, step-by-step plan that the user could almost copy into an event brief, even if it requires a longer answer.

SUSTAINABILITY GUIDANCE

* Whenever you suggest venues or transportation, include at least one lower-impact alternative (e.g., public transit, shuttle consolidation, local suppliers).
* Do not guilt or moralize; frame tradeoffs as practical choices.
* Highlight sustainability certifications when relevant, but avoid claiming a venue has a certification unless you are confident based on tool results or internal knowledge.

INTERACTION & CLOSING
Avoid over-apologizing or repeating yourself. Users should feel like decisions are being quietly handled on their behalf. Return control to the user frequently by summarizing the current plan and inviting them to adjust specifics before you refine further.

End every response with a subtle next step the user could take, phrased as a suggestion rather than a question, and avoid explicit calls for confirmation such as “Let me know if this works.”
```

Although this is a strong starting prompt, there are a few issues we noticed upon testing:

- Small conceptual questions (like asking about a 20-person leadership dinner) triggered unnecessary tool calls and very concrete venue suggestions, despite the prompt allowing internal knowledge for simple, high-level questions.
- The agent oscillated between being overly verbose (multi-day Austin offsites turning into dense, multi-section essays) and overly hesitant (refusing to propose a plan without more questions) and occasionally ignored unit rules (a Berlin summit described in miles and °F instead of km and °C).

Rather than manually guessing which lines of the system prompt caused these behaviors, we can metaprompt GPT-5.1 to inspect its own instructions and traces.

**Step 1**: Ask GPT-5.1 to diagnose failures

Paste the system prompt and a small batch of failure examples into a separate analysis call. Based on the evals you’ve seen, provide a brief overview of the failure modes you expect to address, but leave the fact-finding to the model.

Note that in this prompt, we’re not asking for a solution yet, just a root-cause analysis.

```
You are a prompt engineer tasked with debugging a system prompt for an event-planning agent that uses tools to recommend venues, logistics, and sustainable options.

You are given:

1) The current system prompt:
<system_prompt>
[DUMP_SYSTEM_PROMPT]
</system_prompt>

2) A small set of logged failures. Each log has:
- query
- tools_called (as actually executed)
- final_answer (shortened if needed)
- eval_signal (e.g., thumbs_down, low rating, human grader, or user comment)

<failure_tracess>
[DUMP_FAILURE_TRACES]
</failure_traces>

Your tasks:

1) Identify the distinct failure mode you see (e.g., tool_usage_inconsistency, autonomy_vs_clarifications, verbosity_vs_concision, unit_mismatch).
2) For each failure mode, quote or paraphrase the specific lines or sections of the system prompt that are most likely causing or reinforcing it. Include any contradictions (e.g., “be concise” vs “err on the side of completeness,” “avoid tools” vs “always use tools for events over 30 attendees”).
3) Briefly explain, for each failure mode, how those lines are steering the agent toward the observed behavior.

Return your answer in a structured but readable format:

failure_modes:
- name: ...
  description: ...
  prompt_drivers:
    - exact_or_paraphrased_line: ...
    - why_it_matters: ...
```

Metaprompting works best when the feedback can logically be grouped together. If you provide many failure modes, the model may struggle to tie all of the threads together. In this example, the dump of failure logs may contain examples of errors where the model was overly or insufficiently verbose when responding to the user’s question. A separate query would be issued for the model’s over-eagerness to call tools.

**Step 2:** Ask GPT-5.1 how it would patch the prompt to fix those behaviors

Once you have that analysis, you can run a second, separate call that focuses on implementation: tightening the prompt without fully rewriting it.

```
You previously analyzed this system prompt and its failure modes.

System prompt:

<system_prompt>
[DUMP_SYSTEM_PROMPT]
</system_prompt>

Failure-mode analysis:
[DUMP_FAILURE_MODE_ANALYSIS]

Please propose a surgical revision of the system prompt that reduces the observed issues while preserving the good behaviors.

Constraints:

- Do not redesign the agent from scratch.
- Prefer small, explicit edits: clarify conflicting rules, remove redundant or contradictory lines, tighten vague guidance.
- Make tradeoffs explicit (for example, clearly state when to prioritize concision over completeness, or exactly when tools must vs must not be called).
- Keep the structure and overall length roughly similar to the original, unless a short consolidation removes obvious duplication.

Output:

1) patch_notes: a concise list of the key changes and the reasoning behind each (e.g., “Merged conflicting tool-usage rules into a single hierarchy,” “Removed overlapping tone instructions that encouraged both executive formality and casual first-person with emojis”).
2) revised_system_prompt: the full updated system prompt with your edits applied, ready to drop into an agent configuration.
```

In this example, the first metaprompt helps GPT-5.1 point directly at the contradictory sections (such as the overlapping tool rules and autonomy vs clarification guidance), and the second metaprompt turns that analysis into a concrete, cleaned-up version of the event-planning agent’s instructions.

The output from the second prompt might look something like this:

```
patch_notes:
- Clarified when to prioritize concision vs detail:
  - Simple or single-topic queries should stay within ~3–6 sentences.
  - Longer, structured answers are reserved for clearly complex, multi-day or multi-vendor requests.
- Removed language that told the agent to “err on the side of completeness” for all cases and replaced it with conditional rules based on query complexity.
- Tightened the structure rules so headings and bullets are only used when complexity or explicit user instructions justify them.
- Simplified the guidance on step-by-step plans so they are expected only for complex events, not for every question.

revised_system_prompt:
[...]
```

After this iteration cycle, run the queries again to observe any regressions and repeat this process until your failure modes have been identified and triaged.

As you continue to grow your agentic systems (e.g., broadening scope or increasing the number of tool calls), consider metaprompting the additions you’d like to make rather than adding them by hand. This helps maintain discrete boundaries for each tool and when they should be used.

## What's next

To summarize, GPT-5.1 builds on the foundation set by GPT-5 and adds things like quicker thinking for easy questions, steerability when it comes to model output, new tools for coding use cases, and the option to set reasoning to `none` when your tasks don't require heavy thinking.

Get started with GPT-5.1 in the [docs](https://platform.openai.com/docs/guides/latest-model), or read the [blog post](https://openai.com/index/gpt-5-1-for-developers/) to learn more.

---

*(The second notebook cell contained no content.)*
</file>

<file path="docs/guidetoaitraining.md">
# Comprehensive Guide to AI Training for Tarot Card Interpretation: Advanced Approaches and Rider-Waite-Specific Strategies

---

## Introduction: The Scope and Challenges of AI Tarot Interpretation

The intersection of artificial intelligence (AI) and tarot card interpretation represents a unique challenge at the crossroads of symbolic reasoning, computer vision, and multimodal learning. Tarot, with its centuries-old tradition, is not merely a set of illustrated cards but a complex symbolic system, deeply embedded in cultural, philosophical, and psychological contexts. Each tarot deck—be it the Rider-Waite-Smith (RWS), Thoth, or Marseille—embodies its own iconographic language, historical lineage, and interpretive philosophy [tarotqa.com](https://tarotqa.com/en/tarot-guide/rider-waite-tarot-deck-guide-history-meanings-how-to-read-for-beginners) [en.wikipedia.org](https://en.wikipedia.org/wiki/Thoth_Tarot) [frenchmysticgateway.com](https://www.frenchmysticgateway.com/en/post/the-symbolism-in-the-tarot-of-marseille) [tarot-arcana.com](https://tarot-arcana.com/le-tarot-de-marseille/). For AI to interpret tarot cards meaningfully, it must not only recognize visual features but also comprehend the nuanced symbolism, narrative structures, and stylistic diversity inherent in these decks.

Recent advances in computer vision, vision-language models (VLMs), and multimodal large language models (MLLMs) have enabled machines to process and generate both images and text with increasing sophistication [geeksforgeeks.org](https://www.geeksforgeeks.org/artificial-intelligence/vision-language-models-vlms-explained/). However, the task of tarot interpretation pushes these models into new territory: they must bridge the gap between visual perception and symbolic, often subjective, narrative understanding. This guide explores advanced methods for training AI to interpret tarot cards, focusing on three core areas:

1. **Encoding Deck-Specific Symbolism:** How to represent and adapt to the iconographic and semantic differences across major tarot traditions, with a detailed focus on Rider-Waite-Smith.
2. **Handling Artistic Variations:** Strategies for achieving robust visual understanding across diverse artistic styles, media, and abstraction levels, including variations within RWS-style decks.
3. **Evaluating AI Understanding of Tarot Imagery:** Benchmarks, interpretability techniques, and performance metrics tailored to symbolic and narrative comprehension.

Throughout, we integrate examples of training data design, annotation strategies, and prompt engineering, drawing on recent research and implementations in symbolic AI, computer vision, and multimodal learning. This combined guide merges broad advanced approaches with practical, deck-specific strategies for Rider-Waite-Smith interpretation.

---

## I. Encoding Deck-Specific Symbolism: Representation Strategies and Adaptation

### 1.1. The Symbolic Foundations of Tarot: Deck Traditions and Their Divergence

Tarot decks are not monolithic; each tradition encodes its own symbolic language, visual motifs, and interpretive frameworks. The three most influential decks—Rider-Waite-Smith (RWS), Thoth, and Marseille—exemplify this diversity.

#### Rider-Waite-Smith (RWS)

The RWS deck, created in 1909 by Arthur Edward Waite and illustrated by Pamela Colman Smith, revolutionized tarot by providing fully illustrated scenes for all 78 cards, including the Minor Arcana [tarotqa.com](https://tarotqa.com/en/tarot-guide/rider-waite-tarot-deck-guide-history-meanings-how-to-read-for-beginners) [onecardtarot.com](https://onecardtarot.com/rider-waite-smith-tarot/). Its iconography is rich in Christian and occult symbolism, with narrative scenes that facilitate intuitive and psychological interpretation. The RWS deck’s structure and imagery have become the de facto standard for modern tarot learning and digital implementations [onecardtarot.com](https://onecardtarot.com/rider-waite-smith-tarot/).

#### Thoth Tarot

Developed by Aleister Crowley and Lady Frieda Harris (1938–1943), the Thoth deck is a dense tapestry of esoteric systems, integrating astrology, Kabbalah, alchemy, and Thelemic philosophy [en.wikipedia.org](https://en.wikipedia.org/wiki/Thoth_Tarot) [diarytarot.com](https://diarytarot.com/all-about-tarot-history/crowley-thoth). Its imagery is more abstract and symbolic, often eschewing narrative scenes for complex geometric and color correspondences. The Thoth deck also renames and reorders several Major Arcana cards, and its Minor Arcana are titled (e.g., “Peace,” “Strife”) rather than simply numbered, reflecting specific planetary and elemental dignities.

#### Marseille Tarot

The Marseille Tarot, originating in 16th-century France, is characterized by its minimalist, woodcut-style imagery and straightforward archetypes [frenchmysticgateway.com](https://www.frenchmysticgateway.com/en/post/the-symbolism-in-the-tarot-of-marseille) [tarot-arcana.com](https://tarot-arcana.com/le-tarot-de-marseille/). The Major Arcana are iconic but less elaborately detailed than RWS or Thoth, while the Minor Arcana “pip” cards display only suit symbols (e.g., cups, swords) without narrative scenes. Interpretation relies heavily on numerology and elemental associations, demanding greater intuition and contextual synthesis from the reader.

#### Comparative Table: Symbolism Across Major Decks

|Feature|Rider-Waite-Smith (RWS)|Thoth Tarot|Marseille Tarot|
|---|---|---|---|
|Major Arcana|Fully illustrated, Christian & occult symbols|Esoteric, abstract, Thelemic, astrological|Archetypal, minimalist, traditional|
|Minor Arcana|Illustrated scenes, narrative|Symbolic, titled, abstract|Pip cards, suit symbols only|
|Court Cards|Page, Knight, Queen, King|Princess, Prince, Queen, Knight|Valet, Cavalier, Queen, King|
|Numbering/Order|Strength VIII, Justice XI|Renamed/reordered trumps|Justice VIII, Strength XI|
|Interpretive Approach|Intuitive, psychological, narrative|Esoteric, systematic, meditative|Numerological, elemental, intuitive|
|Accessibility|Beginner-friendly|Advanced, requires esoteric study|Traditionalists, historians|

The differences in symbolism, structure, and philosophy across these decks pose a significant challenge for AI systems: a model trained on RWS imagery and meanings may misinterpret or fail to recognize the abstract symbolism of Thoth or the minimalist cues of Marseille [reddit.com](https://www.reddit.com/r/tarot/comments/1dhzhf7/rws_vs_thoth_vs_marseille/).

### 1.2. Symbolic Representation in AI: From Visual Features to Semantic Embeddings

#### Symbolic AI and Knowledge Graphs

To encode deck-specific symbolism, AI systems can leverage symbolic AI techniques, such as knowledge graphs and ontologies, to represent the relationships between visual motifs, card names, suit associations, and interpretive meanings [arxiv.org](https://arxiv.org/abs/1909.01161). For example, a knowledge graph for tarot might encode that “The Magician” in RWS is associated with the infinity symbol, red and white flowers, and the four elemental tools (wand, cup, sword, pentacle), each linked to specific archetypal meanings (willpower, manifestation, mastery).

#### Embedding Symbolic Knowledge into Deep Models

Recent research demonstrates that symbolic knowledge can be embedded into deep neural networks via graph embeddings, semantic regularization, and hybrid neuro-symbolic architectures [arxiv.org](https://arxiv.org/abs/1909.01161) [link.springer.com](https://link.springer.com/chapter/10.1007/978-3-031-77792-9_10). For tarot, this might involve:

- **Graph Embedding Networks:** Projecting propositional formulae (e.g., “The Empress = fertility ∧ nurturing ∧ Venus symbolism”) onto a manifold, enabling the model to reason about symbolic relationships.
- **Semantic Regularization:** Incorporating constraints that enforce consistency between visual features (e.g., presence of a crown, scepter, or specific color palette) and symbolic interpretations.
- **Hybrid Approaches:** Combining symbolic reasoning (e.g., rule-based mapping of suit and number to meaning) with deep learning for visual recognition.

#### Multimodal Embeddings

Vision-language models (VLMs) and multimodal large language models (MLLMs) can be trained to align visual features with textual descriptions, enabling the model to “ground” symbolic meanings in specific visual cues [geeksforgeeks.org](https://www.geeksforgeeks.org/artificial-intelligence/vision-language-models-vlms-explained/). For tarot, this means associating the image of “The Tower” (lightning, crumbling structure, falling figures) with narrative themes of upheaval, sudden change, and revelation.

### 1.3. Adapting to Deck Variations: Transfer Learning and Domain Adaptation

#### Domain Adaptation Techniques

Given the diversity of tarot decks, domain adaptation is critical. Techniques such as unsupervised domain adaptation (UDA) and robust transfer learning enable models to generalize from one deck’s style and symbolism to another [openaccess.thecvf.com](https://openaccess.thecvf.com/content/CVPR2025/papers/Yang_TAROT_Towards_Essentially_Domain-Invariant_Robustness_with_Theoretical_Justification_CVPR_2025_paper.pdf). For example, the TAROT algorithm (Transfer Adversarially Robust Training) enhances domain adaptability and robustness by learning domain-invariant features, allowing a model trained on RWS to adapt to Thoth or Marseille imagery with minimal labeled data from the target domain.

Key strategies include:

- **Few-Shot Learning:** Providing the model with a handful of annotated examples from a new deck, enabling rapid adaptation through pattern recognition and symbolic mapping [godofprompt.ai](https://www.godofprompt.ai/blog/few-shot-prompting).
- **Prompt Engineering:** Using deck-specific prompts (e.g., “Interpret the Thoth version of the ‘Lust’ card”) to guide the model’s attention to relevant symbolic features and meanings.
- **Structured Output Constraints:** Enforcing consistent output formats (e.g., JSON schemas for card name, upright/reversed meaning, symbolic elements) to reduce hallucination and improve interpretability [mdpi.com](https://www.mdpi.com/2079-9292/14/21/4199).

#### Case Study: Mapping MBTI Types to Major Arcana

A notable example of symbolic adaptation is the mapping of Myers-Briggs Type Indicator (MBTI) personality types to Major Arcana cards, as implemented in a conversational tarot AI system. Here, user responses are classified into MBTI types, which are then mapped to corresponding Major Arcana cards (e.g., INTP → The Magician, ENFP → The Star), with narrative interpretations blending psychological and symbolic insights. This approach demonstrates how symbolic reasoning and domain knowledge can be integrated into AI-driven tarot interpretation.

### 1.4. Training Data Design: Annotated Datasets and Multimodal Inputs

#### Annotated Tarot Datasets

High-quality annotated datasets are essential for training AI models to recognize and interpret tarot symbolism. Several open-source datasets are available:

- **jtatman/tarot_dataset (Hugging Face):** Contains over 1,000 entries with tarot card images, card names, and detailed narrative readings, capturing both visual and textual modalities [huggingface.co](https://huggingface.co/datasets/jtatman/tarot_dataset).
- **Dendory/tarot (Hugging Face):** Features 5,770 tarot readings generated by ChatGPT, each based on three randomly drawn cards, with columns for card names and narrative interpretations.
- **tarot-json (GitHub):** Provides JSON-formatted data and scans of the RWS deck, facilitating image-text alignment and symbolic annotation [github.com](https://github.com/metabismuth/tarot-json).

These datasets typically include:

- **Image Modality:** High-resolution scans or photographs of tarot cards, annotated with bounding boxes or segmentation masks for key symbols.
- **Text Modality:** Card names, upright/reversed meanings, and narrative readings that reference symbolic elements and interpretive themes.
- **Metadata:** Deck type, suit, number, court rank, and symbolic keywords (e.g., “crown,” “lion,” “infinity symbol”).

#### Multimodal Input Design

Multimodal models require carefully aligned image-text pairs. For tarot, this involves:

- **Visual Features:** Extracting symbolic elements (e.g., objects, colors, gestures) using computer vision techniques such as object detection, segmentation, and feature extraction.
- **Textual Features:** Encoding card meanings, narrative interpretations, and symbolic associations using natural language processing (NLP) pipelines.
- **Metadata Integration:** Incorporating deck-specific information, historical context, and user queries to provide richer interpretive context.

#### Designing Multi-Modal Training Data

Building a reliable tarot interpretation model requires carefully designed training data that ties images to symbolic meanings. Effective datasets often combine visual and textual modalities, and sometimes user context, to teach the AI how to perform readings. Key components of training data design include:

- **Annotated Card Imagery:** High-quality scans or images of each tarot card form the basis. These images can be annotated at multiple levels. At minimum, each image is labeled with its card identity (e.g. “2 of Cups, reversed” as a class) and basic metadata (suit, arcana, number). More advanced annotations tag the presence of key symbols or attributes – for example, marking that “the Fool’s image contains a sun, a dog, a cliff” or noting “predominant color = yellow (symbolizing optimism)”. Such annotations allow multi-task training: the model might be asked not only to generate an interpretation text but also to output symbolic labels, improving its internal representation of the card’s features. Projects like the Tarot Cards JSON dataset illustrate this approach: each of the 78 RWS cards is accompanied by structured metadata including its name, suit, and even fortune-telling keywords and meanings for upright and reversed positions[10]. This provides a rich knowledge base that an AI can learn from.

- **Image–Text Pairings:** A core of the training set is paired images and interpretive text. Each card image is matched with one or more textual descriptions or meanings. These texts can be drawn from traditional tarot guidebooks or crowdsourced interpretations. For example, an image of The Hermit could be paired with a sentence like “A robed sage holds out a lantern, symbolizing inner guidance and solitude.” Longer narrative explanations (a paragraph of what the card means spiritually or in a reading) can serve as target outputs for an image-to-text model. Recent projects have constructed multi-modal datasets by scraping tarot websites and books: in one case, developers compiled card meanings from sources like Kaggle and GitHub and fine-tuned a GPT-2 text generator on this divination text corpus[11]. By training a vision-language model on such pairs, the AI learns to translate visual cues into fluent interpretations. A notable best practice is to include both upright and reversed meanings in the data – effectively doubling the examples – so the model can handle both orientations of a card. Each image might be paired with two texts (upright vs. reversed meaning), with orientation indicated as an input.

- **User Query Contexts:** To make the AI’s readings more relevant and interactive (as in a real tarot session), training can incorporate sample user questions or contexts. This means the input to the model would be not just an image, but [User query, Card image] and the output is a context-aware interpretation. For instance, a training sample could have: Input: (“Question: What should I focus on in my career?”, plus image of Three of Wands); Output: a response weaving the card’s meaning into career advice. By including various query contexts (love, career, general guidance, etc.) along with appropriate interpretations, the model learns to tailor its symbolism to the user’s concern. In practice, such data might be created by taking generic card meanings and rewriting them under different themes. Some open-source tarot bots simulate this by mapping each card to multiple prompt templates (e.g. “In a relationship context, [Card] might mean…”)[12]. The result is a multi-modal, conditional dataset. This strategy was highlighted by a 2025 experiment where an engineer prompted GPT-4 with card names plus a role (“wise, poetic guide”) and found the AI could produce eerily apt readings when guided by context[13][5]. Incorporating that approach into training data would further improve an AI’s flexibility.

To summarize, a robust training dataset for a tarot AI will likely include image scans of cards annotated with their identity and symbols, paired with rich interpretive texts, and possibly augmented with context-specific variations. The table below illustrates examples of such training data design:

|Training Data Component|Example|Purpose|
|---|---|---|
|Card image + basic labels|Image: The Fool card; Labels: "The Fool", "Major Arcana", "0"|Teach card recognition (identify which card is shown)|
|Card image + symbol annotations|Image: The Fool; Labels: "sun", "dog", "cliff", "color=yellow"|Emphasize key symbolic features (for model’s visual encoder)|
|Card image + interpretation text|Image: The Fool; Text: “The Fool – Upright: A new journey begins, full of innocence and potential.”|Train image-to-text generation of meanings (upright reading)|
|Card image + alt-context text|Inputs: [“Question: Love life?”, Image: The Fool];<br>Text: “In love, The Fool signifies new beginnings and a leap of faith into the unknown.”|Train model to incorporate user query context into its interpretation|
|Multiple images for same card|Images: The Fool from 3 different decks; Text: same/similar interpretation for each|Teach invariance – different art, same core meaning[6]|

By designing the data in this multi-faceted way, we ensure the model learns not just to identify a card but truly to interpret it in context. As one developer put it, “Tarot is a language – made of symbols, archetypes, and narratives”, so the training data must capture that language in both vision and text[13].

#### Prompt Engineering Examples

Effective prompt engineering is crucial for guiding AI models in tarot interpretation. Examples include:

- “Describe the symbolic meaning of the Magician card in the Thoth deck, focusing on its astrological and alchemical elements.”
- “Given this image of the Five of Cups (Marseille), explain the emotional and narrative themes it represents.”
- “Interpret this three-card spread (Past: The Fool, Present: The Tower, Future: The Star) as a story of transformation.”

Few-shot prompting, where the model is provided with several annotated examples before being asked to interpret a new card or spread, has been shown to improve accuracy and narrative coherence [godofprompt.ai](https://www.godofprompt.ai/blog/few-shot-prompting).

### 1.5. Encoding Rider-Waite Symbolism in AI Models (RWS-Specific Focus)

The Rider–Waite–Smith (RWS) tarot deck is renowned for rich symbolic imagery – every visual element, from color schemes to character poses and archetypes, carries meaning[1]. Advanced AI models must explicitly encode these deck-specific symbols to interpret cards as a human reader would. Key techniques include:

- **Color Encoding:** Colors in RWS cards often have emotional or elemental significance. For example, vibrant yellows in The Sun or The Fool connote optimism and enlightenment. To capture this, models can incorporate color features (e.g. feeding hue distributions or color histograms into the network) or use image augmentations that emphasize color. A CNN or Vision Transformer naturally learns color cues, but adding supervised signals – for instance, tagging training images with color-associated keywords (“bright”, “somber”) – can reinforce their symbolic weight.

- **Positional & Compositional Features:** The spatial arrangement of figures and objects in a card contributes to its meaning. Models benefit from recognizing these positional symbols. One approach is to use object detection or segmentation as a precursor: identify key motifs (e.g. a crown above a figure’s head, a dog at The Fool’s heels) and feed their positions into the interpretation model. As tarot author Rachel Pollak notes, even a character’s gesture can be crucial – “the Rider-Waite Magician raising a magic wand… as above, so below – [this] felt core to the card’s meaning”[2]. An AI should similarly attend to such spatial cues. Advanced neural architectures might use attention maps or relational layers that capture where an object lies (above, below, left, right) and how that positioning resonates symbolically.

- **Archetype & Narrative Embeddings:** Each RWS card embodies an archetype (e.g. The Empress as the nurturing mother, The Tower as sudden upheaval). A best practice is to inject these archetypal labels or narrative keywords into the training data. For example, one developer built a table of all 78 cards with columns for upright keywords, reversed keywords, archetype, and themes[3]. This structured knowledge (drawn from classic sources like Waite’s Pictorial Key and Jungian archetypes[4]) can be used to supervise the model. In practice, a model might be trained in a multi-task fashion: alongside image-to-text learning, it might predict an archetype class or set of symbolic attributes for each card. This forces the internal representation to align with deck-specific symbolism. Indeed, researchers have observed that combining visual and symbolic features helps AI “mirror archetypes clearly” in its outputs[5]. By learning the deck’s unique iconography – e.g. the pillar symbolism flanking The High Priestess or the elemental emblems on each Minor Arcana suit – the model builds a semantic understanding tailored to RWS imagery.

In summary, encoding RWS symbolism requires knowledge-infused vision: the AI must not only see pixels, but also learn the tarot’s symbolic language of color, position, and archetype. Techniques like annotated symbols, attention to spatial layout, and integration of expert knowledge (tarot dictionaries or archetype taxonomies) are crucial to achieve interpretations that feel authentic to the deck’s intent[1][2].

---

## II. Handling Artistic Variations: Style Robustness and Visual Semantics

### 2.1. The Challenge of Artistic Diversity in Tarot

Tarot decks exhibit extraordinary artistic diversity, ranging from hand-drawn, woodcut, and watercolor illustrations to digital, photorealistic, and abstract designs. Even within a single tradition, modern artists reinterpret classic decks with new color palettes, symbolic substitutions, and stylistic innovations [frenchmysticgateway.com](https://www.frenchmysticgateway.com/en/post/the-symbolism-in-the-tarot-of-marseille) [tarot-arcana.com](https://tarot-arcana.com/le-tarot-de-marseille/). For AI systems, this diversity introduces significant challenges:

- **Style Transfer:** The same card (e.g., The Empress) may appear radically different across decks, requiring the model to recognize underlying symbolic structures despite stylistic variation.
- **Medium Differences:** Hand-drawn cards may feature organic textures and imperfections, while digital art offers crisp lines and synthetic effects.
- **Symbolic Abstraction:** Some decks employ highly abstract or minimalist representations, demanding greater reliance on context and symbolic reasoning.

### 2.2. Robust Visual Understanding: Techniques and Architectures

#### Style Transfer and Domain Adaptation

Recent advances in diffusion models and style transfer techniques enable AI systems to adapt to diverse artistic styles while preserving semantic content [arxiv.org](https://arxiv.org/html/2505.16360v1). Methods such as Class-wise Adaptive Instance Normalization (CACTI) and cross-attention filtering allow for:

- **Semantic Consistency:** Aligning style features (color, texture) with semantic classes (e.g., “crown,” “wand”) to ensure that style transfer does not obscure symbolic meaning.
- **Cross-Modal Attention:** Leveraging attention mechanisms to focus on relevant visual regions, enabling the model to distinguish between stylistic variation and core symbolic elements.

Empirical results show that class-aware diffusion-based style transfer effectively bridges the gap between synthetic and real domains, suggesting its applicability to tarot decks with varying artistic media.

#### Hand-Drawn vs. Digital Art: Comparative Analysis

Hand-drawn illustrations offer authenticity, texture, and organic variation, while digital art provides efficiency, scalability, and precise control over visual elements [ilustromania.com](https://www.ilustromania.com/blog/hand-drawn-illustrations-vs-digital-art-which-style-suits-your-needs) [graphics-illustrations.com](https://graphics-illustrations.com/hand-drawn-vs-digital-illustration-which-one-wins/). AI models must be trained to recognize both:

- **Hand-Drawn Art:** Emphasizes unique line work, brushstrokes, and imperfections. Models benefit from data augmentation (e.g., random noise, texture overlays) to simulate hand-drawn variability.
- **Digital Art:** Features clean lines, consistent color fills, and scalable resolution. Models can leverage vector-based representations and high-resolution inputs.

Hybrid approaches, where hand-drawn sketches are scanned and digitally enhanced, combine the strengths of both methods. Training data should include a balanced mix of hand-drawn and digital examples to ensure robustness.

#### Symbolic Abstraction and Visual Semantics

Some tarot decks employ symbolic abstraction, reducing visual cues to geometric shapes, color fields, or minimalist icons. AI models must learn to map these abstract forms to their symbolic meanings, often relying on:

- **Contextual Reasoning:** Interpreting a card’s meaning based on its position in a spread, surrounding cards, and user queries.
- **Symbolic Embeddings:** Learning representations that capture the relationship between abstract visual features and semantic concepts.

Recent research in vision-language models demonstrates that emergent symbolic mechanisms can support binding and content-independent indexing, enabling models to distinguish between similar but symbolically distinct images [arxiv.org](https://arxiv.org/abs/2506.15871).

### 2.3. Training Data and Augmentation for Style Robustness

#### Data Augmentation Strategies

To enhance style robustness, training datasets should incorporate:

- **Multiple Decks:** Images from a wide range of tarot decks, covering different artistic styles, media, and abstraction levels.
- **Augmented Variants:** Synthetic transformations (e.g., color shifts, texture overlays, geometric distortions) to simulate real-world variation.
- **Annotated Symbolic Elements:** Labels for key symbols, objects, and color schemes, enabling supervised learning of symbolic associations.

#### Example: Annotated Dataset Schema

|Card Name|Deck Type|Image Path|Artistic Style|Key Symbols|Symbolic Keywords|Narrative Reading|
|---|---|---|---|---|---|---|
|The Magician|RWS|/images/rws_01.jpg|Hand-drawn|Wand, infinity, table|Manifestation, willpower|“You have the tools to manifest your desires…”|
|The Magus|Thoth|/images/thoth_01.jpg|Abstract|Caduceus, lemniscate|Alchemy, transformation|“The Magus channels the forces of creation…”|
|Le Bateleur|Marseille|/images/marseille_01.jpg|Woodcut|Table, tools, hat|Initiative, potential|“A new journey begins with resourcefulness…”|

### 2.4. Model Architectures: Vision, Multimodal, and Symbolic AI

#### Vision Models

Convolutional neural networks (CNNs) and vision transformers (ViTs) are commonly used for image recognition tasks. For tarot, these models can be fine-tuned to detect symbolic elements, suit symbols, and stylistic features.

#### Multimodal and Vision-Language Models

VLMs and MLLMs, such as CLIP, ViLT, and GPT-4V, integrate visual and textual modalities, enabling the model to align images with narrative interpretations [geeksforgeeks.org](https://www.geeksforgeeks.org/artificial-intelligence/vision-language-models-vlms-explained/). These models are trained on large-scale image-text pairs, learning to associate visual features with semantic concepts.

#### Symbolic and Neuro-Symbolic AI

Hybrid architectures combine symbolic reasoning (e.g., rule-based mapping, knowledge graphs) with deep learning for visual perception. This enables the model to reason about symbolic relationships, adapt to new decks, and provide interpretable explanations for its predictions [arxiv.org](https://arxiv.org/abs/1909.01161) [link.springer.com](https://link.springer.com/chapter/10.1007/978-3-031-77792-9_10).

### 2.5. Prompt Engineering and Few-Shot Strategies for Style Adaptation

Prompt engineering is essential for guiding AI models to account for artistic variation. Strategies include:

- **Deck-Specific Prompts:** “Interpret this card as it appears in the Marseille tradition, focusing on numerology and elemental associations.”
- **Style-Aware Prompts:** “Describe the symbolic meaning of this abstract depiction of The Tower, referencing its core narrative themes.”
- **Few-Shot Examples:** Providing annotated examples from multiple decks to prime the model for cross-style generalization [godofprompt.ai](https://www.godofprompt.ai/blog/few-shot-prompting).

### 2.6. Handling Artistic Variations Across RWS-Style Decks (RWS-Specific Focus)

Many modern decks are Rider-Waite derived – they preserve the core scenes and symbols but vary in art style, color palette, or detail. An AI tarot reader should maintain consistent interpretations across such variations. Domain adaptation and generalization strategies are employed to handle this diversity:

- **Multi-Deck Training:** The most direct approach is to train on images from multiple RWS-style decks. By exposing the model to several artistic renditions of each card, it learns to focus on essential symbols rather than style-specific details. For instance, one open project scraped images from 14 different RWS-based decks (~460 images) to train a generative tarot model[6]. Similarly, an interpretation model can use diverse decks (classic Pamela Colman Smith art, modern recolored versions, etc.) so that a “Knight of Cups” is recognized whether he appears in watercolor or in comic-book style. This acts as a form of data augmentation, teaching the network invariances – the Knight’s posture and cup remain, even if line art or coloring changes.

- **Style Augmentation & Transfer:** Beyond using multiple decks, one can augment images with style variations (color shifts, texture filters) to simulate different artwork. This helps the model become robust to artistic noise. Another advanced method is style transfer normalization: preprocess input images to a common visual domain (for example, using a neural style transfer to convert any deck’s image closer to the original RWS style) before interpretation. This can reduce variance. Alternatively, the model itself can have a style token input – if the deck style is known, the model could adjust internally (though in practice, a well-trained model may not need an explicit token if the data is sufficiently varied).

- **Focused Symbol Detection:** To maintain interpretive consistency, the AI can be tuned to rely on symbolic content rather than fine art details. For example, regardless of deck, The Tower card will usually show a tower being struck and figures falling. A vision model might be trained to detect “lightning + tower” as features that trigger the Tower’s meaning, even if one deck’s lightning is painterly and another’s is cartoonish. By detecting the same core elements across styles, the AI’s output remains consistent. This could be implemented via a mid-layer that explicitly recognizes iconographic elements (perhaps using a small object-recognition module for common tarot symbols).

- **Fine-Tuning and Calibration:** If a new deck has systematic differences (e.g. a minimalist deck with fewer background details), a light fine-tune on a few examples of that deck paired with correct interpretations can calibrate the model. However, maintaining a single model that generalizes is preferable for consistency. Commercial AI tarot platforms often emphasize that their engine works across many decks by focusing on the shared tarot language rather than the art alone[7][8].

It’s worth noting that even generative projects found variety a challenge – tarot images are so varied that generating “consistently coherent” visuals was difficult[9]. For interpretation tasks, this underscores the need to home in on meaning-bearing patterns and ignore stylistic variance. Using the above strategies, an AI can interpret a Rider-Waite clone deck (say, a pastel-colored version of RWS) with the same fidelity as the original, giving the user a familiar reading experience.

---

## III. Evaluating AI Understanding of Tarot Imagery: Benchmarks, Interpretability, and Metrics

### 3.1. The Need for Tailored Evaluation in Symbolic and Narrative Domains

Standard computer vision benchmarks (e.g., ImageNet) focus on object recognition and classification accuracy. However, tarot interpretation demands evaluation of symbolic comprehension, narrative coherence, and interpretive nuance. Effective evaluation frameworks must address:

- **Symbolic Understanding:** Can the model identify and interpret key symbols, colors, and motifs?
- **Narrative Comprehension:** Does the model generate coherent, contextually appropriate readings for single cards and spreads?
- **Style Robustness:** Is the model’s performance consistent across decks and artistic styles?

### 3.2. Proposed Benchmarks and Evaluation Tasks

#### Symbolic Recognition Task

- **Objective:** Assess the model’s ability to identify symbolic elements (e.g., “Does the card contain a lion? An infinity symbol?”).
- **Dataset:** Annotated images with bounding boxes or segmentation masks for key symbols.
- **Metric:** Precision, recall, and F1-score for symbol detection.

#### Deck-Specific Meaning Mapping

- **Objective:** Evaluate the model’s ability to adapt interpretations to different deck traditions.
- **Task:** Given the same card from RWS, Thoth, and Marseille, generate deck-appropriate meanings.
- **Metric:** Human expert ratings for accuracy, appropriateness, and narrative depth.

#### Narrative Spread Interpretation

- **Objective:** Test the model’s capacity to synthesize multi-card spreads into coherent stories.
- **Task:** Given a three-card spread (e.g., Past, Present, Future), generate a narrative that integrates symbolic and positional meanings.
- **Metric:** Human evaluation of narrative coherence, symbolic integration, and emotional resonance.

#### Style Robustness Challenge

- **Objective:** Measure performance across diverse artistic styles and media.
- **Task:** Interpret cards from hand-drawn, digital, abstract, and photorealistic decks.
- **Metric:** Consistency of symbolic recognition and narrative quality across styles.

### 3.3. Interpretability Techniques for Symbolic Understanding

#### Attention Visualization and Relevancy Maps

Interpretability tools such as attention heatmaps and relevancy maps enable users to visualize which image regions or textual tokens the model attends to when generating interpretations [openaccess.thecvf.com](https://openaccess.thecvf.com/content/CVPR2024W/XAI4CV/papers/Stan_LVLM-Intrepret_An_Interpretability_Tool_for_Large_Vision-Language_Models_CVPRW_2024_paper.pdf). For tarot, this can reveal whether the model focuses on key symbols (e.g., the crown in The Empress) or is distracted by irrelevant details.

#### Causal Interpretation and Explanation Graphs

Causal interpretation methods, such as CLEANN, derive causal explanations from attention mechanisms, identifying which input tokens or image regions are most responsible for specific outputs. This enhances transparency and trust, allowing users to understand the model’s reasoning process.

#### Human-in-the-Loop Evaluation

Expert annotators and tarot practitioners can provide qualitative feedback on model outputs, assessing interpretive accuracy, symbolic fidelity, and narrative depth. Human-in-the-loop workflows are essential for refining model behavior and ensuring alignment with domain expertise [keymakr.com](https://keymakr.com/blog/complete-guide-to-llm-data-annotation-best-practices-for-2025/) [aixblock.io](https://aixblock.io/blog/dataset-annotation-in-nlp-expert-techniques-tools-qa-workflows).

### 3.4. Performance Metrics for Symbolic and Narrative Comprehension

#### Symbolic Recognition Metrics

- **Precision/Recall/F1:** For symbol detection and classification tasks.
- **Mean Intersection over Union (mIoU):** For segmentation of symbolic elements.

#### Narrative Coherence Metrics

- **Human Ratings:** Expert evaluation of narrative quality, symbolic integration, and emotional resonance.
- **Textual Similarity:** Automated metrics (e.g., BLEU, ROUGE) for comparing generated readings to reference interpretations, with caution due to the subjective nature of tarot narratives.

#### Multimodal Coherence Metrics

- **Image Coherence:** Measures the alignment between visual content and accompanying text, assessing how effectively the image complements and enhances the narrative [deepeval.com](https://deepeval.com/docs/multimodal-metrics-image-coherence).
- **Visual Narrative Coherence:** Evaluates the consistency of multi-card spread interpretations, focusing on temporal, spatial, and causal relationships [mdpi.com](https://www.mdpi.com/2079-9292/14/21/4199).

#### Inter-Rater Reliability

- **Intraclass Correlation Coefficient (ICC):** Measures agreement among human evaluators, ensuring reliability of subjective ratings.

#### Computational Efficiency

- **Processing Time:** Especially relevant for large-scale or real-time applications, comparing caption-based and direct vision evaluation approaches [mdpi.com](https://www.mdpi.com/2079-9292/14/21/4199).

### 3.5. Existing Implementations and Platforms

Several AI tarot platforms and research prototypes exemplify the integration of advanced methods for symbolic and narrative interpretation:

- **Tarota AI:** Emotionally attuned AI delivering layered insights with responsive reading flows and natural language interaction.
- **TarotNova AI:** Experimental platform supporting deep spreads, context-aware interpretation, and narrative-based AI that connects cards into meaningful storylines [tarotnova.ai](https://tarotnova.ai/en).
- **Tarotap:** Visually immersive tarot experience with virtual card drawing, upright/reversed interpretations, and beginner-friendly explanations [tarotap.com](https://tarotap.com/en/blog/ai-tarot-accuracy).
- **Tarotify AI:** Hybrid astrology-tarot platform with personalized forecasts, mood tracking, and real-time AI interpretation based on celestial cycles.

These platforms leverage multimodal inputs, annotated datasets, and prompt engineering to deliver personalized, context-sensitive tarot readings. They also incorporate user feedback and expert annotation workflows to refine interpretive accuracy and narrative depth.

### 3.6. Ethical, Cultural, and Spiritual Considerations

AI-driven tarot interpretation raises important ethical and cultural questions:

- **Cultural Sensitivity:** Tarot symbolism is deeply rooted in Western esoteric traditions but has been adapted and reinterpreted across cultures. AI models must be trained on diverse datasets and guided by culturally sensitive annotation to avoid bias and misrepresentation [mdpi.com](https://www.mdpi.com/2079-9292/14/21/4199).
- **Spiritual Authenticity:** For many users, tarot is a spiritual or introspective practice. AI systems should be transparent about their algorithmic nature, avoiding claims of mystical insight or deterministic prediction [ourculturemag.com](https://ourculturemag.com/2025/07/25/ai-and-tarot-can-technology-read-energy/).
- **Privacy and Agency:** Conversational tarot AIs often collect personal data. Privacy safeguards and user agency in interpretation are essential to maintain trust and ethical standards [keymakr.com](https://keymakr.com/blog/complete-guide-to-llm-data-annotation-best-practices-for-2025/).
- **Human-AI Collaboration:** The most effective AI tarot systems position themselves as supportive tools, augmenting human intuition and self-reflection rather than replacing the human element [tarot.yobzh.com](https://tarot.yobzh.com/en/blog/tarot-and-ai-integration-the-future-of-intuition) [atarotcards.com](https://atarotcards.com/blog/tarot-ai-ethics-guide/).

### 3.7. Evaluation Metrics for Symbolic Image Understanding (RWS-Specific Focus)

Evaluating an AI’s understanding of tarot imagery is challenging, since “correct” interpretation has subjective elements. However, several metrics and tests can be applied to gauge performance, ensuring the model’s outputs are both faithful to the cards and useful in a spiritual entertainment context:

- **Card Identification Accuracy:** A basic metric is how accurately the model recognizes which card (and orientation) is in an image. If the system involves an image classifier (for example, identifying the card before generating text), this can be measured by classification accuracy. High identification accuracy (e.g. recognizing The High Priestess vs The Empress correctly) is fundamental – an interpretation for the wrong card would be a clear failure. In testing, one can use a held-out set of card images from various decks to ensure the model picks the correct card despite style changes.

- **Symbol/Feature Detection Score:** To assess if the model truly grasps deck symbolism, evaluate its detection of key features. This could involve a set of binary metrics: does the AI’s output mention the presence of iconic symbols that are in the image? For instance, if The Star card image is input, does the generated text mention stars, water, or an aura of hope? Using a predefined list of core symbols per card, one can calculate precision/recall – e.g. the model correctly mentions 80% of the important symbols present, with few false mentions. This ensures the AI isn’t hallucinating details that don’t exist and is focusing on the right imagery cues. (Notably, early experiments have found that without constraints, AI readings can “invent cards or give flawed interpretations”, highlighting the need for this grounded evaluation[14].)

- **Text Similarity to Canonical Meanings:** Although creative phrasing is expected, the essence of the AI’s interpretation should align with established meanings. One quantitative proxy is to compare the AI-generated text to a reference text (say, a standard guidebook description) using NLP metrics. Scores like BLEU, ROUGE, or BERTScore can measure overlap in content. For example, if the AI describes The Tower as “upheaval and sudden change”, it will score highly against a reference that uses those keywords. A high average similarity across all cards indicates the model has learned the conventional interpretations. However, too high a similarity might indicate rote repetition – a balance is needed to allow some creativity while staying “on message.” Embedding-based similarity (using a model like CLIP or Sentence Transformers) can also evaluate if the AI’s text is conceptually close to the image’s known meaning. In research on AI tarot readings, one author noted that GPT-4 outputs gave her “chills” by closely matching the intuitive feel of the card[15] – an anecdotal but telling validation.

- **Contextual Appropriateness (User Satisfaction):** In the realm of spiritual guidance, human evaluation is crucial. Metrics here include user ratings of how relevant, comforting, or insightful a reading is. One can conduct user studies where participants ask questions and draw cards via the AI, then rate the reading for resonance and clarity. Another angle is consistency checks: if the same card is drawn for similar questions, does the AI give consistent core meanings (a form of test–retest reliability)? Also, domain experts (experienced tarot readers) can blind-review AI outputs for accuracy and nuance, providing qualitative scores or rankings. Interestingly, some experts have opined that AI readings are on par with those of many human readers – “often as good as those from mediocre human readers”, with only the top tier of psychics significantly outperforming AI[14]. This suggests that in evaluations, AI can achieve a quality that users find acceptable for entertainment or reflection. Tracking improvement towards expert-level interpretations could be an ultimate metric.

- **Error and Hallucination Rate:** This metric captures how often the AI makes blatant mistakes. For instance, mentioning the wrong card name, contradicting itself (e.g. saying a card is both positive and very negative without context), or producing implausible statements (e.g. claiming The Lovers card depicts a lone figure – clearly incorrect visually). Each such occurrence is logged, and the goal is to minimize it. Developers have implemented filters to catch these, for example, by removing or penalizing any output that names a card not actually drawn[16]. A low hallucination rate is especially important to maintain trust: the system should not, for example, “invent a card” that doesn’t exist[14] or mislead the user about what they drew. We can quantify this as the percentage of outputs free from factual errors about the card’s imagery.

- **Engagement Metrics:** Since this is an entertainment application, one can also measure user engagement: repeat usage, time spent reading interpretations, or click-through in an interactive setting. These indirect metrics indicate how compelling the AI’s readings are. If the AI is truly capturing symbolic subtleties and providing meaningful guidance, users are likely to feel “seen” by the reading and return for more (much as they would to a favorite human reader).

Finally, it’s important that evaluation in this space remains holistic. An AI might score well on technical metrics yet fail to inspire users, or vice versa. Best practice is to combine automatic metrics with human feedback. As one analysis of AI spirituality tools notes, the challenge is to create “meaning machines” – systems that don’t just output data but create a narrative that resonates[8]. Therefore, evaluation should ultimately answer: Does the AI capture the card’s symbolism accurately, and does it deliver an interpretation that feels insightful and spiritually relevant to the user? Metrics are aligned to these dual goals of fidelity and resonance.

---

## IV. Case Study: An End-to-End Training Pipeline for AI Tarot Interpretation

To illustrate the integration of advanced methods, consider an end-to-end pipeline for training an AI tarot interpreter:

### 4.1. Data Collection and Annotation

- **Image Acquisition:** Collect high-resolution scans of cards from multiple decks (RWS, Thoth, Marseille, modern variants).
- **Symbol Annotation:** Label key symbols, objects, and color schemes using bounding boxes or segmentation masks.
- **Textual Annotation:** Curate narrative readings, upright/reversed meanings, and symbolic keywords for each card.
- **Metadata Integration:** Record deck type, artistic style, historical context, and user queries.

### 4.2. Model Training

- **Vision Model Pretraining:** Fine-tune a vision transformer on annotated tarot images for symbol detection and style classification.
- **Multimodal Alignment:** Train a VLM or MLLM to align visual features with textual interpretations, using paired image-text data.
- **Symbolic Embedding:** Integrate knowledge graphs or symbolic embeddings to encode deck-specific relationships and meanings.
- **Domain Adaptation:** Apply transfer learning and few-shot prompting to adapt the model to new decks and artistic styles.

### 4.3. Evaluation and Iteration

- **Symbolic Recognition Benchmark:** Test symbol detection accuracy across decks and styles.
- **Narrative Coherence Evaluation:** Solicit expert ratings for generated readings, assessing symbolic integration and narrative depth.
- **Style Robustness Challenge:** Evaluate performance on hand-drawn, digital, and abstract decks.
- **Interpretability Analysis:** Use attention visualization and causal explanation tools to audit model reasoning.

### 4.4. Deployment and Human-in-the-Loop Refinement

- **Conversational Interface:** Implement a chatbot or web app for user interaction, supporting natural language queries and spread selection.
- **Feedback Collection:** Gather user and expert feedback to identify failure modes and refine model behavior.
- **Ethical Safeguards:** Ensure transparency, privacy, and cultural sensitivity in all user interactions.

### 4.5. Case Studies and Best Practices in Symbolic Image Interpretation (RWS-Specific Focus)

Several projects and research efforts shed light on how best to train and utilize AI for symbolic image domains like tarot:

- **Academic/Research Example – Iconography in Art:** In fields like art history, AI has been used to interpret paintings and religious icons by recognizing symbolic features. These neural-symbolic models often combine computer vision with knowledge graphs of iconography. The tarot domain can borrow from this: e.g. building a knowledge base of tarot symbols (sun, moon, sword, cup, etc.) and having the AI cross-reference its image analysis with that knowledge for a richer interpretation. Although specific academic papers on tarot are sparse, the methodology aligns with broader research on AI understanding cultural symbols[8].

- **Open-Source Projects:** The “AI Tarot” by scrapfishies is a notable open project where a StyleGAN2 model was trained on RWS-style decks to create new card images, and a GPT-2 model was fine-tuned on tarot texts to generate meanings[17][11]. This project illustrated many best practices: using multiple decks for training data, sourcing interpretive text from public datasets, and even clustering generated text to ensure coherence[18][19]. While the goal there was deck creation, not interpretation, the process showed that transfer learning on both images and language can yield credible tarot content. The creators emphasized that every element in a tarot image (down to “the patterns in clothing”) had to be considered, reinforcing the need for detail-oriented training[1]. They also found that the latent space of meanings could be organized – implying that an AI can learn a sort of tarot semantic space where similar card interpretations cluster together. This insight can be applied to ensure an interpretation model’s outputs are diverse but within the bounds of traditional meanings (e.g. various phrasings of “new beginning” for The Fool should cluster around that concept).

- **Commercial Systems:** Platforms like TarotCards.io and other AI tarot reading apps use large language models (LLMs) combined with simple card selection UIs[7]. These systems often don’t rely on analyzing an image pixel-by-pixel; instead, they identify the drawn card (sometimes via image recognition or user selection) and then generate a reading with an LLM. One published review noted that TarotCards.io’s AI provides “personalized readings” and even an interactive chat, analyzing patterns without human bias[20]. The takeaway for best practice is the importance of user experience and narrative cohesion. These systems ensure the interpretation across a multi-card spread forms a coherent story, not just isolated card meanings[7]. Technically, that might mean the model or post-processing links the outputs for each card into a single narrative (perhaps by giving the LLM information about all cards drawn before it responds). Commercial successes also highlight transparency and ethical limits – labeling the service as “for entertainment” and avoiding deterministic predictions[21][22]. For AI designers, this means evaluation isn’t just about correctness but also about tone and safety: the model should deliver guidance in a comforting, non-alarming manner even when a “negative” card appears, similar to how a human reader would couch advice.

- **Hybrid Approaches (Vision + Language):** A promising framework for symbolic interpretation is a two-stage model: first use vision AI to extract structured information from the card image, then feed that into a language model to compose the interpretation. For example, a vision model might output: {Card: “Tower”, Detected symbols: [Lightning, Falling Figure, Crown], Detected mood: “chaotic”}, and then an LLM like GPT-4 is prompted with that data to produce a nuanced reading (“The Tower appears – a sudden upheaval or revelation is at hand…”). This hybrid method leverages the precision of vision AI with the fluent flexibility of language models. Indeed, an engineer who built an AI tarot prototype reported success with a similar method: mapping each card to natural language prompts and letting a GPT-style model “read them like a human would,” yielding impressively human-like readings[13][15]. Best practices here include curating the prompt structure (possibly giving the LLM additional context like the querent’s question or the card’s core themes) and putting guardrails to prevent the LLM from veering off-script (such as verifying it doesn’t introduce extraneous mystical concepts or inappropriate content).

- **Frameworks and Tools:** From a tooling perspective, many developers use frameworks like Hugging Face Transformers for fine-tuning language models on tarot text, and PyTorch or TensorFlow Vision models for image tasks. Vision-language models such as OpenAI’s CLIP could be fine-tuned to embed tarot images and descriptions in the same space, enabling similarity-based evaluation or retrieval of interpretations. There are even ready-made models for image captioning (e.g. BLIP, ViLT) that can serve as a starting point – by initializing with those and then training on tarot pairs, one can accelerate learning. For object detection of symbols, services like Roboflow have community datasets (e.g. a tarot card detection model with 78 classes of cards[23]) which could be repurposed for identifying card types in user-uploaded photos of their own cards. Integrating such components yields a comprehensive system: the vision part assures the model “knows what it’s looking at,” and the language part ensures the output is coherent and contextually apt.

In conclusion, training an AI to interpret Rider-Waite tarot cards draws on a mixture of computer vision, NLP, and domain-specific knowledge. By encoding the rich symbolism of the RWS deck, handling artistic variations through robust training, designing thoughtful multimodal datasets, and evaluating with both technical and human-centered metrics, one can create an AI that provides spiritually resonant and entertaining tarot readings. The journey combines cutting-edge AI methods with the age-old language of symbols – truly a modern take on “as above, so below.” [2][8]

---

## V. Future Directions and Open Challenges

Despite significant progress, several open challenges remain in the quest for AI tarot mastery:

- **Generalization Across Decks:** Achieving robust symbolic understanding across the full spectrum of tarot traditions and artistic styles.
- **Subjective and Contextual Interpretation:** Modeling the inherently subjective, context-dependent nature of tarot readings, including emotional tone and user intent.
- **Explainability and Trust:** Developing interpretable models that can justify their interpretations in human-understandable terms.
- **Cultural and Spiritual Nuance:** Ensuring that AI systems respect the cultural, historical, and spiritual dimensions of tarot practice.
- **Benchmark Development:** Creating standardized, community-validated benchmarks for symbolic and narrative evaluation in tarot and related domains.

---

## Conclusion

Training AI to interpret tarot cards is a multifaceted challenge that demands expertise in symbolic reasoning, computer vision, multimodal learning, and human-centered design. By encoding deck-specific symbolism, handling artistic variation, and developing tailored evaluation frameworks, researchers and practitioners can build AI systems that not only recognize images but also comprehend the rich, narrative tapestry of tarot. As AI tarot platforms continue to evolve, the most successful approaches will harmonize technological sophistication with cultural sensitivity, ethical integrity, and a deep respect for the enduring mystery of the cards.

---

## Sources (From RWS-Specific Content)

1. Scaggiante, A. The AI Tarot – COEVAL Magazine (2022) – Reflections on using AI (DALL·E 2) to generate a tarot deck, discussing symbolism and prompt design[24].
2. Yun, L. Tarot Card Generation with Machine Learning – Project using StyleGAN2 (700 tarot images) and GPT-2 for card meanings[25][26].
3. scrapfishies (GitHub). AI-Generated Tarot (2021) – Open-source project creating a tarot deck with GANs and GPT-2; details on training data from 14 decks and text corpora[1][6][11].
4. Sayantani (Medium). I Built a Tarot Reader Using AI – Here’s What Happened (2025) – Describes using GPT-4/Claude with structured tarot data and prompt engineering[3][5].
5. Skywork.ai. From Playing Cards to AI: A Deep Dive into TarotCards.io (2023) – Overview of an AI tarot reading platform; discusses AI interpretations, user experience, and debates on accuracy[27][8].
6. Kaggle (metabismuth/tarot-json). Tarot Cards Dataset – Public domain Rider-Waite card images (350×600) with JSON metadata including meanings and keywords (2019)[10].
7. Roboflow Universe. Tarot Cards Object Detection (2024) – Dataset/model for detecting tarot cards in images (78 classes)[23].
8. O’Brien, G. It’s in the Cards: Tarot Psychology & Interpretation – Bowdoin Science Journal (2024) – Background on tarot’s psychological aspects (for context on usage).

[1] [6] [9] [11] [17] [18] [19] GitHub - scrapfishies/ai-generated-tarot: Designing tarot cards with StyleGAN2-ADA and GPT-2
https://github.com/scrapfishies/ai-generated-tarot
[2] [24] The AI Tarot - COEVAL Magazine
https://www.coeval-magazine.com/coeval/the-ai-tarot
[3] [4] [5] [12] [13] [15] [16]  I Built a Tarot Reader Using AI — Here’s What Happened | by Sayantani | Medium
https://iamsayantani.medium.com/i-built-a-tarot-reader-using-ai-heres-what-happened-5c955d335cf0
[7] [8] [14] [20] [21] [22] [27] From Playing Cards to AI: A Deep Dive into TarotCards.io
https://skywork.ai/skypage/en/From-Playing-Cards-to-AI:-A-Deep-Dive-into-TarotCards.io/1975224709135659008
[10] Gemma2 Practice: Tarot - Kaggle
https://www.kaggle.com/code/woosungyoon/gemma2-practice-tarot
[23] Tarot Cards Object Detection Model by Reconnaissance tirage de tarot
https://universe.roboflow.com/reconnaissance-tirage-de-tarot/tarot-cards-wxtw6-ulgwh
[25] [26] Tarot Card Generation with Machine Learning — Lynne Yun Design
http://www.lynneyun.com/spring-20-synthetic-media/2020/3/11/tarot-card-generation-with-machine-learning

---
</file>

<file path="docs/INTENTION_COACH_ENHANCEMENTS.md">
# Guided Intention Coach - Week 1-2 Enhancements

**Completion Date:** 2025-11-17
**Status:** ✅ All Foundation & Quick Wins Tasks Completed

## Overview

This document summarizes the enhancements made to the Guided Intention Coach component as part of the Phase 1: Foundation & Quick Wins implementation from the enhancement roadmap.

---

## 🎯 Implemented Features

### 1. ✅ Accessibility Improvements

**Files Modified:**
- `src/components/GuidedIntentionCoach.jsx`

**Changes:**
- Added `role="dialog"` and `aria-modal="true"` attributes for screen reader compatibility
- Implemented Escape key handler to close modal (pressing `Esc` now closes the coach)
- Added `aria-labelledby` attribute linking to modal title for proper announcement
- Made backdrop clickable to dismiss modal (click outside the modal to close)
- Added automatic focus management when modal opens
- Added `modalRef` and `titleId` for proper ARIA relationships

**Impact:**
- ✅ WCAG 2.1 Level AA compliant
- ✅ Better keyboard navigation
- ✅ Improved screen reader experience
- ✅ More intuitive dismissal (click outside or press Esc)

---

### 2. ✅ Spread-Aware Topic Suggestions

**Files Modified:**
- `src/TarotReading.jsx` - passes `selectedSpread` prop
- `src/components/GuidedIntentionCoach.jsx` - receives and uses spread context

**New Logic:**
```javascript
// Smart topic mapping based on spread type
const SPREAD_TO_TOPIC_MAP = {
  relationship: 'relationships',  // Relationship Snapshot → Love & Relationships
  decision: 'decision',            // Decision spread → Choices & Crossroads
  celtic: 'growth',                // Celtic Cross → Self-Growth & Spiritual
  fiveCard: 'wellbeing',           // Five-Card Clarity → Wellbeing & Balance
  threeCard: null,                 // Flexible (no suggestion)
  single: null                     // Flexible (no suggestion)
};
```

**Changes:**
- Coach now receives `selectedSpread` prop from parent
- Pre-selects topic based on spread type (with user override)
- Displays contextual hint explaining the suggestion:
  > "💡 Based on your **Relationship Snapshot** spread, we suggest exploring **Love & Relationships**. Feel free to choose any topic."
- Falls back to default if spread has no specific mapping

**Impact:**
- ✅ Questions feel more contextual and relevant
- ✅ Reduces cognitive load for users
- ✅ Demonstrates spread-aware intelligence
- ✅ Still allows full flexibility (users can choose any topic)

---

### 3. ✅ Question Quality Scoring Utility

**New Files:**
- `src/lib/questionQuality.js` - quality scoring engine

**Files Modified:**
- `src/components/GuidedIntentionCoach.jsx` - integrates quality feedback

**Scoring Dimensions:**

| Dimension | Weight | Description |
|-----------|--------|-------------|
| **Open-ended** | 35% | Avoids yes/no questions, uses "How/What" instead; fate/guarantee phrasing is penalized |
| **Specific** | 25% | Not too vague (5-40 words) and grounded in a concrete subject (person/role/situation) |
| **Actionable** | 25% | Uses reflective + agency verbs (explore, navigate, align, build) |
| **Length** | 10% | Word-based check; full credit at 8-30 words, partial at 6-40 |
| **Context Bonus** | +5 | Mentions a gentle timeframe to focus the spread ("this month", "next six months") |

**Quality Levels:**
- 🌟 **Excellent** (85-100): Ready to use
- 👍 **Good** (65-84): Minor improvements possible
- 💡 **Fair** (40-64): Could be refined
- 🔧 **Needs work** (0-39): Consider revising

**UI Feedback:**
- Real-time quality score with progress bar (0-100%)
- Color-coded indicator (emerald/green/amber/orange)
- Up to 2 specific improvement tips shown below preview
- Example tips:
  - "Try 'How' or 'What' instead of yes/no questions"
  - "Be more specific - what exactly are you exploring?"
  - "Include agency-forward verbs like navigate, align, or cultivate"
  - "Add a gentle timeframe to focus the reading"

**Impact:**
- ✅ Educational - teaches users effective question crafting
- ✅ Real-time feedback as they customize their question
- ✅ Encourages open-ended, reflective questions
- ✅ Builds tarot literacy over time

---

### 4. ✅ localStorage Preferences Persistence

**Files Modified:**
- `src/components/GuidedIntentionCoach.jsx`

**Storage Key:**
```javascript
const COACH_PREFS_KEY = 'tarot-coach-preferences';
```

**Saved Data:**
```javascript
{
  lastTopic: string,        // e.g., "relationships"
  lastTimeframe: string,    // e.g., "week"
  lastDepth: string,        // e.g., "guided"
  timestamp: number         // Unix timestamp
}
```

**Logic:**
- When coach opens:
  - Loads saved preferences from localStorage
  - If recent (within 7 days), pre-selects saved values
  - Otherwise, uses spread-aware defaults
  - Gracefully falls back on errors

- When user applies question:
  - Saves current selections to localStorage
  - Updates timestamp for freshness check
  - Silently fails if localStorage unavailable

**Impact:**
- ✅ Respects user's preferences across sessions
- ✅ Reduces repetitive selections
- ✅ Creates sense of continuity
- ✅ 7-day freshness window balances memory with flexibility

---

### 5. ✅ Mobile Responsiveness Improvements

**Files Modified:**
- `src/components/GuidedIntentionCoach.jsx`

**Changes:**

#### A. Full-Screen Mode on Mobile
```css
/* Modal container */
className="w-full h-full sm:h-auto sm:max-w-3xl sm:mx-4 sm:rounded-3xl"
```
- Full viewport height on mobile (< 640px)
- Centered modal on tablet/desktop
- Rounded corners only on larger screens

#### B. Enhanced Step Progress Indicators
- Shows numeric steps on mobile (`1`, `2`, `3`)
- Shows full labels on desktop (`Topic`, `Timeframe`, `Depth`)
- Added "Step X of 3" counter on right side
- Minimum 32px touch targets (`min-h-[32px]`)

#### C. Sticky Footer with Better Touch Targets
- Footer sticks to bottom on mobile (easy to reach)
- Buttons expand to fill width on mobile (`flex-1`)
- Minimum 44px height for accessibility (`min-h-[44px]`)
- Added `touch-manipulation` CSS for better tap response
- Proper spacing for mobile keyboards (`pt-16` top padding)

#### D. Improved Padding & Spacing
- Adjusted padding: `px-4 pb-safe pt-16` on mobile
- Desktop padding: `sm:px-10 sm:pt-8 sm:pb-6`
- Sticky footer with border separator on mobile

**Impact:**
- ✅ Better usability on phones (iOS/Android)
- ✅ 44px touch targets meet WCAG guidelines
- ✅ Full-screen mode reduces distractions
- ✅ Sticky footer always reachable with thumb
- ✅ Smooth experience across all screen sizes

---

## 📊 Before & After Comparison

| Feature | Before | After |
|---------|--------|-------|
| **Accessibility** | No ARIA, no Esc key, X button only | Full ARIA, Esc key, backdrop click, focus management |
| **Context Awareness** | Generic topic selection | Spread-aware suggestions with hints |
| **Quality Feedback** | None | Real-time scoring with actionable tips |
| **State Persistence** | Reset every time | Remembers last selections (7 days) |
| **Mobile UX** | Centered modal, small buttons | Full-screen, 44px touch targets, sticky footer |
| **Step Progress** | Labels only | Numeric + labels + "X of 3" counter |

---

## 🧪 Testing Checklist

### Accessibility
- [x] Screen reader announces modal title
- [x] Escape key closes modal
- [x] Clicking backdrop closes modal
- [x] Tab navigation works properly
- [x] All interactive elements have focus states

### Spread Awareness
- [x] Relationship spread → suggests "Love & Relationships"
- [x] Decision spread → suggests "Choices & Crossroads"
- [x] Celtic Cross → suggests "Self-Growth & Spiritual"
- [x] Five-Card → suggests "Wellbeing & Balance"
- [x] Three-Card/Single → no suggestion (flexible)
- [x] User can override suggested topic

### Quality Scoring
- [x] Yes/no questions score lower
- [x] "How can I..." questions score higher
- [x] Vague words reduce score
- [x] Quality bar updates in real-time
- [x] Feedback tips show for scores < 85%
- [x] Excellent questions (85%+) get green bar

### Persistence
- [x] Selections saved on apply
- [x] Preferences loaded on reopen (within 7 days)
- [x] Expired preferences (> 7 days) use defaults
- [x] localStorage errors handled gracefully

### Mobile
- [x] Full-screen on small devices (< 640px)
- [x] Buttons 44px minimum height
- [x] Step numbers on mobile (1, 2, 3)
- [x] Footer sticks to bottom
- [x] No layout shift with keyboard
- [x] Touch targets easy to tap

---

## 🔧 Technical Details

### Dependencies
No new dependencies added. All features use:
- React built-in hooks (useState, useEffect, useMemo, useRef, useId)
- Existing Lucide React icons
- Tailwind CSS utility classes
- Browser APIs (localStorage, keyboard events)

### File Structure
```
src/
├── components/
│   └── GuidedIntentionCoach.jsx    [Modified - all 5 features]
├── lib/
│   ├── intentionCoach.js           [Existing - unchanged]
│   └── questionQuality.js          [NEW - quality scoring]
└── TarotReading.jsx                [Modified - pass selectedSpread prop]

docs/
└── INTENTION_COACH_ENHANCEMENTS.md [NEW - this document]
```

### Performance
- Quality scoring runs via `useMemo` (only recalculates when question changes)
- Quality level derived via `useMemo` (only updates when score changes)
- No additional network requests
- localStorage operations wrapped in try/catch for safety
- All operations synchronous and fast

---

## 🚀 Next Steps (Phase 2)

Based on the roadmap, the next enhancements would be:

### Week 3-4: Personalization Core
1. **Journal-Powered Patterns**
   - Create `useQuestionPatterns` hook
   - Analyze past readings for frequent topics
   - Surface "Questions that worked well" (high-rated questions)

2. **Question History**
   - Quick access drawer with recent 10 questions
   - Click to re-use or edit before applying

3. **Enhanced Preferences**
   - Save favorite custom focus phrases
   - Track most-used depth levels
   - Adaptive defaults based on usage patterns

### Week 5-8: Advanced Features (Optional)
4. **Template Library**
   - Curated question bank by topic
   - Fill-in-the-blank templates
   - Community favorites (if scaled)

5. **Follow-Up Suggestions**
   - Post-reading: suggest related questions
   - Create reading continuity
   - "Go deeper" option

---

## 📝 Notes

### Code Quality
- All TypeScript diagnostics resolved
- Build succeeds with no errors or new warnings
- Follows existing code patterns and conventions
- Properly handles edge cases and errors

### User Experience
- Features are discoverable but not intrusive
- Progressive disclosure (advanced features appear when relevant)
- Respects user choices (suggestions can be ignored)
- Maintains authentic tarot app feel

### Backward Compatibility
- No breaking changes
- Works gracefully if localStorage disabled
- Falls back to defaults on any errors
- Older browsers without modern features still work (degrades gracefully)

---

## 🎉 Summary

**All Week 1-2 Foundation & Quick Wins tasks completed successfully:**

✅ **Task 1:** Accessibility fixes (ARIA, Escape key, backdrop click)
✅ **Task 2:** Spread awareness (context-aware suggestions)
✅ **Task 3:** Question quality scoring (real-time feedback)
✅ **Task 4:** localStorage persistence (remember preferences)
✅ **Task 5:** Mobile improvements (full-screen, touch targets)

**Build Status:** ✅ Passing (no errors)
**Ready for:** User testing and Phase 2 planning
</file>

<file path="docs/INTERACTIVE_CARD_TOOLTIPS.md">
# Interactive Card Tooltips (P5)

## Overview

Interactive Card Tooltips transform card symbols from passive metadata lists into an explorable "Museum Mode" experience. Users can tap/click directly on symbols within card images to discover their meanings contextually.

## Implementation

### Architecture

The feature uses **SVG overlay** for optimal mobile support:

- **Fully responsive**: SVG viewBox scales perfectly across all screen sizes
- **Touch-optimized**: Large hit areas (60-100 units) for accurate tapping
- **Visual affordance**: Pulsing indicator dots show interactive regions
- **Tap-based tooltips**: Mobile-friendly (no hover dependency)

### Components

#### 1. `InteractiveCardOverlay.jsx`

Location: `src/components/InteractiveCardOverlay.jsx`

**Purpose**: SVG overlay that renders clickable symbol regions over card images

**Props**:
- `card` - Card object with `number` property for coordinate lookup
- `isReversed` - Boolean indicating card orientation

**Features**:
- Supports 3 shape types: `circle`, `rect`, `polygon`
- Click/tap toggles tooltips (tap same symbol to close)
- Tooltips show: symbol name, color (if applicable), meaning
- Pulsing indicator dots hint at interactivity
- Subtle hover effects (desktop) and active states

#### 2. `symbolCoordinates.js`

Location: `src/data/symbolCoordinates.js`

**Purpose**: Maps descriptive symbol positions to actual SVG coordinates

**ViewBox**: `820 x 1430` (standard RWS aspect ratio)

**Data Structure**:
```javascript
export const SYMBOL_COORDINATES = {
  0: { // Card number (The Fool)
    symbols: [
      {
        symbol: SYMBOL_ANNOTATIONS[0].symbols[0], // Reference to symbol metadata
        shape: 'circle',
        cx: 120,    // Center X
        cy: 140,    // Center Y
        r: 70,      // Radius
        indicatorCx: 120, // Indicator dot position
        indicatorCy: 140
      },
      {
        symbol: SYMBOL_ANNOTATIONS[0].symbols[1],
        shape: 'rect',
        x: 520,     // Top-left X
        y: 1100,    // Top-left Y
        width: 150,
        height: 180,
        indicatorCx: 595,
        indicatorCy: 1190
      }
      // ... more symbols
    ]
  }
};
```

### Current Coverage

✅ **The Fool (0)** - 6 symbols:
- Sun (top-left)
- Dog (bottom-right)
- Cliff (right edge)
- White rose (left hand)
- Bundle (over shoulder)
- Feather in hat

✅ **The Magician (1)** - 7 symbols:
- Infinity symbol (above head)
- Wand (right hand)
- Cup (on table)
- Sword (on table)
- Pentacle (on table)
- Red roses (garden)
- White lilies (garden)

### Integration

The overlay is integrated into `Card.jsx`:

```jsx
<div className="relative">
  <img src={card.image} alt={...} className="..." />
  <InteractiveCardOverlay card={card} isReversed={card.isReversed} />
</div>
```

The overlay automatically:
- Only renders for cards with mapped coordinates
- Returns `null` for unmapped cards (graceful degradation)
- Falls back to existing `CardSymbolInsights` button for all cards

## Adding New Cards

### Process

1. **View the card image**:
   - Open `public/images/cards/RWS1909_-_XX_Name.jpeg`
   - Study symbol positions

2. **Choose shapes**:
   - `circle` - for radial/organic symbols (sun, moon, orbs)
   - `rect` - for geometric/rectangular regions (tables, pillars, garden beds)
   - `polygon` - for complex/irregular shapes (flowing robes, animals)

3. **Map coordinates**:
   - Coordinate system: `(0,0)` is top-left, `(820, 1430)` is bottom-right
   - Use browser dev tools or SVG editor to measure positions
   - Make touch targets **60-100 units minimum** for mobile usability

4. **Add to `symbolCoordinates.js`**:
   ```javascript
   // Card 2: The High Priestess
   2: {
     symbols: [
       {
         symbol: SYMBOL_ANNOTATIONS[2].symbols[0], // Pillars
         shape: 'rect',
         x: 50,
         y: 300,
         width: 700,
         height: 800,
         indicatorCx: 400,
         indicatorCy: 700
       }
       // ... more symbols
     ]
   }
   ```

5. **Test across devices**:
   - Desktop (hover effects)
   - Mobile (touch targets, tooltip positioning)
   - Different screen sizes (responsive scaling)

### Coordinate Tuning Tips

- **Start rough, refine iteratively**: Initial estimates from visual inspection, then adjust in browser
- **Use indicator dots**: Position them at symbol centers to verify alignment
- **Test reversed cards**: Ensure coordinates work when card is rotated 180°
- **Generous touch targets**: Better to overlap slightly than miss taps
- **Tooltip positioning**: Use `Math.min()` to keep tooltips within viewport bounds

### Testing Checklist

- [ ] All symbols are tappable on mobile
- [ ] Touch targets are minimum 44x44px (iOS) / 48x48dp (Android)
- [ ] Tooltips don't obscure the card or overflow viewport
- [ ] Hover effects work on desktop
- [ ] Indicator dots align with symbol centers
- [ ] Coordinates work for both upright and reversed orientations
- [ ] Multiple taps toggle tooltips correctly
- [ ] Tapping outside closes active tooltip

## Mobile Optimization

### Touch Targets

Minimum sizes:
- **iOS**: 44x44 points (Apple HIG)
- **Android**: 48x48 dp (Material Design)
- **Our implementation**: 60-100 viewBox units (generous for accuracy)

### Interaction Pattern

1. **No hover**: Mobile has no hover state, so we use tap-to-reveal
2. **Toggle behavior**: Tap symbol to open, tap again to close
3. **Click outside**: Tap SVG background to close tooltip
4. **No scrolljacking**: Tooltips use `pointer-events-none` to avoid blocking scrolls

### Responsive Scaling

SVG viewBox automatically scales with image size:
- Desktop: `max-w-[280px]`
- Mobile: `max-w-[65%]`
- Coordinates remain accurate at all sizes

## Visual Design

### Indicator Dots

- **Purpose**: Hint that symbols are interactive
- **Style**: Pulsing yellow dots (`animate-pulse`)
- **Position**: Symbol centers (defined by `indicatorCx/Cy`)
- **Visibility**: Hidden when tooltip is active

### Hover/Active States

- **Hover (desktop)**: `fill-yellow-400/20`, `stroke-yellow-400/60`
- **Active (tap)**: `fill-yellow-400/30`, `stroke-yellow-400/80`
- **Transition**: Smooth 200ms

### Tooltips

- **Background**: `bg-surface/95` with backdrop blur
- **Border**: `border-2 border-accent/60`
- **Shadow**: `shadow-2xl` for depth
- **Content**:
  - Symbol name (bold, accent color)
  - Color (if applicable, secondary text)
  - Meaning (readable body text)

## Differences from Existing `CardSymbolInsights`

| Feature | `CardSymbolInsights` (Existing) | `InteractiveCardOverlay` (New) |
|---------|--------------------------------|-------------------------------|
| **Trigger** | Separate "Info" button | Click/tap card image regions |
| **Granularity** | Shows all symbols at once | Shows one symbol at a time |
| **Engagement** | Passive reading (list view) | Active exploration (discovery) |
| **Data req.** | Textual position descriptions | Coordinate mappings required |
| **Coverage** | All 78 cards | Currently 2 cards (expandable) |

**Both features coexist**: Cards without coordinate mappings still show the traditional Info button.

## Future Enhancements

### Short-term

1. **Map remaining Major Arcana** (cards 2-21)
2. **Add coordinate validation tests** (ensure no overlapping regions, all symbols covered)
3. **Analytics**: Track which symbols users explore most

### Long-term

1. **Minor Arcana support** (56 cards with suit-specific patterns)
2. **Symbol relationships**: Highlight related symbols when one is tapped
3. **Guided tours**: "Explore this card" walkthrough for new users
4. **Accessibility**: Keyboard navigation (arrow keys to move between symbols)
5. **Advanced shapes**: Bezier paths for flowing elements (robes, water, clouds)

## Performance Considerations

- **Lightweight**: SVG overlays add minimal overhead (~2KB per card)
- **Lazy loading**: Only loads coordinates for revealed cards
- **No runtime calculations**: Coordinates are pre-defined, no hit detection math
- **Graceful degradation**: Missing coordinates = no overlay, no errors

## Accessibility

Current implementation:
- Clickable regions have `cursor-pointer`
- Tooltips use semantic markup
- Color contrast meets WCAG AA standards

**TODO**:
- Add ARIA labels to symbol regions
- Add keyboard navigation support
- Screen reader announcements for tooltip open/close

## References

- Component: `src/components/InteractiveCardOverlay.jsx`
- Coordinates: `src/data/symbolCoordinates.js`
- Symbol data: `shared/symbols/symbolAnnotations.js`
- Integration: `src/components/Card.jsx:264-277`

## Questions?

For coordinate mapping help or implementation questions, see inline comments in `symbolCoordinates.js`.
</file>

<file path="docs/JOURNAL_SETUP.md">
# Journal Authentication & Persistence Setup

This guide covers the authentication and D1-backed journal persistence system for Mystic Tarot.

## Overview

The journal feature now supports **optional authentication** with **cloud-backed persistence**:

- **Anonymous users** → localStorage (browser-only, existing behavior)
- **Authenticated users** → D1 database (cloud-synced, cross-device access)

## Features

✅ **Zero breaking changes** - App works identically without authentication
✅ **Automatic routing** - `useJournal` hook routes to API or localStorage based on auth state
✅ **Migration support** - One-click migration from localStorage to cloud
✅ **PBKDF2 password hashing** - 100,000 iterations, OWASP-compliant
✅ **HTTP-only cookies** - SameSite=Lax, Secure flags for session management
✅ **30-day sessions** - Persistent authentication with automatic refresh

---

## Setup Instructions

### 1. Run Database Migrations

Execute both migration files to set up the database schema:

```bash
# Migration 0001 (analytics tables - already run)
wrangler d1 execute mystic-tarot-db --remote --file=./migrations/0001_initial_schema.sql

# Migration 0002 (auth and journal tables - NEW)
wrangler d1 execute mystic-tarot-db --remote --file=./migrations/0002_add_auth_and_journals.sql
```

**Tables created by Migration 0002:**
- `users` - User accounts (email, username, password_hash, password_salt)
- `sessions` - Active sessions with HTTP-only cookie tokens
- `journal_entries` - Cloud-synced journal entries

### 2. Verify Database Binding

Ensure `wrangler.toml` has the D1 binding configured (already done):

```toml
[[d1_databases]]
binding = "DB"
database_name = "mystic-tarot-db"
database_id = "ede622bd-5845-4da9-9031-839cb26ae7be"
```

### 3. Deploy to Production

```bash
npm run build
npm run deploy
```

---

## Architecture

### Backend (Cloudflare Pages Functions)

#### Auth API (`functions/api/auth/`)

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/auth/register` | POST | Create new user account |
| `/api/auth/login` | POST | Authenticate and create session |
| `/api/auth/logout` | POST | Destroy session |
| `/api/auth/me` | GET | Get current user info |

**Security features:**
- PBKDF2 with 100,000 iterations (SHA-256)
- Cryptographically secure random salts (16 bytes)
- Session tokens via `crypto.randomUUID()`
- HTTP-only cookies with SameSite=Lax and Secure flags
- 30-day session expiration with last_used_at tracking

#### Journal API (`functions/api/journal/`)

| Endpoint | Method | Description | Auth Required |
|----------|--------|-------------|---------------|
| `/api/journal` | GET | List all entries for user | ✅ |
| `/api/journal` | POST | Save new entry | ✅ |
| `/api/journal/[id]` | DELETE | Delete entry (ownership verified) | ✅ |

#### Auth Library (`functions/lib/auth.js`)

Key functions:
- `hashPassword(password, salt?)` - PBKDF2 hashing
- `verifyPassword(password, storedHash, storedSalt)` - Timing-safe comparison
- `createSession(db, userId, metadata)` - Generate session token
- `validateSession(db, token)` - Verify and refresh session
- `getSessionFromCookie(cookieHeader)` - Extract token from cookies
- `createSessionCookie(token, expiresAt)` - Secure cookie header

### Frontend (React)

#### Context & Hooks

**`AuthContext` (`src/contexts/AuthContext.jsx`)**
- Global auth state (user, loading, error)
- Methods: `register()`, `login()`, `logout()`, `checkAuth()`
- Wraps entire app in `main.jsx`

**`useJournal` Hook (`src/hooks/useJournal.js`)**
- Automatic routing based on `isAuthenticated` state
- Methods: `saveEntry()`, `deleteEntry()`, `migrateToCloud()`
- Returns: `entries`, `loading`, `error`

#### Components

**`AuthModal` (`src/components/AuthModal.jsx`)**
- Login/register UI with form validation
- Email, username, password fields
- Error and success states
- Accessible and responsive

**Updated `Journal.jsx`**
- Auth status banner
- Migration button for localStorage users
- Delete functionality for authenticated users
- Loading states

**Updated `TarotReading.jsx`**
- Uses `useJournal({ autoLoad: false }).saveEntry()` instead of direct localStorage
- Skips the journal fetch on mount to avoid duplicate network requests
- Automatic API/localStorage routing

---

## Usage Examples

### Registering a New User

```javascript
import { useAuth } from './contexts/AuthContext';

const { register } = useAuth();

const result = await register('user@example.com', 'username', 'password123');
if (result.success) {
  console.log('Registered:', result.user);
}
```

### Saving a Journal Entry

```javascript
import { useJournal } from './hooks/useJournal';

// Disable the initial fetch if you only need mutation helpers
const { saveEntry } = useJournal({ autoLoad: false });

const entry = {
  spread: 'Three-Card Story (Past · Present · Future)',
  spreadKey: 'threeCard',
  question: 'What do I need to know?',
  cards: [
    { position: 'Past', name: 'The Fool', orientation: 'Upright' },
    { position: 'Present', name: 'The Magician', orientation: 'Reversed' },
    { position: 'Future', name: 'The High Priestess', orientation: 'Upright' }
  ],
  personalReading: 'Your narrative text here...',
  themes: { /* theme data */ },
  reflections: { /* user notes */ }
};

const result = await saveEntry(entry);
// Automatically saves to API if authenticated, localStorage otherwise
```

### Migrating localStorage to Cloud

```javascript
const { migrateToCloud } = useJournal();

const result = await migrateToCloud();
console.log(`Migrated ${result.migrated} entries`);
// localStorage is cleared after successful migration
```

---

## Database Schema Reference

### `users` Table

| Column | Type | Description |
|--------|------|-------------|
| `id` | TEXT (PK) | UUID |
| `email` | TEXT (UNIQUE) | User email (lowercase) |
| `username` | TEXT (UNIQUE) | Display name |
| `password_hash` | TEXT | PBKDF2 derived hash |
| `password_salt` | TEXT | Hex-encoded salt |
| `created_at` | INTEGER | Unix timestamp |
| `updated_at` | INTEGER | Unix timestamp |
| `last_login_at` | INTEGER | Unix timestamp |
| `is_active` | INTEGER | Boolean (1/0) |
| `email_verified` | INTEGER | Boolean (future feature) |

### `sessions` Table

| Column | Type | Description |
|--------|------|-------------|
| `id` | TEXT (PK) | Session token (UUID) |
| `user_id` | TEXT (FK) | Reference to users.id |
| `created_at` | INTEGER | Unix timestamp |
| `expires_at` | INTEGER | Unix timestamp (30 days) |
| `last_used_at` | INTEGER | Updated on each request |
| `user_agent` | TEXT | Browser info |
| `ip_address` | TEXT | CF-Connecting-IP header |

### `journal_entries` Table

| Column | Type | Description |
|--------|------|-------------|
| `id` | TEXT (PK) | UUID |
| `user_id` | TEXT (FK) | Reference to users.id |
| `created_at` | INTEGER | Unix timestamp |
| `updated_at` | INTEGER | Unix timestamp |
| `spread_key` | TEXT | Spread identifier (e.g., 'threeCard') |
| `spread_name` | TEXT | Human-readable spread name |
| `question` | TEXT | User's question (nullable) |
| `cards_json` | TEXT | JSON array of card objects |
| `narrative` | TEXT | Generated reading text |
| `themes_json` | TEXT | JSON object of themes/insights |
| `reflections_json` | TEXT | JSON object of user notes |
| `context` | TEXT | Reading context (love, career, etc.) |
| `provider` | TEXT | 'azure-gpt5' or 'local' |
| `session_seed` | TEXT | Ritual seed for reproducibility |

---

## Security Best Practices

### Password Requirements
- Minimum 8 characters
- Validated client-side and server-side
- PBKDF2 with 100,000 iterations (OWASP minimum)

### Session Management
- HTTP-only cookies prevent XSS access
- SameSite=Lax prevents CSRF attacks
- Secure flag requires HTTPS in production
- 30-day expiration with automatic cleanup

### Input Validation
- Email format validation (`isValidEmail`)
- Username pattern: 3-30 chars, alphanumeric + underscore (`isValidUsername`)
- Server-side validation on all endpoints

### Database Access
- Prepared statements prevent SQL injection
- Ownership verification on DELETE operations
- Foreign key constraints enforce referential integrity

---

## Troubleshooting

### Sessions not persisting

**Problem:** User logged out after refresh
**Solution:** Check that cookies are enabled and HTTPS is used in production

### Migration fails

**Problem:** "Not authenticated" error during migration
**Solution:** Ensure user is logged in before calling `migrateToCloud()`

### Duplicate email/username

**Problem:** Registration fails with conflict error
**Solution:** Email and username must be unique; users should use different credentials

### Journal entries not loading

**Problem:** Empty journal after login
**Solution:** Check D1 binding in `wrangler.toml` and ensure migrations ran successfully

### CORS errors in local development

**Problem:** API calls fail with CORS errors
**Solution:** Run `npx wrangler pages dev dist` instead of `npm run dev` to test with Functions

---

## API Reference

### POST `/api/auth/register`

**Request:**
```json
{
  "email": "user@example.com",
  "username": "myusername",
  "password": "securepass123"
}
```

**Response (201):**
```json
{
  "success": true,
  "user": {
    "id": "uuid-here",
    "email": "user@example.com",
    "username": "myusername"
  }
}
```

**Errors:**
- `400` - Invalid input (missing fields, invalid format)
- `409` - Email or username already exists
- `500` - Internal server error

### POST `/api/auth/login`

**Request:**
```json
{
  "email": "user@example.com",
  "password": "securepass123"
}
```

**Response (200):**
```json
{
  "success": true,
  "user": {
    "id": "uuid-here",
    "email": "user@example.com",
    "username": "myusername"
  }
}
```

**Errors:**
- `400` - Missing email or password
- `401` - Invalid credentials
- `403` - Account inactive
- `500` - Internal server error

### POST `/api/journal`

**Request:**
```json
{
  "spread": "Three-Card Story",
  "spreadKey": "threeCard",
  "question": "What do I need to know?",
  "cards": [
    { "position": "Past", "name": "The Fool", "orientation": "Upright" }
  ],
  "personalReading": "Your narrative...",
  "themes": {},
  "reflections": {},
  "context": "self",
  "provider": "azure-gpt5",
  "sessionSeed": "abc123"
}
```

**Response (201):**
```json
{
  "success": true,
  "entry": {
    "id": "uuid-here",
    "ts": 1700000000000
  }
}
```

---

## Future Enhancements

- [ ] Email verification
- [ ] Password reset flow
- [ ] Export journal as PDF/JSON
- [ ] Share readings via unique URLs
- [ ] OAuth providers (Google, GitHub)
- [ ] Two-factor authentication

---

## Resources

- [Cloudflare D1 Documentation](https://developers.cloudflare.com/d1/)
- [Web Crypto API](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/)
- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)
- [Pages Functions](https://developers.cloudflare.com/pages/functions/)
</file>

<file path="docs/journal-gap-assessment.md">
# Journal redesign gap assessment (2025-12-04)

## Snapshot

- ✅ Two-pane layout, summary band with stats, month headers, and compact toggle shipped as described in [`Journal.jsx`](src/components/Journal.jsx#L563-L675) and [`JournalEntryCard`](src/components/JournalEntryCard.jsx#L205-L335).
- ✅ Insights rail hosts filters, analytics, and archetype journey with a sticky toolbar per [`Journal.jsx`](src/components/Journal.jsx#L452-L480) and [`JournalInsightsPanel`](src/components/JournalInsightsPanel.jsx#L665-L839).
- ⚠️ Inline status feedback is still handled through toast notifications in entry cards and insights toolbar (see [`JournalEntryCard.handleEntryCopy()`](src/components/JournalEntryCard.jsx#L143-L150) and [`JournalInsightsPanel.handleExport()`](src/components/JournalInsightsPanel.jsx#L214-L220)), leaving the "no floating toasts required" goal unmet.
- ⚠️ Mobile "accordion" treatment for the rail is approximated with a segmented control, but filters/insights/archetype collapse together rather than as individual accordion panels (`Journal.jsx` mobile sections at [`Journal.jsx`](src/components/Journal.jsx#L605-L749)).
- ⚠️ Saved filters slot remains a disabled placeholder (`JournalFilters` at [`JournalFilters.jsx`](src/components/JournalFilters.jsx#L182-L189)) and button/chip tokens could use a final consistency sweep across entry footer & toolbar controls.

## Component-by-component review

### Journal layout (`Journal.jsx`)

- ✅ Summary band exposes entries, reversal %, top context, and last entry with a single dominant CTA (`New entry`) in [`Journal.jsx`](src/components/Journal.jsx#L563-L602).
- ✅ Desktop grid + sticky rail implemented via `lg:grid` container and `lg:sticky lg:top-6` wrapper ([`Journal.jsx`](src/components/Journal.jsx#L630-L744)).
- ⚠️ Mobile segmentation (`MOBILE_SECTIONS`) swaps entire rail content instead of discrete accordions, so filters/insights/archetype cannot be expanded independently ([`Journal.jsx`](src/components/Journal.jsx#L605-L748)).

### Journal entry cards (`JournalEntryCard.jsx`)

- ✅ Collapsed preview shows spread, context chip, timestamp, quoted question, and first cards with reversal marker ([`JournalEntryCard`](src/components/JournalEntryCard.jsx#L205-L269)).
- ✅ Compact mode adjusts spacing via `headerPadding`/`contentPadding` and keeps labels on desktop/mobile actions ([`JournalEntryCard`](src/components/JournalEntryCard.jsx#L196-L205), [`JournalEntryCard`](src/components/JournalEntryCard.jsx#L395-L492)).
- ⚠️ Copy/export/share/delete actions emit ToastContext messages instead of inline feedback ([`JournalEntryCard.handleEntryCopy()`](src/components/JournalEntryCard.jsx#L143-L150), [`handleEntryExport()`](src/components/JournalEntryCard.jsx#L134-L141), [`handleEntryShare()`](src/components/JournalEntryCard.jsx#L152-L188)).

### Journal filters (`JournalFilters.jsx`)

- ✅ Timeframe, context, spread, deck dropdowns share the same rounded-xl pattern and focus styles ([`JournalFilters.jsx`](src/components/JournalFilters.jsx#L157-L244)).
- ⚠️ "Saved filters" placeholder is disabled rather than reserving a functional slot, leaving the future affordance unfinished ([`JournalFilters.jsx`](src/components/JournalFilters.jsx#L182-L189)).
- ⚠️ Secondary button styles differ slightly between filters (`border-secondary/60`) and entry footer (`border-secondary/30`), so the "one outline rule" goal is only partially met.

### Insights panel (`JournalInsightsPanel.jsx`)

- ✅ Sticky toolbar with labeled actions implemented ([`JournalInsightsPanel`](src/components/JournalInsightsPanel.jsx#L685-L729)), share link list surfaces copy/delete controls with inline feedback ([`JournalInsightsPanel`](src/components/JournalInsightsPanel.jsx#L923-L958)).
- ⚠️ Primary share/export/PDF/visual-card actions still rely on toasts for success/error messaging (`handleExport`, `handlePdfDownload`, `handleVisualCardDownload`, `handleShare` at [`JournalInsightsPanel.jsx`](src/components/JournalInsightsPanel.jsx#L214-L345)), contrary to the "inline feedback" requirement.

### Archetype journey section (`ArchetypeJourneySection.jsx`)

- ✅ Header exposes `analytics.currentMonth`, monthly stats, and divider-separated blocks ([`ArchetypeJourneySection`](src/components/ArchetypeJourneySection.jsx#L424-L444)).
- ✅ Empty state backfill CTA with stats and aria labels present ([`ArchetypeJourneySection`](src/components/ArchetypeJourneySection.jsx#L80-L148)).
- ⚠️ After a successful backfill, "last run / entries processed" appears only within the temporary result block and is not persisted once analytics load, so users lose the run timestamp once the empty state clears ([`ArchetypeJourneySection`](src/components/ArchetypeJourneySection.jsx#L93-L144)).

### Accessibility & spacing

- ✅ Sections employ consistent rounded-3xl shells and prose width caps ([`Journal.jsx`](src/components/Journal.jsx#L630-L736), [`JournalEntryCard`](src/components/JournalEntryCard.jsx#L205-L393)).
- ⚠️ Focus indicators exist, but final audit for button/chip variants and inline status replacements is still outstanding to satisfy the "no floating toasts needed" acceptance criterion.

## Recommended implementation order & effort sizing

1. **Inline status feedback refactor (S, ~1 day)**
   Replace ToastContext usage in `JournalEntryCard` and `JournalInsightsPanel` with inline status text/icons near the action buttons; introduce transient state per action. Touchpoints: [`JournalEntryCard`](src/components/JournalEntryCard.jsx#L134-L188), [`JournalEntryCard`](src/components/JournalEntryCard.jsx#L395-L492), [`JournalInsightsPanel`](src/components/JournalInsightsPanel.jsx#L214-L345), [`JournalInsightsPanel`](src/components/JournalInsightsPanel.jsx#L685-L729).

2. **Mobile rail accordion & persistence tweaks (M, ~2-3 days)**
   Rework mobile view so filters, insights, and archetype journey render as independent accordion panels with their own expand/collapse state, preserving sticky behavior on larger breakpoints. Touchpoint: [`Journal.jsx`](src/components/Journal.jsx#L605-L748) plus potential layout helpers.

3. **Saved filters slot & button token sweep (M, ~2 days)**
   Implement the saved filter surface (even a minimal list + CTA) and normalize outline/fill tokens across filters, entry footer, and insights toolbar for consistent visual language. Touchpoints: [`JournalFilters`](src/components/JournalFilters.jsx#L182-L244), [`JournalEntryCard`](src/components/JournalEntryCard.jsx#L395-L492), [`JournalInsightsPanel`](src/components/JournalInsightsPanel.jsx#L685-L729).

4. **Archetype journey run metadata persistence (S, ~0.5 day)**
   Surface the last backfill timestamp and entries processed inside the populated card header so the context remains visible after analytics load ([`ArchetypeJourneySection`](src/components/ArchetypeJourneySection.jsx#L424-L435)).

5. **Follow-up QA sweep (S, ~0.5 day)**
   Re-run keyboard/screen-reader flows, mobile responsiveness, and empty/filtered states once inline statuses and accordion behavior are updated to close out the acceptance criteria checklist.
</file>

<file path="docs/journal-redesign.md">
# Journal Redesign & Enhancement Plan

Context pulled from `Tableu33.png` and the current implementation (`src/components/Journal.jsx`, `JournalEntryCard.jsx`, `JournalFilters.jsx`, `JournalInsightsPanel.jsx`, `ArchetypeJourneySection.jsx`, hooks in `src/hooks/useJournal.js` and `useSaveReading.js`).

## Goals
- Reduce scroll fatigue and make “what to do now” obvious.
- Improve scannability of entries and insights; separate “today” from “history.”
- Tighten visual system (buttons, chips, spacing) while preserving the dark theme and Tailwind tokens.
- Make archetype analytics and sharing/export feel integrated, not bolted on.
- Maintain accessibility: labeled controls, consistent focus states, keyboard reachability.

## Current State (summary)
- Single-column stack of cards; prompts/reports/requests read as a long uniform list.
- Primary actions (e.g., submit entry, share/export) look similar to minor controls.
- Mixed chip and button treatments; icon-only actions lack labels/tooltips.
- Insights and filters scroll away; archetype analytics are isolated and sometimes empty.
- Entry cards hide reflections and use a light preview; share/export feedback floats.

## Proposed Information Architecture
- **Two-pane layout on desktop**: main column for entry creation/history; right rail for filters + insights + archetype journey. Use `lg:grid lg:grid-cols-[1fr_360px] lg:gap-6` and a sticky rail (`lg:sticky lg:top-6`).
- **Mobile**: keep a single column but add top tabs/segmented control for Today / Insights / History; collapse rail into accordion sections.
- **Anchors**: top summary band with stats (entries, reversal %, top context, last entry) and a single primary CTA (start/new entry). Section headers for Today, Insights, History.

## Component-level Changes
### Journal page (`src/components/Journal.jsx`)
- Add a top summary band using `allStats/filteredStats` (entries count, reversal %, top context, last entry date) plus a primary CTA (e.g., “Start a reading” or “New entry”).
- Restructure layout into main + sticky rail. Rail hosts `JournalFilters`, `JournalInsightsPanel`, `ArchetypeJourneySection` (authed only).
- Introduce a “Compact list” toggle (state in Journal) that passes a prop to `JournalEntryCard` to render a condensed list on desktop.
- Paginate or virtualize history beyond the first batch; at minimum, retain batching but add month headers to break monotony.

### Entry cards (`src/components/JournalEntryCard.jsx`)
- Collapsed state should show: spread name, context chip, formatted date, 1-line question, first 2–3 card names (with reversal marker), and optionally a small reflections indicator.
- Add an optional `compact` mode: tighter padding, single-line preview, icons with labels on hover (desktop), always label on mobile.
- Move action buttons into a consistent footer bar with labels/tooltips (Copy, Export CSV, Share, Delete). Use the kebab menu only for small screens.
- Replace floating status toast with inline status text in the footer.
- Surface `reflections` (per-card notes) beneath Cards or as a small list; ensure orientation and spread position are visible.
- Keep `personalReading` toggle but cap width and line length; ensure markdown prose uses readable line height.

### Filters (`src/components/JournalFilters.jsx`)
- Normalize chip/button styling to a single pattern (one radius, one outline rule). Primary vs secondary: accent-filled for main CTA, ghost/outline for utility.
- Add a “Saved filters” slot if needed later; keep clear/reset visible but low-emphasis.

### Insights & share/export (`src/components/JournalInsightsPanel.jsx`)
- Replace dual “Show/Hide” pills with a single toolbar under the header containing labeled buttons: Share, Export CSV, PDF, Visual Card, Custom Link (if authed).
- Make the toolbar sticky within the panel to stay visible while scrolling analytics.
- Keep text labels next to icons for accessibility; ensure focus states.
- If filtered view is empty, show a small explainer (“Filters empty, using full journal”) instead of repeating the action message.

### Archetype Journey (`src/components/ArchetypeJourneySection.jsx` + `src/lib/archetypeJourney.js`)
- Keep placement in the right rail near insights. When empty, show the backfill CTA inline with a tiny “last run / entries processed” caption after a run.
- Expose `analytics.currentMonth` and `stats` in the card header for context; add subtle dividers between Top Cards, Recent Patterns, Achievements.
- Ensure backfill and badge icons have aria-label/title; keep skeletons consistent with rail cards.

### Sharing and export (`src/components/JournalEntryCard.jsx`, `JournalInsightsPanel.jsx`)
- Consolidate per-entry share/export into the footer bar with labels.
- In the panel, show active links in a list with copy/delete icons plus labels; keep text truncation and view counts.
- Provide clear copy feedback inline (not floating).

### Accessibility and spacing
- Standardize padding scale for cards/sections; avoid cramped input/button clusters.
- Add `aria-label`/`title` to icon-only buttons (copy/export/share/backfill/kebab). Keep visible focus rings.
- Slightly increase base font size for body text; cap narrative text width.

## Implementation Outline (incremental)
1) **Layout skeleton** (`Journal.jsx`): add grid + sticky rail; introduce summary band; wire “Compact list” state.
2) **Entry cards**: add compact mode, richer preview, footer actions, inline status; render reflections.
3) **Insights panel**: build labeled sticky toolbar; simplify show/hide controls; tighten share/export messages.
4) **Archetype journey**: surface last updated/backfill stats; ensure aria labels; align styling with rail cards.
5) **Styling sweep**: unify chip/button variants across Filters/Entries/Insights; adjust padding/typography; audit focus states.

## QA Checklist
- Keyboard: tab through filters, toolbar buttons, entry actions, and Archetype Journey backfill; focus rings visible.
- Screen reader: icon-only buttons announce purpose; section headers logical (Today, Insights, History).
- Responsive: desktop two-pane works ≥1024px; rail collapses or becomes accordion on mobile; compact list toggle behaves.
- Data states: empty journal, filtered empty, loading states (skeletons), share link creation failures, archetype backfill success/fail.
- Exports/sharing: CSV download, clipboard copy, PDF/visual card flows; entry-level share when authed vs guest fallback.

## Acceptance Criteria
- Primary CTA clearly visible in the summary band; only one dominant “entry” button on the page.
- Insights/filters/archetype stay accessible without excessive scroll (sticky rail desktop; top-placed accordion mobile).
- Entry list is scannable with context/question/cards visible when collapsed; actions are labeled and consistent.
- Visual system uses a unified button/chip style across journal surfaces.
- Accessibility: labeled icon buttons, visible focus, no floating status toasts needed to understand outcomes.
</file>

<file path="docs/narrativebuilderenhancements.md">
# Narrative Builder Enhancement Integration Guide

## 1. GraphRAG Passage Quality Control

### Current State

Passages are retrieved via [`retrievePassages()`](functions/lib/graphRAG.js) and injected without relevance scoring against the user's specific question.

### Enhancement: Semantic Similarity Filtering

**Step 1: Add similarity scoring to [`graphRAG.js`](functions/lib/graphRAG.js)**

```javascript
// functions/lib/graphRAG.js

import { cosineSimilarity, embedText } from "./embeddings.js"; // New dependency

/**
 * Score passage relevance against user query
 * @param {string} passage - The passage text
 * @param {string} userQuery - User's question
 * @param {Object} options - Scoring options
 * @returns {number} Relevance score 0-1
 */
export async function scorePassageRelevance(passage, userQuery, options = {}) {
  const { keywordWeight = 0.3, semanticWeight = 0.7 } = options;

  if (!userQuery || !passage) return 0.5; // Default neutral score

  // Keyword overlap scoring (fast, cheap)
  const queryTerms = userQuery
    .toLowerCase()
    .split(/\W+/)
    .filter((t) => t.length > 3);
  const passageText = passage.toLowerCase();
  const keywordMatches = queryTerms.filter((term) =>
    passageText.includes(term)
  );
  const keywordScore =
    queryTerms.length > 0 ? keywordMatches.length / queryTerms.length : 0;

  // Semantic similarity (requires embeddings API)
  let semanticScore = 0.5;
  if (options.enableSemanticScoring) {
    try {
      const [queryEmbed, passageEmbed] = await Promise.all([
        embedText(userQuery),
        embedText(passage.slice(0, 500)), // Truncate for efficiency
      ]);
      semanticScore = cosineSimilarity(queryEmbed, passageEmbed);
    } catch (err) {
      console.warn("[GraphRAG] Semantic scoring failed:", err.message);
    }
  }

  return keywordScore * keywordWeight + semanticScore * semanticWeight;
}

/**
 * Enhanced retrieval with quality filtering
 */
export function retrievePassagesWithQuality(graphKeys, options = {}) {
  const {
    maxPassages = 5,
    userQuery = "",
    minRelevanceScore = 0.3,
    enableDeduplication = true,
  } = options;

  // Get raw passages
  const rawPassages = retrievePassages(graphKeys, {
    maxPassages: maxPassages * 2,
  });

  // Score and filter
  const scoredPassages = rawPassages.map((passage) => ({
    ...passage,
    relevanceScore: scorePassageRelevance(passage.text, userQuery, {
      enableSemanticScoring: options.enableSemanticScoring,
    }),
  }));

  // Filter by quality threshold
  let filtered = scoredPassages.filter(
    (p) => p.relevanceScore >= minRelevanceScore
  );

  // Deduplicate similar passages
  if (enableDeduplication) {
    filtered = deduplicatePassages(filtered);
  }

  // Sort by relevance and take top N
  return filtered
    .sort((a, b) => b.relevanceScore - a.relevanceScore)
    .slice(0, maxPassages);
}

/**
 * Remove passages with >80% content overlap
 */
function deduplicatePassages(passages) {
  const seen = new Set();
  return passages.filter((passage) => {
    // Generate content fingerprint (first 100 chars normalized)
    const fingerprint = passage.text
      .toLowerCase()
      .replace(/\s+/g, " ")
      .slice(0, 100);

    if (seen.has(fingerprint)) return false;
    seen.add(fingerprint);
    return true;
  });
}
```

**Step 2: Update [`prompts.js`](functions/lib/narrative/prompts.js:321) to use quality-filtered retrieval**

```javascript
// In buildSystemPrompt() around line 324
if (
  includeGraphRAG &&
  isGraphRAGEnabled() &&
  themes?.knowledgeGraph?.graphKeys
) {
  try {
    // Use quality-filtered retrieval
    const { retrievePassagesWithQuality } = await import("../graphRAG.js");

    const retrievedPassages = retrievePassagesWithQuality(
      themes.knowledgeGraph.graphKeys,
      {
        maxPassages: getPassageCountForSpread(effectiveSpreadKey),
        userQuery: userQuestion,
        minRelevanceScore: 0.35,
        enableDeduplication: true,
        enableSemanticScoring: Boolean(options.enableSemanticScoring),
      }
    );

    // Only inject if we have quality passages
    if (retrievedPassages.length > 0) {
      const avgRelevance =
        retrievedPassages.reduce((sum, p) => sum + p.relevanceScore, 0) /
        retrievedPassages.length;
      console.log(
        `[GraphRAG] Injecting ${
          retrievedPassages.length
        } passages (avg relevance: ${(avgRelevance * 100).toFixed(1)}%)`
      );
      // ... rest of injection logic
    }
  } catch (err) {
    console.error("[GraphRAG] Quality retrieval failed:", err.message);
  }
}
```

---

## 2. Dynamic Prompt Structure for Returning Users

### Current State

The system prompt in [`buildSystemPrompt()`](functions/lib/narrative/prompts.js:266) is static per request.

### Enhancement: Previous Reading Context

**Step 1: Create user context store**

```javascript
// functions/lib/userContext.js

/**
 * User reading history for context continuity
 */
export async function getUserReadingContext(userId, env) {
  if (!userId || !env?.USER_CONTEXT_KV) return null;

  try {
    const key = `user:${userId}:context`;
    const stored = await env.USER_CONTEXT_KV.get(key, { type: "json" });
    return stored;
  } catch (err) {
    console.warn("[UserContext] Failed to retrieve:", err.message);
    return null;
  }
}

export async function updateUserReadingContext(userId, env, readingData) {
  if (!userId || !env?.USER_CONTEXT_KV) return;

  const key = `user:${userId}:context`;
  const existing = (await getUserReadingContext(userId, env)) || {
    readingCount: 0,
    recentThemes: [],
    frequentCards: {},
    lastReadingDate: null,
    feedbackHistory: [],
  };

  // Update context with new reading
  const updated = {
    readingCount: existing.readingCount + 1,
    recentThemes: [
      ...new Set([
        ...(readingData.themes?.suitFocus
          ? [readingData.themes.suitFocus]
          : []),
        ...existing.recentThemes,
      ]),
    ].slice(0, 5),
    frequentCards: updateCardFrequency(
      existing.frequentCards,
      readingData.cards
    ),
    lastReadingDate: new Date().toISOString(),
    lastSpread: readingData.spreadKey,
    lastContext: readingData.context,
    feedbackHistory: existing.feedbackHistory,
  };

  await env.USER_CONTEXT_KV.put(key, JSON.stringify(updated), {
    expirationTtl: 60 * 60 * 24 * 90, // 90 days
  });

  return updated;
}

function updateCardFrequency(existing, cards) {
  const updated = { ...existing };
  cards.forEach((card) => {
    const name = card.card || card.name;
    if (name) {
      updated[name] = (updated[name] || 0) + 1;
    }
  });
  // Keep top 20 most frequent
  return Object.fromEntries(
    Object.entries(updated)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 20)
  );
}
```

**Step 2: Integrate into prompt building**

```javascript
// In buildSystemPrompt() - add new parameter and section
function buildSystemPrompt(
  spreadKey,
  themes,
  context,
  deckStyle,
  userQuestion,
  options = {}
) {
  const { userContext } = options;
  const lines = [
    /* ... existing lines ... */
  ];

  // Add returning user context if available
  if (userContext && userContext.readingCount > 1) {
    lines.push(
      "",
      "RETURNING USER CONTEXT",
      `- This is reading #${userContext.readingCount} for this querent.`
    );

    if (userContext.lastReadingDate) {
      const daysSince = Math.floor(
        (Date.now() - new Date(userContext.lastReadingDate).getTime()) /
          (1000 * 60 * 60 * 24)
      );
      lines.push(`- Last reading was ${daysSince} day(s) ago.`);
    }

    if (userContext.recentThemes?.length > 0) {
      lines.push(
        `- Recent themes: ${userContext.recentThemes.slice(0, 3).join("; ")}`
      );
    }

    // Flag frequently appearing cards
    const frequentInThisReading = options.cardsInfo?.filter(
      (card) => userContext.frequentCards?.[card.card] >= 3
    );
    if (frequentInThisReading?.length > 0) {
      const names = frequentInThisReading.map((c) => c.card).join(", ");
      lines.push(
        `- Recurring cards (3+ appearances): ${names}. Consider acknowledging this pattern.`
      );
    }

    lines.push(
      "- Reference past themes briefly if they resonate with current cards, but prioritize the present spread."
    );
  }

  return lines.join("\n");
}
```

**Step 3: Add feedback learning**

```javascript
// functions/api/reading-feedback.js (new endpoint)

export const onRequestPost = async ({ request, env }) => {
  const { userId, requestId, feedback } = await request.json();

  if (!userId || !feedback) {
    return jsonResponse(
      { error: "Missing userId or feedback" },
      { status: 400 }
    );
  }

  // Store feedback
  const context = await getUserReadingContext(userId, env);
  if (context) {
    context.feedbackHistory = [
      { requestId, feedback, timestamp: Date.now() },
      ...(context.feedbackHistory || []),
    ].slice(0, 10); // Keep last 10

    await env.USER_CONTEXT_KV.put(
      `user:${userId}:context`,
      JSON.stringify(context)
    );
  }

  // Extract learnings for prompt adjustment
  const learnings = extractFeedbackLearnings(context.feedbackHistory);

  return jsonResponse({ success: true, learnings });
};

function extractFeedbackLearnings(history) {
  if (!history || history.length < 3) return null;

  // Analyze patterns
  const sentiments = history.map((h) => h.feedback.sentiment);
  const avgSentiment =
    sentiments.reduce((a, b) => a + b, 0) / sentiments.length;

  return {
    prefersConcise:
      history.filter((h) => h.feedback.tooLong).length > history.length / 2,
    prefersMoreEsoteric:
      history.filter((h) => h.feedback.wantsMoreDepth).length >
      history.length / 2,
    avgSatisfaction: avgSentiment,
  };
}
```

---

## 3. Narrative Spine Validation Enforcement

### Current State

[`validateReadingNarrative()`](functions/lib/narrativeSpine.js:328) only logs suggestions; incomplete sections pass through.

### Enhancement: Hard Enforcement with Auto-Repair

**Step 1: Add enforcement mode to validation**

```javascript
// functions/lib/narrativeSpine.js

/**
 * Validate and optionally enforce spine structure
 * @param {string} readingText - The narrative to validate
 * @param {Object} options - Validation options
 * @param {boolean} options.enforceCompleteness - Fail if sections incomplete
 * @param {boolean} options.autoRepair - Attempt to fix incomplete sections
 * @param {number} options.minCompletionRate - Minimum % of complete sections (0-1)
 */
export function validateReadingNarrative(readingText, options = {}) {
  const {
    enforceCompleteness = false,
    autoRepair = false,
    minCompletionRate = 0.7,
  } = options;

  // ... existing parsing logic ...

  const incompleteCount = analyses.filter((a) => !a.analysis.isComplete).length;
  const completionRate =
    sections.length > 0
      ? (sections.length - incompleteCount) / sections.length
      : 1;

  const result = {
    isValid: incompleteCount === 0,
    completionRate,
    totalSections: sections.length,
    completeSections: sections.length - incompleteCount,
    incompleteSections: incompleteCount,
    sectionAnalyses: analyses,
    suggestions: [],
  };

  // Enforcement mode
  if (enforceCompleteness) {
    if (completionRate < minCompletionRate) {
      result.enforcementFailed = true;
      result.enforcementReason = `Completion rate ${(
        completionRate * 100
      ).toFixed(0)}% below threshold ${(minCompletionRate * 100).toFixed(0)}%`;
    }
  }

  // Auto-repair mode
  if (autoRepair && incompleteCount > 0) {
    result.repairedText = autoRepairNarrative(readingText, analyses);
    result.repairsApplied = true;
  }

  return result;
}

/**
 * Auto-repair incomplete narrative sections
 */
function autoRepairNarrative(readingText, analyses) {
  let repaired = readingText;

  analyses.forEach(({ header, analysis }) => {
    if (analysis.isComplete) return;

    const missing = analysis.missing || [];
    const repairs = [];

    if (missing.includes("what")) {
      // Can't auto-repair WHAT without card context
      repairs.push("*[Situation context needed]*");
    }

    if (missing.includes("why")) {
      repairs.push(
        "This dynamic emerges from the interplay of energies present in your spread."
      );
    }

    if (missing.includes("whatsNext")) {
      repairs.push(
        "Consider what small, intentional step might honor this insight as you move forward."
      );
    }

    if (repairs.length > 0) {
      // Find section and append repairs
      const sectionPattern = new RegExp(
        `(${escapeRegex(header)}[^]*?)(?=###|$)`,
        "i"
      );
      repaired = repaired.replace(sectionPattern, (match) => {
        return match.trimEnd() + "\n\n" + repairs.join(" ") + "\n\n";
      });
    }
  });

  return repaired;
}
```

**Step 2: Update quality gate in [`tarot-reading.js`](functions/api/tarot-reading.js:526)**

```javascript
// In the quality gate section
const qualityMetrics = buildNarrativeMetrics(result, cardsInfo, deckStyle);

// Enhanced spine validation with enforcement
const spineValidation = validateReadingNarrative(result, {
  enforceCompleteness: true,
  autoRepair: true,
  minCompletionRate: 0.6, // At least 60% of sections must be complete
});

if (spineValidation.enforcementFailed) {
  // Try auto-repair first
  if (spineValidation.repairedText) {
    console.log(
      `[${requestId}] Auto-repaired ${spineValidation.incompleteSections} incomplete sections`
    );
    result = spineValidation.repairedText;
    // Re-validate after repair
    const revalidation = validateReadingNarrative(result, {
      enforceCompleteness: true,
    });
    if (revalidation.enforcementFailed) {
      qualityIssues.push(
        `narrative structure incomplete: ${revalidation.enforcementReason}`
      );
    }
  } else {
    qualityIssues.push(
      `narrative structure incomplete: ${spineValidation.enforcementReason}`
    );
  }
}
```

**Step 3: Add per-section requirements**

```javascript
// functions/lib/narrativeSpine.js

const SECTION_REQUIREMENTS = {
  nucleus: { what: true, why: true, whatsNext: false },
  timeline: { what: true, why: true, whatsNext: true },
  consciousness: { what: true, why: false, whatsNext: false },
  staff: { what: true, why: false, whatsNext: true },
  outcome: { what: true, why: true, whatsNext: true },
  guidance: { what: false, why: false, whatsNext: true },
  default: { what: true, why: false, whatsNext: false },
};

export function validateSectionCompleteness(sectionType, present) {
  const requirements =
    SECTION_REQUIREMENTS[sectionType] || SECTION_REQUIREMENTS.default;
  const failures = [];

  Object.entries(requirements).forEach(([element, required]) => {
    if (required && !present[element]) {
      failures.push(element);
    }
  });

  return {
    isComplete: failures.length === 0,
    missingRequired: failures,
    requirements,
  };
}
```

---

## 4. Timing Profile Refinement

### Current State

[`timingMeta.js`](functions/lib/timingMeta.js) produces binary timing (near-term-tilt/longer-arc-tilt).

### Enhancement: Granular Timing with Question Parsing

**Step 1: Enhanced temporal parsing**

```javascript
// functions/lib/timingMeta.js (enhanced)

const TEMPORAL_PATTERNS = {
  immediate: {
    patterns: [
      /today/i,
      /right now/i,
      /this moment/i,
      /immediately/i,
      /tonight/i,
    ],
    horizon: "days",
    days: 1,
  },
  thisWeek: {
    patterns: [/this week/i, /next few days/i, /coming days/i],
    horizon: "week",
    days: 7,
  },
  thisMonth: {
    patterns: [/this month/i, /next few weeks/i, /coming weeks/i, /soon/i],
    horizon: "month",
    days: 30,
  },
  thisSeason: {
    patterns: [
      /this season/i,
      /next few months/i,
      /coming months/i,
      /quarter/i,
    ],
    horizon: "season",
    days: 90,
  },
  thisYear: {
    patterns: [/this year/i, /next year/i, /coming year/i, /annual/i],
    horizon: "year",
    days: 365,
  },
  longTerm: {
    patterns: [
      /long term/i,
      /years/i,
      /life/i,
      /ever/i,
      /future/i,
      /eventually/i,
    ],
    horizon: "long-term",
    days: null, // Undefined horizon
  },
};

/**
 * Parse temporal intent from user question
 */
export function parseQuestionTiming(userQuestion) {
  if (!userQuestion) return { horizon: "unspecified", confidence: 0 };

  const q = userQuestion.toLowerCase();

  // Check each pattern category
  for (const [category, config] of Object.entries(TEMPORAL_PATTERNS)) {
    for (const pattern of config.patterns) {
      if (pattern.test(q)) {
        return {
          category,
          horizon: config.horizon,
          days: config.days,
          confidence: 0.8,
          matchedPattern: pattern.toString(),
        };
      }
    }
  }

  // Fallback: detect implicit timing from question type
  if (/will\s+\w+\s+(happen|come|arrive|change)/i.test(q)) {
    return { horizon: "future-focused", confidence: 0.5, implicit: true };
  }

  if (/should\s+i/i.test(q)) {
    return { horizon: "decision-point", confidence: 0.6, implicit: true };
  }

  return { horizon: "unspecified", confidence: 0 };
}

/**
 * Enhanced timing profile with granular signals
 */
export function analyzeTimingProfile(cardsInfo, options = {}) {
  const { userQuestion, spreadKey } = options;

  // Parse question timing
  const questionTiming = parseQuestionTiming(userQuestion);

  // Analyze card timing signals
  const cardSignals = analyzeCardTimingSignals(cardsInfo);

  // Combine signals
  const combined = combineTimingSignals(questionTiming, cardSignals, spreadKey);

  return {
    // Granular profile
    horizon: combined.primaryHorizon,
    horizonConfidence: combined.confidence,
    estimatedDays: combined.estimatedDays,

    // Legacy compatibility
    profile: mapToLegacyProfile(combined.primaryHorizon),

    // Detailed signals
    signals: {
      questionBased: questionTiming,
      cardBased: cardSignals,
      spreadModifier: getSpreadTimingModifier(spreadKey),
    },

    // Narrative guidance
    narrativeHint: generateTimingNarrativeHint(combined),
  };
}

function analyzeCardTimingSignals(cardsInfo) {
  const signals = {
    immediateIndicators: 0,
    developingIndicators: 0,
    longTermIndicators: 0,
  };

  const IMMEDIATE_CARDS = [
    "The Tower",
    "Ace of Wands",
    "Eight of Wands",
    "The Chariot",
  ];
  const LONG_TERM_CARDS = [
    "The Hermit",
    "The Hanged Man",
    "Four of Swords",
    "Seven of Pentacles",
  ];

  cardsInfo.forEach((card) => {
    const name = card.card || card.name;
    if (IMMEDIATE_CARDS.some((c) => name?.includes(c))) {
      signals.immediateIndicators++;
    }
    if (LONG_TERM_CARDS.some((c) => name?.includes(c))) {
      signals.longTermIndicators++;
    }
  });

  // Rank distribution affects timing
  const avgRank =
    cardsInfo.reduce((sum, c) => sum + (c.rankValue || 5), 0) /
    cardsInfo.length;
  if (avgRank <= 3) signals.immediateIndicators++;
  if (avgRank >= 8) signals.longTermIndicators++;

  return signals;
}

function generateTimingNarrativeHint(combined) {
  const { primaryHorizon, estimatedDays, confidence } = combined;

  if (confidence < 0.4) {
    return "The timing here is open—stay attentive to shifts as they emerge.";
  }

  const hints = {
    days: "These dynamics are quite immediate—expect movement within days if you engage actively.",
    week: "This energy is poised to shift within the week ahead.",
    month:
      "Give this pattern about a month to unfold; watch for early signals around the two-week mark.",
    season:
      "This story plays out across the coming season—plant seeds now and tend them consistently.",
    year: "This is a longer chapter that will take shape over the coming year.",
    "long-term":
      "This speaks to a life pattern rather than a specific timeline.",
    "decision-point":
      "The timing depends heavily on when you make your choice.",
    unspecified: "Trust your own sense of readiness as this unfolds.",
  };

  return hints[primaryHorizon] || hints.unspecified;
}
```

**Step 2: Integrate into prompt building**

```javascript
// In buildUserPrompt() - replace simple timing profile with enhanced version
if (activeThemes.timingAnalysis) {
  const timing = activeThemes.timingAnalysis;

  prompt += `**Timing Profile**:\n`;
  prompt += `- Horizon: ${timing.horizon}`;
  if (timing.estimatedDays) {
    prompt += ` (~${timing.estimatedDays} days)`;
  }
  prompt += `\n`;

  if (timing.signals?.questionBased?.confidence > 0.5) {
    prompt += `- Question suggests: ${timing.signals.questionBased.horizon}\n`;
  }

  prompt += `- Narrative hint: ${timing.narrativeHint}\n\n`;
}
```

**Step 3: Update [`analyzeSpreadThemes()`](functions/lib/spreadAnalysis.js) to use enhanced timing**

```javascript
// In analyzeSpreadThemes()
import { analyzeTimingProfile } from "./timingMeta.js";

// Replace simple timing analysis with enhanced version
const timingAnalysis = analyzeTimingProfile(cardsInfo, {
  userQuestion,
  spreadKey: getSpreadKeyFromName(spreadName),
});

return {
  // ... existing fields ...
  timingProfile: timingAnalysis.profile, // Legacy
  timingAnalysis, // Full enhanced analysis
};
```

---

## Summary

These four enhancements transform the system from a **static prompt generator** to an **adaptive, quality-controlled narrative engine**:

| Enhancement              | Impact                                      | Complexity |
| ------------------------ | ------------------------------------------- | ---------- |
| GraphRAG Quality Control | Better relevance, fewer irrelevant passages | Medium     |
| Dynamic Prompt Structure | Personalized readings for returning users   | High       |
| Spine Enforcement        | Guaranteed narrative completeness           | Medium     |
| Timing Refinement        | More nuanced temporal guidance              | Low-Medium |

**Recommended implementation order**:

1. Timing Refinement (lowest risk, immediate value)
2. Spine Enforcement (catches quality issues early)
3. GraphRAG Quality Control (improves grounding)
4. Dynamic Prompts (highest complexity, requires user auth)
</file>

<file path="docs/SYSTEM_ARCHITECTURE.md">
# System Architecture Guide: Mystic Tarot

## 1. Executive Summary

**Mystic Tarot** is a sophisticated AI-powered tarot reading application designed to bridge the gap between traditional cartomancy and modern generative AI. Unlike simple database-lookup tarot apps, it uses advanced Large Language Models (LLMs) to synthesize complex card relationships, positional meanings, and user context into cohesive, human-like narratives.

**Core Problem Solved:**
Digital tarot readings often feel robotic and disjointed. Mystic Tarot solves this by implementing a "Knowledge Graph" of tarot patterns (triads, dyads, suit progressions) and feeding this structured analysis into state-of-the-art LLMs to generate readings that feel intuitive, empathetic, and contextually aware.

**Primary Tech Stack:**
*   **Frontend:** React, Vite, Tailwind CSS
*   **Backend:** Cloudflare Pages Functions (Serverless), Node.js (ESM)
*   **Database:** Cloudflare D1 (SQLite-compatible)
*   **AI Services:** Azure OpenAI (GPT-5.1, GPT-4o-mini TTS), Anthropic Claude Sonnet 4.5
*   **Infrastructure:** Cloudflare Platform (Pages, KV, D1)

---

## 2. Architectural Map

### Entry Points
*   **Web Client (`src/main.jsx`):** The React Single Page Application (SPA) entry point.
    *   **Main Route (`/`):** `TarotReading.jsx` - The core orchestration layer for selecting spreads, drawing cards, and displaying results.
*   **API Gateway (`functions/api/`):** Serverless functions handling business logic.
    *   **Reading Generation:** `POST /api/tarot-reading` - The primary intelligence engine.
    *   **Text-to-Speech:** `POST /api/tts` - Generates audio for readings.

### Component Communication & Data Flow
1.  **User Interaction:** User selects a spread (e.g., Celtic Cross) and draws cards in the React frontend.
2.  **Request Construction:** Frontend bundles card data, spread metadata, and user question into a JSON payload.
3.  **Analysis Phase (Backend):**
    *   The `tarot-reading` function receives the payload.
    *   **Deterministic Analysis:** `functions/lib/spreadAnalysis.js` and `knowledgeGraph.js` analyze the cards for objective patterns (e.g., "3 of Swords + 10 of Swords = Painful Ending"). This ensures the AI doesn't hallucinate card meanings.
4.  **Narrative Generation (AI):**
    *   The structured analysis is converted into a complex system prompt.
    *   The request is routed to **Azure OpenAI (GPT-5.1)** or **Claude Sonnet 4.5** via the Responses API.
5.  **Response:** The AI returns a JSON object containing the narrative text and metadata, which is sent back to the frontend.
6.  **Persistence:** Reading data is asynchronously stored in **Cloudflare D1** for history and analytics.

### Database Schema (Cloudflare D1)
*   **`readings`**: Stores core reading metadata (ID, timestamp, spread type, provider).
*   **`cards`**: Relational table storing individual cards linked to a reading ID.
*   **`users` / `sessions`**: Manages authentication and session tokens.
*   **`journal_entries`**: Stores full reading text and user reflections for authenticated users.

---

## 3. Feature Extraction

### Core Capabilities
*   **Multi-Spread Support:** Implements logic for standard spreads (Celtic Cross, Three-Card) and custom layouts (Decision, Relationship).
*   **Context-Aware Readings:** Infers context (Love, Career, General) from user questions to tailor the interpretation.
*   **Pattern Detection Engine:** A custom "Knowledge Graph" detects advanced tarot concepts:
    *   *Elemental Dignities* (Fire vs. Water)
    *   *Suit Progressions* (Ace -> 10 arcs)
    *   *Archetypal Triads* (Specific 3-card combinations)
*   **Steerable Text-to-Speech:** Generates audio readings using Azure GPT-4o-mini, with specific instructions for tone (e.g., "mystical," "gentle," "contemplative").
*   **Vision Mode (Research):** Includes pipelines (`scripts/vision/`) and API hooks (`verifyVisionProof`) to validate physical card spreads via image recognition.

### User Stories
*   *As a user, I want to draw cards digitally so I can get a reading anytime.*
*   *As a user, I want to listen to my reading spoken aloud with a soothing voice.*
*   *As a user, I want to save my readings to a journal to reflect on them later.*
*   *As a developer, I want to ensure the AI respects the traditional meanings of cards and doesn't invent symbols.*

---

## 4. Integrations & Dependencies

### External Services
*   **Azure OpenAI Service:**
    *   **Models:** `gpt-5.1` (High-reasoning text), `gpt-4o-mini` (TTS).
    *   **Usage:** Primary narrative generation and audio synthesis.
*   **Anthropic API:**
    *   **Models:** `claude-sonnet-4.5`.
    *   **Usage:** Fallback or alternative narrative provider.

### Critical Libraries
*   **`@xenova/transformers`**: Used for local/browser-based ML tasks (likely vision prototype).
*   **`react-markdown` / `remark-gfm`**: Renders the AI-generated Markdown text in the UI.
*   **`lucide-react`**: Iconography.
*   **`tailwindcss`**: Utility-first styling framework.

### Infrastructure (Cloudflare)
*   **Pages Functions:** Hosts the API.
*   **D1 (SQLite):** Relational data storage.
*   **KV (Key-Value):** Used for rate limiting (`RATELIMIT` binding) and caching.

---

*Generated by GitHub Copilot based on codebase analysis.*
</file>

<file path="docs/UX_EVALUATION_REPORT.md">
# Tableu Tarot Reading Application - UX Evaluation Report

**Date:** November 22, 2025
**Evaluator:** UX Analysis Team
**Application:** Tableu - Tarot Reading Web Application

---

## Executive Summary

Tableu is a sophisticated tarot reading web application with a polished dark theme, elegant typography, and thoughtful interactions. The application demonstrates strong technical execution with smooth animations, responsive layouts, and accessibility considerations. However, several usability friction points, information hierarchy issues, and visual design inconsistencies present opportunities for significant UX improvements.

**Overall UX Score: 7.5/10**

### Key Strengths
- Elegant, cohesive dark mystic theme with warm gold accents
- Smooth, intentional animations that enhance the mystical experience
- Comprehensive responsive design with mobile-first approach
- Strong accessibility foundation (ARIA labels, keyboard navigation, focus states)
- Well-structured information architecture

### Key Opportunities
- Simplify cognitive load in preparation phase (too many collapsed sections)
- Improve visual hierarchy and contrast in critical UI elements
- Enhance onboarding and guidance for first-time users
- Reduce friction in mobile navigation patterns
- Clarify card interaction affordances

---

## 1. Visual Design Analysis

### 1.1 Color Palette & Theme

**Strengths:**
- **Cohesive Color System:** The elegant minimal palette with warm charcoal (`#0F0E13`), champagne gold (`#D4B896`), and muted accents creates a sophisticated mystical atmosphere
- **Semantic Color Tokens:** Well-organized CSS variables for backgrounds, text, and brand colors enable consistent theming
- **Suit-Specific Accents:** Thoughtful color coding for Minor Arcana suits (wands: gold, cups: silver-blue, swords: steel gray, pentacles: sage)

**Issues:**

1. **Potential Contrast Drift in Secondary Elements**
   - **Location:** [`src/styles/theme.css:52`](src/styles/theme.css:52)
   - **Fact Check:** The core token `--text-muted: #9B9388` on `--bg-surface: #1C1A22` actually yields **5.67:1** contrast (computed via the repo’s Node script), so the base palette satisfies WCAG AA.
   - **Problem:** When that token is combined with translucent backgrounds (`bg-surface-muted/60`, `bg-surface-muted/70`) or additional opacity, the rendered contrast can dip below AA.
   - **Affected Components:**
     * [`ReadingPreparation.jsx:102`](src/components/ReadingPreparation.jsx:102) - "Capture an intention..." helper text layered on `bg-surface-muted/60`
     * [`GlobalNav.jsx:17`](src/components/GlobalNav.jsx:17) - Inactive nav button text with `text-muted` over semi-transparent pills
     * [`SpreadSelector.jsx:158-159`](src/components/SpreadSelector.jsx:158-159) - Card count and description text on translucent cards
   - **Code Example:**
   ```css
   /* src/styles/theme.css:52 */
   --text-muted: #9B9388;  /* 5.67:1 vs --bg-surface before translucency is applied */
   ```

2. **Overuse of Opacity Creating Visual Uncertainty**
   - **Location:** Throughout components, particularly [`ReadingPreparation.jsx:104`](src/components/ReadingPreparation.jsx:104) and [`SpreadSelector.jsx:135`](src/components/SpreadSelector.jsx:135)
   - **Problem:** Layered transparencies compound readability issues
   - **Examples:**
   ```jsx
   /* ReadingPreparation.jsx:104 */
   className="...bg-surface-muted/60 border border-accent/20..."

   /* SpreadSelector.jsx:135 */
   className="...bg-surface-muted/70 border-secondary/30..."

   /* src/styles/tarot.css:47 */
   opacity: 0.98;  /* Mobile action bar - unnecessary precision */
   ```

3. **Inconsistent Accent Application**
   - **Location:** [`src/styles/theme.css:58-63`](src/styles/theme.css:58-63)
   - **Problem:** Three similar gold tokens reduce semantic clarity
   ```css
   /* src/styles/theme.css:58-63 */
   --brand-primary: #D4B896;    /* Champagne gold */
   --brand-secondary: #92887D;  /* Warm brown-gray */
   --brand-accent: #D4B896;     /* Same as primary! */
   ```
   - **Impact:** Interactive buttons in [`GlobalNav.jsx:25`](src/components/GlobalNav.jsx:25) use same color as decorative text in [`Header.jsx:15`](src/components/Header.jsx:15)

### 1.2 Typography

**Strengths:**
- **Hierarchy Established:** Clear distinction between serif (headings, card names) and sans-serif (body text)
- **Readable Base Sizes:** `clamp()` functions ensure responsive text scaling
- **Font Loading:** System fonts provide instant rendering

**Issues:**
1. **Inconsistent Size Scale**
   - Mix of `text-xs`, `text-xs-plus`, `text-sm`, `text-base` creates 7+ type sizes
   - The custom `text-xs-plus: 0.8125rem` adds unnecessary complexity
   - No clear typographic rhythm or modular scale

2. **Letter-Spacing Overuse**
   - `tracking-[0.18em]` on uppercase labels creates readability issues on mobile
   - Excessive letterspacing makes scanning harder, particularly in condensed mobile views

3. **Line Height Not Optimized**
   - Default Tailwind line heights don't account for the decorative font choices
   - Card descriptions could benefit from tighter leading

### 1.3 Spacing & Layout

**Strengths:**
- **Generous Whitespace:** Good breathing room between major sections
- **Responsive Padding:** Smart use of `px-4 sm:px-6` for mobile-first spacing
- **Safe Area Support:** Proper handling of notched devices with `env(safe-area-inset-bottom)`

**Issues:**
1. **Inconsistent Gap Patterns**
   - Mix of `gap-2`, `gap-3`, `gap-4`, `gap-6` without clear system
   - Some sections use `space-y-6`, others use explicit margins
   - Creates subtle visual rhythm breaks

2. **Mobile Padding Too Aggressive**
   - Some cards have excessive padding that reduces usable screen space
   - Celtic Cross cards become too small on narrow viewports despite 85vw allocation

3. **Z-Index Conflicts**
   - Multiple competing layers (`z-30`, `z-50`, `z-60`, `z-70`) suggest layering issues
   - Global nav at `z-30` can be obscured by modals at `z-60`

### 1.4 Iconography

**Strengths:**
- **Phosphor Icons:** Consistent, professional icon library
- **Semantic Sizing:** `ICON_SIZES` constant promotes size consistency
- **Decorative Icons:** Appropriate use of `decorative` prop for accessibility

**Issues:**
1. **Icon-Text Balance**
   - Some buttons have large icons with small text creating visual imbalance
   - Mobile action bar icons at 20px feel cramped against 13-14px text

2. **Missing Icon States**
   - No visual difference between enabled/disabled icon states beyond opacity
   - Hover states on icons not consistently implemented

---

## 2. Navigation & Information Hierarchy

### 2.1 Global Navigation

**Current Implementation:**
- Pill-style navigation with "Reading" and "Journal" tabs
- Persistent sticky header with UserMenu in top-right
- Step progress indicator below main nav

**Strengths:**
- Clear two-section structure
- Active state clearly indicated with `bg-primary` and shadow
- Keyboard accessible with proper ARIA labels

**Issues:**
1. **Navigation Prominence**
   - Navigation pills at `text-xs-plus` are too small for primary navigation
   - Only 2 items in nav—could be larger and more prominent
   - Surrounded by busy header creates visual competition

2. **UserMenu Placement**
   - Top-right corner is standard but creates awkward empty space on left
   - Sign In button not immediately discoverable for new users
   - No indication of authentication status until hover/click

3. **Back Button Pattern**
   - Journal page has "Back to Reading" in top-left while global nav exists
   - Creates confusion about navigation hierarchy
   - Redundant with global nav

### 2.2 Step Progress Component

**Strengths:**
- Visual indicator of reading flow progress
- Clickable steps allow non-linear navigation
- Responsive: shows numbers on mobile, labels on desktop
- Hover tooltips provide context

**Issues:**
1. **Cognitive Overhead**
   - 4 steps (Spread, Question, Ritual, Reading) require understanding upfront
   - "Ritual (optional)" label suggests skippable but takes up nav space
   - New users don't understand what each step entails

2. **Active State Confusion**
   - Active step uses `bg-secondary/15` which is visually subtle
   - Inactive steps at `bg-surface/70` are too similar
   - Hard to determine current location at a glance

3. **Mobile Horizontal Scroll**
   - On narrow viewports, 4 items create cramped horizontal scroll
   - `snap-x` helps but still feels constrained
   - Number-only labels on mobile lose semantic meaning

### 2.3 Information Hierarchy

**Page-Level Structure:**

Reading Page Flow:
```
1. Logo & Tagline
2. Global Nav + UserMenu
3. Step Progress
4. Step Indicator Label ("Choose your spread")
5. Deck Selector
6. Spread Selector
7. Preparation Sections (collapsed accordions)
8. Jump Link ("Ready? Jump to draw cards")
9. Reading Display Area
```

**Issues:**

1. **Header Consumes 180px+ on Mobile**
   - **Problem:** Stacked navigation layers push content below fold
   - **Breakdown:**
     * [`Header.jsx:6-16`](src/components/Header.jsx:6-16) - Logo + tagline: ~120px with margins
     * [`GlobalNav.jsx:20-41`](src/components/GlobalNav.jsx:20-41) - Navigation pills: ~44px
     * [`StepProgress.jsx:16-50`](src/components/StepProgress.jsx:16-50) - Step indicators: ~48px
     * Status messages: variable height
     * **Total:** ~180-220px (22-27% of 800px iPhone viewport)

2. **Three Collapsed Preparation Sections**
   - **Location:** [`ReadingPreparation.jsx:99-130`](src/components/ReadingPreparation.jsx:99-130)
   - **Problem:** Three accordion sections (Intention, Experience, Ritual) create decision paralysis
   - **Code:**
   ```jsx
   /* ReadingPreparation.jsx:112 */
   {(['intention', 'experience', 'ritual']).map(section => (
     <div key={section} className="rounded-xl border border-accent/20 bg-surface-muted/70 overflow-hidden">
       <button type="button" onClick={() => togglePrepareSection(section)} className="w-full flex items-center justify-between px-4 py-3 text-left" aria-expanded={prepareSectionsOpen[section]}>
   ```
   - **Evidence of friction:** [`ReadingDisplay.jsx:108-113`](src/components/ReadingDisplay.jsx:108-113) - "Draw cards" button is primary CTA but hidden until scroll

3. **Spread Selector Cards Too Uniform**
   - **Location:** [`SpreadSelector.jsx:120-179`](src/components/SpreadSelector.jsx:120-179)
   - **Problem:** All spread cards use identical styling except for selected state
   - **Code:**
   ```jsx
   /* SpreadSelector.jsx:133-136 */
   className={`relative flex flex-col justify-between rounded-2xl border-2 px-3 py-3 sm:px-4 cursor-pointer select-none transition basis-[78%] shrink-0 snap-center sm:basis-auto ${isActive
     ? 'bg-primary/15 border-primary shadow-lg shadow-primary/20'
     : 'bg-surface-muted/70 border-secondary/30 hover:border-primary/50 hover:bg-surface-muted/90'
   }`}
   ```
   - **Missing:** No visual hierarchy for complexity levels, no recommended/popular indicators, no layout thumbnails

4. **Empty Journal State**
   - **Location:** [`Journal.jsx`](src/components/Journal.jsx) (empty state section - approximate line 200-220)
   - **Code:**
   ```jsx
   <p className="text-muted">No entries yet. Save a reading to start your journal.</p>
   <button>Start a reading</button>
   ```
   - **Missing:** Benefits explanation, illustration, example entry, or tour link

---

## 3. User Flow Analysis

### 3.1 First-Time User Experience

**Current Flow:**
1. Land on page → see logo, nav, deck selector, spreads
2. Must choose deck style (3 options with descriptions)
3. Must choose spread (5+ options with position details)
4. Can set intention (optional, in collapsed section)
5. Can adjust preferences (optional, in collapsed section)
6. Can perform ritual (optional, in collapsed section)
7. Draw cards → reveal cards → view reading

**Issues:**
1. **No Onboarding**
   - No tutorial, tour, or first-run experience
   - Users must understand tarot terminology
   - No explanation of what "spread" means
   - Deck choice feels premature—why does it matter?

2. **Decision Fatigue**
   - 3 immediate decisions before any value delivery
   - Deck selector requires reading 3 descriptions
   - Spread selector requires understanding 5+ layouts
   - Optional sections create "should I?" anxiety

3. **Delayed Gratification**
   - Must make ~5 choices before seeing any cards
   - "Draw cards" button only appears after all setup
   - High drop-off risk for curious visitors

**Recommended Flow:**
1. **Land → Immediate Demo**
   - Show example reading or quick tutorial
   - "Try it now" button with sensible defaults
   - Progressive disclosure of options

2. **Guided Path for First Reading**
   - "Let's draw your first card" approach
   - Explain choices in context
   - Allow customization after initial success

### 3.2 Reading Creation Flow

**Current Experience:**
- Choose spread → Set intention → Optional ritual → Draw → Reveal → Read → Generate narrative → Save

**Strengths:**
- Logical progression through reading stages
- Flexibility to skip ritual steps
- Can reveal cards in any order (good!)

**Issues:**
1. **Ritual Ceremony Friction**
   - Knock/cut ritual feels disconnected from digital experience
   - "Skip ritual" suggestion implies it's burdensome
   - No explanation of why ritual matters
   - Could be reimagined as digital experience or removed

2. **Card Reveal Pattern Unclear**
   - Face-down cards show logo but no position label until revealed
   - "Tap to cut the veil" poetry is beautiful but vague
   - No indication that reveals can be random vs. sequential
   - DeckPile component suggests sequential but reading allows random

3. **Narrative Generation Delay**
   - "Create Personal Narrative" button only appears after all cards revealed
   - Users don't know narrative exists until late in flow
   - "Weaving..." text appears but no progress indicator
   - Analyzing text changes but not structured as steps

4. **Reflection Input Timing**
   - Text areas appear immediately on card reveal
   - Interrupts flow of exploring spread
   - Could be moved to post-reveal reflection phase

### 3.3 Journal Experience

**Strengths:**
- Clean layout with filters
- Entry cards show key metadata
- Share functionality integrated

**Issues:**
1. **Empty State Weak**
   - "No entries yet. Save a reading to start your journal."
   - Doesn't explain benefits or use cases
   - "Start a reading" button sends back to main page (expected but abrupt)

2. **Filter Discoverability**
   - Filters collapsed by default
   - No indication of active filters
   - Can't tell if 0 results means empty or filtered out

3. **Entry Card Hierarchy**
   - All metadata shown at once (date, spread, deck, context)
   - Personal narrative not previewed
   - Reflection notes not highlighted

4. **Migration Banner Persistence**
   - Local storage migration message shown every time
   - Should dismiss permanently or show once

---

## 4. Responsive Design & Accessibility

### 4.1 Mobile Responsiveness

**Strengths:**
- Mobile-first Tailwind approach
- Breakpoints well-planned: `xs: 375px`, `sm: 640px`, `md: 768px`, etc.
- Celtic Cross grid adapts: carousel → 2-col → 3-col → 4-col
- Touch targets generally 44px+ (WCAG AAA)
- `touch-action: manipulation` on sliders prevents zoom issues

**Issues:**
1. **Mobile Action Bar Overlaps**
   - Fixed bottom bar at 60-80px height
   - Covers content when keyboard opens
   - `pb-28` padding sometimes insufficient with keyboard

2. **Horizontal Scrolling**
   - Celtic Cross carousel nice but hides content
   - No visual indicator of off-screen cards
   - Easy to miss cards without exploring

3. **Modal Sizing**
   - Card modal on mobile takes full screen (good)
   - But exit button in corner hard to reach
   - No swipe-to-dismiss gesture

4. **Text Input on Mobile**
   - Reflection textareas trigger zoom on focus (iOS)
   - Need `font-size: 16px` minimum to prevent zoom
   - Currently using `text-sm` which is ~14px

5. **Settings Drawer**
   - MobileSettingsDrawer appears on gear icon
   - Contains all preparation sections
   - No indication it exists (gear icon alone)
   - Could use "Settings" label on larger mobile

### 4.2 Accessibility Evaluation

**Strengths:**
1. **Semantic HTML**
   - Proper heading hierarchy (`h1`, `h2`, `h3`)
   - Landmarks: `<nav>`, `<main>`, `<section>`
   - Lists for spread options

2. **ARIA Implementation**
   - `aria-label` on icon-only buttons
   - `aria-current="page"` on active nav
   - `aria-live="polite"` for dynamic status messages
   - `aria-expanded` on collapsed sections (implied via framework)

3. **Keyboard Navigation**
   - Tab order logical
   - Focus visible with ring (`focus-visible:ring-2`)
   - Cards keyboard activatable
   - Modal trappable (can be tested)

4. **Screen Reader Considerations**
   - Icons marked decorative appropriately
   - Image alt text includes reversed state
   - SR-only text for visual-only elements

**Verified accessibility issues**

1. **Skip links missing**
   - No skip navigation is rendered ahead of the stacked header, so keyboard users must tab through the logo, nav pills, and progress chips before reaching content.
   - **Proof:** `rg` returned no matches for common “Skip to…” anchors anywhere in `src/`.
   ```bash
   $ rg -n "Skip to" src
   # no results (rg exited 1)
   ```
   - **Action:** Add an always-present skip link before the header container that targets `#main-content`, plus a secondary link that jumps directly to the spread grid when cards are available.

**Hypotheses / needs validation**

- **Muted text contrast on translucent panels**
  - Base tokens meet AA (`5.67:1` vs `--bg-surface`, `4.84:1` vs `--bg-surface-muted`), but Tailwind classes such as `bg-surface-muted/60` and `text-accent/60` introduce transparency that could degrade contrast once rendered.
  - **Next step:** Use axe or APCA tooling against helper chips (`ReadingPreparation`) and spread descriptions to capture whether the layered surfaces actually fall below AA.

- **Focus indicator parity on custom controls**
  - Custom checkboxes and card tiles override native focus styling (`src/styles/tarot.css:596-638`). We have not yet confirmed that the resulting rings hit 3:1 contrast against gradients.
  - **Next step:** Record a keyboard-only walkthrough or axe screenshot showing whether the outline remains perceivable.

- **Dynamic announcements for card reveals / streaming text**
  - `StreamingNarrative` uses `aria-live="polite"`, but card reveals rely solely on animation (`Card.jsx:148-193`). Screen-reader output has not been tested.
  - **Next step:** Capture an NVDA/VoiceOver log to confirm whether users get notified when `onReveal` fires; add an explicit live region if not.

- **Form label clarity & toggle associations**
  - Some toggles rely on proximity rather than explicit `for`/`id` pairs. This is inferred from code review only.
  - **Next step:** Validate with browser devtools or axe to identify the exact controls missing programmatic labels.

- **Prefers-reduced-motion coverage**
  - Card flips gate on the media query, but other effects (particle bursts, modal transitions) may not.
  - **Next step:** Test with system-level reduced-motion enabled and document any components that keep animating so they can be wrapped in the same guard.

---

## 5. Usability Issues & Friction Points

### 5.1 Critical Issues (High Priority)

#### Issue 1: Preparation Phase Overwhelming
**Problem:** Three collapsed accordion sections create decision paralysis.

**User Impact:**
- New users unsure what's required vs. optional
- Cognitive load high before any value delivery
- Summary text when collapsed still clutters view

**Evidence:**
- "Jump to draw cards" link exists—suggests users want to skip
- All three sections marked "optional" in code but feel required
- Code comment: "Keeping internal logic simple for now"

**Recommendation:**
- **Phase 1:** Reduce to single preparation section with tabs or steps
- **Phase 2:** Make intention input inline, not collapsed
- **Phase 3:** Move deck/reversal preferences to settings, not main flow
- **Phase 4:** Remove or reimagine ritual steps (very niche)

#### Issue 2: Card Interaction Unclear
**Problem:** Cards don't clearly indicate they're interactive or what interaction does.

**User Impact:**
- Users may not realize cards can be clicked
- Revealed cards have zoom icon but only on hover (desktop)
- "Tap to cut the veil" is poetic but vague
- No indication random reveal is possible

**Evidence:**
```jsx
// Hover-only zoom indicator
<div className="absolute top-0 right-0 z-10 opacity-0 group-hover:opacity-100">
```

**Recommendation:**
- Show click affordance always, not just on hover
- Add tap target outline or button styling to unrevealed cards
- Clarify that cards can be revealed in any order (if intended)
- Consider click-to-flip animation that shows interactivity

#### Issue 3: Navigation Header Too Heavy
**Problem:** Sticky header consumes 180px+ on mobile, pushing content below fold.

**User Impact:**
- Less visible content per screen
- Must scroll to see primary actions
- Feels cramped, especially during reading

**Evidence:**
- Logo: 120px + margin
- Global Nav: 44px
- Step Progress: 48px
- Status messages: variable
- Total: ~180-220px (22-27% of iPhone viewport)

**Recommendation:**
- **Option A:** Make header collapse on scroll (show only on scroll-up)
- **Option B:** Reduce logo size on scroll
- **Option C:** Combine global nav and step progress into one component
- **Option D:** Make step progress non-sticky (only nav sticky)

### 5.2 Moderate Issues (Medium Priority)

#### Issue 4: Empty States Uninspiring
**Problem:** Empty journal doesn't explain value or encourage action.

**Location:** [`Journal.jsx`](src/components/Journal.jsx) (empty state section, approximate lines 200-230)

**User Impact:**
- Missed opportunity to explain journaling benefits
- No visual interest to draw attention
- Return visitors see same empty state if they haven't saved readings
- Doesn't communicate the value proposition of journal feature

**Evidence:**
```jsx
/* Journal.jsx - Current empty state (simplified) */
<div className="text-center py-16 px-4">
  <p className="text-muted text-lg">No entries yet. Save a reading to start your journal.</p>
  <button onClick={() => navigate('/')} className="mt-4...">
    Start a reading
  </button>
</div>
```

**Missing Elements:**
- No illustration or icon
- No explanation of benefits (pattern tracking, growth over time, deeper reflection)
- No example entry preview
- No tour or demo link
- Generic copy doesn't inspire action

**Recommendation:**
- **Phase 1:** Add illustration (consider Phosphor `BookOpen`, `Notebook`, or `ChartLine` icon at large size)
- **Phase 2:** Rewrite copy to emphasize benefits:
  ```jsx
  <h2>Your Tarot Journal</h2>
  <p>Track patterns across readings, revisit past insights, and watch your understanding deepen over time.</p>
  <ul>
    <li>📊 Discover recurring cards and themes</li>
    <li>📝 Add personal reflections and notes</li>
    <li>🔍 Search and filter your reading history</li>
  </ul>
  ```
- **Phase 3:** Add "See example entry" button that shows demo journal entry
- **Phase 4:** Include testimonial or quote about journaling value

#### Issue 5: Voice/Audio Controls Confusing
**Problem:** Multiple audio-related controls with unclear relationships.

**User Impact:**
- "Voice: On/Off" toggle vs. "Read this aloud" button
- Ambience vs. Voice separate but related
- "Enable voice & play" prompt appears unexpectedly

**Recommendation:**
- Consolidate audio settings into one control panel
- Clarify that Voice enables TTS, Ambience is background sound
- Show audio player controls inline when active
- Persist audio preferences more clearly

#### Issue 6: Spread Selection Uniform
**Problem:** All spread cards look identical except icon—hard to differentiate quickly.

**User Impact:**
- Users must read each card fully to understand
- Can't scan quickly to find desired spread
- Visual hierarchy doesn't guide to popular/beginner options

**Recommendation:**
- Add visual differentiation (color accent per spread complexity?)
- Mark recommended/popular spreads
- Show thumbnail of spread layout pattern
- Group by complexity or purpose (Quick, Deep, Relationship, etc.)

### 5.3 Minor Issues (Low Priority)

#### Issue 7: Button Text Truncation
**Problem:** Responsive text using `<span className="hidden xs:inline">` creates many variants.

**Evidence:**
```jsx
<span className="hidden xs:inline">Save this narrative to your journal</span>
<span className="xs:hidden">Save to journal</span>
```

**Recommendation:**
- Use CSS `text-overflow: ellipsis` where appropriate
- Reduce number of text variants per button
- Consider icon-only buttons with tooltips for tight spaces

#### Issue 8: Success Messages Disappear
**Problem:** Status messages auto-dismiss after 5 seconds.

**Impact:**
- Users may miss confirmation
- No way to verify action completed if interrupted

**Recommendation:**
- Add dismiss button so users control timing
- Keep success state visible until next action
- Log to notification center for later reference

#### Issue 9: Inconsistent "Card" Terminology
**Problem:** "Cards" refers to both tarot cards and UI cards (containers).

**Impact:**
- Mild confusion in documentation and labels
- Code comments sometimes ambiguous

**Recommendation:**
- Use "Tarot Cards" vs. "Card Components" in code
- Consider renaming UI pattern to "Panel" or "Surface"

---

## 6. Recommendations Summary

### 6.1 High-Impact Quick Wins (1-2 days)

1. **Validate Text Contrast in Context**
   - Keep the current `--text-muted: #9B9388` token (5.67:1 vs `--bg-surface`) but audit every surface that layers additional opacity (`bg-surface-muted/60`, `text-accent/60`) to ensure AA remains >4.5:1.
   - Increase secondary button border opacity from 20% to 60% so focus rings and outlines clear the 3:1 contrast threshold even when placed over gradients.
   - Capture axe or Lighthouse screenshots for helper chips, spread cards, and preparation summaries to document pass/fail status.

2. **Simplify Preparation Sections**
   - Make intention input always visible (not collapsed)
   - Move experience preferences to settings/modal
   - Add "Skip preparation" button if optional

3. **Improve Card Affordances**
   - Add persistent "Tap to reveal" button/overlay on cards
   - Show zoom icon without hover requirement
   - Clarify reveal order flexibility

4. **Enhance Empty States**
   - Add illustration to empty journal
   - Write compelling benefit-focused copy
   - Include example or tour link

5. **Add Skip Links**
   - Implement "Skip to reading" link
   - Add "Skip to cards" after navigation

### 6.2 Medium-Impact Improvements (3-5 days)

6. **Consolidate Header**
   - Implement collapsing header on scroll
   - Reduce logo size when scrolled
   - Combine nav elements to reduce height

7. **Redesign Spread Selector**
   - Add visual differentiation between spreads
   - Group by complexity or category
   - Show layout thumbnails

8. **Improve Mobile Action Bar**
   - Add labels to icon-only buttons on wider mobile
   - Implement smarter keyboard avoidance
   - Add context-aware button states

9. **Enhance Card Modal**
   - Add swipe-to-dismiss gesture
   - Improve close button accessibility
   - Consider split-view on tablets

10. **Refine Typography Scale**
    - Establish 5-6 size scale (not 8+)
    - Remove custom `text-xs-plus`
    - Document type system in design tokens

### 6.3 Strategic Initiatives (1-2 weeks)

11. **Build Onboarding Flow**
    - Create first-run tutorial (optional)
    - Offer "Try it now" with defaults
    - Progressive feature disclosure

12. **Reimagine Ritual Experience**
    - Either make digital and meaningful
    - Or remove and simplify flow
    - Don't half-commit to skippable ceremony

13. **Improve Narrative Experience**
    - Show progress during generation
    - Preview capability earlier in flow
    - Add save prompts during reading

14. **Enhance Journal Features**
    - Add search within entries
    - Show pattern insights over time
    - Implement tagging/categorization

15. **Accessibility Audit**
    - Run axe DevTools on all pages
    - Test with screen readers (NVDA, VoiceOver)
    - Fix all WCAG AA violations
    - Document keyboard shortcuts

### 6.4 Long-Term Enhancements

16. **Design System Documentation**
    - Document color system with contrast ratios
    - Create component library with variants
    - Establish spacing/sizing tokens
    - Build Storybook or pattern library

17. **Performance Optimization**
    - Lazy load images with proper placeholders
    - Reduce animation complexity on low-end devices
    - Implement service worker for offline experience

18. **Advanced Features**
    - Comparison view for multiple readings
    - Guided interpretation assistant
    - Community features (if desired)
    - Reading reminders/scheduling

---

## 7. Prioritized Action Plan

### Addressed (latest changes)
- Added skip links to main, spreads, and reading sections for keyboard users.
- Strengthened contrast tokens (`--text-muted`, accent/focus) and focus rings; reduced letterspacing on small labels.
- Inline intention field (no accordion) with clearer prep summaries; higher-contrast prep shells.
- Card affordances: persistent “Tap to reveal” overlay, clearer aria copy, always-visible zoom cue, 16px reflections textarea.
- Spread selector: recommended/complexity badges and small layout position preview.
- Journal empty state: benefit-focused copy, icon, example entry, and guided-reading CTA.
- Header density trimmed (smaller logo/tagline, tighter sticky bar padding/shadow); skip links added above.

### Sprint 1: Critical UX Fixes (Week 1)
- [ ] Increase text contrast (Issue #1)
- [ ] Simplify preparation UI (Issue #1)
- [ ] Improve card interaction clarity (Issue #2)
- [ ] Add skip navigation links
- [ ] Enhance empty states (Issue #4)

**Expected Impact:** Immediate improvement in usability, accessibility, and first-time user success.

### Sprint 2: Navigation & Layout (Week 2)
- [ ] Implement collapsing header
- [ ] Consolidate audio controls (Issue #5)
- [ ] Redesign spread selector (Issue #6)
- [ ] Improve mobile action bar
- [ ] Fix form accessibility issues

**Expected Impact:** Reduced cognitive load, more usable screen space, clearer interactions.

### Sprint 3: Polish & Refinement (Week 3)
- [ ] Build basic onboarding flow (Issue #11)
- [ ] Refine typography system
- [ ] Add loading states and progress indicators
- [ ] Improve success/error messaging
- [ ] Enhanced card modal experience

**Expected Impact:** Professional polish, reduced confusion, better user guidance.

### Sprint 4: Strategic Improvements (Week 4)
- [ ] Ritual experience decision (remove or reimagine)
- [ ] Enhance narrative generation UX
- [ ] Journal feature expansion
- [ ] Complete accessibility audit
- [ ] Performance optimization

**Expected Impact:** Cohesive experience, accessibility compliance, improved retention.

---

## 8. Metrics to Track

### Usability Metrics
- **Task Completion Rate:** % of users who complete first reading
- **Time to First Card:** How long until user draws first card
- **Preparation Abandonment:** % who abandon during setup phase
- **Card Interaction Rate:** % who click cards for details
- **Narrative Generation Rate:** % who create personal narrative

### Accessibility Metrics
- **Contrast Violations:** Count of WCAG failures
- **Keyboard Navigation Issues:** Bugs found in keyboard-only testing
- **Screen Reader Compatibility:** Issues found with NVDA/VoiceOver

### Engagement Metrics
- **Journal Save Rate:** % of readings saved
- **Return Visit Rate:** % who return within 7 days
- **Mobile vs. Desktop Completion:** Compare completion rates
- **Feature Discovery:** % who find optional features

### Technical Metrics
- **Lighthouse Accessibility Score:** Target 95+
- **Mobile Performance Score:** Target 90+
- **Largest Contentful Paint:** Target <2.5s
- **First Input Delay:** Target <100ms

---

## 9. Conclusion

Tableu demonstrates strong technical foundation and design sensibility, but several usability friction points prevent it from reaching its full potential. The most critical issues center around:

1. **Overwhelming preparation phase** that creates decision fatigue
2. **Unclear card interactions** that hide core functionality
3. **Header bloat** that reduces usable screen space
4. **Accessibility gaps**—confirmed lack of skip navigation plus suspected contrast/dynamic-announcement issues that still need tooling proof

By addressing the high-impact quick wins first, then systematically working through medium and strategic improvements, the application can transform from a functional tarot tool into a delightful, accessible, and intuitive experience that serves both newcomers and experienced practitioners.

The recommendations prioritize:
- **Removing friction** from the primary user journey
- **Clarifying interactions** through better affordances
- **Improving accessibility** to WCAG AA standards
- **Enhancing visual hierarchy** for faster scanning
- **Optimizing mobile experience** where most users likely engage

With these improvements, Tableu can become a best-in-class digital tarot experience that balances mystical aesthetics with modern UX best practices.

---

## Appendix A: Testing Devices & Browsers

### Recommended Testing Matrix
- **Desktop:** Chrome, Firefox, Safari, Edge (latest)
- **Mobile iOS:** Safari on iPhone 12, 13, 14 (various sizes)
- **Mobile Android:** Chrome on Pixel, Samsung Galaxy (various sizes)
- **Tablet:** iPad Pro, iPad Mini, Samsung Galaxy Tab
- **Screen Readers:** NVDA (Windows), VoiceOver (macOS/iOS), TalkBack (Android)

### Breakpoint Testing
- 375px (iPhone SE)
- 390px (iPhone 13)
- 428px (iPhone 13 Pro Max)
- 768px (iPad Mini portrait)
- 1024px (iPad Pro portrait)
- 1280px (laptop)
- 1920px (desktop)

---

## Appendix B: Color Contrast Reference

### Current Issues
| Element | Foreground | Background | Ratio | Status |
|---------|-----------|------------|-------|--------|
| Muted text | #9B9388 | #1C1A22 | 5.67:1 | ✅ Pass AA (opaque) |
| Secondary button | #D4B896/20 | #1C1A22 | 1.55:1 | ❌ Fail non-text |
| Accent text | #D4B896 | #1C1A22 | 9.09:1 | ✅ Pass AAA |
| Main text | #E8E6E3 | #0F0E13 | 15.43:1 | ✅ Pass AAA |

Ratios above are calculated on opaque surfaces; translucent overlays (e.g., `bg-surface-muted/60`) still need axe validation, though current combinations remain above 5:1 in spot checks.

### Recommended Fixes
| Element | New Foreground | Background | Ratio | Status |
|---------|---------------|------------|-------|--------|
| Muted text | #B5AFA4 | #1C1A22 | 7.89:1 | ✅ Pass AAA |
| Secondary button | #D4B896/60 | #1C1A22 | 4.11:1 | ✅ Pass non-text |

---
 
**End of Report**

## Implementation Update – High-Priority Overlaps (Nov 22 2025)

Work has been completed to address the four unresolved high‑priority issues from the two UX reports, with code-level changes in place and remaining validation work called out explicitly.

---

## 1. Contrast on translucent surfaces & custom focus rings

### Token & global focus-ring hardening

In [`theme.css`](src/styles/theme.css):

- The focus ring token is now a solid accent color instead of a low-opacity mix, improving contrast on dark backgrounds, gradients, and muted surfaces:

```css
/* src/styles/theme.css */
--focus-ring-color: var(--brand-accent);
```

Global focus behavior in [`tarot.css`](src/styles/tarot.css:324-333) continues to apply `outline: 2px solid var(--focus-ring-color)` with an offset, so this change immediately strengthens focus visibility across:

- Native controls: `button`, `a`, `input`, `textarea`.
- Custom checkboxes / sliders and other components that rely on browser focus outlines.

### ReadingPreparation summary chip & badge

In [`ReadingPreparation.jsx`](src/components/ReadingPreparation.jsx:99-110):

- The desktop “preparation summary” chip is now rendered on an opaque surface with a higher-contrast border:

```jsx
<div className="text-[0.78rem] sm:text-xs text-muted bg-surface-muted border border-secondary/60 rounded-lg px-3 py-2 ...">
  …
</div>
```

Previously this used lower-contrast borders and semi-translucent layering; it now:

- Uses `bg-surface-muted` (opaque) to avoid stacking opacity.
- Uses `border-secondary/60` instead of `…/50` to be more legible against dark surfaces.

Also in the same component, the “Inline” badge has been made higher-contrast:

```jsx
<span className="text-[11px] text-main bg-surface-muted border border-secondary/60 rounded-full px-3 py-1 leading-none">
  Inline
</span>
```

Key changes:

- `text-main` instead of `text-secondary` to ensure text stands out.
- Solid `bg-surface-muted` and slightly stronger border, removing translucent `bg-surface-muted/70`.

These address the “chips on translucent shells” concerns called out for ReadingPreparation.

### SpreadSelector cards and complexity badges

In [`SpreadSelector.jsx`](src/components/SpreadSelector.jsx):

- Complexity badge text now consistently uses `text-main` on lightly tinted backgrounds:

```js
function getComplexity(count) {
  if (count <= 1) return { label: 'Quick draw', tone: 'bg-primary/15 border-primary/60 text-main' };
  if (count <= 3) return { label: 'Beginner friendly', tone: 'bg-secondary/15 border-secondary/70 text-main' };
  if (count <= 5) return { label: 'Guided depth', tone: 'bg-secondary/20 border-secondary/70 text-main' };
  return { label: 'Deep dive', tone: 'bg-primary/20 border-primary/70 text-main' };
}
```

Previously, some states used `text-secondary` on translucent secondary tints, creating potential marginal contrast. This change ensures the label text remains bright and readable in all complexity tiers.

- The spread cards’ focus styling has been tuned to use a brighter ring color while keeping offset for clarity:

```jsx
<article
  /* ... */
  className={`... ${isActive
    ? 'bg-primary/20 border-primary shadow-lg shadow-primary/20'
    : 'bg-surface-muted border-secondary/50 hover:border-primary/50 hover:bg-surface-muted/90'
  } focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/90 focus-visible:ring-offset-2 focus-visible:ring-offset-main`}
>
  …
</article>
```

Combined with the global `--focus-ring-color` strengthening, this improves focus-ring contrast on these high-importance selection cards.

### Status of contrast work

- **Code-level changes:** Implemented for token, focus rings, and the most problematic translucent surfaces highlighted in the reports (ReadingPreparation summary chips, SpreadSelector cards and badges).
- **Still required:** A full axe/Lighthouse pass against:
  - ReadingPreparation summary and helper chips.
  - SpreadSelector cards and badges.
  - Custom controls with overridden focus (checkboxes, sliders).
  
This remains explicitly tracked in the todo list as “Run axe/Lighthouse + NVDA/VoiceOver audits…” and must be done to confirm WCAG AA in situ.

---

## 2. Mobile action bar keyboard overlap

The mobile bottom action bar is defined in [`tarot.css`](src/styles/tarot.css:115-131) and rendered in [`TarotReading.jsx`](src/TarotReading.jsx:607-640).

### CSS: allow animated repositioning

In [`tarot.css`](src/styles/tarot.css:115-125):

```css
.mobile-action-bar {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 60;
  padding: 0.75rem 1rem 1rem;
  background: var(--bg-surface);
  backdrop-filter: blur(18px);
  border-top: 1px solid color-mix(in srgb, var(--brand-accent) 65%, transparent);
  transition: bottom 180ms ease-out;
}
```

The new `transition: bottom 180ms ease-out;` allows smooth vertical repositioning when the keyboard opens.

(Existing `@supports (padding: max(...))` block for `.mobile-action-bar` still ensures safe-area-aware bottom padding.)

### JS: dynamic keyboard detection via visualViewport

In [`TarotReading.jsx`](src/TarotReading.jsx):

- New state to track keyboard height offset:

```js
const [keyboardOffset, setKeyboardOffset] = useState(0);
```

- A `visualViewport`-based effect to detect when the virtual keyboard is present and how much vertical space it occupies:

```js
useEffect(() => {
  if (typeof window === 'undefined' || !window.visualViewport) return;

  const viewport = window.visualViewport;

  const updateKeyboardOffset = () => {
    const heightDiff = window.innerHeight - viewport.height - viewport.offsetTop;
    const isKeyboardOpen = heightDiff > 120;
    setKeyboardOffset(isKeyboardOpen ? Math.max(heightDiff, 0) : 0);
  };

  viewport.addEventListener('resize', updateKeyboardOffset);
  viewport.addEventListener('scroll', updateKeyboardOffset);
  updateKeyboardOffset();

  return () => {
    viewport.removeEventListener('resize', updateKeyboardOffset);
    viewport.removeEventListener('scroll', updateKeyboardOffset);
  };
}, []);
```

- The mobile action bar now uses this offset:

```jsx
{!isIntentionCoachOpen && (
  <nav
    className="mobile-action-bar sm:hidden"
    aria-label="Primary mobile actions"
    style={keyboardOffset > 0 ? { bottom: keyboardOffset } : undefined}
  >
    {/* existing buttons */}
  </nav>
)}
```

**Behavior:**

- On browsers that support `window.visualViewport` (iOS Safari, modern Android Chrome, etc.), when the virtual keyboard appears:
  - The effective visible viewport height shrinks.
  - `heightDiff` becomes significant; if `> 120px`, `keyboardOffset` is set.
  - The nav bar animates upwards (increasing its `bottom`), sitting just above the keyboard instead of overlapping input fields.
- On older browsers without `visualViewport`, `keyboardOffset` remains `0`, and behavior falls back to the existing layout (sticky bar plus content padding/safe-area handling).

This directly addresses the “mobile action bar overlaps keyboard” issue called out in both reports.

---

## 3. Narrative generation multi-step progress indicator

A multi-stage model for narrative generation has been introduced, with both visual and screen-reader feedback.

### State & lifecycle

In [`ReadingContext.jsx`](src/contexts/ReadingContext.jsx):

- New state fields:

```js
const [narrativePhase, setNarrativePhase] = useState('idle');
const [srAnnouncement, setSrAnnouncement] = useState('');
```

- [`generatePersonalReading()`](src/contexts/ReadingContext.jsx:78) now advances through explicit phases:

  - **Preconditions / error:**
    - If no reading, we set:

      ```js
      setNarrativePhase('error');
      setSrAnnouncement('Please draw and reveal your cards before requesting a personalized narrative.');
      ```

  - **Step 1 – Analyzing spread:**

    ```js
    setIsGenerating(true);
    setAnalyzingText('');
    setPersonalReading(null);
    setJournalStatus(null);
    setNarrativePhase('analyzing');
    setSrAnnouncement('Step 1 of 3: Analyzing your spread, positions, and reflections.');
    ```

    Later, after assembling `cardsInfo`:

    ```js
    const cardNames = cardsInfo.map(card => card.card).join(', ');
    setAnalyzingText(`Step 1 of 3 — Analyzing spread.\n\nCards in this reading: ${cardNames}.`);
    setNarrativePhase('analyzing');
    setSrAnnouncement('Step 1 of 3: Analyzing spread for your narrative.');
    ```

  - **Step 2 – Drafting narrative:**

    Once the payload is normalized:

    ```js
    setNarrativePhase('drafting');
    setAnalyzingText((prev) => `${prev}\n\nStep 2 of 3 — Drafting narrative insights based on your spread.`);
    setSrAnnouncement('Step 2 of 3: Drafting narrative insights.');
    ```

  - **Step 3 – Final polishing:**

    After receiving a successful API response:

    ```js
    setNarrativePhase('polishing');
    setAnalyzingText('Step 3 of 3 — Final polishing and assembling your narrative...');
    setSrAnnouncement('Step 3 of 3: Final polishing and assembling your narrative.');
    ```

  - **Completion:**

    After formatting the reading:

    ```js
    setPersonalReading(formatted);
    setNarrativePhase('complete');
    ```

  - **Error path:**

    Any failure sets:

    ```js
    setNarrativePhase('error');
    setSrAnnouncement('Unable to generate your narrative right now.');
    ```

### Visual 3-step indicator

In [`ReadingDisplay.jsx`](src/components/ReadingDisplay.jsx):

- New step definition:

```js
const NARRATIVE_STEPS = [
  { id: 'analyzing', label: 'Analyzing spread' },
  { id: 'drafting', label: 'Drafting narrative' },
  { id: 'polishing', label: 'Final polishing' }
];
```

- Phases and their ordering:

```js
const phaseOrder = ['idle', 'analyzing', 'drafting', 'polishing', 'complete', 'error'];
const currentPhaseIndex = phaseOrder.indexOf(narrativePhase);
```

- The indicator bar renders when generating or once a narrative is present:

```jsx
{(isGenerating || (personalReading && !isPersonalReadingError)) && (
  <div className="max-w-3xl mx-auto text-center">
    <div className="flex items-center justify-center gap-2 sm:gap-3 mb-3" role="status" aria-label="Narrative generation progress">
      {NARRATIVE_STEPS.map((step, index) => {
        const stepIndex = phaseOrder.indexOf(step.id);
        const isDone = currentPhaseIndex > stepIndex && currentPhaseIndex !== -1;
        const isCurrent = currentPhaseIndex === stepIndex || (currentPhaseIndex === -1 && index === 0 && isGenerating);
        const statusClass = isDone
          ? 'bg-primary/20 border-primary/70 text-main'
          : isCurrent
            ? 'bg-accent/20 border-accent/70 text-main'
            : 'bg-surface-muted/80 border-secondary/40 text-muted';
        return (
          <div
            key={step.id}
            className={`flex-1 min-w-[5.5rem] px-2 py-1.5 rounded-full border text-[0.7rem] sm:text-xs font-semibold tracking-[0.08em] uppercase ${statusClass}`}
            aria-current={isCurrent ? 'step' : undefined}
          >
            <span>{index + 1}</span>
            <span className="sr-only"> of 3 — </span>
            <span className="ml-1">{step.label}</span>
          </div>
        );
      })}
    </div>
    {isGenerating && (
      <div className="ai-panel-modern">
        <div className="ai-panel-text" aria-live="polite">
          {analyzingText || 'Weaving your personalized narrative from this spread...'}
        </div>
        <HelperToggle className="mt-3">
          <p>This reflection is generated from your spread and question to support insight, not to decide for you.</p>
        </HelperToggle>
      </div>
    )}
  </div>
)}
```

Users now see a clear “1 / 2 / 3” style rail that matches the recommended copy:

- Analyzing spread.
- Drafting narrative.
- Final polishing.

### Screen-reader feedback

In [`TarotReading.jsx`](src/TarotReading.jsx:455-458), the global `aria-live` region now includes `srAnnouncement` from context:

```jsx
<div className="sr-only" role="status" aria-live="polite" aria-atomic="true">
  {[ttsAnnouncement, srAnnouncement, journalStatus?.message].filter(Boolean).join(' · ')}
</div>
```

Narrative-phase transitions emit succinct, structured messages (e.g. “Step 2 of 3: Drafting narrative insights.”), ensuring SR users track the same multi-step indicator as sighted users.

---

## 4. Focus states & ARIA verification for custom controls

This item had two aspects: code changes to better support accessibility, and actual validation runs.

### Card reveal and focus behavior

In [`Card.jsx`](src/components/Card.jsx:206-233):

- Cards already expose keyboard and screen-reader affordances:

  - `role="button"` with a descriptive `aria-label` that changes between unrevealed and revealed states:

    ```jsx
    aria-label={
      isRevealed
        ? `${position}: ${card.name} ${card.isReversed ? 'reversed' : 'upright'}. Click to view details.`
        : `Reveal card for ${position}. Cards can be revealed in any order.`
    }
    ```

  - Keyboard activation via Enter/Space:

    ```jsx
    onKeyDown={event => {
      if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        if (!isRevealed) onReveal(index);
        else if (onCardClick) onCardClick(card, position, index);
      }
    }}
    ```

  - When a card becomes revealed, the explanatory text area receives focus:

    ```jsx
    useEffect(() => {
      if (isRevealed && revealedContentRef.current) {
        revealedContentRef.current.focus();
      }
    }, [isRevealed]);
    ```

- Focus styling of card tiles uses explicit `focus-visible:ring-*` classes, now backed by a stronger `--focus-ring-color`.

### Explicit SR announcements for card reveals

In [`ReadingContext.jsx`](src/contexts/ReadingContext.jsx:391-399):

- `revealCard` from `useTarotState` is wrapped to emit an `srAnnouncement` whenever a card is revealed:

```js
const revealCard = useCallback((index) => {
  const spreadInfo = SPREADS[selectedSpread];
  const card = reading?.[index];
  const position = spreadInfo?.positions?.[index] || `Card ${index + 1}`;
  if (card) {
    setSrAnnouncement(`Revealed ${position}: ${card.name}${card.isReversed ? ' reversed' : ''}.`);
  }
  baseRevealCard(index);
}, [baseRevealCard, reading, selectedSpread]);
```

Because `srAnnouncement` is piped into the global `aria-live="polite"` region in [`TarotReading.jsx`](src/TarotReading.jsx:455-458), screen readers receive explicit notifications when each card is flipped, rather than relying solely on visual animation.

### Narrative streaming & live regions

[`StreamingNarrative`](src/components/StreamingNarrative.jsx:57-117) already renders content inside a `div` with `aria-live="polite"`, and now:

- The new narrative-phase messages and `analyzingText` string are coordinated with the three-step indicator, so SR users get:

  - Phase announcements via `srAnnouncement`.
  - Ongoing “analyzing / drafting / polishing” details via the `ai-panel-text` live region in [`ReadingDisplay.jsx`](src/components/ReadingDisplay.jsx:223-257).
  - Final narrative via the streaming text region.

This addresses the “dynamic announcements for streaming text” concern at a code level.

### Remaining validation work

What is **still outstanding** for this item (per the reports’ expectations):

- **Keyboard-only walkthroughs** on real devices / desktop:
  - Verify that every control (spread cards, bottom bar actions, card tiles, modals) has:
    - A visible, high-contrast focus indicator.
    - Logical tab ordering; no traps.
- **Screen-reader tests** (NVDA on Windows and VoiceOver on macOS/iOS):
  - Confirm that:
    - Skip links, step progress, and spread selection are announced correctly.
    - Card reveal announcements from `srAnnouncement` are delivered as expected.
    - Narrative generation phases and the final narrative are understandable and not overly verbose.
- **axe / Lighthouse audits:**
  - Run against the updated app to validate:
    - Contrast on the adjusted components.
    - ARIA patterns (live regions, roles, labels).

These validation steps are now tracked as separate todos and have **not** been executed programmatically in this session; only the implementation groundwork has been laid.

---

## Summary vs. the four high‑priority overlaps

1. **Contrast validation on translucent surfaces & focus rings**
   - Contrast-improving code changes are in place for global focus rings, ReadingPreparation summary chips, and SpreadSelector cards/badges.
   - Formal axe/Lighthouse validation is still required.

2. **Mobile action bar keyboard overlap**
   - The mobile action bar now detects virtual keyboards via `visualViewport` and animates above them using a dynamic `bottom` offset, addressing the overlap issue on iOS/Android where supported.

3. **Narrative generation progress indicator**
   - A structured three-step indicator (“Analyzing spread → Drafting narrative → Final polishing”) has been implemented, driven by `narrativePhase` and synchronized with both visual UI and screen-reader announcements.

4. **Focus states & ARIA verification**
   - Custom controls now expose clearer focus styling and explicit SR announcements for card reveals and narrative phases.
   - Manual keyboard-only + NVDA/VoiceOver + axe/Lighthouse verification remains outstanding and should be performed next to fully close this item.

These changes bring the codebase into alignment with the UX recommendations; the remaining gap is running and documenting the requested accessibility audits and screen-reader walkthroughs to confirm real-world behavior.
</file>

<file path="docs/VISION_PIPELINE.md">
# Vision Pipeline Prototype

## Goal
Stand up the first iteration of the multimodal pipeline described in `guidetoaitraining.md` and `docs/AI_TRAINING_ANALYSIS.md`: embed tarot card images with CLIP, compare them to text prototypes for each card, and surface the closest symbolic matches. This allows us to validate the feasibility of photo-based readings before wiring the flow into the Cloudflare Functions API.

## Implementation Overview
- **Model**: `Xenova/clip-vit-base-patch32` via `@xenova/transformers` (runs locally/in-browser, downloads weights on first use).
- **Card Library**: Built from `src/data/majorArcana.js` + `src/data/minorArcana.js`. Prompts now combine:
  - Curated Major Arcana annotations from `shared/symbols/symbolAnnotations.js`
  - Programmatic Minor Arcana symbol expansions from `shared/vision/minorSymbolLexicon.js`
  - Deck-style metadata from `shared/vision/deckProfiles.js` (RWS, Thoth, Marseille ready)
  - Physical assets live under `public/images/cards/{rws-1909|thoth|marseille}`. The Marseille folder contains an 18th-century scan set, while `thoth` includes **enhanced abstract placeholders** (v2) with Art Deco gradients, Hebrew letters, astrological symbols, and geometric mandalas that capture the Thoth visual language without reproducing copyrighted artwork (see `docs/THOTH_ENHANCEMENTS.md`).
- **Pipeline Class**: `shared/vision/tarotVisionPipeline.js` loads CLIP stacks, embeds prompts/images, normalizes vectors, and compares cosine similarity. It accepts file paths, URLs, or browser data URLs so both CLI scripts and the React UI can reuse the same engine.
- **CLI Harness**: `scripts/vision/runVisionPrototype.js` accepts image paths, with flags for deck scope/style and number of matches. Useful for quick regression checks while iterating on symbol prompts.
- **Evaluation Harness**: `scripts/evaluation/runVisionConfidence.js` sweeps `public/images/cards`, logs top-5 matches + confidence, and writes reports under `data/evaluations/` for the guide's Section 3 benchmarking work.
- **Metrics + Review Loop**: `scripts/evaluation/computeVisionMetrics.js` ingests any `vision-confidence.json` snapshot, derives ground-truth labels from `src/data/majorArcana.js`/`src/data/minorArcana.js`, computes micro precision/recall/F1 (Section 3 symbolic recognition metric), and emits:
  - `data/evaluations/vision-metrics.json` — machine-readable stats for release gates.
  - `data/evaluations/vision-review-queue.csv` — mismatched samples for human-in-the-loop review (Section 3 human evaluation). The queue preserves any previously recorded `human_verdict`/`human_notes` so annotations survive subsequent runs.
- **Review Summaries**: Once reviewers fill the queue, run `npm run review:vision` (wrapper around `scripts/evaluation/processVisionReviews.js`) to convert their annotations into `data/evaluations/vision-review-summary.json`, capturing acceptance/rejection rates and sample rows for audit.
- **UI Surface**: `VisionValidationPanel` + `useVisionValidation` hook (see `src/components/VisionValidationPanel.jsx`) let users upload photos per spread. The results must match the drawn cards before `/api/tarot-reading` is called, satisfying the "validate before prompting" requirement.

## Rollout Plan
- **Approach:** `/api/tarot-reading` now requires a server-signed `visionProof` instead of trusting raw `visionInsights`. Clients POST their base64 photos to `/api/vision-proof`, the Pages Function reruns CLIP to verify the cards, signs the sanitized insights with `VISION_PROOF_SECRET`, and returns a short-lived proof object that must accompany the reading request. No proof ⇒ HTTP 400.
- **UI Changes:** `VisionValidationPanel` still handles uploads client-side for instant feedback (conflicts, attention maps, removal/reset), but `TarotReading.jsx` triggers the proof handshake immediately before sending the spread so photos are re-verified on the server. Uploads are limited to five images, and any change invalidates the cached proof to prevent replay attacks.
- **Sample Payloads:** Dev scripts (`scripts/fix-and-deploy.sh`, `scripts/setup-*.sh`) now demonstrate the two-step flow: first call `/api/vision-proof` with a data URL, then reuse the returned `visionProof` when calling `/api/tarot-reading`. Tests build signed proofs via `functions/lib/visionProof.js` helpers—see `tests/api.vision.test.mjs` for an example.
- **Support Expectations:** Automations that previously injected `visionInsights` JSON must be upgraded to obtain proofs (or pipe card photos through the new API). There is no bypass anymore—the server will reject unsigned or expired proofs with a 409/400 response. Set the `VISION_PROOF_SECRET` secret in every environment or the proof endpoints will fail to sign/verify.

## Usage
1. Install dependencies (already part of `npm install` after adding `@xenova/transformers`).
2. Run the CLI against any local card images:
   ```bash
   node scripts/vision/runVisionPrototype.js public/images/cards/RWS1909_-_00_Fool.jpeg
   ```
3. Optional flags:
   - `--all-cards`: include Minor Arcana prototypes (78 cards total).
   - `--max-results N`: change how many matches are displayed per image.
   - `--deck-style rws-1909|thoth-a1|marseille-classic`: swap stylistic prompt cues and card assets.

The first run downloads ~350 MB of model weights into the transformers cache. Subsequent runs reuse the cache and finish quickly.

### Deck-specific evaluation suite

- `npm run eval:vision:rws` → evaluates Rider–Waite–Smith reference scans and writes `data/evaluations/vision-confidence.rws.json`.
- `npm run eval:vision:thoth` → evaluates the Thoth placeholders/scans and writes `data/evaluations/vision-confidence.thoth.json`.
- `npm run eval:vision:marseille` → evaluates the Marseille scan set and writes `data/evaluations/vision-confidence.marseille.json`.
- `npm run eval:vision:all` → runs the three commands sequentially so every deck has a fresh confidence snapshot before computing metrics.

## Next Steps
- Persist proof summaries (requestId, deck, proof id) in KV so we can audit vision evidence post-reading.
- Turn the metrics output into a hard gate (e.g., require accuracy ≥ 0.9 and zero mismatches before releasing deck updates).
- Wire `npm run ci:vision-check` into CI (after `npm run eval:vision`) so builds fail automatically when accuracy < 90%, high-confidence coverage < 75%, or high-confidence accuracy < 90%. Thresholds can be tuned via `VISION_MIN_*` env vars when running the gate. Encourage reviewers to commit annotated CSVs plus the generated summary JSON so every release includes human sign-off artifacts.
- Hook CLIP confidences into spread prompts (e.g., "Vision match confidence: 0.82 on The Hermit") so GPT/Claude can reference the computer-vision certainty when narrating reversals or misreads.
</file>

<file path="docs/VISION_RESEARCH_MODE.md">
# Vision Research Mode Refactoring

## Summary

The vision validation system has been refactored from a **production requirement** to an **optional research feature**. Users can now generate AI readings without uploading photos, while still preserving the vision validation infrastructure for research and development purposes.

## Changes Made

### 1. Backend API (`/functions/api/tarot-reading.js`)

**Before:** Hard requirement - API returned `400 Bad Request` if no vision proof provided.

**After:** Optional validation with research telemetry:
- Readings can be generated **without** vision proof
- If vision proof is provided, it's verified and telemetry is collected
- Vision mismatches no longer block readings - they're logged for research
- Vision metrics are set to `null` when no proof is provided

**Key code changes:**
```javascript
// Vision validation is OPTIONAL - used for research/development purposes only
let sanitizedVisionInsights = [];
let visionMetrics = null;

if (!visionProof) {
  console.log(`[${requestId}] No vision proof provided (research mode disabled). Proceeding with standard reading.`);
} else {
  // Research mode: Verify vision proof and collect telemetry
  console.log(`[${requestId}] Vision proof provided - validating for research telemetry...`);
  // ... validation logic ...
}
```

### 2. Frontend (`/src/TarotReading.jsx`)

**Before:** "Create Personal Narrative" button disabled when `!isVisionReady`

**After:** Button always enabled (when cards are revealed):
- Removed `!isVisionReady` from button `disabled` condition
- Added warning message only when vision data has conflicts
- Updated helper text to remove vision requirement

**Key changes:**
```javascript
// Button no longer blocked by vision validation
disabled={isGenerating}  // Previously: disabled={isGenerating || !isVisionReady}

// Show warning only when there are conflicts
{hasVisionData && !isVisionReady && (
  <p className="mt-3 text-sm text-amber-100/80">
    ⚠️ Vision data has conflicts - research telemetry may be incomplete.
  </p>
)}
```

### 3. UI Text Updates

#### VisionValidationPanel.jsx
**Before:**
> "Upload up to five photos of your drawn cards so the deck can confirm what you pulled before unlocking the AI reading. **Validation is required to continue.**"

**After:**
> "Help improve our AI by uploading photos of your drawn cards. This **optional feature** helps us train better card recognition models. **Your contribution is appreciated but not required.**"

#### DeckSelector.jsx
**Before:**
> "Choose your physical deck" - "Select the deck you're using so the vision validation can accurately recognize your cards."

**After:**
> "Select deck style for vision research" - "**If you're participating in vision validation research**, select which deck style you're photographing to help our AI learn."

## Purpose and Rationale

### Original Issue
The vision validation system was designed as research infrastructure (as documented in `guidetoaitraining.md`) but was deployed with a hard requirement that blocked all readings without photo uploads. This created a nonsensical user experience:

1. App digitally draws cards for users
2. Users required to photograph their screens
3. Upload photos back to the app
4. Only then could generate a reading

### Research Purpose
The vision system serves legitimate research goals:
- Training CLIP models to recognize tarot cards
- Evaluating vision AI accuracy across different decks
- Collecting ground-truth labeled data for model improvement
- Testing multimodal AI capabilities

### Solution
Make vision validation **opt-in** for research participants while allowing normal users to use the app without the circular photo requirement.

## User Experience Flow

### Standard Flow (No Research Participation)
1. User selects spread
2. User draws cards (digital)
3. User reveals cards
4. User generates AI reading ✅ **No photos required**

### Research Flow (Opt-in)
1. User selects spread
2. User draws cards (digital)
3. User reveals cards
4. **Optional:** User photographs displayed cards and uploads
5. Vision AI analyzes photos and collects telemetry
6. User generates AI reading (regardless of vision results)
7. Research data sent to telemetry for model improvement

## Enabling / Disabling Research Mode

The frontend now treats vision uploads as a build-time toggle. Set `VITE_ENABLE_VISION_RESEARCH=true` in your `.env` (or hosting dashboard) to show the deck selector and the `VisionValidationPanel`. When the flag is omitted or `false`:

- The client never calls `/api/vision-proof`, so local/dev builds no longer require `VISION_PROOF_SECRET`
- The deck selector and research UI stay hidden, keeping the default experience streamlined
- Readings still include telemetry fields, but `vision` stays `null`

When the flag is enabled and `VISION_PROOF_SECRET` is configured on the worker, the research UI appears and uploads will be signed before `/api/tarot-reading` receives them.

## Testing

To verify the changes work correctly:

### Test 1: Reading Without Vision Proof
```bash
curl -X POST http://localhost:8788/api/tarot-reading \
  -H "Content-Type: application/json" \
  -d '{
    "spreadInfo": {"name": "One-Card Insight"},
    "cardsInfo": [{"card": {"name": "The Fool"}, "isReversed": false}],
    "userQuestion": "Test question",
    "deckStyle": "rws-1909"
  }'
```
**Expected:** Reading generated successfully, no 400 error

### Test 2: Reading With Vision Proof
```bash
# First get a vision proof
curl -X POST http://localhost:8788/api/vision-proof \
  -H "Content-Type: application/json" \
  -d '{
    "deckStyle": "rws-1909",
    "evidence": [{"label": "test", "dataUrl": "data:image/png;base64,..."}]
  }'

# Then use it in reading request
curl -X POST http://localhost:8788/api/tarot-reading \
  -H "Content-Type: application/json" \
  -d '{
    "spreadInfo": {"name": "One-Card Insight"},
    "cardsInfo": [{"card": {"name": "The Fool"}, "isReversed": false}],
    "userQuestion": "Test question",
    "visionProof": { ... },
    "deckStyle": "rws-1909"
  }'
```
**Expected:** Reading generated with vision telemetry collected

### Test 3: Frontend Button
1. Navigate to app
2. Draw cards
3. Reveal all cards
4. Verify "Create Personal Narrative" button is **enabled** (not grayed out)
5. Click button
6. Verify reading generates without requiring photo upload

## Future Enhancements

Consider adding:

1. **Collapsible vision panel** to reduce visual clutter for non-participants

2. **Explicit opt-in checkbox**: "I want to help improve vision AI by uploading photos"

3. **Research participant acknowledgment**: Link to research consent/purpose

4. **Telemetry dashboard** for tracking research data collection metrics

## Related Documentation

- `guidetoaitraining.md` - AI training research methodology (source of vision requirements)
- `docs/VISION_PIPELINE.md` - Technical implementation of CLIP-based vision validation
- `docs/DEPLOYMENT.md` - Deployment configuration and secrets management

## Migration Notes

### Breaking Changes
None - This is a backwards-compatible change that removes restrictions.

### Configuration Updates
- `VITE_ENABLE_VISION_RESEARCH`: Controls whether the client exposes the research UI and attempts to create signed proofs. Defaults to `false`.
- `VISION_PROOF_SECRET`: Required on the worker **only when** research mode is enabled. When absent, the API still serves readings without telemetry data.

### Telemetry Impact
- Readings without vision proof will have `vision: null` in telemetry
- Use this field to track research participation rate
- Filter telemetry queries to analyze vision accuracy only for participated readings
</file>

<file path="docs/WORKERS_MIGRATION.md">
# Cloudflare Workers Migration Guide

This document describes the migration from Cloudflare Pages Functions to Cloudflare Workers with Static Assets.

## Overview

The project has been migrated from:
- **Before**: Cloudflare Pages Functions (`functions/api/*.js`)
- **After**: Cloudflare Workers with Static Assets (`src/worker/index.js`)

## Why Migrate?

1. **Unified Runtime**: Workers provide a more consistent runtime environment
2. **Better Development Experience**: `wrangler dev` provides faster iteration
3. **More Configuration Options**: Full `wrangler.toml` support for bindings
4. **Future-Proof**: Workers is Cloudflare's primary compute platform

## Architecture Changes

### Before (Pages Functions)
```
public/
├── _routes.json          # Route configuration
functions/
├── api/
│   ├── tarot-reading.js  # onRequestGet/onRequestPost
│   ├── tts.js
│   └── ...
```

### After (Workers)
```
src/worker/
├── index.js              # Main Worker entry point with router
wrangler.toml             # Worker configuration
dist/                     # Built static assets (served by ASSETS binding)
functions/                # Legacy handlers (still used, imported by worker)
├── api/
├── lib/
```

## Configuration

### wrangler.jsonc

The project uses `wrangler.jsonc` (JSON with Comments) for configuration:

```jsonc
{
  "name": "tableau",
  "main": "./src/worker/index.js",
  "compatibility_date": "2025-11-24",
  "compatibility_flags": ["nodejs_compat"],
  
  "assets": {
    "directory": "./dist",
    "binding": "ASSETS",
    "not_found_handling": "single-page-application"
  },
  
  "d1_databases": [{
    "binding": "DB",
    "database_id": "YOUR_D1_DATABASE_ID",
    "database_name": "mystic-tarot-db"
  }],
  
  "kv_namespaces": [
    { "binding": "RATELIMIT", "id": "YOUR_KV_ID" },
    { "binding": "FEEDBACK_KV", "id": "YOUR_FEEDBACK_KV_ID" },
    { "binding": "METRICS_DB", "id": "YOUR_METRICS_KV_ID" }
  ],
  
  "r2_buckets": [{
    "binding": "LOGS_BUCKET",
    "bucket_name": "tarot-logs"
  }],
  
  "logpush": true,
  "observability": { "enabled": true }
}
```

## Development Commands

### Start Development Server
```bash
npm run dev
# Or just workers:
npm run dev:workers
```

### Build
```bash
npm run build
```

### Deploy
```bash
npm run deploy
# Or specifically for workers:
npm run deploy:workers
```

### Preview Locally
```bash
npm run preview:workers
```

## Setting Up Bindings

### D1 Database
```bash
# Create the database
wrangler d1 create tableau-db

# Update wrangler.toml with the database_id

# Apply migrations
wrangler d1 execute tableau-db --local --file=./migrations/001_initial.sql
```

### KV Namespaces
```bash
# Create rate limiting KV
wrangler kv:namespace create RATELIMIT
wrangler kv:namespace create METRICS_DB

# Update wrangler.toml with the namespace IDs
```

### Secrets Migration

**IMPORTANT**: Pages secrets are stored separately from Workers secrets. You must re-add all secrets to the Workers deployment.

#### Using the Migration Script

```bash
# Interactive mode (prompts for each value)
./scripts/migrate-secrets.sh

# Or use values from your .dev.vars file
./scripts/migrate-secrets.sh --from-env
```

#### Required Secrets
```bash
wrangler secret put AZURE_OPENAI_ENDPOINT
wrangler secret put AZURE_OPENAI_API_KEY
wrangler secret put AZURE_OPENAI_GPT5_MODEL
```

#### Optional Secrets
```bash
wrangler secret put AZURE_OPENAI_TTS_ENDPOINT
wrangler secret put AZURE_OPENAI_TTS_API_KEY
wrangler secret put AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT
wrangler secret put ANTHROPIC_API_KEY
wrangler secret put VISION_PROOF_SECRET
wrangler secret put HUME_API_KEY
```

#### Verify Secrets
```bash
wrangler secret list --name tableau
```

## Handler Compatibility

The existing Pages Functions handlers (`onRequestGet`, `onRequestPost`, etc.) remain unchanged. The Worker entry point imports and calls them with a compatible context object:

```javascript
// Worker provides the same context structure as Pages Functions
const context = {
  request,
  env,
  params,          // Extracted from URL pattern
  waitUntil,
  next,            // Falls through to static assets
  data: {},
};

const response = await handler(context);
```

## Route Mapping

Routes are defined in `src/worker/index.js`:

| URL Pattern | Handler Module |
|-------------|----------------|
| `/api/tarot-reading` | `functions/api/tarot-reading.js` |
| `/api/tts` | `functions/api/tts.js` |
| `/api/journal` | `functions/api/journal.js` |
| `/api/journal/:id` | `functions/api/journal/[id].js` |
| `/api/auth/login` | `functions/api/auth/login.js` |
| `/api/share/:token` | `functions/api/share/[token].js` |
| ... | ... |

## Port Changes

- **Old**: `localhost:8788` (Pages dev)
- **New**: `localhost:8787` (Workers dev)

## Troubleshooting

### Missing Bindings
Ensure `wrangler.toml` has the correct database_id and namespace IDs from your Cloudflare dashboard.

### Module Import Errors
The Worker uses ESM imports. Ensure all function files use `export` syntax.

### CORS Issues
CORS headers are added automatically by the Worker router for all API responses.

### Static Assets Not Found
Ensure `npm run build` has been run to populate `dist/` before starting the dev server.

## Rollback

To rollback to Pages Functions:
1. Restore `public/_routes.json`
2. Use `wrangler pages dev` instead of `wrangler dev`
3. Deploy with `wrangler pages deploy` instead of `wrangler deploy`
</file>

<file path="functions/api/archetype-journey/[[path]].js">
// Catch-all route to support /api/archetype-journey/* paths
export { onRequest } from '../archetype-journey.js';
</file>

<file path="functions/api/auth/login.js">
/**
 * User Login Endpoint
 * POST /api/auth/login
 *
 * Authenticates a user and creates a new session
 */

import {
  verifyPassword,
  createSession,
  createSessionCookie
} from '../../lib/auth.js';

export async function onRequestPost(context) {
  const { request, env } = context;

  try {
    // Parse request body
    const body = await request.json();
    const { email, password } = body;

    // Validate inputs
    if (!email || !password) {
      return new Response(
        JSON.stringify({ error: 'Email and password are required' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Find user by email
    const user = await env.DB.prepare(`
      SELECT id, email, username, password_hash, password_salt, is_active
      FROM users
      WHERE email = ?
    `)
      .bind(email.toLowerCase())
      .first();

    if (!user) {
      return new Response(
        JSON.stringify({ error: 'Invalid email or password' }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Check if account is active
    if (!user.is_active) {
      return new Response(
        JSON.stringify({ error: 'Account is inactive' }),
        { status: 403, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Verify password
    const isValid = await verifyPassword(password, user.password_hash, user.password_salt);

    if (!isValid) {
      return new Response(
        JSON.stringify({ error: 'Invalid email or password' }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Update last_login_at
    const now = Math.floor(Date.now() / 1000);
    await env.DB.prepare('UPDATE users SET last_login_at = ? WHERE id = ?')
      .bind(now, user.id)
      .run();

    // Create session
    const metadata = {
      userAgent: request.headers.get('User-Agent'),
      ipAddress: request.headers.get('CF-Connecting-IP')
    };

    const { token, expiresAt } = await createSession(env.DB, user.id, metadata);

    // Return success with session cookie
    return new Response(
      JSON.stringify({
        success: true,
        user: {
          id: user.id,
          email: user.email,
          username: user.username
        }
      }),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
          'Set-Cookie': createSessionCookie(token, expiresAt)
        }
      }
    );
  } catch (error) {
    console.error('Login error:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
</file>

<file path="functions/api/auth/logout.js">
/**
 * User Logout Endpoint
 * POST /api/auth/logout
 *
 * Destroys the current session and clears the session cookie
 */

import {
  deleteSession,
  getSessionFromCookie,
  clearSessionCookie
} from '../../lib/auth.js';

export async function onRequestPost(context) {
  const { request, env } = context;

  try {
    // Get session token from cookie
    const cookieHeader = request.headers.get('Cookie');
    const token = getSessionFromCookie(cookieHeader);

    if (token) {
      // Delete session from database
      await deleteSession(env.DB, token);
    }

    // Return success with cleared cookie
    return new Response(
      JSON.stringify({ success: true }),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
          'Set-Cookie': clearSessionCookie()
        }
      }
    );
  } catch (error) {
    console.error('Logout error:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
</file>

<file path="functions/api/auth/me.js">
/**
 * Get Current User Endpoint
 * GET /api/auth/me
 *
 * Returns the currently authenticated user's information
 */

import {
  validateSession,
  getSessionFromCookie
} from '../../lib/auth.js';

export async function onRequestGet(context) {
  const { request, env } = context;

  try {
    // Get session token from cookie
    const cookieHeader = request.headers.get('Cookie');
    const token = getSessionFromCookie(cookieHeader);

    if (!token) {
      return new Response(
        JSON.stringify({ error: 'Not authenticated' }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Validate session and get user
    const user = await validateSession(env.DB, token);

    if (!user) {
      return new Response(
        JSON.stringify({ error: 'Invalid or expired session' }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Return user data
    return new Response(
      JSON.stringify({
        user: {
          id: user.id,
          email: user.email,
          username: user.username
        }
      }),
      {
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  } catch (error) {
    console.error('Get user error:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
</file>

<file path="functions/api/auth/register.js">
/**
 * User Registration Endpoint
 * POST /api/auth/register
 *
 * Creates a new user account with email/username/password
 */

import {
  hashPassword,
  createSession,
  createSessionCookie,
  isValidEmail,
  isValidUsername,
  isValidPassword
} from '../../lib/auth.js';

export async function onRequestPost(context) {
  const { request, env } = context;

  try {
    // Parse request body
    const body = await request.json();
    const { email, username, password } = body;

    // Validate inputs
    if (!email || !username || !password) {
      return new Response(
        JSON.stringify({ error: 'Email, username, and password are required' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (!isValidEmail(email)) {
      return new Response(
        JSON.stringify({ error: 'Invalid email format' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (!isValidUsername(username)) {
      return new Response(
        JSON.stringify({
          error: 'Username must be 3-30 characters and contain only letters, numbers, and underscores'
        }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (!isValidPassword(password)) {
      return new Response(
        JSON.stringify({ error: 'Password must be at least 8 characters' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Check if user already exists
    const existingUser = await env.DB.prepare(
      'SELECT id FROM users WHERE email = ? OR username = ?'
    )
      .bind(email.toLowerCase(), username.toLowerCase())
      .first();

    if (existingUser) {
      return new Response(
        JSON.stringify({ error: 'Email or username already exists' }),
        { status: 409, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Hash password
    const { hash, salt } = await hashPassword(password);

    // Create user
    const userId = crypto.randomUUID();
    const now = Math.floor(Date.now() / 1000);

    await env.DB.prepare(`
      INSERT INTO users (id, email, username, password_hash, password_salt, created_at, updated_at, is_active)
      VALUES (?, ?, ?, ?, ?, ?, ?, 1)
    `)
      .bind(userId, email.toLowerCase(), username, hash, salt, now, now)
      .run();

    // Create session
    const metadata = {
      userAgent: request.headers.get('User-Agent'),
      ipAddress: request.headers.get('CF-Connecting-IP')
    };

    const { token, expiresAt } = await createSession(env.DB, userId, metadata);

    // Return success with session cookie
    return new Response(
      JSON.stringify({
        success: true,
        user: {
          id: userId,
          email: email.toLowerCase(),
          username: username
        }
      }),
      {
        status: 201,
        headers: {
          'Content-Type': 'application/json',
          'Set-Cookie': createSessionCookie(token, expiresAt)
        }
      }
    );
  } catch (error) {
    console.error('Registration error:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
</file>

<file path="functions/api/health/tarot-reading.js">
import { jsonResponse } from '../../lib/utils.js';
import { onRequestGet as tarotReadingHealth } from '../tarot-reading.js';

export const onRequestGet = async (context) => {
  try {
    if (typeof tarotReadingHealth === 'function') {
      return await tarotReadingHealth(context);
    }
  } catch (error) {
    console.warn('Tarot reading health check failed, returning fallback payload:', error);
  }

  return jsonResponse({ status: 'ok', provider: 'local-fallback', timestamp: new Date().toISOString() });
};

export const onRequestPost = () => jsonResponse({ error: 'Not supported.' }, { status: 405 });
</file>

<file path="functions/api/health/tts.js">
import { jsonResponse } from '../../lib/utils.js';
import { onRequestGet as ttsHealth } from '../tts.js';

export const onRequestGet = async (context) => {
  try {
    if (typeof ttsHealth === 'function') {
      return await ttsHealth(context);
    }
  } catch (error) {
    console.warn('TTS health check failed, returning fallback payload:', error);
  }

  return jsonResponse({ status: 'ok', provider: 'local-fallback', timestamp: new Date().toISOString() });
};

export const onRequestPost = () => jsonResponse({ error: 'Not supported.' }, { status: 405 });
</file>

<file path="functions/api/journal/[id].js">
/**
 * Journal Entry Operations by ID
 * DELETE /api/journal/[id] - Delete a specific journal entry
 */

import {
  validateSession,
  getSessionFromCookie
} from '../../lib/auth.js';

/**
 * DELETE /api/journal/[id]
 * Delete a specific journal entry (with ownership verification)
 */
export async function onRequestDelete(context) {
  const { request, env, params } = context;

  try {
    // Authenticate user
    const cookieHeader = request.headers.get('Cookie');
    const token = getSessionFromCookie(cookieHeader);
    const user = await validateSession(env.DB, token);

    if (!user) {
      return new Response(
        JSON.stringify({ error: 'Not authenticated' }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    const entryId = params.id;

    if (!entryId) {
      return new Response(
        JSON.stringify({ error: 'Entry ID is required' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Verify ownership before deleting
    const entry = await env.DB.prepare(
      'SELECT user_id FROM journal_entries WHERE id = ?'
    )
      .bind(entryId)
      .first();

    if (!entry) {
      return new Response(
        JSON.stringify({ error: 'Entry not found' }),
        { status: 404, headers: { 'Content-Type': 'application/json' } }
      );
    }

    if (entry.user_id !== user.id) {
      return new Response(
        JSON.stringify({ error: 'Unauthorized to delete this entry' }),
        { status: 403, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Delete the entry
    await env.DB.prepare('DELETE FROM journal_entries WHERE id = ?')
      .bind(entryId)
      .run();

    return new Response(
      JSON.stringify({ success: true }),
      {
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  } catch (error) {
    console.error('Delete journal entry error:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
</file>

<file path="functions/api/keys/[id].js">
/**
 * API Key Management - Delete/Revoke
 * /api/keys/[id]
 */

import { validateSession, getSessionFromCookie } from '../../lib/auth.js';

export async function onRequestDelete(context) {
  const { request, env, params } = context;
  const keyId = params.id;

  try {
    // Auth check
    const cookieHeader = request.headers.get('Cookie');
    const token = getSessionFromCookie(cookieHeader);
    const user = await validateSession(env.DB, token);

    if (!user) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });
    }

    // Delete key (ensure it belongs to user)
    const result = await env.DB.prepare(`
      DELETE FROM api_keys
      WHERE id = ? AND user_id = ?
    `)
    .bind(keyId, user.id)
    .run();

    if (result.meta.changes === 0) {
      return new Response(JSON.stringify({ error: 'Key not found or permission denied' }), { status: 404 });
    }

    return new Response(JSON.stringify({ success: true }), {
      headers: { 'Content-Type': 'application/json' }
    });

  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), { status: 500 });
  }
}
</file>

<file path="functions/api/keys/index.js">
/**
 * API Key Management - List and Create
 * /api/keys
 */

import { validateSession, getSessionFromCookie } from '../../lib/auth.js';
import { generateApiKey, hashApiKey } from '../../lib/apiKeys.js';

export async function onRequestGet(context) {
  const { request, env } = context;

  try {
    // Auth check
    const cookieHeader = request.headers.get('Cookie');
    const token = getSessionFromCookie(cookieHeader);
    const user = await validateSession(env.DB, token);

    if (!user) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });
    }

    // List keys
    const keys = await env.DB.prepare(`
      SELECT id, name, key_prefix, created_at, last_used_at, is_active
      FROM api_keys
      WHERE user_id = ?
      ORDER BY created_at DESC
    `)
    .bind(user.id)
    .all();

    return new Response(JSON.stringify({ keys: keys.results }), {
      headers: { 'Content-Type': 'application/json' }
    });

  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), { status: 500 });
  }
}

export async function onRequestPost(context) {
  const { request, env } = context;

  try {
    // Auth check
    const cookieHeader = request.headers.get('Cookie');
    const token = getSessionFromCookie(cookieHeader);
    const user = await validateSession(env.DB, token);

    if (!user) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), { status: 401 });
    }

    // Accept empty or invalid JSON bodies so callers can omit payloads.
    let parsedBody = null;
    try {
      parsedBody = await request.json();
    } catch {
      parsedBody = null;
    }

    const providedName = typeof parsedBody?.name === 'string' ? parsedBody.name.trim() : '';
    const name = providedName || 'Untitled Key';

    // Generate key
    const rawKey = generateApiKey();
    const keyHash = await hashApiKey(rawKey);
    const keyPrefix = rawKey.substring(0, 10); // sk_ + 7 chars
    const id = crypto.randomUUID();
    const now = Math.floor(Date.now() / 1000);

    // Store
    await env.DB.prepare(`
      INSERT INTO api_keys (id, user_id, key_hash, key_prefix, name, created_at, is_active)
      VALUES (?, ?, ?, ?, ?, ?, 1)
    `)
    .bind(id, user.id, keyHash, keyPrefix, name, now)
    .run();

    // Return raw key ONLY ONCE
    return new Response(JSON.stringify({
      success: true,
      apiKey: {
        id,
        name,
        prefix: keyPrefix,
        key: rawKey, // The secret key
        createdAt: now
      }
    }), {
      headers: { 'Content-Type': 'application/json' },
      status: 201
    });

  } catch (error) {
    return new Response(JSON.stringify({ error: error.message }), { status: 500 });
  }
}
</file>

<file path="functions/api/share/[token].js">
import { computeJournalStats } from '../../../shared/journal/stats.js';
import { validateSession, getSessionFromCookie } from '../../lib/auth.js';
import { loadShareRecord, loadShareEntries, loadShareNotes } from '../../lib/shareData.js';
import { buildShareMeta } from '../../lib/shareUtils.js';

export async function onRequestGet(context) {
  const { env, params } = context;
  const token = params.token;

  try {
    const share = await loadShareRecord(env, token);
    if (!share) {
      return new Response(JSON.stringify({ error: 'Share link not found' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    if (share.expiresAt && share.expiresAt < Math.floor(Date.now() / 1000)) {
      return new Response(JSON.stringify({ error: 'Share link expired' }), {
        status: 410,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    const [entries, notes] = await Promise.all([
      loadShareEntries(env, token),
      loadShareNotes(env, token)
    ]);

    const stats = computeJournalStats(entries);
    const derivedMeta = buildShareMeta(entries);
    const mergedMeta = { ...share.meta, ...derivedMeta };
    const nextViewCount = (share.viewCount || 0) + 1;
    const collaboration = {
      noteCount: notes.length,
      lastNoteAt: notes.length ? Math.max(...notes.map((note) => note.createdAt)) : null
    };

    await env.DB.prepare('UPDATE share_tokens SET view_count = view_count + 1 WHERE token = ?')
      .bind(token)
      .run()
      .catch(() => null);

    return new Response(
      JSON.stringify({
        scope: share.scope,
        title: share.title || (share.scope === 'entry' ? 'Shared reading' : 'Journal snapshot'),
        createdAt: share.createdAt * 1000,
        expiresAt: share.expiresAt ? share.expiresAt * 1000 : null,
        viewCount: nextViewCount,
        meta: mergedMeta,
        stats,
        entries,
        notes,
        collaboration
      }),
      {
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  } catch (error) {
    console.error('GET /api/share/:token error:', error);
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

export async function onRequestDelete(context) {
  const { request, env, params } = context;
  const shareToken = params.token;

  try {
    const cookieHeader = request.headers.get('Cookie');
    const sessionToken = getSessionFromCookie(cookieHeader);
    const user = await validateSession(env.DB, sessionToken);

    if (!user) {
      return new Response(JSON.stringify({ error: 'Not authenticated' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    const share = await loadShareRecord(env, shareToken);
    if (!share) {
      return new Response(JSON.stringify({ error: 'Share link not found' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    if (share.userId !== user.id) {
      return new Response(JSON.stringify({ error: 'Not authorized to delete this share' }), {
        status: 403,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    await env.DB.prepare('DELETE FROM share_tokens WHERE token = ?')
      .bind(shareToken)
      .run();

    return new Response(JSON.stringify({ success: true }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('DELETE /api/share/:token error:', error);
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
</file>

<file path="functions/api/share-notes/[token].js">
import { loadShareRecord, loadShareNotes } from '../../lib/shareData.js';

export async function onRequestGet(context) {
  const { env, params } = context;
  try {
    const share = await loadShareRecord(env, params.token);
    if (!share) {
      return new Response(JSON.stringify({ error: 'Share link not found' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    const notes = await loadShareNotes(env, params.token);
    return new Response(JSON.stringify({ notes }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('GET /api/share-notes/:token error:', error);
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

export async function onRequestPost(context) {
  const { env, params, request } = context;
  try {
    const share = await loadShareRecord(env, params.token);
    if (!share) {
      return new Response(JSON.stringify({ error: 'Share link not found' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    if (share.expiresAt && share.expiresAt < Math.floor(Date.now() / 1000)) {
      return new Response(JSON.stringify({ error: 'Share link expired' }), {
        status: 410,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    const payload = await request.json().catch(() => ({}));
    const rawBody = typeof payload.body === 'string' ? payload.body : '';
    const bodyText = rawBody.trim();
    if (!bodyText) {
      return new Response(JSON.stringify({ error: 'Note text is required' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    if (bodyText.length > 600) {
      return new Response(JSON.stringify({ error: 'Note is too long (max 600 characters)' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    const authorNameInput = typeof payload.authorName === 'string' ? payload.authorName : '';
    const authorName = (authorNameInput.trim() || 'Guest Seeker').slice(0, 40);
    const cardPositionInput = typeof payload.cardPosition === 'string' ? payload.cardPosition : null;
    const cardPosition = cardPositionInput ? cardPositionInput.trim().slice(0, 80) : null;

    const id = crypto.randomUUID();
    const now = Math.floor(Date.now() / 1000);

    await env.DB.prepare(`
      INSERT INTO share_notes (id, token, author_name, body, card_position, created_at)
      VALUES (?, ?, ?, ?, ?, ?)
    `).bind(id, params.token, authorName, bodyText, cardPosition, now).run();

    const note = {
      id,
      authorName,
      body: bodyText,
      cardPosition,
      createdAt: now * 1000
    };

    return new Response(JSON.stringify({ note }), {
      status: 201,
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('POST /api/share-notes/:token error:', error);
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
</file>

<file path="functions/api/archetype-journey-backfill.js">
/**
 * Archetype Journey Backfill API
 *
 * POST /api/archetype-journey-backfill
 * Populates card_appearances from existing journal_entries for the authenticated user.
 * This enables Archetype Journey analytics for users with historical readings.
 *
 * Truly idempotent: Computes absolute counts from all entries and replaces existing data.
 * Running multiple times always produces the same result.
 */

import { getUserFromRequest } from '../lib/auth.js';

function buildCorsHeaders(request) {
  const origin = request.headers.get('Origin');
  const base = {
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization'
  };

  if (origin) {
    return {
      ...base,
      'Access-Control-Allow-Origin': origin,
      'Access-Control-Allow-Credentials': 'true',
      'Vary': 'Origin'
    };
  }

  return {
    ...base,
    'Access-Control-Allow-Origin': '*'
  };
}

/**
 * Parse cards from journal entry
 * Handles both JSON string and already-parsed array
 */
function parseCards(cardsJson) {
  if (!cardsJson) return [];

  if (Array.isArray(cardsJson)) {
    return cardsJson;
  }

  if (typeof cardsJson === 'string') {
    try {
      const parsed = JSON.parse(cardsJson);
      return Array.isArray(parsed) ? parsed : [];
    } catch {
      return [];
    }
  }

  return [];
}

/**
 * Extract card number from card data
 * Major Arcana: 0-21 (from `number` field)
 * Minor Arcana: null (we track by name only)
 */
function getCardNumber(card) {
  // Major Arcana have a `number` field (0-21)
  if (typeof card.number === 'number' && card.number >= 0 && card.number <= 21) {
    return card.number;
  }
  return null;
}

export async function onRequest(context) {
  const { request, env } = context;
  const method = request.method;
  const corsHeaders = buildCorsHeaders(request);

  if (method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  if (method !== 'POST') {
    return new Response(JSON.stringify({ error: 'Method not allowed' }), {
      status: 405,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }

  try {
    // Get authenticated user
    const user = await getUserFromRequest(request, env);
    if (!user) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    const db = env.DB;
    const userId = user.id;

    // Fetch all journal entries for this user
    const entriesQuery = await db.prepare(`
      SELECT id, cards_json, created_at
      FROM journal_entries
      WHERE user_id = ?
      ORDER BY created_at ASC
    `).bind(userId).all();

    const entries = entriesQuery.results || [];

    if (entries.length === 0) {
      return new Response(JSON.stringify({
        success: true,
        message: 'No journal entries to backfill',
        stats: { entriesProcessed: 0, cardsTracked: 0, badgesAwarded: 0 }
      }), {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // Step 1: Compute absolute counts from all entries
    // Key: "cardName|yearMonth" -> { count, cardNumber, firstSeen, lastSeen }
    const cardCounts = new Map();

    for (const entry of entries) {
      const cards = parseCards(entry.cards_json);
      if (cards.length === 0) continue;

      const timestamp = entry.created_at;
      const yearMonth = new Date(timestamp * 1000).toISOString().slice(0, 7);

      for (const card of cards) {
        const cardName = card.name;
        if (!cardName) continue;

        const key = `${cardName}|${yearMonth}`;
        const existing = cardCounts.get(key);

        if (existing) {
          existing.count += 1;
          existing.lastSeen = Math.max(existing.lastSeen, timestamp);
          existing.firstSeen = Math.min(existing.firstSeen, timestamp);
        } else {
          cardCounts.set(key, {
            cardName,
            cardNumber: getCardNumber(card),
            yearMonth,
            count: 1,
            firstSeen: timestamp,
            lastSeen: timestamp
          });
        }
      }
    }

    // Step 2: Delete existing card_appearances for this user (clean slate)
    await db.prepare(`
      DELETE FROM card_appearances WHERE user_id = ?
    `).bind(userId).run();

    // Step 3: Insert computed absolute counts
    let totalCardsTracked = 0;
    const processedMonths = new Set();

    for (const data of cardCounts.values()) {
      await db.prepare(`
        INSERT INTO card_appearances (user_id, card_name, card_number, year_month, count, last_seen, first_seen)
        VALUES (?, ?, ?, ?, ?, ?, ?)
      `).bind(
        userId,
        data.cardName,
        data.cardNumber,
        data.yearMonth,
        data.count,
        data.lastSeen,
        data.firstSeen
      ).run();

      totalCardsTracked += data.count;
      processedMonths.add(data.yearMonth);
    }

    // Step 4: Delete existing badges and recompute (for true idempotency)
    await db.prepare(`
      DELETE FROM archetype_badges WHERE user_id = ?
    `).bind(userId).run();

    // Award badges for any months with streaks
    let badgesAwarded = 0;
    for (const yearMonth of processedMonths) {
      const awarded = await checkAndAwardBadges(db, userId, yearMonth);
      badgesAwarded += awarded;
    }

    return new Response(JSON.stringify({
      success: true,
      message: 'Backfill complete',
      stats: {
        entriesProcessed: entries.length,
        cardsTracked: totalCardsTracked,
        uniqueCardMonths: cardCounts.size,
        monthsProcessed: processedMonths.size,
        badgesAwarded
      }
    }), {
      status: 200,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });

  } catch (error) {
    console.error('Backfill error:', error);
    return new Response(JSON.stringify({
      error: 'Backfill failed',
      message: error.message
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
}

/**
 * Check for and award badges based on card frequencies
 * Returns count of new badges awarded
 *
 * Note: This is called after all badges have been deleted for idempotency,
 * so we insert directly without checking for existing badges.
 */
async function checkAndAwardBadges(db, userId, yearMonth) {
  const now = Math.floor(Date.now() / 1000);
  let awarded = 0;

  // Get current month's card counts
  const cardsQuery = await db.prepare(`
    SELECT card_name, count
    FROM card_appearances
    WHERE user_id = ? AND year_month = ?
  `).bind(userId, yearMonth).all();

  const cards = cardsQuery.results || [];

  // Award streak badges for cards appearing 3+ times
  for (const card of cards) {
    if (card.count >= 3) {
      const badgeKey = `streak_3x_${card.card_name.toLowerCase().replace(/\s+/g, '_')}_${yearMonth}`;

      const metadata = JSON.stringify({
        count: card.count,
        month: yearMonth,
        context: `${card.card_name} appeared ${card.count} times in ${yearMonth}`
      });

      await db.prepare(`
        INSERT INTO archetype_badges (user_id, badge_type, badge_key, card_name, earned_at, metadata_json)
        VALUES (?, 'streak', ?, ?, ?, ?)
      `).bind(userId, badgeKey, card.card_name, now, metadata).run();

      awarded++;
    }
  }

  return awarded;
}
</file>

<file path="functions/api/archetype-journey.js">
/**
 * Archetype Journey Analytics API
 *
 * Endpoints:
 * - GET /api/archetype-journey - Get analytics data for authenticated user
 * - POST /api/archetype-journey/track - Track card appearances (called automatically on reading save)
 * - PUT /api/archetype-journey/preferences - Update analytics preferences
 * - POST /api/archetype-journey/reset - Reset all analytics data
 */

import { getUserFromRequest } from '../lib/auth.js';

function buildCorsHeaders(request) {
  const origin = request.headers.get('Origin');
  const base = {
    'Access-Control-Allow-Methods': 'GET, POST, PUT, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization'
  };

  if (origin) {
    return {
      ...base,
      'Access-Control-Allow-Origin': origin,
      'Access-Control-Allow-Credentials': 'true',
      'Vary': 'Origin'
    };
  }

  return {
    ...base,
    'Access-Control-Allow-Origin': '*'
  };
}

/**
 * Main handler for archetype journey endpoints
 */
export async function onRequest(context) {
  const { request, env } = context;
  const url = new URL(request.url);
  const method = request.method;

  // CORS headers (credential-friendly)
  const corsHeaders = buildCorsHeaders(request);

  if (method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    // Get authenticated user
    const user = await getUserFromRequest(request, env);
    if (!user) {
      return new Response(JSON.stringify({ error: 'Unauthorized' }), {
        status: 401,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // Check user preferences
    const prefs = await getUserPreferences(env.DB, user.id);
    if (!prefs.archetype_journey_enabled && !url.pathname.includes('/preferences')) {
      return new Response(JSON.stringify({
        error: 'Analytics disabled',
        enabled: false
      }), {
        status: 403,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }

    // Route to appropriate handler
    if (url.pathname === '/api/archetype-journey' && method === 'GET') {
      return await handleGetAnalytics(env.DB, user.id, corsHeaders);
    } else if (url.pathname === '/api/archetype-journey/track' && method === 'POST') {
      const body = await request.json();
      return await handleTrackCards(env.DB, user.id, body, corsHeaders);
    } else if (url.pathname === '/api/archetype-journey/preferences' && method === 'PUT') {
      const body = await request.json();
      return await handleUpdatePreferences(env.DB, user.id, body, corsHeaders);
    } else if (url.pathname === '/api/archetype-journey/reset' && method === 'POST') {
      return await handleResetAnalytics(env.DB, user.id, corsHeaders);
    } else {
      return new Response(JSON.stringify({ error: 'Not found' }), {
        status: 404,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });
    }
  } catch (error) {
    console.error('Archetype journey error:', error);
    return new Response(JSON.stringify({
      error: 'Internal server error',
      message: error.message
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
}

/**
 * Get analytics data for user
 */
async function handleGetAnalytics(db, userId, corsHeaders) {
  const _now = Math.floor(Date.now() / 1000);
  const currentMonth = new Date().toISOString().slice(0, 7); // YYYY-MM

  // Get top 5 cards this month
  const topCardsQuery = await db.prepare(`
    SELECT card_name, card_number, count, last_seen, first_seen
    FROM card_appearances
    WHERE user_id = ? AND year_month = ?
    ORDER BY count DESC, last_seen DESC
    LIMIT 5
  `).bind(userId, currentMonth).all();

  const topCards = topCardsQuery.results || [];

  // Get all cards for current month (for trends)
  const allCardsQuery = await db.prepare(`
    SELECT card_name, card_number, count
    FROM card_appearances
    WHERE user_id = ? AND year_month = ?
    ORDER BY count DESC
  `).bind(userId, currentMonth).all();

  const allCards = allCardsQuery.results || [];

  // Get recent badges
  const badgesQuery = await db.prepare(`
    SELECT badge_type, badge_key, card_name, earned_at, metadata_json
    FROM archetype_badges
    WHERE user_id = ?
    ORDER BY earned_at DESC
    LIMIT 10
  `).bind(userId).all();

  const badges = (badgesQuery.results || []).map(badge => ({
    ...badge,
    metadata: badge.metadata_json ? JSON.parse(badge.metadata_json) : {}
  }));

  // Calculate streaks (cards appearing multiple times)
  const streaks = allCards.filter(card => card.count >= 2).map(card => ({
    cardName: card.card_name,
    cardNumber: card.card_number,
    count: card.count,
    month: currentMonth
  }));

  // Get historical data for trends (last 6 months)
  const sixMonthsAgo = new Date();
  sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
  const startMonth = sixMonthsAgo.toISOString().slice(0, 7);

  const trendsQuery = await db.prepare(`
    SELECT card_name, card_number, year_month, count
    FROM card_appearances
    WHERE user_id = ? AND year_month >= ?
    ORDER BY year_month DESC, count DESC
  `).bind(userId, startMonth).all();

  const trends = trendsQuery.results || [];

  // Calculate Major Arcana frequency distribution
  const majorArcanaFreq = allCards
    .filter(card => card.card_number !== null && card.card_number <= 21)
    .reduce((acc, card) => {
      acc[card.card_name] = card.count;
      return acc;
    }, {});

  return new Response(JSON.stringify({
    success: true,
    analytics: {
      currentMonth,
      topCards,
      allCards,
      streaks,
      badges,
      trends,
      majorArcanaFrequency: majorArcanaFreq,
      totalReadingsThisMonth: allCards.reduce((sum, card) => sum + card.count, 0)
    }
  }), {
    status: 200,
    headers: { ...corsHeaders, 'Content-Type': 'application/json' }
  });
}

/**
 * Track card appearances from a reading
 */
async function handleTrackCards(db, userId, body, corsHeaders) {
  const { cards, timestamp } = body;

  if (!Array.isArray(cards) || cards.length === 0) {
    return new Response(JSON.stringify({
      error: 'Invalid cards data'
    }), {
      status: 400,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }

  const now = Math.floor((timestamp || Date.now()) / 1000);
  const yearMonth = new Date(now * 1000).toISOString().slice(0, 7);

  try {
    // Track each card
    for (const card of cards) {
      const cardName = card.name;
      const cardNumber = card.number !== undefined ? card.number : null;

      // Upsert card appearance
      await db.prepare(`
        INSERT INTO card_appearances (user_id, card_name, card_number, year_month, count, last_seen, first_seen)
        VALUES (?, ?, ?, ?, 1, ?, ?)
        ON CONFLICT(user_id, card_name, year_month) DO UPDATE SET
          count = count + 1,
          last_seen = ?
      `).bind(userId, cardName, cardNumber, yearMonth, now, now, now).run();
    }

    // Check for new badges (streaks)
    await checkAndAwardBadges(db, userId, yearMonth, now);

    return new Response(JSON.stringify({
      success: true,
      tracked: cards.length
    }), {
      status: 200,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('Failed to track cards:', error);
    return new Response(JSON.stringify({
      error: 'Failed to track cards',
      message: error.message
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
}

/**
 * Check for and award new badges based on card frequencies
 */
async function checkAndAwardBadges(db, userId, yearMonth, now) {
  // Get current month's card counts
  const cardsQuery = await db.prepare(`
    SELECT card_name, count
    FROM card_appearances
    WHERE user_id = ? AND year_month = ?
  `).bind(userId, yearMonth).all();

  const cards = cardsQuery.results || [];

  // Award streak badges for cards appearing 3+ times
  for (const card of cards) {
    if (card.count === 3) {
      const badgeKey = `streak_3x_${card.card_name.toLowerCase().replace(/\s+/g, '_')}_${yearMonth}`;

      // Check if badge already exists
      const existingBadge = await db.prepare(`
        SELECT id FROM archetype_badges WHERE user_id = ? AND badge_key = ?
      `).bind(userId, badgeKey).first();

      if (!existingBadge) {
        // Award new badge
        const metadata = JSON.stringify({
          count: card.count,
          month: yearMonth,
          context: `${card.card_name} appeared ${card.count} times in ${yearMonth}`
        });

        await db.prepare(`
          INSERT INTO archetype_badges (user_id, badge_type, badge_key, card_name, earned_at, metadata_json)
          VALUES (?, 'streak', ?, ?, ?, ?)
        `).bind(userId, badgeKey, card.card_name, now, metadata).run();
      }
    }
  }
}

/**
 * Update user preferences
 */
async function handleUpdatePreferences(db, userId, body, corsHeaders) {
  const { archetype_journey_enabled, show_badges } = body;
  const now = Math.floor(Date.now() / 1000);

  try {
    await db.prepare(`
      INSERT INTO user_analytics_prefs (user_id, archetype_journey_enabled, show_badges, updated_at)
      VALUES (?, ?, ?, ?)
      ON CONFLICT(user_id) DO UPDATE SET
        archetype_journey_enabled = COALESCE(?, archetype_journey_enabled),
        show_badges = COALESCE(?, show_badges),
        updated_at = ?
    `).bind(
      userId,
      archetype_journey_enabled !== undefined ? (archetype_journey_enabled ? 1 : 0) : 1,
      show_badges !== undefined ? (show_badges ? 1 : 0) : 1,
      now,
      archetype_journey_enabled !== undefined ? (archetype_journey_enabled ? 1 : 0) : null,
      show_badges !== undefined ? (show_badges ? 1 : 0) : null,
      now
    ).run();

    return new Response(JSON.stringify({
      success: true,
      preferences: {
        archetype_journey_enabled: archetype_journey_enabled !== undefined ? archetype_journey_enabled : true,
        show_badges: show_badges !== undefined ? show_badges : true
      }
    }), {
      status: 200,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('Failed to update preferences:', error);
    return new Response(JSON.stringify({
      error: 'Failed to update preferences',
      message: error.message
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
}

/**
 * Reset all analytics data for user
 */
async function handleResetAnalytics(db, userId, corsHeaders) {
  try {
    await db.prepare(`DELETE FROM card_appearances WHERE user_id = ?`).bind(userId).run();
    await db.prepare(`DELETE FROM archetype_badges WHERE user_id = ?`).bind(userId).run();

    return new Response(JSON.stringify({
      success: true,
      message: 'Analytics data reset'
    }), {
      status: 200,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('Failed to reset analytics:', error);
    return new Response(JSON.stringify({
      error: 'Failed to reset analytics',
      message: error.message
    }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
}

/**
 * Get user analytics preferences
 */
async function getUserPreferences(db, userId) {
  const result = await db.prepare(`
    SELECT archetype_journey_enabled, show_badges
    FROM user_analytics_prefs
    WHERE user_id = ?
  `).bind(userId).first();

  if (!result) {
    // Default preferences
    return {
      archetype_journey_enabled: true,
      show_badges: true
    };
  }

  return {
    archetype_journey_enabled: result.archetype_journey_enabled === 1,
    show_badges: result.show_badges === 1
  };
}
</file>

<file path="functions/api/feedback.js">
import { jsonResponse, readJsonBody } from '../lib/utils.js';

function sanitizeRatings(ratings = {}) {
  if (typeof ratings !== 'object' || ratings === null) return null;
  const entries = ['overallAccuracy', 'narrativeCoherence', 'practicalValue'];
  const sanitized = {};
  let hasValue = false;
  entries.forEach((key) => {
    const value = Number(ratings[key]);
    if (!Number.isFinite(value)) {
      sanitized[key] = null;
      return;
    }
    const clamped = Math.min(5, Math.max(1, value));
    sanitized[key] = clamped;
    if (clamped) hasValue = true;
  });
  return hasValue ? sanitized : null;
}

export async function onRequestPost({ request, env }) {
  try {
    const payload = await readJsonBody(request);
    const ratings = sanitizeRatings(payload?.ratings);
    if (!ratings) {
      return jsonResponse({ error: 'Missing or invalid ratings.' }, { status: 400 });
    }

    const record = {
      id: payload?.feedbackId || (crypto.randomUUID ? crypto.randomUUID() : `fb_${Date.now()}`),
      requestId: payload?.requestId || null,
      spreadKey: payload?.spreadKey || null,
      spreadName: payload?.spreadName || null,
      deckStyle: payload?.deckStyle || null,
      provider: payload?.provider || null,
      userQuestion: payload?.userQuestion || null,
      ratings,
      notes: payload?.notes ? String(payload.notes).slice(0, 1000) : null,
      visionSummary: payload?.visionSummary || null,
      cards: Array.isArray(payload?.cards) ? payload.cards.slice(0, 15) : null,
      submittedAt: new Date().toISOString()
    };

    if (env?.FEEDBACK_KV) {
      const key = `feedback:${record.id}`;
      await env.FEEDBACK_KV.put(key, JSON.stringify(record), {
        metadata: {
          requestId: record.requestId,
          spreadKey: record.spreadKey,
          submittedAt: record.submittedAt
        }
      });
    } else {
      console.warn('FEEDBACK_KV is not configured; feedback will not be persisted.');
    }

    return jsonResponse({ success: true });
  } catch (error) {
    console.error('feedback function failed:', error);
    return jsonResponse({ error: 'Unable to record feedback.' }, { status: 500 });
  }
}

export async function onRequestGet() {
  return jsonResponse({ error: 'Listing feedback is not supported via public API.' }, { status: 405 });
}
</file>

<file path="functions/api/generate-question.js">
import { callAzureResponses, ensureAzureConfig } from '../lib/azureResponses.js';
import {
  fetchEphemerisForecast,
  formatForecastHighlights
} from '../lib/ephemerisIntegration.js';

const JSON_HEADERS = { 'Content-Type': 'application/json' };

function sanitizeSnippet(value, fallback) {
  if (!value || typeof value !== 'string') return fallback;
  return value.trim();
}

function ensureQuestionMark(text) {
  if (!text) return '';
  return text.trim().endsWith('?') ? text.trim() : `${text.trim()}?`;
}

/**
 * FNV-1a hash function (matches deck.js implementation)
 */
function hashString(str) {
  let h = 2166136261 >>> 0;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

/**
 * Deterministic variant picker using seed.
 * Same seed + same list = same result.
 */
function pickDeterministic(list, seed) {
  if (!Array.isArray(list) || list.length === 0) return '';
  const numericSeed = typeof seed === 'string' ? hashString(seed) : (seed >>> 0);
  return list[numericSeed % list.length];
}

/**
 * Legacy picker with time-based randomization (non-deterministic).
 * Used when no seed is provided.
 */
function pick(list, seed = '') {
  if (!Array.isArray(list) || list.length === 0) return '';
  const mixed = seed ? Math.abs(hashString(`${seed}|${Math.random()}|${Date.now()}`)) : Math.floor(Math.random() * list.length);
  return list[mixed % list.length];
}

/**
 * Crafts a creative question from prompt and metadata.
 *
 * @param {string} prompt - The prompt text
 * @param {Object} metadata - Question metadata including seed
 * @returns {string} Generated question text
 */
function craftQuestionFromPrompt(prompt, metadata = {}) {
  const focusMatch = prompt.match(/about (.+?) for the/i);
  const timeframeMatch = prompt.match(/for the (.+?)(?:\.|$)/i);
  const depthMatch = prompt.match(/depth is (.+?)(?:\.|$)/i);

  const focus = sanitizeSnippet(metadata.focus || metadata.customFocus || (focusMatch ? focusMatch[1] : ''), 'this area of my life');
  const timeframePhrase = sanitizeSnippet(metadata.timeframePhrase || (timeframeMatch ? timeframeMatch[1] : ''), '');
  const depthLabel = sanitizeSnippet(metadata.depth || (depthMatch ? depthMatch[1] : ''), 'Focused guidance');
  const topicLabel = sanitizeSnippet(metadata.topic, 'this chapter');
  const pattern = inferPattern(metadata.pattern, depthLabel);
  const closing = sanitizeSnippet(metadata.closing, '') || inferClosing(pattern, depthLabel);

  const focusWithTimeframe = timeframePhrase
    ? `${focus} ${timeframePhrase}`.replace(/\s+/g, ' ').trim()
    : focus;

  const closingSuffix = pattern === 'transform'
    ? (closing ? ` so I can ${closing}` : '')
    : (closing ? ` ${closing}` : '');

  const supportVariants = [
    `How can I better support ${focusWithTimeframe}${closingSuffix}`,
    `What would help me tend to ${focusWithTimeframe}${closingSuffix}`,
    `Where should I focus to steady ${focusWithTimeframe}${closingSuffix}`,
    `What support will help me honor ${focusWithTimeframe}${closingSuffix}`,
    `How can I hold space for ${focusWithTimeframe}${closingSuffix}`,
    `How can I show up for ${focusWithTimeframe}${closingSuffix}`,
    `What would nourish ${focusWithTimeframe}${closingSuffix}`
  ];

  const navigateVariants = [
    `How can I navigate ${focusWithTimeframe}${closingSuffix}`,
    `How can I stay aligned with ${focusWithTimeframe}${closingSuffix}`,
    `What next step would move ${focus} forward${timeframePhrase ? ` ${timeframePhrase}` : ''}${closingSuffix}`,
    `What should I prioritize to move through ${focusWithTimeframe}${closingSuffix}`,
    `Where should I direct my energy to navigate ${focusWithTimeframe}${closingSuffix}`,
    `How can I make progress with ${focus}${timeframePhrase ? ` ${timeframePhrase}` : ''}${closingSuffix}`,
    `What would help me navigate ${focusWithTimeframe} with ease${closingSuffix}`
  ];

  const lessonVariants = [
    `What deeper lesson is ${focus} offering${timeframePhrase ? ` ${timeframePhrase}` : ''}${closingSuffix}`,
    `How can I interpret ${focusWithTimeframe} as guidance${closingSuffix}`,
    `What am I being shown about ${focusWithTimeframe}${closingSuffix}`,
    `Where is ${focus} inviting me to grow${timeframePhrase ? ` ${timeframePhrase}` : ''}${closingSuffix}`,
    `How does ${focusWithTimeframe} reflect my bigger story${closingSuffix}`,
    `What insight sits beneath ${focusWithTimeframe}${closingSuffix}`
  ];

  const transformVariants = [
    `How can I transform ${focusWithTimeframe}${closingSuffix}`,
    `What needs to shift within ${focusWithTimeframe}${closingSuffix}`,
    `What would renewal look like for ${focusWithTimeframe}${closingSuffix}`,
    `How might I nurture ${focusWithTimeframe}${closingSuffix}`,
    `What must I release to renew ${focusWithTimeframe}${closingSuffix}`,
    `How can I support the transformation of ${focusWithTimeframe}${closingSuffix}`,
    `Where is ${focusWithTimeframe} ready for change${closingSuffix}`
  ];

  const variantsByPattern = {
    support: supportVariants,
    navigate: navigateVariants,
    lesson: lessonVariants,
    transform: transformVariants
  };

  const variants = variantsByPattern[pattern] || [`How can I explore ${focusWithTimeframe}${closingSuffix}`];

  const seed = metadata.seed;
  const hasSeed = seed !== null && seed !== undefined;
  const picker = hasSeed ? pickDeterministic : pick;
  const pickerSeed = hasSeed
    ? `${seed}|${focusWithTimeframe}|${depthLabel}|${pattern}`
    : `${focusWithTimeframe}|${depthLabel}|${topicLabel}|${pattern}`;

  const question = picker(variants, pickerSeed);
  return ensureQuestionMark(question);
}

function inferPattern(patternValue, depthLabel = '') {
  const normalized = (patternValue || '').toLowerCase();
  if (['support', 'navigate', 'lesson', 'transform'].includes(normalized)) {
    return normalized;
  }
  const depth = depthLabel.toLowerCase();
  if (depth.includes('pulse')) return 'support';
  if (depth.includes('guided')) return 'navigate';
  if (depth.includes('lesson')) return 'lesson';
  if (depth.includes('deep')) return 'transform';
  return 'navigate';
}

function inferClosing(pattern, depthLabel = '') {
  if (pattern === 'support') return 'with calm awareness';
  if (pattern === 'navigate') return 'with confidence';
  if (pattern === 'lesson') return '';
  if (pattern === 'transform') return 'honor my growth';

  const depth = depthLabel.toLowerCase();
  if (depth.includes('pulse')) return 'with calm awareness';
  if (depth.includes('guided')) return 'with confidence';
  if (depth.includes('deep')) return 'honor my growth';
  return '';
}

function getForecastDays(metadata = {}) {
  const tf = `${metadata.timeframe || ''} ${metadata.timeframePhrase || ''} ${metadata.timeframeValue || ''}`.toLowerCase();

  if (tf.includes('season')) return 90;
  if (tf.includes('few months')) return 90;
  if (tf.includes('30') || tf.includes('month')) return 30;
  return null;
}

function buildAzureQuestionPrompt(prompt, metadata = {}) {
  const focusMatch = prompt.match(/about (.+?) for the/i);
  const timeframeMatch = prompt.match(/for the (.+?)(?:\.|$)/i);
  const depthMatch = prompt.match(/depth is (.+?)(?:\.|$)/i);

  const focus = sanitizeSnippet(metadata.focus || metadata.customFocus || (focusMatch ? focusMatch[1] : ''), 'this area of my life');
  const timeframe = sanitizeSnippet(metadata.timeframePhrase || (timeframeMatch ? timeframeMatch[1] : ''), 'the current moment');
  const depthLabel = sanitizeSnippet(metadata.depth || (depthMatch ? depthMatch[1] : ''), 'Focused guidance');
  const topicLabel = sanitizeSnippet(metadata.topic, 'this chapter');
  const pattern = inferPattern(metadata.pattern, depthLabel);
  const closing = sanitizeSnippet(metadata.closing, '') || inferClosing(pattern, depthLabel);

  const personalizationLines = [];
  if (Array.isArray(metadata.recentThemes) && metadata.recentThemes.length > 0) {
    personalizationLines.push(`Recent themes: ${metadata.recentThemes.slice(0, 3).join(', ')}`);
  }
  if (metadata.frequentCard) personalizationLines.push(`Recurring card: ${metadata.frequentCard}`);
  if (metadata.leadingContext) personalizationLines.push(`Common context: ${metadata.leadingContext}`);
  if (metadata.reversalRate) personalizationLines.push(`Reversals: ${metadata.reversalRate}`);
  if (Array.isArray(metadata.recentQuestions) && metadata.recentQuestions.length > 0) {
    personalizationLines.push(`Avoid repeating: ${metadata.recentQuestions.join('; ')}`);
  }
  if (Array.isArray(metadata.focusAreas) && metadata.focusAreas.length > 0) {
    personalizationLines.push(`User focus areas: ${metadata.focusAreas.join(', ')}`);
  }

  const astroHighlights = Array.isArray(metadata.ephemerisForecast?.highlights)
    ? metadata.ephemerisForecast.highlights
    : [];

  const instructions = [
    'You are a tarot intention coach. Write ONE open, agency-forward question that fits the user’s focus, timeframe, and depth.',
    'Use supportive verbs like support, navigate, transform, or explore. Avoid yes/no phrasing and avoid listing options.',
    'Do not add quotes, bullets, or any preamble. Respond with the question only and end with a question mark.',
    `Pattern: ${pattern} (support/navigate/lesson/transform), Closing: ${closing || 'none'}.`,
    astroHighlights.length ? 'Astro window is contextual; you may echo the timing (e.g., “this cycle”, “up to the next Full Moon”) but do not list the events verbatim.' : null,
    metadata.seed ? `Seed: ${metadata.seed} (use to pick a variant; do not mention).` : null
  ].filter(Boolean).join('\n');

  const inputLines = [
    `Focus: ${focus}`,
    `Timeframe: ${timeframe}`,
    `Depth: ${depthLabel}`,
    `Topic: ${topicLabel}`,
    personalizationLines.length > 0 ? personalizationLines.join('\n') : null,
    astroHighlights.length ? `Astro window: ${astroHighlights.slice(0, 3).join(' • ')}` : null,
    '',
    'Return a single question. Keep it under 28 words.'
  ].filter(Boolean).join('\n');

  return { instructions, input: inputLines };
}

async function generateQuestionWithAzure(env, prompt, metadata) {
  ensureAzureConfig(env); // Throws if missing
  const { instructions, input } = buildAzureQuestionPrompt(prompt, metadata);

  const question = await callAzureResponses(env, {
    instructions,
    input,
    // Give the model ample budget for a short question while
    // keeping latency reasonable. We no longer request reasoning
    // tokens, so this is mostly for the final text.
    maxTokens: 256,
    verbosity: 'low'
  });

  const finalQuestion = ensureQuestionMark(question);

  // Log successful Azure-backed question for debugging (no PII beyond prompt summary)
  try {
    console.log('[generate-question] Azure question generated', {
      provider: 'azure-gpt5',
      model: env?.AZURE_OPENAI_GPT5_MODEL || null,
      snippet: finalQuestion.slice(0, 160)
    });
  } catch (logError) {
    console.warn('[generate-question] Failed to log Azure question result', logError);
  }

  return finalQuestion;
}

function isAzureConfigured(env) {
  return Boolean(env?.AZURE_OPENAI_API_KEY && env?.AZURE_OPENAI_ENDPOINT && env?.AZURE_OPENAI_GPT5_MODEL);
}

export async function onRequestPost({ request, env }) {
  try {
    const body = await request.json();
    const prompt = body?.prompt;
    const metadata = body?.metadata || {};

    if (!prompt || typeof prompt !== 'string') {
      return new Response(
        JSON.stringify({ error: 'Missing prompt' }),
        { status: 400, headers: JSON_HEADERS }
      );
    }

    // Optional ephemeris forecast for medium/long-range timeframes
    let ephemerisForecast = null;
    const forecastDays = getForecastDays(metadata);

    if (forecastDays) {
      try {
        const forecast = await fetchEphemerisForecast(forecastDays);
        const highlights = formatForecastHighlights(forecast, 4);

        if (highlights.length) {
          ephemerisForecast = {
            days: forecast.forecastDays,
            highlights,
            source: forecast.source || 'astronomy-engine'
          };

          metadata.ephemerisForecast = ephemerisForecast;
          metadata.timeframeValue = metadata.timeframeValue || (forecastDays === 90 ? 'season' : 'month');
        }
      } catch (error) {
        console.warn('[generate-question] Ephemeris forecast unavailable:', error?.message || error);
      }
    }

    let provider = 'local-fallback';
    let question = null;

    if (isAzureConfigured(env)) {
      try {
        question = await generateQuestionWithAzure(env, prompt, metadata);
        provider = 'azure-gpt5';
      } catch (error) {
        console.warn('Azure GPT-5 question generation failed, using fallback:', error?.message || error);
      }
    }

    if (!question) {
      console.warn('[generate-question] No question returned from Azure path, falling back to local template.', {
        hasAzureConfig: isAzureConfigured(env),
        providerBeforeFallback: provider
      });
      question = craftQuestionFromPrompt(prompt, metadata);
      provider = 'local-fallback';
    }

    return new Response(
      JSON.stringify({
        question,
        provider,
        model: provider === 'azure-gpt5' ? env?.AZURE_OPENAI_GPT5_MODEL || null : null,
        forecast: ephemerisForecast
      }),
      { status: 200, headers: JSON_HEADERS }
    );
  } catch (error) {
    console.error('generate-question error:', error);
    return new Response(
      JSON.stringify({ error: 'Unable to craft question' }),
      { status: 500, headers: JSON_HEADERS }
    );
  }
}
</file>

<file path="functions/api/journal-export.js">
/**
 * Journal Export API Endpoint
 *
 * GET /api/journal-export/:id - Export a single reading as PDF
 * GET /api/journal-export?format=pdf - Export all readings as PDF
 *
 * Generates PDF documents and optionally stores them in R2 for caching.
 */

import { validateSession, getSessionFromCookie } from '../lib/auth.js';
import { jsonResponse } from '../lib/utils.js';

// PDF generation constants
const PDF_PAGE_HEIGHT = 842; // A4 height in points
const PDF_PAGE_WIDTH = 595;  // A4 width in points
const PDF_MARGIN = 50;
const PDF_LINE_HEIGHT = 14;
const PDF_CHARS_PER_LINE = 80;
const PDF_TOP_Y = 750;
const PDF_BOTTOM_Y = 50;

/**
 * Simple multi-page PDF generator for Cloudflare Workers
 * Creates a basic PDF document without external dependencies
 * @param {string} content - Text content to render
 * @returns {{pdf: string, pageCount: number, truncated: boolean}}
 */
export function generatePDF(content) {
  const lines = content.split('\n');

  // Encode text for PDF (handle special characters)
  const encodeText = (text) => {
    return text
      .replace(/\\/g, '\\\\')
      .replace(/\(/g, '\\(')
      .replace(/\)/g, '\\)')
      .replace(/[^\x00-\x7F]/g, '?'); // Replace non-ASCII with ?
  };

  // Word wrap a single line
  const wrapLine = (line) => {
    const wrapped = [];
    if (line.length > PDF_CHARS_PER_LINE) {
      let remaining = line;
      while (remaining.length > 0) {
        let breakPoint = PDF_CHARS_PER_LINE;
        if (remaining.length > PDF_CHARS_PER_LINE) {
          const lastSpace = remaining.lastIndexOf(' ', PDF_CHARS_PER_LINE);
          if (lastSpace > 0) {
            breakPoint = lastSpace;
          }
        }
        wrapped.push(remaining.substring(0, breakPoint));
        remaining = remaining.substring(breakPoint).trim();
      }
    } else {
      wrapped.push(line);
    }
    return wrapped;
  };

  // Generate content for a single page
  const generatePageContent = (pageLines) => {
    let yPosition = PDF_TOP_Y;
    let streamContent = 'BT\n/F1 11 Tf\n';

    for (const line of pageLines) {
      const isHeader = line.startsWith('# ') ||
                       line.startsWith('## ') ||
                       line.startsWith('### ');

      if (isHeader) {
        streamContent += 'ET\nBT\n/F1 14 Tf\n';
      }

      streamContent += `${PDF_MARGIN} ${yPosition} Td\n`;
      streamContent += `(${encodeText(line.replace(/^#+\s*/, ''))}) Tj\n`;
      streamContent += `${-PDF_MARGIN} ${-PDF_LINE_HEIGHT} Td\n`;

      if (isHeader) {
        streamContent += 'ET\nBT\n/F1 11 Tf\n';
        yPosition -= PDF_LINE_HEIGHT * 0.5;
      }

      yPosition -= PDF_LINE_HEIGHT;

      // Extra space for empty lines (paragraph breaks)
      if (line === '') {
        yPosition -= PDF_LINE_HEIGHT * 0.5;
      }
    }

    streamContent += 'ET';
    return streamContent;
  };

  // Split content into pages
  const pages = [];
  let currentPage = [];
  let currentY = PDF_TOP_Y;
  const maxPages = 20; // Limit to prevent runaway generation
  let truncated = false;
  let pageLimitReached = false;

  for (const line of lines) {
    if (pageLimitReached) break;

    const wrappedLines = wrapLine(line);

    for (const wrappedLine of wrappedLines) {
      const lineSpace = PDF_LINE_HEIGHT + (wrappedLine === '' ? PDF_LINE_HEIGHT * 0.5 : 0);

      if (currentY - lineSpace < PDF_BOTTOM_Y) {
        // Start new page
        if (currentPage.length > 0) {
          pages.push(currentPage);
        }
        if (pages.length >= maxPages) {
          // Truncate at max pages
          truncated = true;
          pageLimitReached = true;
          break;
        }
        currentPage = [];
        currentY = PDF_TOP_Y;
      }

      currentPage.push(wrappedLine);
      currentY -= lineSpace;
    }

    if (pageLimitReached) break;
  }

  // Add last page
  if (currentPage.length > 0 && pages.length < maxPages) {
    pages.push(currentPage);
  }

  const pageCount = pages.length || 1;

  // Build PDF structure
  const objects = [];
  let objectCount = 0;

  const addObject = (content) => {
    objectCount++;
    objects.push({ id: objectCount, content });
    return objectCount;
  };

  // Object 1: Catalog
  addObject('<<\n/Type /Catalog\n/Pages 2 0 R\n>>');

  // Object 2: Pages (will be updated with Kids array)
  const pageObjectIds = [];
  const pagesObjIndex = objects.length;
  addObject(''); // Placeholder

  // Object 3: Font
  const fontId = addObject('<<\n/Type /Font\n/Subtype /Type1\n/BaseFont /Helvetica\n>>');

  // Generate page objects
  for (let i = 0; i < pageCount; i++) {
    const pageLines = pages[i] || [];
    const streamContent = generatePageContent(pageLines);

    // Content stream
    const streamId = addObject(
      `<<\n/Length ${streamContent.length}\n>>\nstream\n${streamContent}\nendstream`
    );

    // Page object
    const pageId = addObject(
      `<<\n/Type /Page\n/Parent 2 0 R\n/MediaBox [0 0 ${PDF_PAGE_WIDTH} ${PDF_PAGE_HEIGHT}]\n/Contents ${streamId} 0 R\n/Resources <<\n/Font <<\n/F1 ${fontId} 0 R\n>>\n>>\n>>`
    );
    pageObjectIds.push(pageId);
  }

  // Update Pages object with correct Kids array
  const kidsArray = pageObjectIds.map(id => `${id} 0 R`).join(' ');
  objects[pagesObjIndex].content = `<<\n/Type /Pages\n/Kids [${kidsArray}]\n/Count ${pageCount}\n>>`;

  // Build PDF
  let pdf = '%PDF-1.4\n';
  const offsets = [];

  for (const obj of objects) {
    offsets.push(pdf.length);
    pdf += `${obj.id} 0 obj\n${obj.content}\nendobj\n`;
  }

  // Cross-reference table
  const xrefOffset = pdf.length;
  pdf += 'xref\n';
  pdf += `0 ${objectCount + 1}\n`;
  pdf += '0000000000 65535 f \n';

  for (const offset of offsets) {
    pdf += `${offset.toString().padStart(10, '0')} 00000 n \n`;
  }

  // Trailer
  pdf += 'trailer\n';
  pdf += `<<\n/Size ${objectCount + 1}\n/Root 1 0 R\n>>\n`;
  pdf += 'startxref\n';
  pdf += `${xrefOffset}\n`;
  pdf += '%%EOF';

  return { pdf, pageCount, truncated };
}

/**
 * Format a journal entry as readable text for PDF
 */
function formatEntryAsText(entry) {
  const lines = [];
  const date = new Date(entry.ts).toLocaleString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });

  lines.push(`# ${entry.spread || 'Tarot Reading'}`);
  lines.push(`Date: ${date}`);
  lines.push('');

  if (entry.question) {
    lines.push('## Question');
    lines.push(entry.question);
    lines.push('');
  }

  if (entry.context) {
    lines.push(`Context: ${entry.context}`);
    lines.push('');
  }

  lines.push('## Cards Drawn');
  if (Array.isArray(entry.cards)) {
    for (const card of entry.cards) {
      const position = card.position ? `${card.position}: ` : '';
      const orientation = card.orientation ? ` (${card.orientation})` : '';
      lines.push(`- ${position}${card.card || card.name}${orientation}`);
    }
  }
  lines.push('');

  if (entry.personalReading) {
    lines.push('## Reading');
    // Split long reading into paragraphs
    const paragraphs = entry.personalReading.split(/\n\n+/);
    for (const para of paragraphs) {
      lines.push(para.replace(/\n/g, ' ').trim());
      lines.push('');
    }
  }

  if (entry.reflections && Object.keys(entry.reflections).length > 0) {
    lines.push('## Personal Reflections');
    for (const [position, reflection] of Object.entries(entry.reflections)) {
      if (reflection) {
        lines.push(`Position ${position}: ${reflection}`);
      }
    }
    lines.push('');
  }

  lines.push('---');
  lines.push('');

  return lines.join('\n');
}

/**
 * GET /api/journal-export/:id or /api/journal-export
 */
export async function onRequestGet(context) {
  const { request, env, params } = context;

  try {
    // Authenticate user
    const cookieHeader = request.headers.get('Cookie');
    const token = getSessionFromCookie(cookieHeader);
    const user = await validateSession(env.DB, token);

    if (!user) {
      return jsonResponse({ error: 'Not authenticated' }, { status: 401 });
    }

    const url = new URL(request.url);
    const format = url.searchParams.get('format') || 'pdf';
    const cacheParam = url.searchParams.get('cache');
    const shouldCache = cacheParam === null
      ? true
      : !['0', 'false', 'no', 'off'].includes(cacheParam.toLowerCase());
    const entryId = params?.id;

    let entries = [];

    if (entryId) {
      // Export single entry
      const entry = await env.DB.prepare(`
        SELECT
          id, created_at, spread_key, spread_name, question,
          cards_json, narrative, themes_json, reflections_json,
          context, provider, session_seed
        FROM journal_entries
        WHERE user_id = ? AND id = ?
      `).bind(user.id, entryId).first();

      if (!entry) {
        return jsonResponse({ error: 'Entry not found' }, { status: 404 });
      }

      entries = [{
        id: entry.id,
        ts: entry.created_at * 1000,
        spread: entry.spread_name,
        spreadKey: entry.spread_key,
        question: entry.question,
        cards: JSON.parse(entry.cards_json || '[]'),
        personalReading: entry.narrative,
        themes: entry.themes_json ? JSON.parse(entry.themes_json) : null,
        reflections: entry.reflections_json ? JSON.parse(entry.reflections_json) : {},
        context: entry.context,
        provider: entry.provider
      }];
    } else {
      // Export all entries (with limit)
      const rawLimit = parseInt(url.searchParams.get('limit') || '50', 10);
      const limit = Number.isFinite(rawLimit) && rawLimit > 0
        ? Math.min(rawLimit, 100)
        : 50;
      const result = await env.DB.prepare(`
        SELECT
          id, created_at, spread_key, spread_name, question,
          cards_json, narrative, themes_json, reflections_json,
          context, provider, session_seed
        FROM journal_entries
        WHERE user_id = ?
        ORDER BY created_at DESC
        LIMIT ?
      `).bind(user.id, limit).all();

      entries = (result.results || []).map(entry => ({
        id: entry.id,
        ts: entry.created_at * 1000,
        spread: entry.spread_name,
        spreadKey: entry.spread_key,
        question: entry.question,
        cards: JSON.parse(entry.cards_json || '[]'),
        personalReading: entry.narrative,
        themes: entry.themes_json ? JSON.parse(entry.themes_json) : null,
        reflections: entry.reflections_json ? JSON.parse(entry.reflections_json) : {},
        context: entry.context,
        provider: entry.provider
      }));
    }

    if (entries.length === 0) {
      return jsonResponse({ error: 'No entries to export' }, { status: 404 });
    }

    // Generate content
    let content = `TAROT JOURNAL EXPORT\n`;
    content += `Generated: ${new Date().toISOString()}\n`;
    content += `Entries: ${entries.length}\n`;
    content += `\n${'='.repeat(50)}\n\n`;

    for (const entry of entries) {
      content += formatEntryAsText(entry);
    }

    if (format === 'pdf') {
      const { pdf, pageCount, truncated } = generatePDF(content);

      // Optionally store in R2 for caching
      const cacheKey = entryId
        ? `exports/readings/${user.id}/${entryId}.pdf`
        : `exports/journals/${user.id}/${Date.now()}.pdf`;

      if (shouldCache && env.LOGS_BUCKET) {
        try {
          const cacheTtlDays = 30;
          const expiresAt = new Date(Date.now() + cacheTtlDays * 24 * 60 * 60 * 1000).toISOString();
          await env.LOGS_BUCKET.put(cacheKey, pdf, {
            httpMetadata: {
              contentType: 'application/pdf',
              cacheControl: `private, max-age=${cacheTtlDays * 24 * 60 * 60}`
            },
            customMetadata: {
              userId: user.id,
              entryCount: entries.length.toString(),
              pageCount: pageCount.toString(),
              truncated: truncated.toString(),
              generatedAt: new Date().toISOString(),
              expiresAt,
              cacheTtlDays: cacheTtlDays.toString()
            }
          });
        } catch (err) {
          console.warn('Failed to cache PDF in R2:', err.message);
        }
      }

      const filename = entryId
        ? `tarot-reading-${entryId.slice(0, 8)}.pdf`
        : `tarot-journal-${new Date().toISOString().split('T')[0]}.pdf`;

      // Add warning header if content was truncated
      const headers = {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'X-PDF-Pages': pageCount.toString()
      };

      if (truncated) {
        headers['X-PDF-Truncated'] = 'true';
        headers['X-PDF-Warning'] = 'Content exceeded 20 pages and was truncated. Use format=txt for full export.';
      }

      return new Response(pdf, { headers });
    } else if (format === 'txt') {
      return new Response(content, {
        headers: {
          'Content-Type': 'text/plain; charset=utf-8',
          'Content-Disposition': `attachment; filename="tarot-journal.txt"`
        }
      });
    } else if (format === 'json') {
      return jsonResponse({
        exportedAt: new Date().toISOString(),
        entryCount: entries.length,
        entries
      });
    } else {
      return jsonResponse({ error: 'Invalid format. Use pdf, txt, or json.' }, { status: 400 });
    }
  } catch (error) {
    console.error('Journal export error:', error);
    return jsonResponse({ error: 'Export failed', message: error.message }, { status: 500 });
  }
}
</file>

<file path="functions/api/journal-summary.js">
/**
 * Journal Summary API Endpoint
 *
 * POST /api/journal-summary
 *
 * Authenticated users can request a high-level summary of their tarot journal.
 * When Azure OpenAI is configured, this uses the Responses API for rich,
 * narrative summaries and falls back to the shared heuristic summary helper
 * otherwise.
 */

import { getSessionFromCookie, validateSession } from '../lib/auth.js';
import { jsonResponse, readJsonBody } from '../lib/utils.js';
import { computeJournalStats } from '../../shared/journal/stats.js';
import { buildHeuristicJourneySummary } from '../../shared/journal/summary.js';
import { callAzureResponses } from '../lib/azureResponses.js';

const MAX_SUMMARY_ENTRIES = 10;

function normalizeLimit(value, fallback) {
  const num = Number.parseInt(value, 10);
  if (!Number.isFinite(num)) return fallback;
  return Math.min(MAX_SUMMARY_ENTRIES, Math.max(1, num));
}

function mapRowToEntry(row) {
  let cards = [];
  let themes = null;
  let reflections = {};

  try {
    cards = row.cards_json ? JSON.parse(row.cards_json) : [];
  } catch (error) {
    console.error(`Failed to parse cards_json for entry ${row.id}:`, error.message);
    cards = [];
  }

  try {
    themes = row.themes_json ? JSON.parse(row.themes_json) : null;
  } catch (error) {
    console.error(`Failed to parse themes_json for entry ${row.id}:`, error.message);
    themes = null;
  }

  try {
    reflections = row.reflections_json ? JSON.parse(row.reflections_json) : {};
  } catch (error) {
    console.error(`Failed to parse reflections_json for entry ${row.id}:`, error.message);
    reflections = {};
  }

  return {
    id: row.id,
    ts: row.created_at * 1000,
    spread: row.spread_name,
    spreadKey: row.spread_key,
    question: row.question,
    cards,
    personalReading: row.narrative,
    themes,
    reflections,
    context: row.context
  };
}

function buildEntrySummaryLines(entries) {
  if (!Array.isArray(entries) || entries.length === 0) return '';

  return entries
    .map((entry) => {
      const when = entry?.ts ? new Date(entry.ts).toLocaleDateString() : 'recently';
      const context = entry?.context || 'general';
      const spread = entry?.spread || 'Reading';
      const cards = Array.isArray(entry?.cards)
        ? entry.cards.slice(0, 4).map((card) => {
            const orientation = (card?.orientation || '').toLowerCase();
            return `${card?.name || 'Unknown'}${orientation ? ` (${orientation})` : ''}`;
          }).join(', ')
        : '';
      const question = (entry?.question || '').trim();

      const parts = [];
      parts.push(`• ${spread} on ${when} (${context} lens)`);
      if (question) {
        parts.push(`  - Question: ${question}`);
      }
      if (cards) {
        parts.push(`  - Cards: ${cards}`);
      }
      return parts.join('\n');
    })
    .join('\n');
}

async function generateLLMSummary(env, entries) {
  if (!Array.isArray(entries) || entries.length === 0) {
    throw new Error('No entries to summarize');
  }

  const stats = computeJournalStats(entries);
  const lines = [];

  if (stats) {
    lines.push(
      `You are an introspective tarot journaling companion. Summarize the patterns, lessons, and next steps across this person's recent tarot readings.`,
      '',
      `Entries: ${stats.totalReadings}`,
      `Cards logged: ${stats.totalCards}`,
      `Reversal rate: ${stats.reversalRate}%`,
      ''
    );

    if (Array.isArray(stats.contextBreakdown) && stats.contextBreakdown.length > 0) {
      const topContexts = stats.contextBreakdown
        .slice()
        .sort((a, b) => b.count - a.count)
        .slice(0, 3)
        .map((ctx) => `${ctx.name} (${ctx.count})`)
        .join(', ');
      lines.push(`Top contexts: ${topContexts}`);
    }

    if (Array.isArray(stats.frequentCards) && stats.frequentCards.length > 0) {
      const recurring = stats.frequentCards
        .map((card) => `${card.name}${card.reversed ? ` · ${card.reversed} rev` : ''}`)
        .join(', ');
      lines.push(`Recurring cards: ${recurring}`);
    }

    if (Array.isArray(stats.recentThemes) && stats.recentThemes.length > 0) {
      lines.push(`Recent themes: ${stats.recentThemes.join(', ')}`);
    }

    lines.push('');
  }

  lines.push(
    'Here is a compact log of recent entries. Use this as raw material, but respond with a coherent, human-friendly summary instead of bullet points:'
  );
  lines.push('');
  lines.push(buildEntrySummaryLines(entries));

  const input = lines.join('\n');

  const summary = await callAzureResponses(env, {
    instructions:
      'Write a gentle, encouraging journal summary for this tarot reader. Highlight the arc of their journey, energies asking for focus, and 2-3 grounded next steps. Keep it under 400 words. Use clear section headings like "Arc of the Journey", "Energies Calling for Focus", and "Gentle Next Steps".',
    input,
    maxTokens: 900,
    reasoningEffort: 'medium',
    verbosity: 'medium'
  });

  return summary;
}

export async function onRequestPost(context) {
  const { request, env } = context;

  try {
    const cookieHeader = request.headers.get('Cookie');
    const token = getSessionFromCookie(cookieHeader);
    const user = await validateSession(env.DB, token);

    if (!user) {
      return jsonResponse(
        { error: 'Not authenticated' },
        { status: 401 }
      );
    }

    const body = await readJsonBody(request);
    const entryIds = Array.isArray(body.entryIds)
      ? body.entryIds.filter((id) => typeof id === 'string' && id.trim().length > 0).slice(0, MAX_SUMMARY_ENTRIES)
      : [];

    const limit = normalizeLimit(
      body.limit,
      entryIds.length > 0 ? Math.min(entryIds.length, MAX_SUMMARY_ENTRIES) : MAX_SUMMARY_ENTRIES
    );

    // Build query: either by explicit entry IDs or just most recent entries for the user
    let sql = `
      SELECT
        id,
        created_at,
        spread_key,
        spread_name,
        question,
        cards_json,
        narrative,
        themes_json,
        reflections_json,
        context
      FROM journal_entries
      WHERE user_id = ?
    `;

    const params = [user.id];

    if (entryIds.length > 0) {
      const placeholders = entryIds.map(() => '?').join(', ');
      sql += ` AND id IN (${placeholders})`;
      params.push(...entryIds);
    }

    sql += ' ORDER BY created_at DESC LIMIT ?';
    params.push(limit);

    const result = await env.DB.prepare(sql).bind(...params).all();
    const rows = Array.isArray(result.results) ? result.results : [];

    if (rows.length === 0) {
      return jsonResponse(
        { error: 'No journal entries available to summarize' },
        { status: 400 }
      );
    }

    const entries = rows.map(mapRowToEntry);
    const stats = computeJournalStats(entries);

    let summary = '';
    let provider = 'heuristic';

    try {
      summary = await generateLLMSummary(env, entries);
      provider = 'azure-responses';
    } catch (error) {
      console.warn('LLM journal summary failed, falling back to heuristic summary:', error?.message || error);
    }

    if (!summary) {
      summary = buildHeuristicJourneySummary(entries, stats);
      provider = 'heuristic';
    }

    return jsonResponse({
      summary,
      meta: {
        provider,
        totalEntries: entries.length,
        model: env.AZURE_OPENAI_GPT5_MODEL || null
      }
    });
  } catch (error) {
    console.error('Journal summary error:', error);
    return jsonResponse(
      { error: 'Unable to generate summary' },
      { status: 500 }
    );
  }
}
</file>

<file path="functions/api/journal.js">
/**
 * Journal API Endpoints
 * GET /api/journal - List all journal entries for authenticated user
 * POST /api/journal - Save a new journal entry
 */

import {
  validateSession,
  getSessionFromCookie
} from '../lib/auth.js';

/**
 * GET /api/journal
 * Returns all journal entries for the authenticated user
 */
export async function onRequestGet(context) {
  const { request, env } = context;

  try {
    // Authenticate user
    const cookieHeader = request.headers.get('Cookie');
    const token = getSessionFromCookie(cookieHeader);
    const user = await validateSession(env.DB, token);

    if (!user) {
      return new Response(
        JSON.stringify({ error: 'Not authenticated' }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Get all journal entries for user, ordered by most recent first
    const entries = await env.DB.prepare(`
      SELECT
        id,
        created_at,
        spread_key,
        spread_name,
        question,
        cards_json,
        narrative,
        themes_json,
        reflections_json,
        context,
        provider,
        session_seed,
        user_preferences_json
      FROM journal_entries
      WHERE user_id = ?
      ORDER BY created_at DESC
    `)
      .bind(user.id)
      .all();

    // Parse JSON fields
    const parsedEntries = entries.results.map(entry => ({
      id: entry.id,
      ts: entry.created_at * 1000, // Convert to milliseconds for JS Date
      spread: entry.spread_name,
      spreadKey: entry.spread_key,
      question: entry.question,
      cards: JSON.parse(entry.cards_json),
      personalReading: entry.narrative,
      themes: entry.themes_json ? JSON.parse(entry.themes_json) : null,
      reflections: entry.reflections_json ? JSON.parse(entry.reflections_json) : {},
      context: entry.context,
      provider: entry.provider,
      sessionSeed: entry.session_seed,
      userPreferences: entry.user_preferences_json ? JSON.parse(entry.user_preferences_json) : null
    }));

    return new Response(
      JSON.stringify({ entries: parsedEntries }),
      {
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  } catch (error) {
    console.error('Get journal entries error:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}

/**
 * POST /api/journal
 * Save a new journal entry for the authenticated user
 */
export async function onRequestPost(context) {
  const { request, env } = context;

  try {
    // Authenticate user
    const cookieHeader = request.headers.get('Cookie');
    const token = getSessionFromCookie(cookieHeader);
    const user = await validateSession(env.DB, token);

    if (!user) {
      return new Response(
        JSON.stringify({ error: 'Not authenticated' }),
        { status: 401, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Parse request body
    const body = await request.json();
    const {
      spread,
      spreadKey,
      question,
      cards,
      personalReading,
      themes,
      reflections,
      context,
      provider,
      sessionSeed,
      // Optional: original timestamp in milliseconds (used for migrations)
      timestampMs,
      // User preferences snapshot at time of reading (Phase 5.2)
      userPreferences
    } = body;

    // Validate required fields
    if (!spread || !spreadKey || !cards || !Array.isArray(cards)) {
      return new Response(
        JSON.stringify({ error: 'Invalid journal entry data' }),
        { status: 400, headers: { 'Content-Type': 'application/json' } }
      );
    }

    // Deduplicate by session_seed to prevent double-saves
    if (sessionSeed) {
      const existing = await env.DB.prepare(
        `SELECT id, created_at FROM journal_entries WHERE user_id = ? AND session_seed = ?`
      ).bind(user.id, sessionSeed).first();

      if (existing) {
        // Return existing entry instead of creating duplicate
        return new Response(
          JSON.stringify({
            success: true,
            entry: {
              id: existing.id,
              ts: existing.created_at * 1000
            },
            deduplicated: true
          }),
          {
            status: 200,
            headers: { 'Content-Type': 'application/json' }
          }
        );
      }
    }

    // Create journal entry
    const entryId = crypto.randomUUID();
    const nowSeconds = Math.floor(Date.now() / 1000);

    // Derive created_at/updated_at, allowing a **sanitized** client timestamp
    // for trusted flows like local-to-cloud migration.
    let createdAt = nowSeconds;

    if (typeof timestampMs === 'number' && Number.isFinite(timestampMs)) {
      const candidateSeconds = Math.floor(timestampMs / 1000);

      // Basic sanity window: >= 2000-01-01 and not more than 24h in the future
      const MIN_ALLOWED = 946684800; // 2000-01-01T00:00:00Z
      const MAX_ALLOWED = nowSeconds + 60 * 60 * 24;

      if (candidateSeconds >= MIN_ALLOWED && candidateSeconds <= MAX_ALLOWED) {
        createdAt = candidateSeconds;
      }
    }

    const updatedAt = createdAt;

    await env.DB.prepare(`
      INSERT INTO journal_entries (
        id,
        user_id,
        created_at,
        updated_at,
        spread_key,
        spread_name,
        question,
        cards_json,
        narrative,
        themes_json,
        reflections_json,
        context,
        provider,
        session_seed,
        user_preferences_json
      )
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `)
      .bind(
        entryId,
        user.id,
        createdAt,
        updatedAt,
        spreadKey,
        spread,
        question || null,
        JSON.stringify(cards),
        personalReading || null,
        themes ? JSON.stringify(themes) : null,
        reflections ? JSON.stringify(reflections) : null,
        context || null,
        provider || null,
        sessionSeed || null,
        userPreferences ? JSON.stringify(userPreferences) : null
      )
      .run();

    return new Response(
      JSON.stringify({
        success: true,
        entry: {
          id: entryId,
          ts: createdAt * 1000
        }
      }),
      {
        status: 201,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  } catch (error) {
    console.error('Save journal entry error:', error);
    return new Response(
      JSON.stringify({ error: 'Internal server error' }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
}
</file>

<file path="functions/api/share.js">
import { validateSession, getSessionFromCookie } from '../lib/auth.js';
import { loadEntriesForUser, loadRecentEntries, buildShareMeta } from '../lib/shareUtils.js';

function buildShareResponseRow(row) {
  const meta = row.meta_json ? safeJson(row.meta_json, {}) : {};
  return {
    token: row.token,
    scope: row.scope,
    title: row.title || (row.scope === 'entry' ? 'Shared reading' : 'Journal snapshot'),
    createdAt: row.created_at * 1000,
    expiresAt: row.expires_at ? row.expires_at * 1000 : null,
    viewCount: row.view_count || 0,
    entryCount: meta.entryCount ?? row.entry_count ?? 0,
    spreadKeys: Array.isArray(meta.spreadKeys) ? meta.spreadKeys : [],
    contexts: Array.isArray(meta.contexts) ? meta.contexts : [],
    lastEntryTs: typeof meta.lastEntryTs === 'number' ? meta.lastEntryTs : null
  };
}

function safeJson(value, fallback) {
  if (!value) return fallback;
  try {
    return JSON.parse(value);
  } catch {
    return fallback;
  }
}

export async function onRequestGet(context) {
  const { request, env } = context;

  try {
    const cookieHeader = request.headers.get('Cookie');
    const token = getSessionFromCookie(cookieHeader);
    const user = await validateSession(env.DB, token);

    if (!user) {
      return new Response(JSON.stringify({ error: 'Not authenticated' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    const result = await env.DB.prepare(`
      SELECT st.token, st.scope, st.title, st.created_at, st.expires_at, st.view_count, st.meta_json,
             (SELECT COUNT(*) FROM share_token_entries ste WHERE ste.token = st.token) AS entry_count
      FROM share_tokens st
      WHERE st.user_id = ?
      ORDER BY st.created_at DESC
      LIMIT 50
    `).bind(user.id).all();

    const shares = result.results.map(buildShareResponseRow);

    return new Response(JSON.stringify({ shares }), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    console.error('GET /api/share error:', error);
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

function normalizeEntryIds(raw) {
  if (!Array.isArray(raw)) return [];
  return raw
    .map((value) => (typeof value === 'string' ? value.trim() : ''))
    .filter(Boolean);
}

export async function onRequestPost(context) {
  const { request, env } = context;

  try {
    const cookieHeader = request.headers.get('Cookie');
    const token = getSessionFromCookie(cookieHeader);
    const user = await validateSession(env.DB, token);

    if (!user) {
      return new Response(JSON.stringify({ error: 'Not authenticated' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    const body = await request.json().catch(() => ({}));
    const scope = body.scope === 'entry' ? 'entry' : 'journal';
    const entryIds = normalizeEntryIds(body.entryIds);
    const limit = Number(body.limit) > 0 ? Math.min(Number(body.limit), 10) : 5;
    const expiresInHours = Number(body.expiresInHours) > 0 ? Math.min(Number(body.expiresInHours), 24 * 30) : null;

    let entries = [];
    if (scope === 'entry') {
      if (entryIds.length !== 1) {
        return new Response(JSON.stringify({ error: 'entry share requires exactly one entryId' }), {
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        });
      }
      entries = await loadEntriesForUser(env, user.id, entryIds);
    } else if (entryIds.length > 0) {
      entries = await loadEntriesForUser(env, user.id, entryIds);
    } else {
      entries = await loadRecentEntries(env, user.id, limit);
    }

    if (!entries.length) {
      return new Response(JSON.stringify({ error: 'No entries available to share' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' }
      });
    }

    const shareToken = crypto.randomUUID().replace(/-/g, '');
    const now = Math.floor(Date.now() / 1000);
    const expiresAt = expiresInHours ? now + expiresInHours * 3600 : null;
    const title = (body.title && typeof body.title === 'string') ? body.title.trim().slice(0, 80) : null;
    const meta = buildShareMeta(entries);

    await env.DB.prepare(`
      INSERT INTO share_tokens (token, user_id, scope, title, created_at, expires_at, view_count, meta_json)
      VALUES (?, ?, ?, ?, ?, ?, 0, ?)
    `).bind(
      shareToken,
      user.id,
      scope,
      title,
      now,
      expiresAt,
      JSON.stringify(meta)
    ).run();

    const insertStmt = env.DB.prepare(
      'INSERT INTO share_token_entries (token, entry_id, sort_index) VALUES (?, ?, ?)'
    );

    for (let index = 0; index < entries.length; index += 1) {
      await insertStmt.bind(shareToken, entries[index].id, index).run();
    }

    return new Response(
      JSON.stringify({
        token: shareToken,
        scope,
        url: `/share/${shareToken}`,
        entryCount: entries.length
      }),
      {
        status: 201,
        headers: { 'Content-Type': 'application/json' }
      }
    );
  } catch (error) {
    console.error('POST /api/share error:', error);
    return new Response(JSON.stringify({ error: 'Internal server error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
</file>

<file path="functions/api/tarot-reading.js">
/**
 * Cloudflare Pages Function for generating a personalized tarot reading.
 *
 * Enhanced with authentic position-relationship analysis, elemental dignities,
 * and spread-specific narrative construction.
 *
 * Delegates narrative synthesis to Azure OpenAI GPT-5.1 via the Responses API
 * when AZURE_OPENAI_API_KEY / AZURE_OPENAI_ENDPOINT / AZURE_OPENAI_GPT5_MODEL are configured.
 * Falls back to local deterministic composer with full analysis.
 */

// Import analysis and narrative building libraries
import {
  analyzeSpreadThemes,
  analyzeCelticCross,
  analyzeThreeCard,
  analyzeFiveCard,
  analyzeRelationship,
  analyzeDecision
} from '../lib/spreadAnalysis.js';

import {
  buildCelticCrossReading,
  buildThreeCardReading,
  buildFiveCardReading,
  buildRelationshipReading,
  buildDecisionReading,
  buildSingleCardReading,
  buildEnhancedClaudePrompt,
  buildPositionCardText,
  buildElementalRemedies,
  shouldOfferElementalRemedies,
  formatReversalLens,
  computeRemedyRotationIndex
} from '../lib/narrativeBuilder.js';
import { enhanceSection, validateReadingNarrative } from '../lib/narrativeSpine.js';
import { inferContext } from '../lib/contextDetection.js';
import { parseMinorName } from '../lib/minorMeta.js';
import { jsonResponse, readJsonBody } from '../lib/utils.js';
import { canonicalizeCardName, canonicalCardKey } from '../../shared/vision/cardNameMapping.js';
import { safeParseReadingRequest } from '../../shared/contracts/readingSchema.js';
import { verifyVisionProof } from '../lib/visionProof.js';
import {
  buildPromptEngineeringPayload,
  shouldPersistPrompts,
  redactPII
} from '../lib/promptEngineering.js';
import { MAJOR_ARCANA } from '../../src/data/majorArcana.js';
import { MINOR_ARCANA } from '../../src/data/minorArcana.js';
import {
  fetchEphemerisContext,
  fetchEphemerisForecast,
  matchTransitsToCards,
  getEphemerisSummary
} from '../lib/ephemerisIntegration.js';
import { deriveEmotionalTone } from '../../src/data/emotionMapping.js';
import { normalizeVisionLabel } from '../lib/visionLabels.js';
import { getToneStyle, getFrameVocabulary, buildNameClause, buildPersonalizedClosing, getDepthProfile } from '../lib/narrative/styleHelpers.js';
import {
  escapeRegex,
  hasExplicitCardContext,
  normalizeCardName,
  AMBIGUOUS_CARD_NAMES,
  TAROT_TERMINOLOGY_EXCLUSIONS
} from '../lib/cardContextDetection.js';

// Detect if question asks about future timeframe
function detectForecastTimeframe(userQuestion) {
  if (!userQuestion) return null;
  const q = userQuestion.toLowerCase();

  // Season-level (90 days)
  if (q.includes('season') || q.includes('next few months') ||
    q.includes('coming months') || q.includes('quarter')) {
    return 90;
  }

  // Month-level (30 days)
  if (q.includes('month') || q.includes('30 days') ||
    q.includes('next weeks') || q.includes('coming weeks')) {
    return 30;
  }

  // Week-level (14 days)
  if (q.includes('week') || q.includes('next few days')) {
    return 14;
  }

  return null;
}

const SPREAD_NAME_MAP = {
  'Celtic Cross (Classic 10-Card)': { key: 'celtic', count: 10 },
  'Three-Card Story (Past · Present · Future)': { key: 'threeCard', count: 3 },
  'Five-Card Clarity': { key: 'fiveCard', count: 5 },
  'One-Card Insight': { key: 'single', count: 1 },
  'Relationship Snapshot': { key: 'relationship', count: 3 },
  'Decision / Two-Path': { key: 'decision', count: 5 }
};

const CARD_NAME_PATTERNS = [...MAJOR_ARCANA, ...MINOR_ARCANA]
  .map((card) => card.name)
  .map((name) => ({
    name,
    normalized: normalizeCardName(name),
    pattern: new RegExp(`\\b${escapeRegex(name)}\\b`, 'i')
  }));

const CARD_NAMES_REQUIRING_CARD_CASE = new Set(
  MAJOR_ARCANA
    .map((card) => normalizeCardName(card.name))
    .filter((name) => name.startsWith('the ') || name === 'wheel of fortune')
);
const CARD_NAME_STOP_WORDS = new Set(['the', 'of']);

function trimForTelemetry(text = '', limit = 500) {
  if (!text || typeof text !== 'string') return '';
  const trimmed = text.trim();
  return trimmed.length > limit ? `${trimmed.slice(0, limit)}...` : trimmed;
}

function getSpreadDefinition(spreadName) {
  return SPREAD_NAME_MAP[spreadName] || null;
}

function getExpectedCardCount(spreadName) {
  const def = getSpreadDefinition(spreadName);
  return def?.count ?? null;
}

function getSpreadKey(spreadName) {
  const def = getSpreadDefinition(spreadName);
  return def?.key || 'general';
}

function requiresHighReasoningEffort(modelName = '') {
  const normalized = modelName.toLowerCase();
  return normalized.includes('gpt-5-pro') || normalized.includes('gpt-5.1');
}

const NARRATIVE_BACKEND_ORDER = ['azure-gpt5', 'claude-sonnet45', 'local-composer'];

const NARRATIVE_BACKENDS = {
  'azure-gpt5': {
    id: 'azure-gpt5',
    label: 'Azure GPT-5 Responses',
    isAvailable: (env) => Boolean(env?.AZURE_OPENAI_API_KEY && env?.AZURE_OPENAI_ENDPOINT && env?.AZURE_OPENAI_GPT5_MODEL)
  },
  'claude-sonnet45': {
    id: 'claude-sonnet45',
    label: 'Claude Opus 4.5 (Azure Foundry)',
    // Uses Azure AI Foundry Anthropic endpoint - may use separate API key
    isAvailable: (env) => Boolean(
      (env?.AZURE_ANTHROPIC_API_KEY || env?.AZURE_OPENAI_API_KEY) &&
      env?.AZURE_ANTHROPIC_ENDPOINT
    )
  },
  'local-composer': {
    id: 'local-composer',
    label: 'Local Narrative Composer',
    isAvailable: () => true
  }
};

function getAvailableNarrativeBackends(env) {
  return NARRATIVE_BACKEND_ORDER
    .map((id) => {
      const backend = NARRATIVE_BACKENDS[id];
      if (!backend) return null;
      if (!backend.isAvailable(env)) return null;
      return backend;
    })
    .filter(Boolean);
}

function normalizeBooleanFlag(value) {
  if (typeof value === 'boolean') return value;
  if (value === undefined || value === null) return false;
  return String(value).toLowerCase() === 'true';
}

function shouldLogLLMPrompts(env) {
  if (!env) return false;

  // SECURITY: Block prompt logging in production to prevent PII leaks
  // Production is detected via the Pages production branch or explicit prod env flags
  const normalizedBranch = (env.CF_PAGES_BRANCH || '').toLowerCase();
  const prodBranches = new Set(['main', 'master']);
  if (env.CF_PAGES_BRANCH_PRODUCTION) {
    prodBranches.add(String(env.CF_PAGES_BRANCH_PRODUCTION).toLowerCase());
  }
  const isProdBranch = normalizedBranch && prodBranches.has(normalizedBranch);

  const isProd =
    isProdBranch ||
    env.NODE_ENV === 'production' ||
    env.ENVIRONMENT === 'production';

  if (isProd) {
    return false;
  }

  if (env.LOG_LLM_PROMPTS !== undefined) return normalizeBooleanFlag(env.LOG_LLM_PROMPTS);
  if (env.DEBUG_LLM_PROMPTS !== undefined) return normalizeBooleanFlag(env.DEBUG_LLM_PROMPTS);
  if (env.DEBUG_PROMPTS !== undefined) return normalizeBooleanFlag(env.DEBUG_PROMPTS);
  return false;
}

function shouldLogNarrativeEnhancements(env) {
  if (!env) return false;
  if (env.LOG_NARRATIVE_ENHANCEMENTS !== undefined) {
    return normalizeBooleanFlag(env.LOG_NARRATIVE_ENHANCEMENTS);
  }
  if (env.DEBUG_NARRATIVE_ENHANCEMENTS !== undefined) {
    return normalizeBooleanFlag(env.DEBUG_NARRATIVE_ENHANCEMENTS);
  }
  return false;
}

function shouldLogEnhancementTelemetry(env) {
  if (!env) return false;
  if (env.LOG_ENHANCEMENT_TELEMETRY !== undefined) {
    return normalizeBooleanFlag(env.LOG_ENHANCEMENT_TELEMETRY);
  }
  if (env.DEBUG_ENHANCEMENT_TELEMETRY !== undefined) {
    return normalizeBooleanFlag(env.DEBUG_ENHANCEMENT_TELEMETRY);
  }
  return false;
}

/**
 * Determine if semantic scoring should be enabled for GraphRAG retrieval.
 * Defaults to true if the embeddings API is configured, but can be
 * explicitly disabled via environment variable.
 *
 * @param {Object} env - Environment variables
 * @returns {boolean|null} - true/false for explicit config, null for auto-detect
 */
function getSemanticScoringConfig(env) {
  if (!env) return null;
  
  // Check explicit override
  if (env.ENABLE_SEMANTIC_SCORING !== undefined) {
    return normalizeBooleanFlag(env.ENABLE_SEMANTIC_SCORING);
  }
  if (env.GRAPHRAG_SEMANTIC_SCORING !== undefined) {
    return normalizeBooleanFlag(env.GRAPHRAG_SEMANTIC_SCORING);
  }
  
  // Return null to let auto-detection based on API availability
  return null;
}

function summarizeNarrativeEnhancements(sections = []) {
  if (!Array.isArray(sections) || sections.length === 0) {
    return null;
  }

  const summary = {
    totalSections: sections.length,
    enhancedSections: 0,
    enhancementCounts: {},
    sectionTypes: {},
    sectionNames: [],
    missingCounts: {},
    totalEnhancements: 0,
    sections: []
  };

  sections.forEach((section, index) => {
    const metadata = section?.metadata || {};
    const validation = section?.validation || {};
    const type =
      metadata.type ||
      metadata.section ||
      `section-${index + 1}`;
    const name =
      metadata.name ||
      metadata.label ||
      metadata.title ||
      type;

    const enhanced = Boolean(validation?.enhanced);
    const enhancements = Array.isArray(validation?.enhancements)
      ? validation.enhancements
      : [];
    const missing = Array.isArray(validation?.missing)
      ? validation.missing
      : [];
    const present = validation?.present || {};

    if (!summary.sectionTypes[type]) {
      summary.sectionTypes[type] = { total: 0, enhanced: 0 };
    }
    summary.sectionTypes[type].total += 1;
    if (enhanced) {
      summary.enhancedSections += 1;
      summary.sectionTypes[type].enhanced += 1;
    }

    enhancements.forEach((tag) => {
      if (!tag) return;
      summary.enhancementCounts[tag] =
        (summary.enhancementCounts[tag] || 0) + 1;
    });

    summary.totalEnhancements += enhancements.length;
    summary.sectionNames.push(name);

    missing.forEach((key) => {
      if (!key) return;
      summary.missingCounts[key] = (summary.missingCounts[key] || 0) + 1;
    });

    summary.sections.push({
      type,
      name,
      enhanced,
      enhancements,
      missing,
      present
    });
  });

  return summary;
}

export { summarizeNarrativeEnhancements };

function maybeLogNarrativeEnhancements(env, requestId, provider, summary) {
  if (!shouldLogNarrativeEnhancements(env) || !summary) return;
  console.log(`[${requestId}] [${provider}] Narrative enhancement summary:`, summary);
}

function redactPromptSegment(text, personalization) {
  if (!text || typeof text !== 'string') return text;
  const displayName = personalization?.displayName;
  if (!displayName || typeof displayName !== 'string') return text;
  const trimmed = displayName.trim();
  if (!trimmed) return text;
  try {
    const matcher = new RegExp(escapeRegex(trimmed), 'gi');
    return text.replace(matcher, '[REDACTED_NAME]');
  } catch {
    return text;
  }
}

function maybeLogPromptPayload(env, requestId, backendLabel, systemPrompt, userPrompt, promptMeta, options = {}) {
  if (!shouldLogLLMPrompts(env)) return;

  // SECURITY: Use comprehensive PII redaction for all prompt logging
  // This includes email, phone, SSN, credit card, dates, URLs, IP addresses,
  // and any user-provided display name
  const personalization = options.personalization || null;
  const redactionOptions = {
    displayName: personalization?.displayName
  };

  const redactedSystem = redactPII(systemPrompt, redactionOptions);
  const redactedUser = redactPII(userPrompt, redactionOptions);

  console.log(`[${requestId}] [${backendLabel}] === SYSTEM PROMPT BEGIN ===`);
  console.log(redactedSystem);
  console.log(`[${requestId}] [${backendLabel}] === SYSTEM PROMPT END ===`);

  console.log(`[${requestId}] [${backendLabel}] === USER PROMPT BEGIN ===`);
  console.log(redactedUser);
  console.log(`[${requestId}] [${backendLabel}] === USER PROMPT END ===`);

  if (promptMeta?.estimatedTokens) {
    const { total, system, user, budget } = promptMeta.estimatedTokens;
    const budgetNote = budget ? ` / budget ${budget}` : '';
    console.log(`[${requestId}] [${backendLabel}] Estimated tokens: total ${total} (system ${system} + user ${user})${budgetNote}`);
  }
}

function maybeLogEnhancementTelemetry(env, requestId, telemetry) {
  if (!shouldLogEnhancementTelemetry(env)) return;
  if (!telemetry) return;

  const summary = telemetry.summary || telemetry;
  console.log(
    `[${requestId}] [enhancement-telemetry] sections=${summary.totalSections || 0}, enhanced=${summary.enhancedSections || 0}, tags=${summary.totalEnhancements || 0}`
  );

  if (summary.enhancementCounts && Object.keys(summary.enhancementCounts).length > 0) {
    console.log(`[${requestId}] [enhancement-telemetry] enhancementCounts`, summary.enhancementCounts);
  }
}

export const onRequestGet = async ({ env }) => {
  // Health check endpoint
  return jsonResponse({
    status: 'ok',
    provider: env?.AZURE_OPENAI_GPT5_MODEL ? 'azure-gpt5' : 'local',
    timestamp: new Date().toISOString()
  });
};

export const onRequestPost = async ({ request, env }) => {
  const startTime = Date.now();
  const requestId = crypto.randomUUID ? crypto.randomUUID() : `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

  console.log(`[${requestId}] === TAROT READING REQUEST START ===`);

  try {
    console.log(`[${requestId}] Reading request body...`);
    const payload = await readJsonBody(request);
    const schemaResult = safeParseReadingRequest(payload);
    if (!schemaResult.success) {
      console.error(`[${requestId}] Schema validation failed: ${schemaResult.error}`);
      return jsonResponse(
        { error: schemaResult.error || 'Invalid reading request payload.' },
        { status: 400 }
      );
    }

    const normalizedPayload = schemaResult.data;
    const {
      spreadInfo,
      cardsInfo,
      userQuestion,
      reflectionsText,
      reversalFrameworkOverride,
      visionProof,
      deckStyle: requestDeckStyle,
      personalization
    } = normalizedPayload;
    const deckStyle = requestDeckStyle || spreadInfo?.deckStyle || 'rws-1909';

    console.log(`[${requestId}] Payload parsed:`, {
      spreadName: spreadInfo?.name,
      cardCount: cardsInfo?.length,
      hasQuestion: !!userQuestion,
      hasReflections: !!reflectionsText,
      reversalOverride: reversalFrameworkOverride,
      deckStyle,
      hasVisionProof: !!visionProof,
      hasPersonalization: Boolean(personalization)
    });

    const validationError = validatePayload(normalizedPayload);
    if (validationError) {
      console.error(`[${requestId}] Validation failed:`, validationError);
      return jsonResponse(
        { error: validationError },
        { status: 400 }
      );
    }
    console.log(`[${requestId}] Payload validation passed`);

    // Vision validation is OPTIONAL - used for research/development purposes only
    let sanitizedVisionInsights = [];
    let visionMetrics = null;

    if (!visionProof) {
      console.log(`[${requestId}] No vision proof provided (research mode disabled). Proceeding with standard reading.`);
    } else {
      // Research mode: Verify vision proof and collect telemetry
      console.log(`[${requestId}] Vision proof provided - validating for research telemetry...`);

      let verifiedProof;
      try {
        verifiedProof = await verifyVisionProof(visionProof, env?.VISION_PROOF_SECRET);
      } catch (err) {
        console.warn(`[${requestId}] Vision proof verification failed: ${err.message}`);
        const status = /expired/i.test(err.message) ? 409 : 400;
        return jsonResponse(
          { error: err.message || 'Vision validation proof invalid. Please re-upload your photos.' },
          { status }
        );
      }

      if (verifiedProof.deckStyle && verifiedProof.deckStyle !== deckStyle) {
        console.warn(`[${requestId}] Vision proof deck mismatch. proof=${verifiedProof.deckStyle}, request=${deckStyle}`);
      }

      sanitizedVisionInsights = annotateVisionInsights(verifiedProof.insights, cardsInfo, deckStyle);

      if (sanitizedVisionInsights.length === 0) {
        console.warn(`[${requestId}] Vision proof did not contain recognizable cards. Proceeding without vision data.`);
      } else {
        const avgConfidence = sanitizedVisionInsights.reduce((sum, item) => sum + (item.confidence ?? 0), 0) / sanitizedVisionInsights.length;
        const mismatchedDetections = sanitizedVisionInsights.filter((item) => item.matchesDrawnCard === false);
        visionMetrics = buildVisionMetrics(sanitizedVisionInsights, avgConfidence, mismatchedDetections.length);
        console.log(`[${requestId}] Vision proof verified: ${sanitizedVisionInsights.length} uploads, avg confidence ${(avgConfidence * 100).toFixed(1)}%.`);

        if (mismatchedDetections.length > 0) {
          console.warn(`[${requestId}] Vision uploads that do not match selected cards:`, mismatchedDetections.map((item) => ({ label: item.label, predictedCard: item.predictedCard, confidence: item.confidence })));
          // In research mode, log mismatches but don't block the reading
          console.log(`[${requestId}] Research mode: Continuing despite vision mismatches for data collection.`);
        }
      }
    }


    // STEP 1: Comprehensive spread analysis
    console.log(`[${requestId}] Starting spread analysis...`);
    const analysisStart = Date.now();
    const analysis = await performSpreadAnalysis(spreadInfo, cardsInfo, {
      reversalFrameworkOverride,
      deckStyle,
      userQuestion
    }, requestId, env);
    const analysisTime = Date.now() - analysisStart;
    console.log(`[${requestId}] Spread analysis completed in ${analysisTime}ms:`, {
      spreadKey: analysis.spreadKey,
      hasSpreadAnalysis: !!analysis.spreadAnalysis,
      reversalCount: analysis.themes?.reversalCount,
      reversalFramework: analysis.themes?.reversalFramework
    });

    const contextDiagnostics = [];
    const context = inferContext(userQuestion, analysis.spreadKey, {
      onUnknown: (message) => contextDiagnostics.push(message)
    });
    console.log(`[${requestId}] Context inferred: ${context}`);

    // STEP 2: Generate reading via configured narrative backends
    const narrativePayload = {
      spreadInfo,
      cardsInfo,
      userQuestion,
      reflectionsText,
      analysis,
      context,
      contextDiagnostics,
      visionInsights: sanitizedVisionInsights,
      deckStyle,
      personalization: personalization || null,
      narrativeEnhancements: [],
      graphRAGPayload: analysis.graphRAGPayload || null,
      promptMeta: null
    };

    let reading = null;
    let provider = 'local-composer';
    let acceptedQualityMetrics = null; // Store metrics from successful backend to avoid recomputation
    const backendErrors = [];
    const candidateBackends = getAvailableNarrativeBackends(env);
    const backendsToTry = candidateBackends.length ? candidateBackends : [NARRATIVE_BACKENDS['local-composer']];

    // Track captured prompts for engineering persistence
    let capturedPrompts = null;
    let capturedUsage = null;
    
    for (const backend of backendsToTry) {
      const attemptStart = Date.now();
      console.log(`[${requestId}] Attempting narrative backend ${backend.id} (${backend.label})...`);
      narrativePayload.narrativeEnhancements = [];
      narrativePayload.promptMeta = null;
      try {
        const backendResult = await runNarrativeBackend(backend.id, env, narrativePayload, requestId);
        
        // Extract reading and prompts from result
        const result = typeof backendResult === 'object' && backendResult.reading
          ? backendResult.reading
          : backendResult;
        
        if (!result || !result.toString().trim()) {
          throw new Error('Backend returned empty narrative.');
        }

        // Capture prompts if available
        if (typeof backendResult === 'object' && backendResult.prompts) {
          capturedPrompts = backendResult.prompts;
          capturedUsage = backendResult.usage;
        }

        // Quality gate: validate narrative structure and content before accepting
        const qualityMetrics = buildNarrativeMetrics(result, cardsInfo, deckStyle);
        const qualityIssues = [];

        // Check for hallucinated cards (allow up to 2 for natural LLM comparisons)
        // Only fail if excessive hallucinations suggest model is off-track
        const maxAllowedHallucinations = Math.max(2, Math.floor(cardsInfo.length / 2));
        if (qualityMetrics.hallucinatedCards && qualityMetrics.hallucinatedCards.length > maxAllowedHallucinations) {
          qualityIssues.push(`excessive hallucinated cards (${qualityMetrics.hallucinatedCards.length}): ${qualityMetrics.hallucinatedCards.join(', ')}`);
        } else if (qualityMetrics.hallucinatedCards?.length > 0) {
          // Log but don't fail for minor hallucinations (comparisons/examples)
          console.log(`[${requestId}] Minor hallucinations (allowed): ${qualityMetrics.hallucinatedCards.join(', ')}`);
        }

        // Check card coverage (at least 50% of cards should be mentioned)
        if (qualityMetrics.cardCoverage < 0.5) {
          qualityIssues.push(`low card coverage: ${(qualityMetrics.cardCoverage * 100).toFixed(0)}%`);
        }

        // Check narrative has at least one section (basic structure validation)
        if (qualityMetrics.spine && qualityMetrics.spine.totalSections === 0) {
          qualityIssues.push('no narrative sections detected');
        }

        if (qualityIssues.length > 0) {
          console.warn(`[${requestId}] Backend ${backend.id} failed quality gate: ${qualityIssues.join('; ')}`);
          throw new Error(`Narrative failed quality checks: ${qualityIssues.join('; ')}`);
        }

        reading = result;
        provider = backend.id;
        acceptedQualityMetrics = qualityMetrics; // Store for reuse in response
        console.log(`[${requestId}] Backend ${backend.id} succeeded in ${Date.now() - attemptStart}ms, reading length: ${reading.length}, coverage: ${(qualityMetrics.cardCoverage * 100).toFixed(0)}%`);
        break;
      } catch (err) {
        backendErrors.push({ backend: backend.id, error: err.message });
        console.error(`[${requestId}] Backend ${backend.id} failed:`, err.message);
      }
    }

    if (!reading) {
      console.error(`[${requestId}] All narrative backends failed.`, backendErrors);
      return jsonResponse(
        { error: 'All narrative providers are currently unavailable. Please try again shortly.' },
        { status: 503 }
      );
    }

    // STEP 3: Return structured response with server-centric analysis
    // - spreadAnalysis: canonical source for patterns/highlights
    // - themes: shared thematic summary
    // Frontend should trust these when present, and only fall back locally if missing.
    const totalTime = Date.now() - startTime;
    console.log(`[${requestId}] Request completed successfully in ${totalTime}ms using provider: ${provider}`);
    console.log(`[${requestId}] === TAROT READING REQUEST END ===`);

    const narrativeEnhancementSummary = summarizeNarrativeEnhancements(
      Array.isArray(narrativePayload.narrativeEnhancements)
        ? narrativePayload.narrativeEnhancements
        : []
    );
    maybeLogNarrativeEnhancements(env, requestId, provider, narrativeEnhancementSummary);
    const enhancementSections = (narrativePayload.narrativeEnhancements || []).map((section, index) => ({
      name: section?.metadata?.name || section?.metadata?.type || `section-${index + 1}`,
      type: section?.metadata?.type || null,
      text: trimForTelemetry(section?.text, 500),
      validation: section?.validation || null
    }));

    const enhancementTelemetry = narrativeEnhancementSummary
      ? { summary: narrativeEnhancementSummary, sections: enhancementSections }
      : null;

    const promptMeta = narrativePayload.promptMeta || null;
    const promptTokens = promptMeta?.estimatedTokens || null;
    const promptSlimming = promptMeta?.slimmingSteps || [];
    const graphRAGStats = analysis.graphRAGPayload?.retrievalSummary || null;
    const diagnosticsPayload = {
      messages: contextDiagnostics,
      count: contextDiagnostics.length
    };

    // Reuse quality metrics from the successful backend (computed during quality gate)
    // to avoid redundant computation
    const baseNarrativeMetrics = acceptedQualityMetrics || buildNarrativeMetrics(reading, cardsInfo, deckStyle);
    const narrativeMetrics = {
      ...baseNarrativeMetrics,
      enhancementTelemetry,
      promptTokens,
      promptSlimming,
      graphRAG: graphRAGStats,
      contextDiagnostics: diagnosticsPayload
    };

    // Build prompt engineering payload if prompts were captured
    let promptEngineering = null;
    if (capturedPrompts && shouldPersistPrompts(env)) {
      try {
        promptEngineering = await buildPromptEngineeringPayload({
          systemPrompt: capturedPrompts.system,
          userPrompt: capturedPrompts.user,
          response: reading,
          redactionOptions: {
            displayName: personalization?.displayName
          }
        });
      } catch (err) {
        console.warn(`[${requestId}] Failed to build prompt engineering payload: ${err.message}`);
      }
    }

    await persistReadingMetrics(env, {
      requestId,
      timestamp: new Date().toISOString(),
      provider,
      deckStyle,
      spreadKey: analysis.spreadKey,
      context,
      vision: visionMetrics,
      narrative: narrativeMetrics,
      narrativeEnhancements: narrativeEnhancementSummary,
      graphRAG: graphRAGStats,
      promptMeta,
      enhancementTelemetry,
      contextDiagnostics: diagnosticsPayload,
      // New: prompt engineering data
      promptEngineering,
      llmUsage: capturedUsage
    });

    maybeLogEnhancementTelemetry(env, requestId, enhancementTelemetry);

    // Derive emotional tone from GraphRAG patterns for TTS
    const emotionalTone = deriveEmotionalTone(analysis.themes);

    return jsonResponse({
      reading,
      provider,
      requestId,
      backendErrors: backendErrors.length > 0 ? backendErrors : undefined,
      themes: analysis.themes,
      emotionalTone,
      context,
      contextDiagnostics,
      narrativeMetrics,
      graphRAG: graphRAGStats,
      spreadAnalysis: {
        // Normalize top-level metadata for all spreads
        version: '1.0.0',
        spreadKey: analysis.spreadKey,
        // For spreads where analyzeX already returns normalized shape, prefer it directly
        ...(analysis.spreadAnalysis || {})
      }
    });
  } catch (error) {
    const totalTime = Date.now() - startTime;
    console.error(`[${requestId}] FATAL ERROR after ${totalTime}ms:`, {
      error: error.message,
      stack: error.stack,
      name: error.name
    });
    console.log(`[${requestId}] === TAROT READING REQUEST END (ERROR) ===`);

    return jsonResponse(
      { error: 'Failed to generate reading.' },
      { status: 500 }
    );
  }
};

/**
 * Perform comprehensive spread analysis
 * Returns themes, spread-specific relationships, and elemental insights
 */
async function performSpreadAnalysis(spreadInfo, cardsInfo, options = {}, requestId = 'unknown', env = null) {
  // Guard against malformed input (defensive: validatePayload should have run already)
  if (!spreadInfo || !Array.isArray(cardsInfo) || cardsInfo.length === 0) {
    console.warn(`[${requestId}] performSpreadAnalysis: missing or invalid spreadInfo/cardsInfo, falling back to generic themes only.`);
    return {
      themes: { suitCounts: {}, elementCounts: {}, reversalCount: 0, reversalFramework: 'contextual', reversalDescription: { name: 'Context-Dependent', description: 'Reversed cards are interpreted individually based on context.', guidance: 'Read each reversal in light of its position and relationships.' } },
      spreadAnalysis: null,
      spreadKey: 'general'
    };
  }

  // Pass env through to options for API access in semantic scoring
  if (env && !options.env) {
    options.env = env;
  }

  // Apply semantic scoring config from environment
  const semanticScoringConfig = env ? getSemanticScoringConfig(env) : null;
  if (semanticScoringConfig !== null && options.enableSemanticScoring === undefined) {
    options.enableSemanticScoring = semanticScoringConfig;
  }

  // Theme analysis (suits, elements, majors, reversals)
  let themes;
  try {
    console.log(`[${requestId}] Analyzing spread themes...`);
    themes = await analyzeSpreadThemes(cardsInfo, {
      reversalFrameworkOverride: options.reversalFrameworkOverride,
      deckStyle: options.deckStyle,
      userQuestion: options.userQuestion
    });
    console.log(`[${requestId}] Theme analysis complete:`, {
      suitCounts: themes.suitCounts,
      elementCounts: themes.elementCounts,
      reversalCount: themes.reversalCount,
      framework: themes.reversalFramework
    });
  } catch (err) {
    console.error(`[${requestId}] performSpreadAnalysis: analyzeSpreadThemes failed, using minimal fallback themes.`, err);
    themes = {
      suitCounts: {},
      elementCounts: {},
      reversalCount: 0,
      reversalFramework: 'contextual',
      reversalDescription: {
        name: 'Context-Dependent',
        description: 'Reversed cards are interpreted individually based on context.',
        guidance: 'Read each reversal by listening to its position and neighboring cards.'
      }
    };
  }

  // Spread-specific position-relationship analysis
  let spreadAnalysis = null;
  let spreadKey = 'general';
  let graphRAGPayload = null;

  try {
    spreadKey = getSpreadKey(spreadInfo.name);
    console.log(`[${requestId}] Spread key identified: ${spreadKey}`);

    if (spreadKey === 'celtic' && cardsInfo.length === 10) {
      console.log(`[${requestId}] Performing Celtic Cross analysis...`);
      spreadAnalysis = analyzeCelticCross(cardsInfo);
      console.log(`[${requestId}] Celtic Cross analysis complete`);
    } else if (spreadKey === 'threeCard' && cardsInfo.length === 3) {
      console.log(`[${requestId}] Performing Three-Card analysis...`);
      spreadAnalysis = analyzeThreeCard(cardsInfo);
      console.log(`[${requestId}] Three-Card analysis complete`);
    } else if (spreadKey === 'fiveCard' && cardsInfo.length === 5) {
      console.log(`[${requestId}] Performing Five-Card analysis...`);
      spreadAnalysis = analyzeFiveCard(cardsInfo);
      console.log(`[${requestId}] Five-Card analysis complete`);
    } else if (spreadKey === 'relationship' && cardsInfo.length >= 3) {
      console.log(`[${requestId}] Performing Relationship analysis...`);
      spreadAnalysis = analyzeRelationship(cardsInfo);
      console.log(`[${requestId}] Relationship analysis complete`);
    } else if (spreadKey === 'decision' && cardsInfo.length === 5) {
      console.log(`[${requestId}] Performing Decision analysis...`);
      spreadAnalysis = analyzeDecision(cardsInfo);
      console.log(`[${requestId}] Decision analysis complete`);
    } else {
      console.log(`[${requestId}] No specific analysis for spreadKey: ${spreadKey} with ${cardsInfo.length} cards`);
    }
  } catch (err) {
    console.error(`[${requestId}] performSpreadAnalysis: spread-specific analysis failed, continuing with themes only.`, err);
    spreadAnalysis = null;
    spreadKey = 'general';
  }

  // Memoize GraphRAG retrieval once so prompts for multiple backends reuse it
  try {
    const graphKeys = themes?.knowledgeGraph?.graphKeys;
    if (graphKeys) {
      const {
        isGraphRAGEnabled,
        retrievePassages,
        retrievePassagesWithQuality,
        formatPassagesForPrompt,
        buildRetrievalSummary,
        buildQualityRetrievalSummary,
        getPassageCountForSpread,
        isSemanticScoringAvailable
      } = await import('../lib/graphRAG.js');

      if (isGraphRAGEnabled(options.env)) {
        const maxPassages = getPassageCountForSpread(spreadKey || 'general');
        
        // Determine if semantic scoring should be used
        // Default: enabled if API is available, can be overridden via options
        const semanticAvailable = isSemanticScoringAvailable(options.env);
        const enableSemanticScoring = options.enableSemanticScoring !== undefined
          ? Boolean(options.enableSemanticScoring)
          : semanticAvailable;

        let passages;
        let retrievalSummary;

        if (enableSemanticScoring) {
          // Use quality-aware retrieval with relevance scoring
          console.log(`[${requestId}] Using quality-aware GraphRAG retrieval with semantic scoring`);
          passages = await retrievePassagesWithQuality(graphKeys, {
            maxPassages,
            userQuery: options.userQuestion,
            minRelevanceScore: 0.3,
            enableDeduplication: true,
            enableSemanticScoring: true,
            env: options.env
          });
          retrievalSummary = buildQualityRetrievalSummary(graphKeys, passages);
          
          // Log average relevance for monitoring
          if (retrievalSummary.qualityMetrics?.averageRelevance) {
            console.log(`[${requestId}] GraphRAG quality: ${passages.length} passages, avg relevance: ${(retrievalSummary.qualityMetrics.averageRelevance * 100).toFixed(1)}%`);
          }
        } else {
          // Fall back to standard retrieval (keyword-only)
          passages = retrievePassages(graphKeys, {
            maxPassages,
            userQuery: options.userQuestion
          });
          retrievalSummary = buildRetrievalSummary(graphKeys, passages);
        }

        const semanticScoringRequested = enableSemanticScoring === true;
        const semanticScoringUsed = retrievalSummary?.qualityMetrics?.semanticScoringUsed === true;
        const semanticScoringFallback = semanticScoringRequested && !semanticScoringUsed;

        retrievalSummary = {
          ...retrievalSummary,
          semanticScoringRequested,
          semanticScoringUsed,
          semanticScoringFallback
        };

        const formattedBlock = formatPassagesForPrompt(passages, {
          includeSource: true,
          markdown: true
        });

        graphRAGPayload = {
          passages,
          formattedBlock,
          retrievalSummary,
          maxPassages,
          initialPassageCount: passages.length,
          rankingStrategy: enableSemanticScoring ? 'semantic' : 'keyword',
          enableSemanticScoring,
          qualityMetrics: retrievalSummary.qualityMetrics || null,
          semanticScoringRequested,
          semanticScoringUsed,
          semanticScoringFallback
        };

        // Make memoized payload discoverable to downstream consumers
        themes.knowledgeGraph = {
          ...(themes.knowledgeGraph || {}),
          graphRAGPayload
        };
      }
    }
  } catch (err) {
    console.warn(`[${requestId}] performSpreadAnalysis: GraphRAG memoization failed: ${err.message}`);
  }

  // Ephemeris integration: fetch real-time astrological context
  let ephemerisContext = null;
  let transitResonances = [];
  let ephemerisForecast = null;

  try {
    console.log(`[${requestId}] Fetching ephemeris context...`);
    ephemerisContext = await fetchEphemerisContext();

    if (ephemerisContext?.available) {
      console.log(`[${requestId}] Ephemeris context available:`, getEphemerisSummary(ephemerisContext));

      // Match current transits to drawn cards
      transitResonances = matchTransitsToCards(cardsInfo, ephemerisContext);
      if (transitResonances.length > 0) {
        console.log(`[${requestId}] Found ${transitResonances.length} transit resonance(s)`);
      }

      // Check if question asks about future timeframe
      const forecastDays = detectForecastTimeframe(options.userQuestion);
      if (forecastDays) {
        console.log(`[${requestId}] Detected future timeframe, fetching ${forecastDays}-day forecast...`);
        ephemerisForecast = await fetchEphemerisForecast(forecastDays);
        if (ephemerisForecast?.available) {
          console.log(`[${requestId}] Forecast available: ${ephemerisForecast.events?.length || 0} events`);
        }
      }
    } else {
      console.log(`[${requestId}] Ephemeris context not available (server may not be running)`);
    }
  } catch (err) {
    console.warn(`[${requestId}] performSpreadAnalysis: Ephemeris fetch failed: ${err.message}`);
    ephemerisContext = { available: false, error: err.message };
  }

  return {
    themes,
    spreadAnalysis,
    spreadKey,
    graphRAGPayload,
    ephemerisContext,
    ephemerisForecast,
    transitResonances
  };
}

/**
 * Validates the baseline structure expected by the tarot-reading endpoint.
 */
export function validatePayload({ spreadInfo, cardsInfo }) {
  if (!spreadInfo || typeof spreadInfo.name !== 'string') {
    return 'Missing spread information.';
  }

  if (!Array.isArray(cardsInfo) || cardsInfo.length === 0) {
    return 'No cards were provided for the reading.';
  }

  const expectedCount = getExpectedCardCount(spreadInfo.name);
  if (expectedCount !== null && cardsInfo.length !== expectedCount) {
    return `Spread "${spreadInfo.name}" expects ${expectedCount} cards, but received ${cardsInfo.length}.`;
  }

  const hasInvalidCard = cardsInfo.some(card => {
    if (typeof card !== 'object' || card === null) return true;
    const requiredFields = ['position', 'card', 'orientation', 'meaning'];
    return requiredFields.some(field => {
      const value = card[field];
      return typeof value !== 'string' || !value.trim();
    });
  });

  if (hasInvalidCard) {
    return 'One or more cards are missing required details.';
  }

  // Warn (without rejecting) if Minor Arcana cards are missing suit/rank metadata.
  const minorMetadataIssues = [];
  cardsInfo.forEach((card, index) => {
    if (!card || typeof card.card !== 'string') return;
    const parsed = parseMinorName(card.card);
    if (!parsed) return; // Not a Minor Arcana title (likely Major)

    const hasSuit = typeof card.suit === 'string' && card.suit.trim().length > 0;
    const hasRank = typeof card.rank === 'string' && card.rank.trim().length > 0;
    const hasRankValue = typeof card.rankValue === 'number';

    if (hasSuit && hasRank && hasRankValue) {
      return;
    }

    const missing = [];
    if (!hasSuit) missing.push('suit');
    if (!hasRank) missing.push('rank');
    if (!hasRankValue) missing.push('rankValue');

    minorMetadataIssues.push(
      `${card.card} @ position ${index + 1} missing ${missing.join(', ')}`
    );
  });

  if (minorMetadataIssues.length > 0) {
    console.warn(
      '[validatePayload] Minor Arcana metadata incomplete; falling back to string parsing which may degrade nuance:',
      minorMetadataIssues.join(' | ')
    );
  }

  return null;
}

/**
 * Generate reading using Azure OpenAI GPT-5/5.1 via Responses API
 *
 * The Responses API is the recommended API for GPT-5 family models, bringing together
 * the best capabilities from chat completions and assistants API.
 *
 * API Reference: https://learn.microsoft.com/en-us/azure/ai-foundry/openai/how-to/responses
 */
async function generateWithAzureGPT5Responses(env, payload, requestId = 'unknown') {
  const { spreadInfo, cardsInfo, userQuestion, reflectionsText, analysis, context, visionInsights, contextDiagnostics = [] } = payload;
  
  // Track prompts for engineering analysis
  let capturedSystemPrompt = '';
  let capturedUserPrompt = '';
  // Normalize endpoint: strip trailing slashes and any existing /openai/v1 path
  // to avoid double-pathing when constructing the full URL
  const rawEndpoint = env.AZURE_OPENAI_ENDPOINT || '';
  const endpoint = rawEndpoint
    .replace(/\/+$/, '')                    // Remove trailing slashes
    .replace(/\/openai\/v1\/?$/, '')        // Remove /openai/v1 suffix if present
    .replace(/\/openai\/?$/, '');           // Remove /openai suffix if present
  const apiKey = env.AZURE_OPENAI_API_KEY;
  const deploymentName = env.AZURE_OPENAI_GPT5_MODEL; // Azure deployment name (often mirrors the base model name)
  // Responses API requires v1 path format - use dedicated Responses version binding
  // (same pattern as functions/lib/azureResponses.js)
  const apiVersion = env.AZURE_OPENAI_RESPONSES_API_VERSION || env.AZURE_OPENAI_API_VERSION || 'v1';
  const deckStyle = spreadInfo?.deckStyle || analysis?.themes?.deckStyle || cardsInfo?.[0]?.deckStyle || 'rws-1909';

  console.log(`[${requestId}] Building Azure GPT-5 prompts...`);
  console.log(`[${requestId}] Azure config: endpoint=${endpoint ? 'set' : 'missing'}, apiKey=${apiKey ? 'set' : 'missing'}, model=${deploymentName}, apiVersion=${apiVersion}`);

  // Determine semantic scoring configuration
  const semanticScoringConfig = getSemanticScoringConfig(env);
  const enableSemanticScoring = semanticScoringConfig !== null
    ? semanticScoringConfig
    : analysis.graphRAGPayload?.enableSemanticScoring ?? null;

  // Build enhanced prompts using narrative builder
  const { systemPrompt, userPrompt, promptMeta, contextDiagnostics: promptDiagnostics } = buildEnhancedClaudePrompt({
    spreadInfo,
    cardsInfo,
    userQuestion,
    reflectionsText,
    themes: analysis.themes,
    spreadAnalysis: analysis.spreadAnalysis,
    context,
    visionInsights,
    deckStyle,
    graphRAGPayload: analysis.graphRAGPayload,
    ephemerisContext: analysis.ephemerisContext,
    ephemerisForecast: analysis.ephemerisForecast,
    transitResonances: analysis.transitResonances,
    budgetTarget: 'azure',
    contextDiagnostics,
    promptBudgetEnv: env,
    personalization: payload.personalization,
    enableSemanticScoring
  });

  if (promptMeta) {
    payload.promptMeta = promptMeta;
  }

  if (Array.isArray(promptDiagnostics) && promptDiagnostics.length) {
    payload.contextDiagnostics = Array.from(new Set([...(payload.contextDiagnostics || []), ...promptDiagnostics]));
  }

  // Capture prompts for persistence
  capturedSystemPrompt = systemPrompt;
  capturedUserPrompt = userPrompt;
  
  console.log(`[${requestId}] System prompt length: ${systemPrompt.length}, User prompt length: ${userPrompt.length}`);
  maybeLogPromptPayload(
    env,
    requestId,
    'azure-gpt5',
    systemPrompt,
    userPrompt,
    promptMeta,
    { personalization: payload.personalization }
  );

  // Azure OpenAI Responses API endpoint format (v1 API):
  // POST {endpoint}/openai/v1/responses?api-version=v1
  // Model is passed in the request body, NOT in the URL path
  const url = `${endpoint}/openai/v1/responses?api-version=${encodeURIComponent(apiVersion)}`;

  // Log endpoint normalization for debugging
  if (rawEndpoint !== endpoint) {
    console.log(`[${requestId}] Endpoint normalized: "${rawEndpoint}" -> "${endpoint}"`);
  }
  console.log(`[${requestId}] Making Azure GPT-5 Responses API request to: ${url}`);
  console.log(`[${requestId}] Using deployment: ${deploymentName}, api-version: ${apiVersion}`);

  // Dynamic reasoning effort based on model capabilities
  // - gpt-5-pro, gpt-5.1: Use 'high' reasoning effort for best results
  // - gpt-5-codex: supports low/medium/high (not minimal)
  // - gpt-5: supports low/medium/high
  // - Other GPT-5 family models: support low/medium/high
  let reasoningEffort = 'medium'; // Default for most models
  if (deploymentName && requiresHighReasoningEffort(deploymentName)) {
    reasoningEffort = 'high';
    console.log(`[${requestId}] Detected ${deploymentName} deployment, using 'high' reasoning effort`);
  }

  // Responses API uses a different structure than Chat Completions
  // System prompts go in "instructions", user content in "input"
  // Note: Responses API does NOT support temperature parameter
  const requestBody = {
    model: deploymentName,
    instructions: systemPrompt,
    input: userPrompt,
    // max_output_tokens: 3000, // Removed to allow full model context length
    reasoning: {
      effort: reasoningEffort // Dynamically set based on model
    },
    text: {
      verbosity: 'medium' // low, medium, or high - controls output conciseness
    }
  };

  console.log(`[${requestId}] Request config:`, {
    deployment: deploymentName,
    max_output_tokens: requestBody.max_output_tokens,
    reasoning_effort: requestBody.reasoning.effort,
    verbosity: requestBody.text.verbosity
  });

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'api-key': apiKey,
      'content-type': 'application/json'
    },
    body: JSON.stringify(requestBody)
  });

  console.log(`[${requestId}] Azure Responses API response status: ${response.status}`);

  if (!response.ok) {
    const errText = await response.text().catch(() => '');
    console.error(`[${requestId}] Azure Responses API error response:`, errText);
    throw new Error(`Azure OpenAI GPT-5 Responses API error ${response.status}: ${errText}`);
  }

  const data = await response.json();
  console.log(`[${requestId}] Azure Responses API raw response:`, JSON.stringify(data, null, 2));
  console.log(`[${requestId}] Azure Responses API response received:`, {
    id: data.id,
    model: data.model,
    status: data.status,
    outputCount: data.output?.length,
    usage: data.usage
  });

  // Responses API returns output as an array of output items
  // Extract text from message output items
  let content = '';
  if (data.output && Array.isArray(data.output)) {
    for (const item of data.output) {
      // Handle message output type
      if (item.type === 'message' && item.content) {
        for (const contentItem of item.content) {
          if (contentItem.type === 'output_text' && contentItem.text) {
            content += contentItem.text;
          }
        }
      }
    }
  }

  // Fallback: try output_text property (some models use this)
  if (!content && data.output_text) {
    content = data.output_text;
  }

  if (!content || typeof content !== 'string' || !content.trim()) {
    console.error(`[${requestId}] Empty or invalid response from Azure GPT-5:`, {
      hasOutput: !!data.output,
      outputLength: data.output?.length,
      status: data.status
    });
    throw new Error('Empty response from Azure OpenAI GPT-5 Responses API');
  }

  console.log(`[${requestId}] Generated reading length: ${content.length} characters`);
  console.log(`[${requestId}] Token usage:`, {
    input_tokens: data.usage?.input_tokens,
    output_tokens: data.usage?.output_tokens,
    reasoning_tokens: data.usage?.output_tokens_details?.reasoning_tokens,
    total_tokens: data.usage?.total_tokens
  });

  // Return reading with captured prompts for engineering analysis
  return {
    reading: content.trim(),
    prompts: {
      system: capturedSystemPrompt,
      user: capturedUserPrompt
    },
    usage: data.usage
  };
}

/**
 * Enhanced Claude Sonnet 4.5 generation with position-relationship analysis
 */
async function generateWithClaudeSonnet45Enhanced(env, payload, requestId = 'unknown') {
  const { spreadInfo, cardsInfo, userQuestion, reflectionsText, analysis, context, visionInsights, contextDiagnostics = [] } = payload;
  
  // Track prompts for engineering analysis
  let capturedSystemPrompt = '';
  let capturedUserPrompt = '';
  
  // Azure AI Foundry Anthropic endpoint
  // API key: prefer AZURE_ANTHROPIC_API_KEY, fall back to AZURE_OPENAI_API_KEY
  const apiKey = env.AZURE_ANTHROPIC_API_KEY || env.AZURE_OPENAI_API_KEY;
  // Base URL should be: https://<resource>.services.ai.azure.com/anthropic
  // We append /v1/messages if not already present
  const baseEndpoint = env.AZURE_ANTHROPIC_ENDPOINT || '';
  const apiUrl = baseEndpoint.endsWith('/v1/messages')
    ? baseEndpoint
    : `${baseEndpoint.replace(/\/$/, '')}/v1/messages`;
  // Model = deployment name in Foundry (e.g., 'claude-opus-4-5' or custom)
  const model = env.AZURE_ANTHROPIC_MODEL || 'claude-opus-4-5';

  console.log(`[${requestId}] Azure Foundry Claude config: endpoint=${baseEndpoint ? 'set' : 'missing'}, apiKey=${apiKey ? 'set' : 'missing'}, model=${model}`);
  const deckStyle = spreadInfo?.deckStyle || analysis?.themes?.deckStyle || cardsInfo?.[0]?.deckStyle || 'rws-1909';

  // Determine semantic scoring configuration
  const semanticScoringConfig = getSemanticScoringConfig(env);
  const enableSemanticScoring = semanticScoringConfig !== null
    ? semanticScoringConfig
    : analysis.graphRAGPayload?.enableSemanticScoring ?? null;

  // Build enhanced prompts using narrative builder
  const { systemPrompt, userPrompt, promptMeta, contextDiagnostics: promptDiagnostics } = buildEnhancedClaudePrompt({
    spreadInfo,
    cardsInfo,
    userQuestion,
    reflectionsText,
    themes: analysis.themes,
    spreadAnalysis: analysis.spreadAnalysis,
    context,
    visionInsights,
    deckStyle,
    graphRAGPayload: analysis.graphRAGPayload,
    ephemerisContext: analysis.ephemerisContext,
    ephemerisForecast: analysis.ephemerisForecast,
    transitResonances: analysis.transitResonances,
    budgetTarget: 'claude',
    contextDiagnostics,
    promptBudgetEnv: env,
    personalization: payload.personalization,
    enableSemanticScoring
  });

  // Capture prompts for persistence
  capturedSystemPrompt = systemPrompt;
  capturedUserPrompt = userPrompt;
  
  if (promptMeta) {
    payload.promptMeta = promptMeta;
  }

  if (Array.isArray(promptDiagnostics) && promptDiagnostics.length) {
    payload.contextDiagnostics = Array.from(new Set([...(payload.contextDiagnostics || []), ...promptDiagnostics]));
  }

  maybeLogPromptPayload(
    env,
    requestId,
    'claude-sonnet45',
    systemPrompt,
    userPrompt,
    promptMeta,
    { personalization: payload.personalization }
  );

  const response = await fetch(apiUrl, {
    method: 'POST',
    headers: {
      'x-api-key': apiKey,  // Azure Foundry Anthropic uses 'x-api-key' header
      'anthropic-version': '2023-06-01',
      'content-type': 'application/json'
    },
    body: JSON.stringify({
      model,
      max_tokens: 8192, // Increased to allow full narrative generation without arbitrary limits
      temperature: 0.75,
      system: systemPrompt,
      messages: [
        {
          role: 'user',
          content: userPrompt
        }
      ]
    })
  });

  console.log(`[${requestId}] Azure Foundry Claude response status: ${response.status}`);

  if (!response.ok) {
    const errText = await response.text().catch(() => '');
    throw new Error(`Azure Anthropic proxy error ${response.status}: ${errText}`);
  }

  const data = await response.json();
  console.log(`[${requestId}] Azure Foundry Claude raw response:`, JSON.stringify(data, null, 2));
  const content = Array.isArray(data.content)
    ? data.content.map(part => part.text || '').join('').trim()
    : (data.content?.toString?.() || '').trim();

  if (!content) {
    throw new Error('Empty response from Azure Claude Opus 4.5');
  }

  // Return reading with captured prompts for engineering analysis
  return {
    reading: content,
    prompts: {
      system: capturedSystemPrompt,
      user: capturedUserPrompt
    },
    usage: data.usage
  };
}

const SPREAD_READING_BUILDERS = {
  celtic: ({ spreadAnalysis, cardsInfo, userQuestion, reflectionsText, themes, context }, options = {}) =>
    spreadAnalysis
      ? buildCelticCrossReading({
        cardsInfo,
        userQuestion,
        reflectionsText,
        celticAnalysis: spreadAnalysis,
        themes,
        context
      }, options)
      : null,
  threeCard: ({ spreadAnalysis, cardsInfo, userQuestion, reflectionsText, themes, context }, options = {}) =>
    spreadAnalysis
      ? buildThreeCardReading({
        cardsInfo,
        userQuestion,
        reflectionsText,
        threeCardAnalysis: spreadAnalysis,
        themes,
        context
      }, options)
      : null,
  fiveCard: ({ spreadAnalysis, cardsInfo, userQuestion, reflectionsText, themes, context }, options = {}) =>
    spreadAnalysis
      ? buildFiveCardReading({
        cardsInfo,
        userQuestion,
        reflectionsText,
        fiveCardAnalysis: spreadAnalysis,
        themes,
        context
      }, options)
      : null,
  relationship: ({ cardsInfo, userQuestion, reflectionsText, themes, context }, options = {}) =>
    buildRelationshipReading({ cardsInfo, userQuestion, reflectionsText, themes, context }, options),
  decision: ({ cardsInfo, userQuestion, reflectionsText, themes, context }, options = {}) =>
    buildDecisionReading({ cardsInfo, userQuestion, reflectionsText, themes, context }, options),
  single: ({ cardsInfo, userQuestion, reflectionsText, themes, context }, options = {}) =>
    buildSingleCardReading({ cardsInfo, userQuestion, reflectionsText, themes, context }, options)
};

/**
 * Enhanced local composer with spread-specific narrative construction
 */
async function composeReadingEnhanced(payload) {
  const {
    spreadInfo,
    cardsInfo,
    userQuestion,
    reflectionsText,
    analysis,
    context,
    personalization = null
  } = payload;
  const { themes, spreadAnalysis, spreadKey } = analysis;
  const collectedSections = [];

  const readingText = await generateReadingFromAnalysis(
    {
      spreadKey,
      spreadAnalysis,
      cardsInfo,
      userQuestion,
      reflectionsText,
      themes,
      spreadInfo,
      context
    },
    {
      personalization,
      collectValidation: (section) => {
        if (!section) return;
        collectedSections.push({
          text: section.text || '',
          metadata: section.metadata || {},
          validation: section.validation || null
        });
      }
    }
  );

  payload.narrativeEnhancements = collectedSections;

  if (!payload.promptMeta) {
    payload.promptMeta = {
      backend: 'local-composer',
      estimatedTokens: null,
      slimmingSteps: []
    };
  }

  // Return reading with null prompts (local composer doesn't use LLM prompts)
  return {
    reading: readingText,
    prompts: null,
    usage: null
  };
}

async function runNarrativeBackend(backendId, env, payload, requestId) {
  switch (backendId) {
    case 'azure-gpt5':
      return generateWithAzureGPT5Responses(env, payload, requestId);
    case 'claude-sonnet45':
      return generateWithClaudeSonnet45Enhanced(env, payload, requestId);
    case 'local-composer':
    default:
      return composeReadingEnhanced(payload);
  }
}

async function generateReadingFromAnalysis(
  { spreadKey, spreadAnalysis, cardsInfo, userQuestion, reflectionsText, themes, spreadInfo, context },
  options = {}
) {
  const builder = SPREAD_READING_BUILDERS[spreadKey];

  if (builder) {
    const result = await builder({
      spreadAnalysis,
      cardsInfo,
      userQuestion,
      reflectionsText,
      themes,
      spreadInfo,
      context
    }, options);

    if (typeof result === 'string' && result.trim()) {
      return result;
    }
  }

  return buildGenericReading(
    {
      spreadInfo,
      cardsInfo,
      userQuestion,
      reflectionsText,
      themes,
      context
    },
    options
  );
}

/**
 * Generic enhanced reading builder (for spreads without specific builders yet)
 */
function buildGenericReading(
  { spreadInfo, cardsInfo, userQuestion, reflectionsText, themes, context },
  options = {}
) {
  const { collectValidation, personalization = null } = options;
  const spreadName = spreadInfo?.name?.trim() || 'your chosen spread';
  const entries = [];
  const safeCards = Array.isArray(cardsInfo) ? cardsInfo : [];
  const remedyRotationIndex = computeRemedyRotationIndex({
    cardsInfo: safeCards,
    userQuestion,
    spreadInfo
  });
  const tone = getToneStyle(personalization?.readingTone);
  const _vocab = getFrameVocabulary(personalization?.spiritualFrame);
  const nameOpening = buildNameClause(personalization?.displayName, 'opening');
  const depthProfile = getDepthProfile(personalization?.preferredSpreadDepth);
  
  // Opening
  const trimmedQuestion = userQuestion && userQuestion.trim();
  const subject = nameOpening ? `${nameOpening}the cards` : 'The cards';
  const descriptor = tone.openingAdjectives?.[0] || 'thoughtful';
  const preface = depthProfile?.openingPreface ? `${depthProfile.openingPreface}\n\n` : '';
  const openingBody = trimmedQuestion
    ? `${subject} offer a ${descriptor} response through the ${spreadName.toLowerCase()} to your question: "${trimmedQuestion}".\n\nThey honor both seen and unseen influences while centering your agency.`
    : `${subject} share a ${descriptor} impression of what the ${spreadName.toLowerCase()} reveals around you right now.\n\nThey honor both seen and unseen influences while centering your agency.`;
  const openingText = `${preface}${openingBody}`.trim();

  entries.push({
    text: openingText,
    metadata: { type: 'opening', cards: safeCards.length > 0 ? [safeCards[0]] : [] }
  });

  // Cards section
  let cardsSection = buildCardsSection(safeCards, context, {
    detailLevel: depthProfile?.cardDetail,
    heading: depthProfile?.cardsHeading,
    note: depthProfile?.cardsNote
  });
  if (tone.challengeFraming) {
    cardsSection += `\n\nTreat any friction or challenge as a ${tone.challengeFraming}; the spread is highlighting choices, not fixed fate.`;
  }
  entries.push({
    text: cardsSection,
    metadata: { type: 'cards', cards: safeCards }
  });

  // Reflections
  if (reflectionsText && reflectionsText.trim()) {
    entries.push({
      text: `**Your Reflections**\n\n${reflectionsText.trim()}\n\nYour intuitive impressions add personal meaning to this reading.`,
      metadata: { type: 'reflections' }
    });
  }

  // Synthesis with enhanced themes
  const finalCard = safeCards.length > 0 ? safeCards[safeCards.length - 1] : null;
  entries.push({
    text: buildEnhancedSynthesis(safeCards, themes, userQuestion, context, {
      rotationIndex: remedyRotationIndex,
      depthProfile
    }),
    metadata: { type: 'synthesis', cards: finalCard ? [finalCard] : [] }
  });

  const enhancedSections = entries
    .map(({ text, metadata }) => {
      const result = enhanceSection(text, metadata || {});
      if (!result || !result.text) {
        return null;
      }
      const sectionRecord = {
        text: result.text,
        metadata: metadata || {},
        validation: result.validation || null
      };
      if (typeof collectValidation === 'function') {
        collectValidation(sectionRecord);
      }
      return sectionRecord;
    })
    .filter(Boolean);

  const readingBody = enhancedSections.map((section) => section.text).join('\n\n');
  const closing = buildPersonalizedClosing(personalization);
  const bodyWithClosing = closing ? `${readingBody}\n\n${closing}` : readingBody;
  return appendGenericReversalReminder(bodyWithClosing, safeCards, themes);
}

function annotateVisionInsights(proofInsights, cardsInfo = [], deckStyle = 'rws-1909') {
  if (!Array.isArray(proofInsights) || proofInsights.length === 0) {
    return [];
  }

  const normalizedDeck = deckStyle || 'rws-1909';
  const drawnNames = new Set(
    (cardsInfo || [])
      .map((card) => canonicalCardKey(card?.card || card?.name, normalizedDeck))
      .filter(Boolean)
  );

  return proofInsights
    .filter((entry) => entry && typeof entry === 'object')
    .map((entry) => {
      const predictedCard = canonicalizeCardName(entry.predictedCard || entry.card, normalizedDeck);
      if (!predictedCard) {
        return null;
      }

      const predictedKey = canonicalCardKey(predictedCard, normalizedDeck);
      const matchesDrawnCard = drawnNames.size > 0
        ? (predictedKey ? drawnNames.has(predictedKey) : null)
        : null;

      const matches = Array.isArray(entry.matches)
        ? entry.matches
          .map((match) => {
            const card = canonicalizeCardName(match?.card || match?.cardName, normalizedDeck);
            if (!card) return null;
            return {
              ...match,
              card
            };
          })
          .filter(Boolean)
          .slice(0, 3)
        : [];

      return {
        label: normalizeVisionLabel(entry.label),
        predictedCard,
        confidence: typeof entry.confidence === 'number' ? entry.confidence : null,
        basis: typeof entry.basis === 'string' ? entry.basis : null,
        matchesDrawnCard,
        matches,
        attention: entry.attention || null,
        symbolVerification: entry.symbolVerification || null,
        visualProfile: entry.visualProfile || null
      };
    })
    .filter(Boolean)
    .slice(0, 10);
}

/**
 * Build cards section with reversal framework awareness
 */
function buildCardsSection(cardsInfo, context, options = {}) {
  const safeCards = Array.isArray(cardsInfo) ? cardsInfo : [];
  const normalizedDetail = typeof options.detailLevel === 'string' ? options.detailLevel : 'standard';
  const heading = options.heading
    || (normalizedDetail === 'concise'
      ? '**Quick Card Highlights**'
      : normalizedDetail === 'expansive'
        ? '**Layered Card Weaving**'
        : '**The Cards Speak**');

  const lines = safeCards.map((card, index) => {
    const position = (card?.position || '').trim() || `Card ${index + 1}`;
    let description = buildPositionCardText(card, position, { context });
    if (normalizedDetail === 'concise') {
      description = condenseDescriptionForDepth(description);
    } else if (normalizedDetail === 'expansive') {
      const reflectionPrompt = buildDepthReflectionPrompt(card, position);
      if (reflectionPrompt) {
        description = `${description}\n*Deep dive: ${reflectionPrompt}*`;
      }
    }
    return `**${position}**\n${description}`;
  });

  let section = `${heading}\n\n${lines.join('\n\n')}`;
  if (options.note) {
    section += `\n\n${options.note}`;
  }
  return section;
}

function condenseDescriptionForDepth(text, sentenceCount = 2) {
  if (!text || typeof text !== 'string') {
    return text;
  }
  const segments = text.match(/[^.!?]+[.!?]?/g);
  if (!segments || segments.length <= sentenceCount) {
    return text;
  }
  return segments.slice(0, sentenceCount).join(' ').trim();
}

function buildDepthReflectionPrompt(card, position) {
  if (!card) return '';
  const cardName = typeof card.card === 'string' && card.card.trim() ? card.card.trim() : 'this card';
  const orientation = typeof card.orientation === 'string' && card.orientation.trim() ? ` ${card.orientation.trim()}` : '';
  const focus = (position || 'this position').toLowerCase();
  return `Journal on how ${cardName}${orientation} wants you to engage with ${focus}.`;
}

/**
 * Format meaning for position context
 */
/**
 * Enhanced synthesis with rich theme analysis
 */
function buildEnhancedSynthesis(cardsInfo, themes, userQuestion, context, options = {}) {
  const safeCards = Array.isArray(cardsInfo) ? cardsInfo : [];
  const depthProfile = options.depthProfile || null;
  const heading = depthProfile?.key === 'short'
    ? '**Quick Trajectory**'
    : depthProfile?.key === 'deep'
      ? '**Deep Synthesis & Guidance**'
      : '**Synthesis & Guidance**';
  let section = `${heading}\n\n`;
  const rotationIndex = Number.isFinite(options.rotationIndex)
    ? Math.abs(Math.floor(options.rotationIndex))
    : 0;

  if (context && context !== 'general') {
    const contextMap = {
      love: 'relationships and heart-centered experience',
      career: 'career, vocation, and material pathways',
      self: 'personal growth and inner landscape',
      spiritual: 'spiritual practice and meaning-making'
    };
    const descriptor = contextMap[context] || 'your life as a whole';
    section += `Focus: Interpreting the spread through the lens of ${descriptor}.\n\n`;
  }

  // Suit focus
  if (themes.suitFocus) {
    section += `${themes.suitFocus}\n\n`;
  }

  // Timing profile (soft, non-deterministic)
  if (themes.timingProfile === 'near-term-tilt') {
    section += `Pace: These influences are likely to move or clarify in the nearer term, assuming you stay engaged with them.\n\n`;
  } else if (themes.timingProfile === 'longer-arc-tilt') {
    section += `Pace: This reading leans toward a slower-burn, structural arc that unfolds over a longer chapter, not overnight.\n\n`;
  } else if (themes.timingProfile === 'developing-arc') {
    section += `Pace: Themes here describe an unfolding chapter—neither instant nor distant, but evolving as you work with them.\n\n`;
  }

  // Archetype level
  if (themes.archetypeDescription) {
    section += `${themes.archetypeDescription}\n\n`;
  }

  // Elemental balance with actionable remedies
  if (themes.elementalBalance) {
    section += `Elemental context: ${themes.elementalBalance}\n\n`;

    // Add elemental remedies if imbalanced
    if (shouldOfferElementalRemedies(themes.elementCounts, safeCards.length)) {
      const remedies = buildElementalRemedies(themes.elementCounts, safeCards.length, context, {
        rotationIndex
      });
      if (remedies) {
        section += `${remedies}\n\n`;
      }
    }
  }

  // Lifecycle stage
  if (themes.lifecycleStage) {
    section += `The cards speak to ${themes.lifecycleStage}.\n\n`;
  }

  // Actionable guidance
  const personalAnchor = userQuestion?.trim()
    ? 'Take the next small, intentional step that honors both your intuition and the practical realities at hand.'
    : 'Carry this insight gently into your next steps, allowing space for new awareness to bloom.';

  section += `${personalAnchor}\n\n`;

  // Free will reminder
  section += `Remember: These cards show a trajectory based on current patterns. Your awareness, choices, and actions shape what unfolds. You are co-creating this path.`;

  if (depthProfile?.synthesisReminder) {
    section += `\n\n${depthProfile.synthesisReminder}`;
  }

  return section;
}

function appendGenericReversalReminder(readingText, cardsInfo, themes) {
  if (!readingText) return readingText;

  const hasReversed = Array.isArray(cardsInfo) && cardsInfo.some(card =>
    (card?.orientation || '').toLowerCase() === 'reversed'
  );

  if (!hasReversed || !themes?.reversalDescription) {
    return readingText;
  }

  const lens = formatReversalLens(themes, { includeExamples: false, includeReminder: false });
  const guidanceLine = Array.isArray(lens.lines)
    ? lens.lines.find((line) => line.toLowerCase().includes('guidance'))
    : null;
  const reminderText = guidanceLine
    ? guidanceLine.replace(/^[-\s]*/, '').trim()
    : (themes.reversalDescription.guidance
      ? `Guidance: ${themes.reversalDescription.guidance}`
      : `Reversal lens: ${themes.reversalDescription.name}`);

  const reminder = `*Reversal lens reminder: ${reminderText}*`;
  if (readingText.includes(reminder)) {
    return readingText;
  }

  return `${readingText}\n\n${reminder}`;
}

function buildVisionMetrics(insights, avgConfidence, mismatchCount) {
  const safeInsights = Array.isArray(insights) ? insights : [];
  const symbolStats = safeInsights
    .filter((entry) => entry && entry.symbolVerification)
    .map((entry) => ({
      card: entry.predictedCard,
      matchRate: typeof entry.symbolVerification.matchRate === 'number' ? entry.symbolVerification.matchRate : null,
      missingSymbols: Array.isArray(entry.symbolVerification.missingSymbols)
        ? entry.symbolVerification.missingSymbols
        : [],
      unexpectedDetections: Array.isArray(entry.symbolVerification.unexpectedDetections)
        ? entry.symbolVerification.unexpectedDetections
        : [],
      expectedCount: entry.symbolVerification.expectedCount ?? null,
      detectedCount: entry.symbolVerification.detectedCount ?? null
    }));

  return {
    uploads: safeInsights.length,
    avgConfidence: Number.isFinite(avgConfidence) ? avgConfidence : null,
    mismatchCount,
    symbolStats
  };
}

function buildNarrativeMetrics(readingText, cardsInfo, deckStyle = 'rws-1909') {
  const text = typeof readingText === 'string' ? readingText : '';
  const safeCards = Array.isArray(cardsInfo) ? cardsInfo : [];
  const spine = validateReadingNarrative(text);
  const coverage = analyzeCardCoverage(text, safeCards);
  const hallucinatedCards = detectHallucinatedCards(text, safeCards, deckStyle);

  return {
    spine: {
      isValid: spine.isValid,
      totalSections: spine.totalSections || 0,
      completeSections: spine.completeSections || 0,
      incompleteSections: spine.incompleteSections || 0,
      suggestions: spine.suggestions || []
    },
    cardCoverage: coverage.coverage,
    missingCards: coverage.missingCards,
    hallucinatedCards
  };
}

function analyzeCardCoverage(readingText, cardsInfo = []) {
  if (!Array.isArray(cardsInfo) || cardsInfo.length === 0) {
    return { coverage: 1, missingCards: [] };
  }

  const text = typeof readingText === 'string' ? readingText : '';
  const missingCards = cardsInfo
    .filter((card) => card && typeof card.card === 'string')
    .map((card) => card.card)
    .filter((name) => {
      if (!name) return true;
      const pattern = new RegExp(escapeRegex(name), 'i');
      return !pattern.test(text);
    });

  const presentCount = cardsInfo.length - missingCards.length;
  const coverage = cardsInfo.length ? presentCount / cardsInfo.length : 1;
  return { coverage, missingCards };
}

function looksLikeCardNameCase(matchText) {
  if (!matchText || typeof matchText !== 'string') return false;
  if (matchText === matchText.toUpperCase()) return true;

  const words = matchText.trim().split(/\s+/).filter(Boolean);
  if (!words.length) return false;

  const significantWords = words.filter((word) => !CARD_NAME_STOP_WORDS.has(word.toLowerCase()));
  if (!significantWords.length) return false;

  return significantWords.every((word) => /^[A-Z]/.test(word));
}

function detectHallucinatedCards(readingText, cardsInfo = [], deckStyle = 'rws-1909') {
  if (!readingText) return [];

  let text = typeof readingText === 'string' ? readingText : '';
  const safeCards = Array.isArray(cardsInfo) ? cardsInfo : [];

  // Remove tarot terminology phrases that reference card names but aren't card references
  // e.g., "Fool's Journey" refers to the archetypal journey, not The Fool card
  TAROT_TERMINOLOGY_EXCLUSIONS.forEach(pattern => {
    text = text.replace(pattern, '[TERMINOLOGY]');
  });

  // Track both canonical deck-aware keys and normalized literal names for drawn cards.
  const drawnKeys = new Set(
    safeCards
      .filter((card) => card && typeof card.card === 'string')
      .map((card) => {
        const canonical = canonicalCardKey(card.card, deckStyle);
        return canonical || normalizeCardName(card.card);
      })
      .filter(Boolean)
  );

  const hallucinated = [];

  CARD_NAME_PATTERNS.forEach(({ name, normalized, pattern }) => {
    const flags = pattern.flags.includes('g') ? pattern.flags : `${pattern.flags}g`;
    const matches = Array.from(text.matchAll(new RegExp(pattern.source, flags)));
    if (!matches.length) {
      return;
    }

    const hasContext = hasExplicitCardContext(text, name);
    const requiresCardCase = CARD_NAMES_REQUIRING_CARD_CASE.has(normalized);
    const hasCardCase = requiresCardCase
      ? matches.some((match) => looksLikeCardNameCase(match[0]))
      : true;

    // For names that are also common vocabulary (Justice, Strength, Temperance, Death, Judgement),
    // only treat them as card mentions when there is explicit card-like context in the text.
    if (AMBIGUOUS_CARD_NAMES.has(normalized) && !hasContext) {
      return;
    }

    if (requiresCardCase && !hasContext && !hasCardCase) {
      return;
    }

    const canonical = canonicalCardKey(name, deckStyle);
    const key = canonical || normalized;

    if (!drawnKeys.has(key)) {
      hallucinated.push(name);
    }
  });

  // De-duplicate while preserving insertion order
  return [...new Set(hallucinated)];
}

async function persistReadingMetrics(env, payload) {
  if (!env?.METRICS_DB?.put) {
    return;
  }

  try {
    const key = `reading:${payload.requestId}`;
    await env.METRICS_DB.put(key, JSON.stringify(payload), {
      metadata: {
        provider: payload.provider,
        spreadKey: payload.spreadKey,
        deckStyle: payload.deckStyle,
        timestamp: payload.timestamp
      }
    });
  } catch (err) {
    console.warn(`[${payload.requestId}] Failed to persist reading metrics: ${err.message}`);
  }
}
</file>

<file path="functions/api/tts-hume.js">
import { jsonResponse, readJsonBody } from '../lib/utils.js';
import { getActingInstructions, EMOTION_DESCRIPTIONS } from '../../src/data/emotionMapping.js';

/**
 * Cloudflare Pages Function that provides text-to-speech audio using Hume AI's Octave TTS.
 * 
 * Hume AI Octave TTS offers emotionally expressive voices with natural prosody and voice continuity.
 * Perfect for tarot readings where tone, emotion, and mystical atmosphere matter.
 *
 * Supports:
 * - Context-specific voice descriptions (mystical, contemplative, wise)
 * - Voice selection from Hume's preset library (Wise Wizard, Mysterious Woman, etc.)
 * - Custom voice design through natural language descriptions
 * - Speech continuity across multiple utterances via context.generationId
 * - Speed control and trailing silence
 *
 * API Documentation: https://dev.hume.ai/reference/text-to-speech-tts
 *
 * Usage:
 *
 * Basic request:
 *   POST /api/tts-hume
 *   Body: { "text": "...", "voiceName": "ITO" }
 *   Response: { "audio": "data:audio/mpeg;base64,...", "provider": "hume-ai", "generationId": "..." }
 *
 * Context-aware request with custom voice:
 *   POST /api/tts-hume
 *   Body: { 
 *     "text": "The Fool represents...", 
 *     "context": "card-reveal",
 *     "description": "a mystical, gentle voice with contemplative pacing"
 *   }
 *
 * Continued speech (maintains voice consistency):
 *   POST /api/tts-hume
 *   Body: { 
 *     "text": "Next, we see The Magician...", 
 *     "previousGenerationId": "generation-id-from-previous-call"
 *   }
 */

// Voice name mappings for different tarot reading contexts
const CONTEXT_VOICES = {
  'card-reveal': 'ITO',
  'full-reading': 'ITO',
  'synthesis': 'KORA',
  'question': 'STELLA',
  'reflection': 'DACHER',
  'default': 'ITO'
};

// Context-specific voice descriptions for acting instructions
const CONTEXT_DESCRIPTIONS = {
  'card-reveal': 'Speak gently and mystically, as a tarot reader revealing a card with reverence. Use a slightly slower pace with brief pauses. Convey wisdom and contemplation.',
  
  'full-reading': 'Speak as a wise, compassionate tarot reader sharing a complete reading. Use a thoughtful, contemplative tone with natural pauses. Allow space for reflection—speak slowly and deliberately. Convey mystical depth while remaining grounded and accessible.',
  
  'synthesis': 'Speak as a tarot reader weaving together the threads of a reading. Use a flowing, storytelling cadence that connects themes. Pause briefly between major insights. Convey both wisdom and warmth.',
  
  'question': 'Speak gently and clearly, acknowledging the question with respect. Use a warm, inviting tone that creates space for exploration.',
  
  'reflection': 'Speak softly and affirmingly, honoring personal reflections. Use a validating, supportive tone that acknowledges intuitive insights.',
  
  'default': 'Speak thoughtfully and gently, as a tarot reader sharing wisdom. Use a mystical yet grounded tone with natural pacing and slight pauses for contemplation.'
};

export const onRequestGet = async ({ env }) => {
  // Health check endpoint
  const hasHumeKey = !!resolveEnv(env, 'HUME_API_KEY');
  return jsonResponse({
    status: 'ok',
    provider: hasHumeKey ? 'hume-ai' : 'unavailable',
    timestamp: new Date().toISOString()
  });
};

export const onRequestPost = async ({ request, env }) => {
  try {
    const {
      text,
      context,
      voiceName,
      description,
      emotion,
      speed,
      previousGenerationId,
      trailingSilence
    } = await readJsonBody(request);

    const sanitizedText = sanitizeText(text);

    if (!sanitizedText) {
      return jsonResponse(
        { error: 'The "text" field is required.' },
        { status: 400 }
      );
    }

    // Check for Hume API key
    const humeApiKey = resolveEnv(env, 'HUME_API_KEY');
    if (!humeApiKey) {
      return jsonResponse(
        { error: 'Hume AI is not configured. Please set HUME_API_KEY environment variable.' },
        { status: 503 }
      );
    }

    try {
      // Build the utterance object
      const utterance = {
        text: sanitizedText
      };

      // Add voice (use context-based voice if not provided)
      const selectedVoiceName = voiceName || 
                                (context && CONTEXT_VOICES[context]) || 
                                CONTEXT_VOICES.default;
      
      utterance.voice = {
        name: selectedVoiceName,
        provider: 'HUME_AI'
      };

      // Add voice description/acting instructions
      // Priority: custom description > emotion-based > context-based
      if (description) {
        utterance.description = description;
      } else if (emotion && EMOTION_DESCRIPTIONS[emotion]) {
        utterance.description = getActingInstructions(emotion);
      } else if (context && CONTEXT_DESCRIPTIONS[context]) {
        utterance.description = CONTEXT_DESCRIPTIONS[context];
      }

      // Add speed if provided (0.5-2.0 range)
      if (speed !== undefined) {
        utterance.speed = Math.max(0.5, Math.min(2.0, speed));
      }

      // Add trailing silence if provided (0-5 seconds) - API uses snake_case
      if (trailingSilence !== undefined) {
        const clamped = Math.max(0, Math.min(5, Number(trailingSilence)));
        utterance.trailing_silence = clamped;
      }

      // Build the TTS request payload - format is REQUIRED as an object
      const ttsPayload = {
        utterances: [utterance],
        format: { type: 'mp3' } // Required object: { type: 'mp3' | 'pcm' | 'wav' }
      };

      // Add continuation context if provided
      if (previousGenerationId) {
        ttsPayload.context = {
          generationId: previousGenerationId
        };
      }

      // Call Hume AI TTS API (non-streaming endpoint)
      // Endpoint: POST https://api.hume.ai/v0/tts
      const response = await fetch('https://api.hume.ai/v0/tts', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Hume-Api-Key': humeApiKey
        },
        body: JSON.stringify(ttsPayload)
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Hume AI TTS error:', response.status, errorText);
        
        // Try to parse error message from Hume
        let errorMessage = `Hume TTS failed (${response.status})`;
        try {
          const errorBody = JSON.parse(errorText);
          errorMessage = errorBody.error ?? errorBody.message ?? errorMessage;
        } catch {
          // Keep default message if parsing fails
        }
        
        if (response.status === 429) {
          return jsonResponse(
            { error: 'Rate limit exceeded. Please try again in a moment.' },
            { status: 429 }
          );
        }
        
        return jsonResponse(
          { error: errorMessage },
          { status: response.status }
        );
      }

      // Parse the response
      const result = await response.json();
      
      // Extract the first generation
      const generation = result.generations?.[0];
      if (!generation?.audio) {
        throw new Error('No audio generated in response');
      }

      // Extract generation ID correctly (may be in context or at top level)
      const generationId = generation.context?.generationId ?? generation.id ?? null;

      // The audio is already base64-encoded, create data URI (mp3 format)
      const dataUri = `data:audio/mpeg;base64,${generation.audio}`;

      return jsonResponse({ 
        audio: dataUri, 
        provider: 'hume-ai',
        generationId,
        voiceUsed: selectedVoiceName
      });

    } catch (error) {
      console.error('Hume AI TTS generation failed:', error);
      return jsonResponse(
        { error: 'Unable to generate audio with Hume AI at this time.' },
        { status: 500 }
      );
    }

  } catch (error) {
    console.error('tts-hume function error:', error);
    return jsonResponse(
      { error: 'Unable to process TTS request.' },
      { status: 500 }
    );
  }
};

function sanitizeText(text) {
  if (typeof text !== 'string') return '';
  // Hume supports up to 5000 characters per utterance
  return text.trim().slice(0, 5000);
}

function resolveEnv(env, key) {
  // Handle both Cloudflare Workers env object and process.env
  if (env?.[key]) return env[key];
  if (typeof process !== 'undefined' && process.env?.[key]) {
    return process.env[key];
  }
  return undefined;
}
</file>

<file path="functions/api/tts.js">
import { generateFallbackWaveform } from '../../shared/fallbackAudio.js';
import { jsonResponse, readJsonBody } from '../lib/utils.js';

/**
 * Cloudflare Pages Function that provides text-to-speech audio as a data URI or streaming response.
 *
 * Enhanced with gpt-4o-mini-tts steerable instructions for context-aware,
 * mystical tarot reading narration.
 *
 * Supports:
 * - Context-specific instruction templates (card-reveal, full-reading, synthesis)
 * - Voice selection (verse, nova, shimmer, alloy, echo, fable, onyx, etc.)
 * - Speed control for contemplative pacing (0.25-4.0, default 1.1)
 * - Streaming mode for real-time audio playback
 * - Graceful fallback to local waveform
 *
 * Usage:
 *
 * Non-streaming mode (returns JSON with base64 data URI):
 *   POST /api/tts
 *   Body: { "text": "...", "context": "full-reading", "voice": "verse", "speed": 0.9 }
 *   Response: { "audio": "data:audio/mp3;base64,...", "provider": "azure-gpt-4o-mini-tts" }
 *
 * Streaming mode (returns audio stream):
 *   POST /api/tts?stream=true
 *   Body: { "text": "...", "context": "full-reading", "voice": "verse", "speed": 0.9 }
 *   Response: audio/mp3 stream (content-type: audio/mp3)
 *
 * API Reference: https://learn.microsoft.com/en-us/azure/ai-foundry/openai/reference-preview-latest#create-speech
 */
export const onRequestGet = async ({ env }) => {
  // Health check endpoint
  // TTS can use separate credentials (AZURE_OPENAI_TTS_*) or fall back to shared credentials
  const azureEndpoint = resolveEnv(env, 'AZURE_OPENAI_TTS_ENDPOINT') || resolveEnv(env, 'AZURE_OPENAI_ENDPOINT');
  const azureKey = resolveEnv(env, 'AZURE_OPENAI_TTS_API_KEY') || resolveEnv(env, 'AZURE_OPENAI_API_KEY');
  const azureDeployment = resolveEnv(env, 'AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT');
  const hasAzure = !!(azureEndpoint && azureKey && azureDeployment);
  return jsonResponse({
    status: 'ok',
    provider: hasAzure ? 'azure-openai' : 'local',
    timestamp: new Date().toISOString()
  });
};

export const onRequestPost = async ({ request, env }) => {
  try {
    const url = new URL(request.url);
    const stream = url.searchParams.get('stream') === 'true';

    const rateLimitResult = await enforceTtsRateLimit(env, request);
    if (rateLimitResult?.limited) {
      return jsonResponse(
        {
          error: 'Too many text-to-speech requests. Please wait a few moments and try again.'
        },
        {
          status: 429,
          headers: {
            'retry-after': rateLimitResult.retryAfter.toString()
          }
        }
      );
    }

    const { text, context, voice, speed } = await readJsonBody(request);
    const sanitizedText = sanitizeText(text);
    const debugLoggingEnabled = isTtsDebugLoggingEnabled(env);

    if (!sanitizedText) {
      return jsonResponse(
        { error: 'The "text" field is required.' },
        { status: 400 }
      );
    }

    // Primary: Azure OpenAI gpt-4o-mini-tts with steerable instructions
    // TTS can use separate credentials (AZURE_OPENAI_TTS_*) or fall back to shared credentials
    const azureConfig = {
      endpoint: resolveEnv(env, 'AZURE_OPENAI_TTS_ENDPOINT') || resolveEnv(env, 'AZURE_OPENAI_ENDPOINT'),
      apiKey: resolveEnv(env, 'AZURE_OPENAI_TTS_API_KEY') || resolveEnv(env, 'AZURE_OPENAI_API_KEY'),
      deployment: resolveEnv(env, 'AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT'),
      apiVersion: resolveEnv(env, 'AZURE_OPENAI_API_VERSION'),
      format: resolveEnv(env, 'AZURE_OPENAI_GPT_AUDIO_MINI_FORMAT'),
      useV1Format: resolveEnv(env, 'AZURE_OPENAI_USE_V1_FORMAT'),
      debugLoggingEnabled
    };

    if (azureConfig.endpoint && azureConfig.apiKey && azureConfig.deployment) {
      try {
        if (stream) {
          // Return streaming response
          return await generateWithAzureGptMiniTTSStream(azureConfig, {
            text: sanitizedText,
            context: context || 'default',
            voice: voice || 'verse',
            speed: speed
          });
        } else {
          // Return complete audio as data URI
          const audio = await generateWithAzureGptMiniTTS(azureConfig, {
            text: sanitizedText,
            context: context || 'default',
            voice: voice || 'verse',
            speed: speed
          });
          if (audio) {
            return jsonResponse({ audio, provider: 'azure-gpt-4o-mini-tts' });
          }
        }
      } catch (error) {
        console.error('Azure OpenAI gpt-4o-mini-tts failed, falling back to local waveform:', error);
      }
    }

    // Fallback: local synthesized waveform (no external dependency).
    const fallbackAudio = generateFallbackWaveform(sanitizedText);

    if (stream) {
      // For streaming requests, decode base64 and return binary audio
      const base64Data = fallbackAudio.split(',')[1];
      const binaryString = atob(base64Data);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return new Response(bytes, {
        headers: {
          'content-type': 'audio/wav',
          'cache-control': 'no-cache'
        }
      });
    }

    return jsonResponse({ audio: fallbackAudio, provider: 'fallback' });
  } catch (error) {
    console.error('tts function error:', error);
    return jsonResponse(
      { error: 'Unable to generate audio at this time.' },
      { status: 500 }
    );
  }
};

function sanitizeText(text) {
  if (typeof text !== 'string') return '';
  return text.trim().slice(0, 4000); // Increased for full readings; gpt-4o-mini-tts handles longer text well
}

/**
 * Convert Uint8Array to base64 string.
 * Used for encoding audio binary data into data URIs.
 */
function uint8ToBase64(uint8Array) {
  let binary = '';
  for (let i = 0; i < uint8Array.length; i++) {
    binary += String.fromCharCode(uint8Array[i]);
  }
  return btoa(binary);
}

/**
 * Steerable instruction templates for different tarot reading contexts.
 * These leverage gpt-4o-mini-tts's ability to control tone, pacing, and delivery style.
 */
const INSTRUCTION_TEMPLATES = {
  'card-reveal': `Speak gently and mystically, as a tarot reader revealing a single card with reverence.
    Use a slightly slower pace with brief pauses after the card name and orientation.
    Convey wisdom and contemplation in your tone.`,

  'full-reading': `Speak as a wise, compassionate tarot reader sharing a complete reading.
    Use a thoughtful, contemplative tone with natural pauses between card descriptions and themes.
    Allow space for reflection—speak slowly and deliberately, as if sitting across from the querent.
    Convey mystical depth while remaining grounded and accessible.
    Maintain a gentle, trauma-informed presence throughout.`,

  'synthesis': `Speak as a tarot reader weaving together the threads of a reading into cohesive guidance.
    Use a flowing, storytelling cadence that connects themes and patterns.
    Pause briefly between major insights to allow integration.
    Convey both wisdom and warmth, emphasizing agency and empowerment.`,

  'question': `Speak gently and clearly, acknowledging the querent's question with respect.
    Use a warm, inviting tone that creates space for exploration rather than fixed answers.`,

  'reflection': `Speak softly and affirmingly, honoring the querent's personal reflections.
    Use a validating, supportive tone that acknowledges their intuitive insights.`,

  'default': `Speak thoughtfully and gently, as a tarot reader sharing wisdom.
    Use a mystical yet grounded tone with natural pacing and slight pauses for contemplation.`
};

/**
 * Build TTS request configuration shared by both streaming and non-streaming modes.
 * Extracts common logic for endpoint construction, payload building, and parameter validation.
 *
 * @param {Object} env - Environment configuration
 * @param {Object} options - TTS options
 * @param {string} options.text - Text to synthesize
 * @param {string} options.context - Context template (card-reveal, full-reading, etc.)
 * @param {string} [options.voice='verse'] - Voice selection
 * @param {number} [options.speed=1.1] - Speech speed (0.25-4.0)
 * @returns {Object} Request configuration with url, payload, format, etc.
 */
function buildTTSRequest(env, { text, context, voice, speed }) {
  const endpoint = env.endpoint.replace(/\/+$/, '');
  const deployment = env.deployment;
  const format = env.format || 'mp3';
  const useV1Format = env.useV1Format === 'true' || env.useV1Format === true;
  const debugLoggingEnabled = Boolean(env.debugLoggingEnabled);

  // API version logic:
  // - v1 format uses "preview"
  // - deployment format uses dated preview version (e.g., "2025-04-01-preview")
  const apiVersion = useV1Format
    ? 'preview'
    : (env.apiVersion || '2025-04-01-preview');

  // Select instruction template based on context
  const instructions = INSTRUCTION_TEMPLATES[context] || INSTRUCTION_TEMPLATES.default;

  // Voice validation (gpt-4o-mini-tts voices - 11 available)
  // Base voices: alloy, ash, ballad, coral, echo, fable, nova, onyx, sage, shimmer, verse
  const validVoices = ['alloy', 'ash', 'ballad', 'coral', 'echo', 'fable', 'nova', 'onyx', 'sage', 'shimmer', 'verse'];
  const selectedVoice = validVoices.includes(voice) ? voice : 'verse';

  // Speed validation (0.25 - 4.0 range per API spec)
  const selectedSpeed = speed !== undefined
    ? Math.max(0.25, Math.min(4.0, speed))
    : 1.1; // Default: slightly faster for engaging tarot reading pace

  // Build URL based on format preference
  const url = useV1Format
    ? `${endpoint}/openai/v1/audio/speech?api-version=${apiVersion}`
    : `${endpoint}/openai/deployments/${deployment}/audio/speech?api-version=${apiVersion}`;

  // Build payload per API specification
  const payload = {
    input: text,
    model: deployment,
    voice: selectedVoice,
    response_format: format,
    speed: selectedSpeed
  };

  // Check if this deployment supports steerable instructions
  const isSteerableModel = /gpt-4o|mini-tts|audio-preview/i.test(deployment);

  if (isSteerableModel) {
    payload.instructions = instructions;
  }

  return { url, payload, format, useV1Format, apiVersion, debugLoggingEnabled };
}

/**
 * Enhanced Azure OpenAI TTS generation with optional steerable instructions.
 *
 * For steerable-capable models (e.g. gpt-4o-mini-tts, audio-preview variants), includes
 * context-aware instructions. For standard models (tts-1, tts-1-hd), omits unsupported fields.
 * This keeps behavior model-agnostic while preserving rich narration when available.
 *
 * API Reference: https://learn.microsoft.com/en-us/azure/ai-foundry/openai/reference-preview-latest#create-speech
 */
async function generateWithAzureGptMiniTTS(env, { text, context, voice, speed }) {
  const { url, payload, format, debugLoggingEnabled } = buildTTSRequest(env, { text, context, voice, speed });

  if (debugLoggingEnabled) {
    console.log('[TTS] Request URL:', url);
    console.log('[TTS] Request payload:', JSON.stringify(payload, null, 2));
  }

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'api-key': env.apiKey,
      'content-type': 'application/json'  // JSON works despite docs saying multipart/form-data
    },
    body: JSON.stringify(payload)
  });

  if (debugLoggingEnabled) {
    console.log('[TTS] Response status:', response.status, response.statusText);
    console.log('[TTS] Response headers:', JSON.stringify([...response.headers.entries()]));
  }

  if (!response.ok) {
    let errText = '';
    if (debugLoggingEnabled) {
      errText = await response.text().catch(() => '');
    }
    console.error('[TTS] Azure request failed', response.status, response.statusText);
    if (debugLoggingEnabled && errText) {
      console.error('[TTS] Error response body:', errText);
    }
    throw new Error(`Azure TTS error ${response.status}`);
  }

  const arrayBuffer = await response.arrayBuffer();
  const base64 = uint8ToBase64(new Uint8Array(arrayBuffer));
  const mime = format === 'wav' ? 'audio/wav' : `audio/${format}`;
  return `data:${mime};base64,${base64}`;
}

/**
 * Streaming Azure OpenAI TTS generation.
 *
 * Uses the stream_format parameter to request Server-Sent Events (SSE)
 * or raw audio streaming from Azure OpenAI.
 *
 * Per API docs: "sse is not supported for tts-1 or tts-1-hd"
 * Use stream_format: 'audio' for all models
 *
 * API Reference: https://learn.microsoft.com/en-us/azure/ai-foundry/openai/reference-preview-latest#create-speech
 */
async function generateWithAzureGptMiniTTSStream(env, { text, context, voice, speed }) {
  const { url, payload, format, debugLoggingEnabled } = buildTTSRequest(env, { text, context, voice, speed });

  // Add streaming parameter
  payload.stream_format = 'audio'; // Stream raw audio chunks (safer, works with all models)

  if (debugLoggingEnabled) {
    console.log('[TTS Streaming] Request URL:', url);
    console.log('[TTS Streaming] Request payload:', JSON.stringify(payload, null, 2));
  }

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'api-key': env.apiKey,
      'content-type': 'application/json'  // JSON works despite docs saying multipart/form-data
    },
    body: JSON.stringify(payload)
  });

  if (debugLoggingEnabled) {
    console.log('[TTS Streaming] Response status:', response.status, response.statusText);
  }

  if (!response.ok) {
    let errText = '';
    if (debugLoggingEnabled) {
      errText = await response.text().catch(() => '');
    }
    console.error('[TTS Streaming] Azure request failed', response.status, response.statusText);
    if (debugLoggingEnabled && errText) {
      console.error('[TTS Streaming] Error response body:', errText);
    }
    throw new Error(`Azure TTS streaming error ${response.status}`);
  }

  // Return the streaming response directly
  // The response body is a ReadableStream of audio chunks
  const mime = format === 'wav' ? 'audio/wav' : `audio/${format}`;
  return new Response(response.body, {
    headers: {
      'content-type': mime,
      'cache-control': 'no-cache'
    }
  });
}
const DEFAULT_RATE_LIMIT_MAX = 30;
const DEFAULT_RATE_LIMIT_WINDOW_SECONDS = 60;
const TTS_RATE_LIMIT_KEY_PREFIX = 'tts-rate';

async function enforceTtsRateLimit(env, request) {
  try {
    const store = env?.RATELIMIT;
    if (!store) {
      return { limited: false };
    }

    const maxRequests = Number(resolveEnv(env, 'TTS_RATE_LIMIT_MAX')) || DEFAULT_RATE_LIMIT_MAX;
    const windowSeconds = Number(resolveEnv(env, 'TTS_RATE_LIMIT_WINDOW')) || DEFAULT_RATE_LIMIT_WINDOW_SECONDS;
    const now = Date.now();
    const windowBucket = Math.floor(now / (windowSeconds * 1000));
    const clientId = getClientIdentifier(request);
    const rateLimitKey = `${TTS_RATE_LIMIT_KEY_PREFIX}:${clientId}:${windowBucket}`;

    const existing = await store.get(rateLimitKey);
    const currentCount = existing ? Number(existing) || 0 : 0;

    if (currentCount >= maxRequests) {
      const windowBoundary = (windowBucket + 1) * windowSeconds * 1000;
      const retryAfter = Math.max(1, Math.ceil((windowBoundary - now) / 1000));
      return { limited: true, retryAfter };
    }

    await store.put(rateLimitKey, String(currentCount + 1), {
      expirationTtl: windowSeconds
    });

    return { limited: false };
  } catch (error) {
    console.warn('Rate limit check failed, allowing request:', error);
    return { limited: false };
  }
}

function getClientIdentifier(request) {
  const headerCandidates = [
    'cf-connecting-ip',
    'x-forwarded-for',
    'x-real-ip'
  ];

  for (const header of headerCandidates) {
    const value = request.headers.get(header);
    if (value) {
      if (header === 'x-forwarded-for') {
        return value.split(',')[0].trim();
      }
      return value;
    }
  }

  return 'anonymous';
}

function resolveEnv(env, key) {
  if (env && typeof env[key] !== 'undefined' && env[key] !== null) {
    return env[key];
  }

  if (typeof process !== 'undefined' && process.env && typeof process.env[key] !== 'undefined') {
    return process.env[key];
  }

  return undefined;
}

function parseBooleanFlag(value) {
  if (typeof value === 'boolean') {
    return value;
  }

  if (typeof value === 'number') {
    return value !== 0;
  }

  if (typeof value === 'string') {
    const normalized = value.trim().toLowerCase();
    return normalized === 'true' || normalized === '1' || normalized === 'yes';
  }

  return false;
}

function isTtsDebugLoggingEnabled(env) {
  const explicit = resolveEnv(env, 'ENABLE_TTS_DEBUG_LOGGING');
  if (typeof explicit !== 'undefined') {
    return parseBooleanFlag(explicit);
  }

  const nodeEnv = resolveEnv(env, 'NODE_ENV');
  if (nodeEnv && nodeEnv.toLowerCase() !== 'production') {
    return true;
  }

  const mode = resolveEnv(env, 'MODE');
  if (mode && mode.toLowerCase() !== 'production') {
    return true;
  }

  return false;
}
</file>

<file path="functions/api/vision-proof.js">
import { jsonResponse, readJsonBody } from '../lib/utils.js';
import { createVisionBackend } from '../../shared/vision/visionBackends.js';
import { buildVisionProofPayload, signVisionProof } from '../lib/visionProof.js';
import { canonicalizeCardName } from '../../shared/vision/cardNameMapping.js';
import { normalizeVisionLabel } from '../lib/visionLabels.js';

const MAX_EVIDENCE = 5;
const MAX_DATA_URL_BYTES = 8 * 1024 * 1024; // 8MB per upload
const visionBackendCache = new Map();

function clampConfidence(value) {
  if (typeof value !== 'number' || Number.isNaN(value)) return null;
  if (!Number.isFinite(value)) return null;
  if (value < 0) return 0;
  if (value > 1) return 1;
  return value;
}

function sanitizeMatches(matches, deckStyle) {
  if (!Array.isArray(matches)) return [];
  return matches
    .map((match) => {
      const card = canonicalizeCardName(match?.cardName || match?.card, deckStyle);
      const confidence = clampConfidence(match?.score ?? match?.confidence);
      if (!card) return null;
      return {
        card,
        confidence,
        basis: match?.basis || null
      };
    })
    .filter(Boolean)
    .slice(0, 3);
}

function sanitizeAttention(attention) {
  if (!attention || typeof attention !== 'object') return null;
  const gridSize = Number(attention.gridSize) || (Array.isArray(attention.heatmap) ? attention.heatmap.length : null);
  const heatmap = Array.isArray(attention.heatmap)
    ? attention.heatmap.map((row) => (Array.isArray(row) ? row.map((value) => Number(Number(value).toFixed(4))) : []))
    : null;
  const focusRegions = Array.isArray(attention.focusRegions)
    ? attention.focusRegions.slice(0, 8).map((region) => ({
      x: Number(region.x),
      y: Number(region.y),
      intensity: Number(Number(region.intensity).toFixed(4))
    }))
    : null;
  const symbolAlignment = Array.isArray(attention.symbolAlignment)
    ? attention.symbolAlignment.slice(0, 5).map((symbol) => ({
      object: symbol.object,
      position: symbol.position,
      attentionScore: Number(Number(symbol.attentionScore).toFixed(4)),
      isModelFocused: Boolean(symbol.isModelFocused)
    }))
    : null;
  return {
    gridSize,
    heatmap,
    focusRegions,
    symbolAlignment,
    stats: attention.stats || null
  };
}

function sanitizeSymbolVerification(symbolVerification) {
  if (!symbolVerification || typeof symbolVerification !== 'object') {
    return null;
  }

  const matchRate = typeof symbolVerification.matchRate === 'number'
    ? Number(Number(symbolVerification.matchRate).toFixed(4))
    : null;

  const matches = Array.isArray(symbolVerification.matches)
    ? symbolVerification.matches.slice(0, 6).map((match) => ({
      object: match.object,
      expectedPosition: match.expectedPosition || null,
      found: Boolean(match.found),
      confidence: typeof match.confidence === 'number'
        ? Number(Number(match.confidence).toFixed(4))
        : null,
      detectionLabel: match.detectionLabel || null
    }))
    : null;

  const missingSymbols = Array.isArray(symbolVerification.missingSymbols)
    ? symbolVerification.missingSymbols.slice(0, 6)
    : [];

  const unexpectedDetections = Array.isArray(symbolVerification.unexpectedDetections)
    ? symbolVerification.unexpectedDetections.slice(0, 5).map((det) => ({
      label: det.label,
      confidence: typeof det.confidence === 'number'
        ? Number(Number(det.confidence).toFixed(4))
        : null
    }))
    : [];

  return {
    expectedCount: symbolVerification.expectedCount ?? null,
    detectedCount: symbolVerification.detectedCount ?? null,
    matchRate,
    matches,
    missingSymbols,
    unexpectedDetections
  };
}

async function getVisionBackend(deckStyle) {
  if (visionBackendCache.has(deckStyle)) {
    return visionBackendCache.get(deckStyle);
  }
  const backendPromise = (async () => {
    const backend = await createVisionBackend({
      backendId: 'clip-default',
      cardScope: 'all',
      deckStyle,
      maxResults: 5
    });
    await backend.warmup();
    return backend;
  })();
  visionBackendCache.set(deckStyle, backendPromise);
  return backendPromise;
}

function validateEvidence(evidence) {
  if (!Array.isArray(evidence) || evidence.length === 0) {
    throw new Error('Vision proof requires at least one uploaded image.');
  }
  if (evidence.length > MAX_EVIDENCE) {
    throw new Error(`Please limit vision uploads to ${MAX_EVIDENCE} images per request.`);
  }
  return evidence.map((entry, index) => {
    const label = normalizeVisionLabel(entry?.label || `upload-${index + 1}`);
    const dataUrl = entry?.dataUrl;
    if (typeof dataUrl !== 'string' || !dataUrl.startsWith('data:image/')) {
      throw new Error(`Upload ${label} must include a base64 data URL.`);
    }
    if (dataUrl.length > MAX_DATA_URL_BYTES * 1.37) {
      throw new Error(`${label} exceeds the maximum upload size (${MAX_DATA_URL_BYTES} bytes).`);
    }
    return { label, dataUrl };
  });
}

async function analyzeEvidence(evidence, deckStyle) {
  const backend = await getVisionBackend(deckStyle);
  const analyses = await backend.analyzeImages(
    evidence.map((entry) => ({
      source: entry.dataUrl,
      label: entry.label
    })),
    { includeAttention: true, includeSymbols: true }
  );
  return analyses.map((entry) => {
    const predictedCard = canonicalizeCardName(entry.topMatch?.canonicalName || entry.topMatch?.cardName, deckStyle);
    return {
      label: normalizeVisionLabel(entry.label || entry.imagePath),
      predictedCard,
      confidence: clampConfidence(entry.confidence ?? entry.topMatch?.score ?? null),
      basis: entry.topMatch?.basis || null,
      matches: sanitizeMatches(entry.matches, deckStyle),
      attention: sanitizeAttention(entry.attention),
      symbolVerification: sanitizeSymbolVerification(entry.symbolVerification),
      visualProfile: entry.visualProfile || null
    };
  });
}

export async function onRequestPost({ request, env }) {
  try {
    const body = await readJsonBody(request);
    const deckStyle = body?.deckStyle || 'rws-1909';
    const evidence = validateEvidence(body?.evidence);
    const insights = await analyzeEvidence(evidence, deckStyle);

    const payload = buildVisionProofPayload({
      id: crypto.randomUUID ? crypto.randomUUID() : `proof_${Date.now()}`,
      deckStyle,
      insights
    });
    const signature = await signVisionProof(payload, env?.VISION_PROOF_SECRET);

    return jsonResponse({
      proof: {
        ...payload,
        signature
      }
    }, { status: 201 });
  } catch (error) {
    console.error('vision-proof error:', error);
    const status = /size|limit/i.test(error.message) ? 413 : 400;
    return jsonResponse({ error: error.message || 'Vision proof failed.' }, { status });
  }
}

export function onRequestGet() {
  return jsonResponse({ error: 'Not supported.' }, { status: 405 });
}
</file>

<file path="functions/lib/__tests__/knowledgeGraph.test.js">
// functions/lib/__tests__/knowledgeGraph.test.js
// Unit tests for Knowledge Graph pattern detection
// Run with: node --test functions/lib/__tests__/knowledgeGraph.test.js

import { describe, it } from 'node:test';
import assert from 'node:assert';

import {
  detectFoolsJourneyStage,
  detectArchetypalTriads,
  detectArchetypalDyads,
  detectSuitProgressions,
  detectAllPatterns,
  getPriorityPatternNarratives
} from '../knowledgeGraph.js';

describe('detectFoolsJourneyStage', () => {
  it('detects initiation stage (3+ cards from 0-7)', () => {
    const cards = [
      { number: 0, name: 'The Fool' },
      { number: 1, name: 'The Magician' },
      { number: 7, name: 'The Chariot' },
      { number: 5, name: 'The Hierophant' }
    ];
    const result = detectFoolsJourneyStage(cards);

    // Note: The stage property is 'departure' (not 'initiation' which is the key)
    assert.strictEqual(result.stage, 'departure');
    assert.strictEqual(result.cardCount, 4);
    assert.strictEqual(result.significance, 'strong');
  });

  it('detects integration stage (cards 8-14)', () => {
    const cards = [
      { number: 9, name: 'The Hermit' },
      { number: 12, name: 'The Hanged Man' },
      { number: 13, name: 'Death' }
    ];
    const result = detectFoolsJourneyStage(cards);

    // Note: The stage property is 'initiation' (not 'integration' which is the key)
    assert.strictEqual(result.stage, 'initiation');
    assert.strictEqual(result.cardCount, 3);
    assert.strictEqual(result.significance, 'strong');
  });

  it('detects culmination stage (cards 15-21)', () => {
    const cards = [
      { number: 15, name: 'The Devil' },
      { number: 16, name: 'The Tower' },
      { number: 19, name: 'The Sun' },
      { number: 21, name: 'The World' }
    ];
    const result = detectFoolsJourneyStage(cards);

    // Note: The stage property is 'return' (not 'culmination' which is the key)
    assert.strictEqual(result.stage, 'return');
    assert.strictEqual(result.cardCount, 4);
  });

  it('returns minimal significance for single Major Arcana card', () => {
    const cards = [
      { number: 1, name: 'The Magician' },
      { suit: 'Wands', rank: 'Ace' }
    ];
    const result = detectFoolsJourneyStage(cards);

    // Single Major now returns result with 'minimal' significance for basic archetypal context
    assert.strictEqual(result.significance, 'minimal');
    assert.strictEqual(result.cardCount, 1);
    assert.strictEqual(result.totalMajors, 1);
    assert.strictEqual(result.stageKey, 'initiation');
  });

  it('handles mixed stages (returns dominant)', () => {
    const cards = [
      { number: 0, name: 'The Fool' },      // Initiation
      { number: 1, name: 'The Magician' },  // Initiation
      { number: 9, name: 'The Hermit' },    // Integration
      { number: 15, name: 'The Devil' }     // Culmination
    ];
    const result = detectFoolsJourneyStage(cards);

    assert.strictEqual(result.stage, 'departure'); // Dominant stage for 0-7 range
    assert.strictEqual(result.cardCount, 2);
  });

  it('marks 2-card dominant as "moderate" significance', () => {
    const cards = [
      { number: 8, name: 'Strength' },
      { number: 11, name: 'Justice' }
    ];
    const result = detectFoolsJourneyStage(cards);

    assert.strictEqual(result.significance, 'moderate');
  });
});

describe('detectArchetypalTriads', () => {
  it('detects complete Death-Temperance-Star triad', () => {
    const cards = [
      { number: 13, name: 'Death' },
      { number: 14, name: 'Temperance' },
      { number: 17, name: 'The Star' }
    ];
    const result = detectArchetypalTriads(cards);

    assert.strictEqual(result.length, 1);
    assert.strictEqual(result[0].id, 'death-temperance-star');
    assert.strictEqual(result[0].isComplete, true);
    assert.strictEqual(result[0].theme, 'Healing Arc');
    assert.strictEqual(result[0].completeness, 100);
  });

  it('detects complete Devil-Tower-Sun triad', () => {
    const cards = [
      { number: 15, name: 'The Devil' },
      { number: 16, name: 'The Tower' },
      { number: 19, name: 'The Sun' }
    ];
    const result = detectArchetypalTriads(cards);

    assert.strictEqual(result.length, 1);
    assert.strictEqual(result[0].id, 'devil-tower-sun');
    assert.strictEqual(result[0].theme, 'Liberation Arc');
  });

  it('detects partial triads (2 of 3 cards)', () => {
    const cards = [
      { number: 13, name: 'Death' },
      { number: 17, name: 'The Star' }
      // Missing: Temperance (14)
    ];
    const result = detectArchetypalTriads(cards);

    assert.strictEqual(result.length, 1);
    assert.strictEqual(result[0].isComplete, false);
    assert.strictEqual(result[0].completeness, 67); // 2/3 = 66.67% rounded
    assert.strictEqual(result[0].strength, 'supporting');
  });

  it('returns empty array when no triads detected', () => {
    const cards = [
      { number: 0, name: 'The Fool' },
      { number: 4, name: 'The Emperor' },
      { number: 8, name: 'Strength' }
    ];
    const result = detectArchetypalTriads(cards);

    assert.strictEqual(result.length, 0);
  });

  it('detects multiple triads in same spread', () => {
    const cards = [
      { number: 13, name: 'Death' },        // Healing Arc
      { number: 14, name: 'Temperance' },   // Healing Arc
      { number: 17, name: 'The Star' },     // Healing Arc
      { number: 1, name: 'The Magician' },  // Mastery Arc
      { number: 7, name: 'The Chariot' },   // Mastery Arc
      { number: 21, name: 'The World' }     // Mastery Arc (also partial fool-magician-world)
    ];
    const result = detectArchetypalTriads(cards);

    // Expects 3: two complete (Healing + Mastery) plus partial fool-magician-world (1,21)
    assert.strictEqual(result.length, 3);
    assert.strictEqual(result[0].isComplete, true);
    assert.strictEqual(result[1].isComplete, true);
    // Third is the partial fool-magician-world triad (Magician + World)
    const partialTriad = result.find(t => !t.isComplete);
    assert.ok(partialTriad, 'Should find partial fool-magician-world triad');
    assert.strictEqual(partialTriad.id, 'fool-magician-world');
  });

  it('sorts complete triads before partial', () => {
    const cards = [
      { number: 13, name: 'Death' },     // Healing partial (death-star)
      { number: 17, name: 'The Star' },  // Healing partial + tower-star-moon partial
      { number: 15, name: 'The Devil' }, // Liberation complete
      { number: 16, name: 'The Tower' }, // Liberation complete + tower-star-moon partial
      { number: 19, name: 'The Sun' }    // Liberation complete
    ];
    const result = detectArchetypalTriads(cards);

    // Expects 3: one complete (Liberation) + two partials (death-star, tower-star)
    assert.strictEqual(result.length, 3);
    assert.strictEqual(result[0].isComplete, true);  // Complete first
    assert.strictEqual(result[1].isComplete, false); // Partial second
    assert.strictEqual(result[2].isComplete, false); // Partial third
  });
});

describe('detectArchetypalDyads', () => {
  it('detects Death + Star dyad', () => {
    const cards = [
      { number: 13, name: 'Death' },
      { number: 17, name: 'The Star' }
    ];
    const result = detectArchetypalDyads(cards);

    assert.strictEqual(result.length, 1);
    assert.deepStrictEqual(result[0].cards, [13, 17]);
    assert.strictEqual(result[0].theme, 'Transformation clearing into hope');
    assert.strictEqual(result[0].significance, 'high');
  });

  it('detects Fool + Magician dyad', () => {
    const cards = [
      { number: 0, name: 'The Fool' },
      { number: 1, name: 'The Magician' }
    ];
    const result = detectArchetypalDyads(cards);

    assert.strictEqual(result.length, 1);
    assert.strictEqual(result[0].category, 'empowerment');
  });

  it('returns empty array when no dyads detected', () => {
    const cards = [
      { number: 4, name: 'The Emperor' },
      { number: 8, name: 'Strength' }
    ];
    const result = detectArchetypalDyads(cards);

    assert.strictEqual(result.length, 0);
  });

  it('detects multiple dyads and sorts by significance', () => {
    const cards = [
      { number: 0, name: 'The Fool' },        // Fool+Magician (high)
      { number: 1, name: 'The Magician' },    // Fool+Magician (high)
      { number: 8, name: 'Strength' },        // Strength+Justice (medium)
      { number: 11, name: 'Justice' }         // Strength+Justice (medium)
    ];
    const result = detectArchetypalDyads(cards);

    assert.strictEqual(result.length, 2);
    assert.strictEqual(result[0].significance, 'high');    // High first
    assert.strictEqual(result[1].significance, 'medium');  // Medium second
  });

  it('returns null when <2 Major Arcana', () => {
    const cards = [
      { number: 1, name: 'The Magician' },
      { suit: 'Cups', rank: 'Ace' }
    ];
    const result = detectArchetypalDyads(cards);

    assert.strictEqual(result.length, 0);
  });
});

describe('detectSuitProgressions', () => {
  it('detects strong Wands ignition progression', () => {
    const cards = [
      { card: 'Ace of Wands', suit: 'Wands', rank: 'Ace', rankValue: 1 },
      { card: 'Two of Wands', suit: 'Wands', rank: 'Two', rankValue: 2 },
      { card: 'Three of Wands', suit: 'Wands', rank: 'Three', rankValue: 3 }
    ];

    const result = detectSuitProgressions(cards);

    assert.strictEqual(result.length, 1);
    assert.strictEqual(result[0].suit, 'Wands');
    assert.strictEqual(result[0].stage, 'beginning');
    assert.strictEqual(result[0].significance, 'strong-progression');
  });

  it('detects emerging Cups mastery progression with 2 cards', () => {
    const cards = [
      { card: 'Nine of Cups', suit: 'Cups', rank: 'Nine', rankValue: 9 },
      { card: 'Ten of Cups', suit: 'Cups', rank: 'Ten', rankValue: 10 },
      { number: 0, name: 'The Fool' }
    ];

    const result = detectSuitProgressions(cards);

    assert.strictEqual(result.length, 1);
    assert.strictEqual(result[0].stage, 'mastery');
    assert.strictEqual(result[0].significance, 'emerging-progression');
  });

  it('returns empty array when suit metadata missing', () => {
    const cards = [
      { number: 13, name: 'Death' },
      { card: 'Page of Pentacles', suit: 'Pentacles', rank: 'Page', rankValue: 11 }
    ];

    const result = detectSuitProgressions(cards);
    assert.strictEqual(result.length, 0);
  });
});

describe('detectAllPatterns', () => {
  it('detects all pattern types when present', () => {
    const cards = [
      { number: 0, name: 'The Fool' },      // Journey: initiation, Dyad: Fool+Magician, Partial: fool-magician-world
      { number: 1, name: 'The Magician' },  // Journey: initiation, Dyad: Fool+Magician, Partial Triad: Mastery Arc + fool-magician-world
      { number: 7, name: 'The Chariot' },   // Journey: initiation, Partial Triad: Mastery Arc
      { number: 13, name: 'Death' },        // Triad: Healing Arc, Dyad: Death+Star
      { number: 14, name: 'Temperance' },   // Triad: Healing Arc
      { number: 17, name: 'The Star' },     // Triad: Healing Arc, Dyad: Death+Star
      { card: 'Ace of Wands', suit: 'Wands', rank: 'Ace', rankValue: 1 },
      { card: 'Two of Wands', suit: 'Wands', rank: 'Two', rankValue: 2 }
    ];
    const result = detectAllPatterns(cards);

    assert.ok(result.foolsJourney);
    assert.ok(result.triads);
    assert.ok(result.dyads);
    assert.ok(result.suitProgressions);
    assert.strictEqual(result.foolsJourney.stage, 'departure'); // Stage value for 0-7 range
    // 3 triads: Healing Arc (complete) + Mastery Arc partial (1,7) + fool-magician-world partial (0,1)
    assert.strictEqual(result.triads.length, 3);
    assert.strictEqual(result.dyads.length, 2); // Fool+Magician + Death+Star
    assert.strictEqual(result.suitProgressions.length, 1);
  });

  it('detects court lineages with deck-aware suit aliases', () => {
    const cards = [
      { card: 'Page of Wands', suit: 'Wands', rank: 'Page', rankValue: 11 },
      { card: 'Knight of Wands', suit: 'Wands', rank: 'Knight', rankValue: 12 },
      { card: 'Queen of Wands', suit: 'Wands', rank: 'Queen', rankValue: 13 }
    ];
    const result = detectAllPatterns(cards, { deckStyle: 'marseille-classic' });

    assert.ok(result);
    assert.ok(result.courtLineages);
    assert.strictEqual(result.courtLineages[0].displaySuit, 'Batons');
    assert.strictEqual(result.courtLineages[0].significance, 'council');
  });

  it('returns null when no patterns detected', () => {
    const cards = [
      { suit: 'Wands', rank: 'Ace' },
      { suit: 'Cups', rank: 'Two' }
    ];
    const result = detectAllPatterns(cards);

    assert.strictEqual(result, null);
  });

  it('handles empty or invalid input gracefully', () => {
    assert.strictEqual(detectAllPatterns([]), null);
    assert.strictEqual(detectAllPatterns(null), null);
    assert.strictEqual(detectAllPatterns(undefined), null);
  });

  it('continues if one detector fails', () => {
    // This test validates graceful degradation
    // Even if one detection function throws, others should still run
    const cards = [
      { number: 13, name: 'Death' },
      { number: 14, name: 'Temperance' },
      { number: 17, name: 'The Star' }
    ];
    const result = detectAllPatterns(cards);

    // Should detect triads regardless of other detectors
    assert.ok(result.triads);
  });
});

describe('getPriorityPatternNarratives', () => {
  it('prioritizes complete triads first', () => {
    const patterns = {
      triads: [
        {
          id: 'death-temperance-star',
          theme: 'Healing Arc',
          isComplete: true,
          matchedNames: ['Death', 'Temperance', 'The Star'],
          matchedCards: [13, 14, 17],
          narrative: 'Ending → Integration → Renewal'
        }
      ],
      dyads: [
        {
          cards: [0, 1],
          names: ['The Fool', 'The Magician'],
          narrative: 'Fresh vision with tools to manifest',
          significance: 'high'
        }
      ]
    };

    const result = getPriorityPatternNarratives(patterns);

    assert.ok(result.length > 0);
    assert.strictEqual(result[0].priority, 1);
    assert.strictEqual(result[0].type, 'complete-triad');
  });

  it('includes strong Fool\'s Journey at priority 2', () => {
    const patterns = {
      foolsJourney: {
        stage: 'integration',
        cardCount: 4,
        significance: 'strong',
        readingSignificance: 'shadow work and transformation',
        cards: [
          { number: 9 }, { number: 12 }, { number: 13 }, { number: 14 }
        ]
      }
    };

    const result = getPriorityPatternNarratives(patterns);

    assert.ok(result.length > 0);
    assert.strictEqual(result[0].priority, 2);
    assert.strictEqual(result[0].type, 'fools-journey');
  });

  it('surfaces strong suit progression at priority 3', () => {
    const patterns = {
      triads: [
        {
          id: 'triad1',
          theme: 'Arc',
          isComplete: true,
          matchedNames: ['Death', 'Temperance', 'The Star'],
          matchedCards: [13, 14, 17],
          narrative: 'Healing arc'
        }
      ],
      suitProgressions: [
        {
          suit: 'Wands',
          stage: 'beginning',
          theme: 'Ignition',
          readingSignificance: 'Ignition phase energy.',
          narrative: 'Ace → Two → Three',
          stageCards: [
            { card: 'Ace of Wands', rankValue: 1 },
            { card: 'Two of Wands', rankValue: 2 },
            { card: 'Three of Wands', rankValue: 3 }
          ],
          stageCardCount: 3,
          significance: 'strong-progression'
        }
      ],
      dyads: [
        {
          cards: [0, 1],
          names: ['The Fool', 'The Magician'],
          narrative: 'Fresh potential meets skill',
          significance: 'high',
          category: 'empowerment'
        }
      ]
    };

    const result = getPriorityPatternNarratives(patterns);

    assert.ok(result.length >= 2);
    assert.strictEqual(result[1].type, 'suit-progression');
    assert.strictEqual(result[1].priority, 3);
  });

  it('includes court lineage highlights with deck-aware naming', () => {
    const cards = [
      { card: 'Page of Wands', suit: 'Wands', rank: 'Page', rankValue: 11 },
      { card: 'Knight of Wands', suit: 'Wands', rank: 'Knight', rankValue: 12 }
    ];
    const patterns = detectAllPatterns(cards, { deckStyle: 'thoth-a1' });
    const result = getPriorityPatternNarratives(patterns, 'thoth-a1');

    const lineage = result.find((entry) => entry.type === 'court-lineage');
    assert.ok(lineage, 'Expected a court-lineage narrative');
    assert.match(lineage.text, /Princess of Wands/);
  });

  it('limits output to maximum 5 patterns', () => {
    const patterns = {
      triads: [
        // 3 complete triads
        { id: 'triad1', isComplete: true, theme: 'Arc 1', matchedNames: ['A', 'B', 'C'], matchedCards: [1, 2, 3], narrative: 'test' },
        { id: 'triad2', isComplete: true, theme: 'Arc 2', matchedNames: ['D', 'E', 'F'], matchedCards: [4, 5, 6], narrative: 'test' },
        { id: 'triad3', isComplete: true, theme: 'Arc 3', matchedNames: ['G', 'H', 'I'], matchedCards: [7, 8, 9], narrative: 'test' }
      ],
      foolsJourney: {
        stage: 'initiation',
        cardCount: 3,
        significance: 'strong',
        readingSignificance: 'building',
        cards: [{ number: 0 }, { number: 1 }, { number: 2 }]
      },
      dyads: [
        { cards: [10, 11], names: ['X', 'Y'], narrative: 'test', significance: 'high', category: 'test' },
        { cards: [12, 13], names: ['W', 'Z'], narrative: 'test', significance: 'high', category: 'test' }
      ]
    };

    const result = getPriorityPatternNarratives(patterns);

    assert.ok(result.length <= 5);
  });

  it('returns empty array when no patterns provided', () => {
    const result = getPriorityPatternNarratives(null);

    assert.strictEqual(result.length, 0);
  });

  it('includes moderate Fool\'s Journey at priority 4', () => {
    const patterns = {
      foolsJourney: {
        stage: 'initiation',
        cardCount: 2,
        significance: 'moderate',
        readingSignificance: 'building',
        displayNames: ['The Fool', 'The Magician'],
        cards: [{ number: 0 }, { number: 1 }]
      }
    };

    const result = getPriorityPatternNarratives(patterns);

    // Moderate journey now included at priority 4
    assert.strictEqual(result.length, 1);
    assert.strictEqual(result[0].priority, 4);
    assert.strictEqual(result[0].type, 'fools-journey');
  });
});
</file>

<file path="functions/lib/__tests__/spreadAnalysis.test.js">
import { describe, it } from 'node:test';
import assert from 'node:assert/strict';
import { REVERSAL_FRAMEWORKS, selectReversalFramework } from '../spreadAnalysis.js';

describe('Reversal Frameworks', () => {
  it('should have all expected frameworks defined', () => {
    const expectedKeys = [
      'none',
      'blocked',
      'delayed',
      'internalized',
      'contextual',
      'shadow',
      'mirror',
      'potentialBlocked'
    ];

    expectedKeys.forEach(key => {
      const framework = REVERSAL_FRAMEWORKS[key];
      assert.ok(framework, `Framework ${key} is missing`);
      assert.ok(framework.name, `Framework ${key} needs a name`);
      assert.ok(framework.description, `Framework ${key} needs a description`);
      assert.ok(framework.guidance, `Framework ${key} needs guidance text`);
    });
  });

  it('shadow framework should have examples for key cards', () => {
    const shadow = REVERSAL_FRAMEWORKS.shadow;
    assert.ok(shadow.examples['The Moon']);
    assert.ok(shadow.examples['The Tower']);
  });
});

describe('selectReversalFramework', () => {
  it('detects shadow intent from question keywords', () => {
    const result = selectReversalFramework(0.3, [], {
      userQuestion: 'What am I afraid to face?'
    });
    assert.strictEqual(result, 'shadow');
  });

  it('detects mirror intent from question keywords', () => {
    const result = selectReversalFramework(0.3, [], {
      userQuestion: 'Why do I keep attracting the same patterns?'
    });
    assert.strictEqual(result, 'mirror');
  });

  it('detects potential-blocked when 2+ Major Arcana are reversed', () => {
    const cardsInfo = [
      { number: 1, orientation: 'Reversed' },
      { number: 17, orientation: 'Reversed' },
      { number: 5, orientation: 'Upright' }
    ];
    const result = selectReversalFramework(0.4, cardsInfo, {});
    assert.strictEqual(result, 'potentialBlocked');
  });
});
</file>

<file path="functions/lib/__tests__/telemetry.test.js">
// functions/lib/__tests__/telemetry.test.js
// Tests for telemetry summaries, prompt budgeting, reversal formatting, and context diagnostics.

import { describe, it, afterEach, mock } from 'node:test';
import assert from 'node:assert/strict';

import { summarizeNarrativeEnhancements } from '../../api/tarot-reading.js';
import { buildEnhancedClaudePrompt } from '../narrative/prompts.js';
import { formatReversalLens, normalizeContext } from '../narrative/helpers.js';
import * as graphRAG from '../graphRAG.js';

const ORIGINAL_ENV = { ...process.env };

afterEach(() => {
  // Restore env between tests to avoid cross-test coupling
  Object.keys(process.env).forEach((key) => {
    if (!(key in ORIGINAL_ENV)) {
      delete process.env[key];
    }
  });
  Object.entries(ORIGINAL_ENV).forEach(([key, value]) => {
    process.env[key] = value;
  });
});

describe('enhancement telemetry summary', () => {
  it('captures counts, names, and missing keys', () => {
    const sections = [
      {
        text: 'Opening section',
        metadata: { type: 'opening', name: 'Opening' },
        validation: {
          enhanced: true,
          enhancements: ['Added card identification'],
          missing: ['why'],
          present: { what: true }
        }
      },
      {
        text: 'Guidance body',
        metadata: { type: 'guidance' },
        validation: {
          enhanced: false,
          enhancements: [],
          missing: [],
          present: { what: true, why: true, whatsNext: true }
        }
      }
    ];

    const summary = summarizeNarrativeEnhancements(sections);

    assert.equal(summary.totalSections, 2);
    assert.equal(summary.enhancedSections, 1);
    assert.deepEqual(summary.sectionNames, ['Opening', 'guidance']);
    assert.equal(summary.enhancementCounts['Added card identification'], 1);
    assert.equal(summary.missingCounts.why, 1);
  });
});

describe('prompt slimming respects budget order', () => {
  it('applies slimming steps when token budget is exceeded', () => {
    process.env.PROMPT_BUDGET_CLAUDE = '40';

    const spreadInfo = { name: 'Three-Card Story (Past · Present · Future)' };
    const cardsInfo = [
      { card: 'The Fool', position: 'Past', number: 0, orientation: 'Upright', meaning: 'A long wandering path.' },
      { card: 'The Magician', position: 'Present', number: 1, orientation: 'Upright', meaning: 'Manifesting resources and skill.' },
      { card: 'The High Priestess', position: 'Future', number: 2, orientation: 'Reversed', meaning: 'Trust inner knowing and mystery.' }
    ];

    const themes = {
      reversalCount: 1,
      reversalDescription: {
        name: 'Blocked Energy',
        description: 'Reversals show resistance.',
        guidance: 'Name the block, then describe how to clear or integrate it.'
      },
      knowledgeGraph: {},
      suitCounts: {},
      elementCounts: {}
    };

    const { promptMeta } = buildEnhancedClaudePrompt({
      spreadInfo,
      cardsInfo,
      userQuestion: 'How do I navigate this massive life transition? '.repeat(8),
      reflectionsText: '',
      themes,
      spreadAnalysis: null,
      context: 'career',
      visionInsights: [],
      deckStyle: 'rws-1909'
    });

    assert.ok(promptMeta.estimatedTokens.total > promptMeta.estimatedTokens.budget);
    assert.deepEqual(promptMeta.slimmingSteps, [
      'drop-low-weight-imagery',
      'drop-graphrag-block',
      'drop-deck-geometry',
      'drop-diagnostics'
    ]);
    assert.equal(promptMeta.appliedOptions.includeGraphRAG, false);
  });
});

describe('reversal formatter', () => {
  it('produces cached, multi-line reversal description', () => {
    const themes = {
      reversalCount: 2,
      reversalDescription: {
        name: 'Internalized Energy',
        description: 'Energy moves inward before it emerges.',
        guidance: 'Invite reflection and integration before action.',
        examples: { 'The Sun': 'Joy cultivated privately first.' }
      }
    };

    const formatted = formatReversalLens(themes, { includeExamples: true, includeReminder: true });

    assert.ok(formatted.lines.some((line) => line.includes('Reversal lens')));
    assert.ok(formatted.lines.some((line) => line.includes('Guidance')));
    assert.ok(formatted.lines.some((line) => line.includes('Example applications')));

    // Should cache on the description object
    assert.ok(themes.reversalDescription.formattedLens);
  });
});

describe('context diagnostics propagation', () => {
  it('pushes unknown context warnings into diagnostics array', () => {
    const diagnostics = [];
    const themes = {
      reversalCount: 0,
      reversalDescription: {
        name: 'All Upright',
        description: 'No reversals present.',
        guidance: 'Read cards in their upright flow.'
      },
      knowledgeGraph: {},
      suitCounts: {},
      elementCounts: {}
    };

    const { contextDiagnostics } = buildEnhancedClaudePrompt({
      spreadInfo: { name: 'One-Card Insight' },
      cardsInfo: [
        { card: 'The Star', position: 'Theme', number: 17, orientation: 'Upright', meaning: 'Hope and healing.' }
      ],
      userQuestion: 'What should I know?',
      reflectionsText: '',
      themes,
      spreadAnalysis: null,
      context: 'mystery-context',
      visionInsights: [],
      deckStyle: 'rws-1909',
      contextDiagnostics: diagnostics
    });

    assert.equal(diagnostics.length, 1);
    assert.equal(contextDiagnostics.length, 1);
    assert.match(contextDiagnostics[0], /Unknown context/);

    const normalized = normalizeContext('mystery-context', {
      onUnknown: (msg) => diagnostics.push(msg)
    });
    assert.equal(normalized, 'general');
  });
});

describe('prompt builder resilience', () => {
  it('handles missing themes and sanitizes long reflections', () => {
    const reflectionsText = '# Heading\n' + 'This is a very long reflection '.repeat(50);

    const { userPrompt } = buildEnhancedClaudePrompt({
      spreadInfo: { name: 'One-Card Insight' },
      cardsInfo: [
        { card: 'The Hermit', position: 'Theme / Guidance of the Moment', number: 9, orientation: 'Upright', meaning: 'Inner guidance and solitude.' }
      ],
      userQuestion: '',
      reflectionsText,
      themes: null,
      spreadAnalysis: null,
      context: 'self',
      visionInsights: [],
      deckStyle: 'rws-1909'
    });

    const match = userPrompt.match(/\*\*Querent's Reflections\*\*:\n([\s\S]+?)\n\n/);
    assert.ok(match, 'Reflections block should be present when provided');
    const sanitized = match[1];
    assert.ok(!sanitized.includes('#'), 'Sanitized reflections should strip markdown headings');
    assert.ok(sanitized.length <= 620, 'Sanitized reflections should be truncated to a safe length');
  });

  it('reuses GraphRAG payload across slimming passes', () => {
    process.env.PROMPT_BUDGET_CLAUDE = '40';
    process.env.GRAPHRAG_ENABLED = 'true';

    const tracker = mock.method(graphRAG, 'retrievePassages', () => ([
      { title: 'Triad Wisdom', text: 'Insight about the Fool’s Journey.', source: 'Arcana Anthology', priority: 1, type: 'triad' }
    ]));

    try {
      const themes = {
        reversalCount: 0,
        reversalDescription: {
          name: 'Upright Focus',
          description: 'No reversals detected.',
          guidance: 'Refer to upright meanings unless a reversed card appears.'
        },
        knowledgeGraph: {
          graphKeys: {
            completeTriadIds: ['fool-magician-highpriestess']
          }
        },
        suitCounts: {},
        elementCounts: {}
      };

      buildEnhancedClaudePrompt({
        spreadInfo: { name: 'Three-Card Story (Past · Present · Future)' },
        cardsInfo: [
          { card: 'The Fool', position: 'Past', number: 0, orientation: 'Upright', meaning: 'Leap of faith.' },
          { card: 'The Magician', position: 'Present', number: 1, orientation: 'Upright', meaning: 'Channel skills.' },
          { card: 'The High Priestess', position: 'Future', number: 2, orientation: 'Reversed', meaning: 'Inner knowing.' }
        ],
        userQuestion: 'How do I integrate this chapter? '.repeat(6),
        reflectionsText: '',
        themes,
        spreadAnalysis: null,
        context: 'self',
        visionInsights: [],
        deckStyle: 'rws-1909'
      });

      assert.equal(tracker.mock.calls.length, 1, 'GraphRAG retrieval should execute only once despite slimming');
    } finally {
      tracker.restore();
    }
  });
});
</file>

<file path="functions/lib/narrative/spreads/celticCross.js">
import { enhanceSection, validateReadingNarrative } from '../../narrativeSpine.js';
import { sortCardsByImportance, getPositionWeight } from '../../positionWeights.js';
import {
  appendReversalReminder,
  buildOpening,
  buildPositionCardText,
  buildWeightAttentionIntro,
  buildSupportingPositionsSummary,
  buildWeightNote,
  getPositionOptions,
  buildReflectionsSection,
  buildPatternSynthesis,
  getConnector,
  shouldEmphasizePosition,
  formatCrossCheck,
  getContextDescriptor,
  DEFAULT_WEIGHT_DETAIL_THRESHOLD,
  computeRemedyRotationIndex
} from '../helpers.js';
import { buildPersonalizedClosing } from '../styleHelpers.js';

export async function buildCelticCrossReading({
  cardsInfo,
  userQuestion,
  reflectionsText,
  celticAnalysis,
  themes,
  context,
  spreadInfo
}, options = {}) {
  const prioritized = sortCardsByImportance(cardsInfo, 'celtic');
  const sections = [];
  const personalization = options.personalization || null;
  const collectValidation = typeof options.collectValidation === 'function' ? options.collectValidation : null;
  const remedyRotationIndex = computeRemedyRotationIndex({ cardsInfo, userQuestion, spreadInfo });

  const recordEnhancedSection = (sectionText, metadata = {}) => {
    const result = enhanceSection(sectionText, metadata);
    if (collectValidation) {
      collectValidation({
        text: result.text,
        metadata,
        validation: result.validation || null
      });
    }
    sections.push(result.text);
  };

  // Opening
  sections.push(
    buildOpening(
      'Celtic Cross (Classic 10-Card)',
      userQuestion,
      context,
      { personalization: options.personalization }
    )
  );

  const attentionNote = buildWeightAttentionIntro(prioritized, 'Celtic Cross');
  if (attentionNote) {
    sections.push(attentionNote);
  }

  // 1. NUCLEUS - The Heart of the Matter (Cards 1-2)
  recordEnhancedSection(
    buildNucleusSection(celticAnalysis.nucleus, cardsInfo, themes, context),
    {
      type: 'nucleus',
      cards: [cardsInfo[0], cardsInfo[1]],
      relationships: { elementalRelationship: celticAnalysis.nucleus.elementalDynamic }
    }
  );

  // 2. TIMELINE - Past, Present, Future (Cards 3-1-4)
  recordEnhancedSection(
    buildTimelineSection(celticAnalysis.timeline, cardsInfo, themes, context),
    { type: 'timeline' }
  );

  // 3. CONSCIOUSNESS - Subconscious, Center, Conscious (Cards 6-1-5)
  recordEnhancedSection(
    buildConsciousnessSection(celticAnalysis.consciousness, cardsInfo, themes, context),
    { type: 'consciousness' }
  );

  // 4. STAFF - Self, External, Hopes/Fears, Outcome (Cards 7-10)
  recordEnhancedSection(
    buildStaffSection(celticAnalysis.staff, cardsInfo, themes, context),
    { type: 'staff' }
  );

  // 5. CROSS-CHECKS - Key position comparisons
  recordEnhancedSection(
    buildCrossChecksSection(celticAnalysis.crossChecks, themes),
    { type: 'relationships' }
  );

  // 6. User Reflections
  if (reflectionsText && reflectionsText.trim()) {
    sections.push(buildReflectionsSection(reflectionsText));
  }

  const patternSection = buildPatternSynthesis(themes);
  if (patternSection) {
    sections.push(patternSection);
  }

  // 7. SYNTHESIS - Actionable integration
  recordEnhancedSection(
    await buildSynthesisSection(cardsInfo, themes, celticAnalysis, userQuestion, context, remedyRotationIndex),
    { type: 'outcome' }
  );

  const supportingSummary = buildSupportingPositionsSummary(prioritized, 'Celtic Cross');
  if (supportingSummary) {
    sections.push(supportingSummary);
  }

  // Final validation log (non-blocking)
  const readingBody = sections.filter(Boolean).join('\n\n');
  const validation = validateReadingNarrative(readingBody);
  if (!validation.isValid) {
    console.debug('Celtic Cross narrative spine suggestions:', validation.suggestions || validation.sectionAnalyses);
  }

  const closing = buildPersonalizedClosing(personalization);
  const narrative = closing ? `${readingBody}\n\n${closing}` : readingBody;
  return appendReversalReminder(narrative, cardsInfo, themes);
}



function buildNucleusSection(nucleus, cardsInfo, themes, context) {
  const present = cardsInfo[0];
  const challenge = cardsInfo[1];

  let section = `### The Heart of the Matter (Nucleus)\n\n`;

  const presentPosition = present.position || 'Present — core situation (Card 1)';
  const challengePosition = challenge.position || 'Challenge — crossing / tension (Card 2)';

  section += `${buildPositionCardText(present, presentPosition, getPositionOptions(themes, context))}\n\n`;
  section += `${buildPositionCardText(challenge, challengePosition, getPositionOptions(themes, context))}\n\n`;

  section += nucleus.synthesis;

  const emphasisNotes = [
    buildWeightNote('celtic', 0, presentPosition),
    buildWeightNote('celtic', 1, challengePosition)
  ].filter(Boolean);

  if (emphasisNotes.length > 0) {
    section += `\n\n${emphasisNotes.join('\n\n')}`;
  }

  return section;
}

function buildTimelineSection(timeline, cardsInfo, themes, context) {
  const past = cardsInfo[2];
  const present = cardsInfo[0];
  const future = cardsInfo[3];

  let section = `### The Timeline (Horizontal Axis)\n\n`;

  const options = getPositionOptions(themes, context);
  const pastPosition = past.position || 'Past — what lies behind (Card 3)';
  const presentPosition = present.position || 'Present — core situation (Card 1)';
  const futurePosition = future.position || 'Near Future — what lies before (Card 4)';

  // Past card
  section += `${buildPositionCardText(past, pastPosition, options)}\n\n`;

  // Present card with connector and elemental imagery
  const pastToPresent = timeline.pastToPresent;
  const presentConnector = getConnector(presentPosition, 'toPrev');
  section += `${presentConnector} ${buildPositionCardText(present, presentPosition, {
    ...options,
    prevElementalRelationship: pastToPresent
  })}\n\n`;

  // Future card with connector and elemental imagery
  const presentToFuture = timeline.presentToFuture;
  const futureConnector = getConnector(futurePosition, 'toPrev');
  section += `${futureConnector} ${buildPositionCardText(future, futurePosition, {
    ...options,
    prevElementalRelationship: presentToFuture
  })}\n\n`;

  section += timeline.causality;

  const timelineWeightNotes = [
    buildWeightNote('celtic', 0, presentPosition),
    buildWeightNote('celtic', 3, futurePosition)
  ].filter(Boolean);

  if (timelineWeightNotes.length > 0) {
    section += `\n\n${timelineWeightNotes.join(' ')}`;
  }

  return section;
}

function buildConsciousnessSection(consciousness, cardsInfo, themes, context) {
  const subconscious = cardsInfo[5];
  const conscious = cardsInfo[4];

  let section = `### Consciousness Flow (Vertical Axis)\n\n`;

  const subconsciousPosition = subconscious.position || 'Subconscious — roots / hidden forces (Card 6)';
  const consciousPosition = conscious.position || 'Conscious — goals & focus (Card 5)';

  section += `${buildPositionCardText(subconscious, subconsciousPosition, getPositionOptions(themes, context))}\n\n`;
  section += `${buildPositionCardText(conscious, consciousPosition, getPositionOptions(themes, context))}\n\n`;

  section += consciousness.synthesis;

  if (consciousness.alignment === 'conflicted') {
    section += `\n\n*This misalignment suggests inner work is needed to bring your depths and aspirations into harmony.*`;
  } else if (consciousness.alignment === 'aligned') {
    section += `\n\n*This alignment is a source of power—your whole being is moving in one direction.*`;
  }

  const consciousnessWeightNotes = [
    buildWeightNote('celtic', 5, subconsciousPosition),
    buildWeightNote('celtic', 4, consciousPosition)
  ].filter(Boolean);

  if (consciousnessWeightNotes.length > 0) {
    section += `\n\n${consciousnessWeightNotes.join(' ')}`;
  }

  return section;
}

function buildStaffSection(staff, cardsInfo, themes, context) {
  const self = cardsInfo[6];
  const external = cardsInfo[7];
  const hopesFears = cardsInfo[8];
  const outcome = cardsInfo[9];

  let section = `### The Staff (Context & Trajectory)\n\n`;

  const selfPosition = self.position || 'Self / Advice — how to meet this (Card 7)';
  const externalPosition = external.position || 'External Influences — people & environment (Card 8)';
  const hopesFearsPosition = hopesFears.position || 'Hopes & Fears — deepest wishes & worries (Card 9)';
  const outcomePosition = outcome.position || 'Outcome — likely path if unchanged (Card 10)';

  section += `${buildPositionCardText(self, selfPosition, getPositionOptions(themes, context))}\n\n`;
  section += `${buildPositionCardText(external, externalPosition, getPositionOptions(themes, context))}\n\n`;
  section += `${buildPositionCardText(hopesFears, hopesFearsPosition, getPositionOptions(themes, context))}\n\n`;
  section += `${buildPositionCardText(outcome, outcomePosition, getPositionOptions(themes, context))}\n\n`;

  section += staff.adviceImpact;

  const staffWeightNotes = [
    buildWeightNote('celtic', 6, selfPosition),
    buildWeightNote('celtic', 7, externalPosition),
    buildWeightNote('celtic', 8, hopesFearsPosition),
    buildWeightNote('celtic', 9, outcomePosition)
  ].filter(Boolean);

  if (staffWeightNotes.length > 0) {
    section += `\n\n${staffWeightNotes.join(' ')}`;
  }

  if (shouldEmphasizePosition('celtic', 6) || shouldEmphasizePosition('celtic', 9)) {
    section += `\n\n*Extended staff detail appears because the Advice/Outcome axis carries concentrated weighting.*`;
  }

  return section;
}

function buildCrossChecksSection(crossChecks, themes) {
  let section = `### Key Relationships\n\n`;

  section += 'This overview shows how core positions interact and compare.\n\n';

  section += formatCrossCheck('Conscious Goal vs Outcome', crossChecks.goalVsOutcome, themes);
  section += `\n\n${formatCrossCheck('Advice vs Outcome', crossChecks.adviceVsOutcome, themes)}`;
  section += `\n\n${formatCrossCheck('Near Future vs Outcome', crossChecks.nearFutureVsOutcome, themes)}`;
  section += `\n\n${formatCrossCheck('Subconscious vs Hopes & Fears', crossChecks.subconsciousVsHopesFears, themes)}`;

  section += '\n\nTaken together, these cross-checks point toward how to translate the spread\'s insights into your next aligned step.';

  return section;
}

/**
 * Generate synthesis prose from cross-check structured data
 */



async function buildSynthesisSection(cardsInfo, themes, celticAnalysis, userQuestion, context, rotationIndex = 0) {
  let section = `### Synthesis & Guidance\n\n`;

  section += 'This synthesis shows how the spread integrates into actionable guidance.\n\n';

  if (context && context !== 'general') {
    section += `Focus: Interpreting this guidance through ${getContextDescriptor(context)}.\n\n`;
  }

  // Thematic summary
  if (themes.suitFocus) {
    section += `${themes.suitFocus}\n\n`;
  }

  if (themes.archetypeDescription) {
    section += `${themes.archetypeDescription}\n\n`;
  }

  if (themes.elementalBalance) {
    section += `Elemental context: ${themes.elementalBalance}\n\n`;

    // Elemental remedies if imbalanced
    if (themes.elementCounts) {
      try {
        const { buildElementalRemedies, shouldOfferElementalRemedies } = await import('../helpers.js');
        if (shouldOfferElementalRemedies(themes.elementCounts, cardsInfo.length)) {
          const remedies = buildElementalRemedies(themes.elementCounts, cardsInfo.length, context, {
            rotationIndex
          });
          if (remedies) {
            section += `${remedies}\n\n`;
          }
        }
      } catch (err) {
        console.error('[Celtic Cross] Elemental remedies unavailable:', err.message);
      }
    }
  }

  // Timing profile (if available)
  if (themes.timingProfile === 'near-term-tilt') {
    section += `Pace: These dynamics are poised to move in the nearer term if you act on them.\n\n`;
  } else if (themes.timingProfile === 'longer-arc-tilt') {
    section += `Pace: This pattern points to a longer, structural shift that unfolds over time.\n\n`;
  } else if (themes.timingProfile === 'developing-arc') {
    section += `Pace: This reads as an unfolding chapter that rewards consistent, conscious engagement.\n\n`;
  }

  const options = getPositionOptions(themes, context);
  const advice = cardsInfo[6];
  const outcome = cardsInfo[9];
  const adviceWeight = getPositionWeight('celtic', 6);
  const outcomeWeight = getPositionWeight('celtic', 9);

  section += `**Your next step**\n`;
  section += `This step shows where to focus your agency right now.\n`;
  section += `${buildPositionCardText(advice, advice.position || 'Self / Advice — how to meet this (Card 7)', options)}\n`;
  section += `${celticAnalysis.staff.adviceImpact}\n\n`;

  if (adviceWeight >= DEFAULT_WEIGHT_DETAIL_THRESHOLD) {
    section += `*This Advice position sits at weight ${adviceWeight.toFixed(2)}, so it receives extended guidance above.*\n\n`;
  }

  section += `**Trajectory Reminder**\n${buildPositionCardText(outcome, outcome.position || 'Outcome — likely path if unchanged (Card 10)', options)}\n`;
  section += `Remember: The outcome shown by ${outcome.card} is a trajectory based on current patterns. Your choices, consciousness, and actions shape what unfolds. You are co-creating this path.`;

  if (outcomeWeight >= DEFAULT_WEIGHT_DETAIL_THRESHOLD) {
    section += `\n\n*Outcome receives extra attention because its weight clocks in at ${outcomeWeight.toFixed(2)}.*`;
  }

  return section;
}
</file>

<file path="functions/lib/narrative/spreads/decision.js">
import { enhanceSection, validateReadingNarrative } from '../../narrativeSpine.js';
import { sortCardsByImportance } from '../../positionWeights.js';
import { analyzeElementalDignity } from '../../spreadAnalysis.js';
import {
  appendReversalReminder,
  buildOpening,
  buildPositionCardText,
  getPositionOptions,
  buildWeightAttentionIntro,
  buildWeightNote,
  buildSupportingPositionsSummary,
  buildReflectionsSection,
  buildPatternSynthesis,
  getConnector,
  computeRemedyRotationIndex
} from '../helpers.js';
import { getToneStyle, getFrameVocabulary, buildNameClause, buildPersonalizedClosing } from '../styleHelpers.js';

export async function buildDecisionReading({
  cardsInfo,
  userQuestion,
  reflectionsText,
  themes,
  context,
  spreadInfo
}, options = {}) {
  const sections = [];
  const collectValidation =
    typeof options.collectValidation === 'function'
      ? options.collectValidation
      : null;

  const recordSection = (text, metadata = {}) => {
    const result = enhanceSection(text, metadata);
    if (collectValidation) {
      collectValidation({
        text: result.text,
        metadata,
        validation: result.validation || null
      });
    }
    return result.text;
  };
  const spreadName = 'Decision / Two-Path';
  const personalization = options.personalization || null;
  const tone = getToneStyle(personalization?.readingTone);
  const frameVocab = getFrameVocabulary(personalization?.spiritualFrame);
  const nameInline = buildNameClause(personalization?.displayName, 'inline');

  sections.push(
    buildOpening(
      spreadName,
      userQuestion ||
      'This spread illuminates the heart of your decision, two possible paths, clarifying insight, and a reminder of your agency.',
      context,
      { personalization: options.personalization }
    )
  );

  const normalizedCards = Array.isArray(cardsInfo) ? cardsInfo : [];
  if (normalizedCards.length < 5) {
    const placeholder = '### Decision / Two-Path\n\nThis spread needs all five cards (heart, two paths, clarifier, and free-will reminder) before a narrative can be generated. Draw or reveal the remaining cards, then try again.';
    return appendReversalReminder(placeholder, normalizedCards, themes);
  }
  const prioritized = sortCardsByImportance(normalizedCards, 'decision');
  const [heart, pathA, pathB, clarifier, freeWill] = normalizedCards;
  const positionOptions = getPositionOptions(themes, context);
  const remedyRotationIndex = computeRemedyRotationIndex({ cardsInfo: normalizedCards, userQuestion, spreadInfo });

  const attentionNote = buildWeightAttentionIntro(prioritized, spreadName);
  if (attentionNote) {
    sections.push(attentionNote);
  }

  // THE CHOICE
  let choice = `### The Choice\n\n`;
  const heartPosition = heart?.position || 'Heart of the decision';
  if (heart) {
    choice += buildPositionCardText(
      heart,
      heartPosition,
      positionOptions
    );
    choice += '\n\nThis position stands at the center of your decision and points toward what truly matters as you weigh each path.';
  } else {
    choice += 'This position has not been revealed yet, so the core of the decision is still taking shape.';
  }

  if (heart) {
    const heartWeightNote = buildWeightNote('decision', 0, heartPosition);
    if (heartWeightNote) {
      choice += `\n\n${heartWeightNote}`;
    }
  }
  sections.push(
    recordSection(choice, {
      type: 'decision-core',
      cards: [heart]
    })
  );

  // PATH A
  let aSection = `### Path A\n\n`;
  const pathAPosition = pathA?.position || 'Path A — energy & likely outcome';
  if (pathA) {
    const pathAConnector = getConnector(pathAPosition, 'toPrev');
    const pathAText = buildPositionCardText(
      pathA,
      pathAPosition,
      positionOptions
    );
    aSection += pathAConnector ? `${pathAConnector} ${pathAText}` : pathAText;
    aSection += '\n\nThis path suggests one possible trajectory if you commit to this direction.';

    const pathAWeightNote = buildWeightNote('decision', 1, pathAPosition);
    if (pathAWeightNote) {
      aSection += `\n\n${pathAWeightNote}`;
    }
  } else {
    aSection += 'Path A has not been revealed yet, so we cannot describe this trajectory.\n\n';
  }
  sections.push(
    recordSection(aSection, {
      type: 'decision-path',
      cards: [pathA]
    })
  );

  // PATH B
  let bSection = `### Path B\n\n`;
  const pathBPosition = pathB?.position || 'Path B — energy & likely outcome';
  if (pathB) {
    const pathBConnector = getConnector(pathBPosition, 'toPrev');
    const pathBText = buildPositionCardText(
      pathB,
      pathBPosition,
      positionOptions
    );
    bSection += pathBConnector ? `${pathBConnector} ${pathBText}` : pathBText;
    bSection += '\n\nThis path suggests an alternate trajectory, inviting you to compare how each route aligns with your values.';

    const pathBWeightNote = buildWeightNote('decision', 2, pathBPosition);
    if (pathBWeightNote) {
      bSection += `\n\n${pathBWeightNote}`;
    }
  } else {
    bSection += 'Path B has not been revealed yet, so there is no comparison point for the alternate route.\n\n';
  }
  sections.push(
    recordSection(bSection, {
      type: 'decision-path',
      cards: [pathB]
    })
  );

  // CLARITY + AGENCY
  let clarity = `### Clarity + Agency\n\n`;

  if (clarifier) {
    const clarifierPosition = clarifier.position || 'What clarifies the best path';
    const clarifierConnector = getConnector(clarifierPosition, 'toPrev');
    const clarifierText = buildPositionCardText(
      clarifier,
      clarifierPosition,
      positionOptions
    );
    clarity += clarifierConnector ? `${clarifierConnector} ${clarifierText}` : clarifierText;
    clarity += '\n\n';

    const clarifierWeightNote = buildWeightNote('decision', 3, clarifierPosition);
    if (clarifierWeightNote) {
      clarity += `${clarifierWeightNote}\n\n`;
    }
  } else {
    clarity += 'Clarifier card not provided yet, so note any new information you need before committing.\n\n';
  }

  if (pathA && pathB) {
    const elemental = analyzeElementalDignity(pathA, pathB);
    if (elemental && elemental.description) {
      clarity += `Comparing the two paths: ${elemental.description}. `;
    }
  }

  if (freeWill) {
    const freeWillPosition = freeWill.position || 'What to remember about your free will';
    const freeWillConnector = getConnector(freeWillPosition, 'toPrev');
    const freeWillText = buildPositionCardText(
      freeWill,
      freeWillPosition,
      positionOptions
    );
    clarity += freeWillConnector ? `${freeWillConnector} ${freeWillText}` : freeWillText;
    clarity += '\n\n';

    const freeWillWeightNote = buildWeightNote('decision', 4, freeWillPosition);
    if (freeWillWeightNote) {
      clarity += `${freeWillWeightNote}\n\n`;
    }
  } else {
    clarity += 'Remember: your free will ultimately guides this choice, even without a dedicated card drawn yet.\n\n';
  }

  clarity +=
    'Use these insights to understand how each option feels in your body and life. The cards illuminate possibilities; you remain the one who chooses. Each route is a trajectory shaped by your next intentional steps.';

  sections.push(
    recordSection(clarity, {
      type: 'decision-clarity',
      cards: [clarifier, freeWill].filter(Boolean)
    })
  );

  const supportingSummary = buildSupportingPositionsSummary(prioritized, spreadName);
  if (supportingSummary) {
    sections.push(supportingSummary);
  }

  if (reflectionsText && reflectionsText.trim()) {
    sections.push(buildReflectionsSection(reflectionsText));
  }

  const patternSection = buildPatternSynthesis(themes);
  if (patternSection) {
    sections.push(patternSection);
  }

  // Guidance synthesis with elemental remedies
  let guidanceSection = await buildDecisionGuidance(normalizedCards, themes, context, remedyRotationIndex);
  if (guidanceSection) {
    const tonePhrase = tone.challengeFraming || 'clear reminder';
    const frameWord = frameVocab[0] || 'insight';
    guidanceSection += `\n\nFor you${nameInline || ''} this is a ${tonePhrase} to notice which path carries more ${frameWord} and agency.`;
  }
  if (guidanceSection) {
    sections.push(
      recordSection(guidanceSection, {
        type: 'guidance',
        cards: normalizedCards
      })
    );
  }

  const full = sections.filter(Boolean).join('\n\n');
  const validation = validateReadingNarrative(full);
  if (!validation.isValid) {
    console.debug('Decision narrative spine suggestions:', validation.suggestions || validation.sectionAnalyses);
  }

  const closing = buildPersonalizedClosing(personalization);
  const narrative = closing ? `${full}\n\n${closing}` : full;

  return appendReversalReminder(narrative, cardsInfo, themes);
}

async function buildDecisionGuidance(cardsInfo, themes, context, rotationIndex = 0) {
  let section = `### Guidance\n\n`;

  if (themes.suitFocus) {
    section += `${themes.suitFocus}\n\n`;
  }

  // Elemental remedies if imbalanced
  if (themes.elementCounts && themes.elementalBalance) {
    try {
      const { buildElementalRemedies, shouldOfferElementalRemedies } = await import('../helpers.js');
      if (shouldOfferElementalRemedies(themes.elementCounts, cardsInfo.length)) {
        const remedies = buildElementalRemedies(themes.elementCounts, cardsInfo.length, context, {
          rotationIndex
        });
        if (remedies) {
          section += `${themes.elementalBalance}\n\n${remedies}\n\n`;
        }
      }
    } catch (err) {
      console.error('[Decision] Elemental remedies unavailable:', err.message);
    }
  }

  // Decision-specific guidance
  section += `Remember: a decision is not a single moment but a series of aligned actions. `;
  section += `These cards show energies and tendencies, not fixed outcomes. `;
  section += `Your choices, moment to moment, shape which path you actually walk.`;

  return section;
}
</file>

<file path="functions/lib/narrative/spreads/fiveCard.js">
import { enhanceSection, validateReadingNarrative } from '../../narrativeSpine.js';
import { sortCardsByImportance } from '../../positionWeights.js';
import {
  appendReversalReminder,
  buildOpening,
  buildPositionCardText,
  getPositionOptions,
  buildWeightAttentionIntro,
  buildWeightNote,
  buildSupportingPositionsSummary,
  buildReflectionsSection,
  buildPatternSynthesis,
  getConnector,
  computeRemedyRotationIndex
} from '../helpers.js';
import { getToneStyle, getFrameVocabulary, buildNameClause, buildPersonalizedClosing } from '../styleHelpers.js';

export async function buildFiveCardReading({
  cardsInfo,
  userQuestion,
  reflectionsText,
  fiveCardAnalysis,
  themes,
  context,
  spreadInfo
}, options = {}) {
  const sections = [];
  const personalization = options.personalization || null;
  const tone = getToneStyle(personalization?.readingTone);
  const frameVocab = getFrameVocabulary(personalization?.spiritualFrame);
  const nameInline = buildNameClause(personalization?.displayName, 'inline');
  const collectValidation =
    typeof options.collectValidation === 'function'
      ? options.collectValidation
      : null;

  const recordSection = (text, metadata = {}) => {
    const result = enhanceSection(text, metadata);
    if (collectValidation) {
      collectValidation({
        text: result.text,
        metadata,
        validation: result.validation || null
      });
    }
    return result.text;
  };
  const spreadName = 'Five-Card Clarity';

  // Opening
  sections.push(
    buildOpening(
      spreadName,
      userQuestion ||
      'This spread clarifies the core issue, the challenge, hidden influences, support, and where things are heading if nothing shifts.',
      context,
      { personalization: options.personalization }
    )
  );

  if (!Array.isArray(cardsInfo) || cardsInfo.length < 5) {
    return 'This five-card spread is incomplete; please redraw or ensure all five cards are present.';
  }

  const [core, challenge, hidden, support, direction] = cardsInfo;
  const prioritized = sortCardsByImportance(cardsInfo, 'fiveCard');
  const positionOptions = getPositionOptions(themes, context);
  const remedyRotationIndex = computeRemedyRotationIndex({ cardsInfo, userQuestion, spreadInfo });

  const attentionNote = buildWeightAttentionIntro(prioritized, spreadName);
  if (attentionNote) {
    sections.push(attentionNote);
  }

  // Core + Challenge section
  let coreSection = `### Five-Card Clarity — Core & Challenge\n\n`;
  const corePosition = core.position || 'Core of the matter';
  coreSection += buildPositionCardText(
    core,
    corePosition,
    positionOptions
  );
  coreSection += '\n\n';
  const challengePosition = challenge.position || 'Challenge or tension';
  const challengeConnector = getConnector(challengePosition, 'toPrev');
  const challengeText = buildPositionCardText(
    challenge,
    challengePosition,
    {
      ...positionOptions,
      prevElementalRelationship: fiveCardAnalysis?.coreVsChallenge
    }
  );
  coreSection += challengeConnector ? `${challengeConnector} ${challengeText}` : challengeText;
  coreSection += '\n\n';

  if (fiveCardAnalysis?.coreVsChallenge?.description) {
    coreSection += `\n\n${fiveCardAnalysis.coreVsChallenge.description}.`;
  }

  const coreWeightNotes = [
    buildWeightNote('fiveCard', 0, corePosition),
    buildWeightNote('fiveCard', 1, challengePosition)
  ].filter(Boolean);
  if (coreWeightNotes.length > 0) {
    coreSection += `\n\n${coreWeightNotes.join(' ')}`;
  }

  sections.push(
    recordSection(coreSection, {
      type: 'nucleus',
      cards: [core, challenge],
      relationships: { elementalRelationship: fiveCardAnalysis?.coreVsChallenge }
    })
  );

  // Hidden influence
  let hiddenSection = `### Hidden Influence\n\n`;
  const hiddenPosition = hidden.position || 'Hidden / subconscious influence';
  const hiddenConnector = getConnector(hiddenPosition, 'toPrev');
  const hiddenText = buildPositionCardText(
    hidden,
    hiddenPosition,
    positionOptions
  );
  hiddenSection += hiddenConnector ? `${hiddenConnector} ${hiddenText}` : hiddenText;

  const hiddenWeightNote = buildWeightNote('fiveCard', 2, hiddenPosition);
  if (hiddenWeightNote) {
    hiddenSection += `\n\n${hiddenWeightNote}`;
  }
  sections.push(
    recordSection(hiddenSection, {
      type: 'subconscious',
      cards: [hidden]
    })
  );

  // Support
  let supportSection = `### Supporting Energies\n\n`;
  const supportPosition = support.position || 'Support / helpful energy';
  const supportConnector = getConnector(supportPosition, 'toPrev');
  const supportText = buildPositionCardText(
    support,
    supportPosition,
    positionOptions
  );
  supportSection += supportConnector ? `${supportConnector} ${supportText}` : supportText;

  const supportWeightNote = buildWeightNote('fiveCard', 3, supportPosition);
  if (supportWeightNote) {
    supportSection += `\n\n${supportWeightNote}`;
  }
  sections.push(
    recordSection(supportSection, {
      type: 'support',
      cards: [support]
    })
  );

  // Direction
  let directionSection = `### Direction on Your Current Path\n\n`;
  const directionPosition = direction.position || 'Likely direction on current path';
  const directionConnector = getConnector(directionPosition, 'toPrev');
  const directionText = buildPositionCardText(
    direction,
    directionPosition,
    {
      ...positionOptions,
      prevElementalRelationship: fiveCardAnalysis?.supportVsDirection
    }
  );
  directionSection += directionConnector ? `${directionConnector} ${directionText}` : directionText;

  if (fiveCardAnalysis?.synthesis) {
    directionSection += `\n\n${fiveCardAnalysis.synthesis}`;
  }

  const directionWeightNote = buildWeightNote('fiveCard', 4, directionPosition);
  if (directionWeightNote) {
    directionSection += `\n\n${directionWeightNote}`;
  }

  sections.push(
    recordSection(directionSection, {
      type: 'outcome',
      cards: [direction],
      relationships: { elementalRelationship: fiveCardAnalysis?.supportVsDirection }
    })
  );

  const supportingSummary = buildSupportingPositionsSummary(prioritized, spreadName);
  if (supportingSummary) {
    sections.push(supportingSummary);
  }

  // Reflections
  if (reflectionsText && reflectionsText.trim()) {
    sections.push(buildReflectionsSection(reflectionsText));
  }

  const patternSection = buildPatternSynthesis(themes);
  if (patternSection) {
    sections.push(patternSection);
  }

  // Guidance synthesis with elemental remedies
  let guidanceSection = await buildFiveCardGuidance(cardsInfo, themes, context, direction, remedyRotationIndex);
  if (guidanceSection) {
    const tonePhrase = tone.challengeFraming || 'grounded next step';
    const frameWord = frameVocab[0] || 'insight';
    guidanceSection += `\n\nFor you${nameInline || ''} this becomes a ${tonePhrase}, translating ${frameWord} into practice.`;
  }
  if (guidanceSection) {
    sections.push(
      recordSection(guidanceSection, {
        type: 'guidance',
        cards: [direction]
      })
    );
  }

  const full = sections.filter(Boolean).join('\n\n');
  const validation = validateReadingNarrative(full);
  if (!validation.isValid) {
    console.debug('Five-Card narrative spine suggestions:', validation.suggestions || validation.sectionAnalyses);
  }

  const closing = buildPersonalizedClosing(personalization);
  const narrative = closing ? `${full}\n\n${closing}` : full;
  return appendReversalReminder(narrative, cardsInfo, themes);
}

async function buildFiveCardGuidance(cardsInfo, themes, context, direction, rotationIndex = 0) {
  let section = `### Guidance\n\n`;

  if (themes.suitFocus) {
    section += `${themes.suitFocus}\n\n`;
  }

  // Elemental remedies if imbalanced
  if (themes.elementCounts && themes.elementalBalance) {
    try {
      const { buildElementalRemedies, shouldOfferElementalRemedies } = await import('../helpers.js');
      if (shouldOfferElementalRemedies(themes.elementCounts, cardsInfo.length)) {
        const remedies = buildElementalRemedies(themes.elementCounts, cardsInfo.length, context, {
          rotationIndex
        });
        if (remedies) {
          section += `${themes.elementalBalance}\n\n${remedies}\n\n`;
        }
      }
    } catch (err) {
      console.error('[Five-Card] Elemental remedies unavailable:', err.message);
    }
  }

  // Direction summary
  section += `The path ahead shows ${direction.card} ${direction.orientation}. `;
  section += `This is not fixed fate, but where current momentum leads if nothing shifts. `;
  section += `Your awareness and choices shape what unfolds next.`;

  return section;
}
</file>

<file path="functions/lib/narrative/spreads/relationship.js">
import { enhanceSection, validateReadingNarrative } from '../../narrativeSpine.js';
import { sortCardsByImportance } from '../../positionWeights.js';
import { analyzeElementalDignity } from '../../spreadAnalysis.js';
import {
  appendReversalReminder,
  buildOpening,
  buildPositionCardText,
  getPositionOptions,
  buildWeightAttentionIntro,
  buildWeightNote,
  buildSupportingPositionsSummary,
  buildReflectionsSection,
  buildPatternSynthesis,
  getConnector,
  buildInlineReversalNote,
  buildGuidanceActionPrompt,
  computeRemedyRotationIndex
} from '../helpers.js';
import { getToneStyle, getFrameVocabulary, buildNameClause, buildPersonalizedClosing } from '../styleHelpers.js';

export async function buildRelationshipReading({
  cardsInfo,
  userQuestion,
  reflectionsText,
  themes,
  context,
  spreadInfo
}, options = {}) {
  const sections = [];
  const collectValidation =
    typeof options.collectValidation === 'function'
      ? options.collectValidation
      : null;

  const recordSection = (text, metadata = {}) => {
    const result = enhanceSection(text, metadata);
    if (collectValidation) {
      collectValidation({
        text: result.text,
        metadata,
        validation: result.validation || null
      });
    }
    return result.text;
  };
  const spreadName = 'Relationship Snapshot';
  const personalization = options.personalization || null;
  const tone = getToneStyle(personalization?.readingTone);
  const frameVocab = getFrameVocabulary(personalization?.spiritualFrame);
  const nameInline = buildNameClause(personalization?.displayName, 'inline');

  sections.push(
    buildOpening(
      spreadName,
      userQuestion ||
      'This spread explores your energy, their energy, the connection between you, and guidance for relating with agency and care.',
      context,
      { personalization: options.personalization }
    )
  );

  const normalizedCards = Array.isArray(cardsInfo) ? cardsInfo : [];
  const prioritized = sortCardsByImportance(normalizedCards, 'relationship');
  const remedyRotationIndex = computeRemedyRotationIndex({ cardsInfo: normalizedCards, userQuestion, spreadInfo });
  const [youCard, themCard, connectionCard, ...extraCards] = normalizedCards;
  const dynamicsCard = extraCards[0];
  const outcomeCard = extraCards[1];
  const positionOptions = getPositionOptions(themes, context);
  let reversalReminderEmbedded = false;

  const attentionNote = buildWeightAttentionIntro(prioritized, spreadName);
  if (attentionNote) {
    sections.push(attentionNote);
  }

  // YOU AND THEM
  let youThem = `### You and Them\n\n`;
  const dyadCards = [youCard, themCard].filter(Boolean);

  if (youCard) {
    const youPosition = youCard.position || 'You / your energy';
    const youText = buildPositionCardText(
      youCard,
      youPosition,
      positionOptions
    );
    youThem += youText;

    const youReversalNote = buildInlineReversalNote(youCard, themes, {
      shouldIncludeReminder: !reversalReminderEmbedded
    });
    if (youReversalNote) {
      youThem += `\n\n${youReversalNote.text}`;
      if (youReversalNote.includesReminder) {
        reversalReminderEmbedded = true;
      }
    }

    youThem += '\n\n';

    const youWeightNote = buildWeightNote('relationship', 0, youPosition);
    if (youWeightNote) {
      youThem += `${youWeightNote}\n\n`;
    }
  }

  if (themCard) {
    const themPosition = themCard.position || 'Them / their energy';
    const themConnector = getConnector(themPosition, 'toPrev');
    const themText = buildPositionCardText(
      themCard,
      themPosition,
      positionOptions
    );
    youThem += themConnector ? `${themConnector} ${themText}` : themText;

    const themReversalNote = buildInlineReversalNote(themCard, themes, {
      shouldIncludeReminder: !reversalReminderEmbedded
    });
    if (themReversalNote) {
      youThem += `\n\n${themReversalNote.text}`;
      if (themReversalNote.includesReminder) {
        reversalReminderEmbedded = true;
      }
    }

    const themWeightNote = buildWeightNote('relationship', 1, themPosition);
    if (themWeightNote) {
      youThem += `\n\n${themWeightNote}`;
    }
  }

  const elemental = analyzeElementalDignity(youCard, themCard);
  const summaryLines = [];
  if (elemental && elemental.description) {
    summaryLines.push(`*Elemental interplay between you: ${elemental.description}.*`);
    const elementalTakeaway = buildRelationshipElementalTakeaway(elemental, youCard, themCard);
    if (elementalTakeaway) {
      summaryLines.push(elementalTakeaway);
    }
  } else {
    summaryLines.push('Together, this pairing suggests the current dynamic between you and points toward how energy is moving in this connection.');
  }
  youThem += `\n\n${summaryLines.join(' ')}`;

  const relationshipsMeta = elemental && elemental.description
    ? { elementalRelationship: elemental }
    : undefined;

  sections.push(
    recordSection(youThem, {
      type: 'relationship-dyad',
      cards: dyadCards,
      relationships: relationshipsMeta
    })
  );

  // THE CONNECTION
  if (connectionCard) {
    let connection = `### The Connection\n\n`;
    connection += 'This position shows what the bond is asking for right now.\n\n';
    const connectionPosition = connectionCard.position || 'The connection / shared lesson';
    const connectionConnector = getConnector(connectionPosition, 'toPrev');
    const connectionText = buildPositionCardText(
      connectionCard,
      connectionPosition,
      positionOptions
    );
    connection += connectionConnector ? `${connectionConnector} ${connectionText}` : connectionText;

    const connectionReversalNote = buildInlineReversalNote(connectionCard, themes, {
      shouldIncludeReminder: !reversalReminderEmbedded
    });
    if (connectionReversalNote) {
      connection += `\n\n${connectionReversalNote.text}`;
      if (connectionReversalNote.includesReminder) {
        reversalReminderEmbedded = true;
      }
    }

    const connectionWeightNote = buildWeightNote('relationship', 2, connectionPosition);
    if (connectionWeightNote) {
      connection += `\n\n${connectionWeightNote}`;
    }

    connection += '\n\nThis focus invites you to notice what this bond is asking from both of you next.';
    sections.push(
      recordSection(connection, {
        type: 'connection',
        cards: [connectionCard]
      })
    );
  }

  // GUIDANCE FOR THIS CONNECTION (three-card friendly)
  const primaryGuidanceCards = [dynamicsCard, outcomeCard].filter(Boolean);
  const fallbackGuidanceCard = primaryGuidanceCards[0] || connectionCard || themCard || youCard;

  let guidance = `### Guidance for This Connection\n\n`;
  guidance += 'This guidance shows how to participate with agency, honesty, and care.\n\n';

  if (fallbackGuidanceCard) {
    const fallbackPosition = fallbackGuidanceCard.position
      ? fallbackGuidanceCard.position
      : fallbackGuidanceCard === youCard
        ? 'You / your energy'
        : fallbackGuidanceCard === themCard
          ? 'Them / their energy'
          : fallbackGuidanceCard === dynamicsCard
            ? 'Dynamics / guidance'
            : fallbackGuidanceCard === outcomeCard
              ? 'Outcome / what this can become'
              : 'The connection / shared lesson';
    const fallbackConnector = getConnector(fallbackPosition, 'toPrev');
    const fallbackText = buildPositionCardText(
      fallbackGuidanceCard,
      fallbackPosition,
      positionOptions
    );
    guidance += fallbackConnector ? `${fallbackConnector} ${fallbackText}\n\n` : `${fallbackText}\n\n`;

    const fallbackReversal = buildInlineReversalNote(fallbackGuidanceCard, themes, {
      shouldIncludeReminder: !reversalReminderEmbedded
    });
    if (fallbackReversal) {
      guidance += `${fallbackReversal.text}\n\n`;
      if (fallbackReversal.includesReminder) {
        reversalReminderEmbedded = true;
      }
    }

    const fallbackIndex = normalizedCards.findIndex(card => card === fallbackGuidanceCard);
    if (fallbackIndex >= 0) {
      const guidanceWeightNote = buildWeightNote('relationship', fallbackIndex, fallbackPosition);
      if (guidanceWeightNote) {
        guidance += `${guidanceWeightNote}\n\n`;
      }
    }
  }

  const actionSources = [youCard, themCard, connectionCard, dynamicsCard, outcomeCard].filter(Boolean);
  const guidancePrompts = actionSources
    .map(card => buildGuidanceActionPrompt(card, themes))
    .filter(Boolean);
  if (guidancePrompts.length > 0) {
    guidance += `${guidancePrompts.join(' ')}\n\n`;
  }

  if (dynamicsCard) {
    const dynamicsPosition = dynamicsCard.position || 'Dynamics / guidance';
    const dynamicsWeightNote = buildWeightNote('relationship', 3, dynamicsPosition);
    if (dynamicsWeightNote) {
      guidance += `${dynamicsWeightNote}\n\n`;
    }
  }

  if (outcomeCard) {
    const outcomePosition = outcomeCard.position || 'Outcome / what this can become';
    const outcomeWeightNote = buildWeightNote('relationship', 4, outcomePosition);
    if (outcomeWeightNote) {
      guidance += `${outcomeWeightNote}\n\n`;
    }
  }

  guidance += 'Emphasize honest communication, reciprocal care, and boundaries. Treat these insights as a mirror that informs how you choose to show up—never as a command to stay or leave. Choose the path that best honors honesty, care, and your own boundaries—the outcome still rests in the choices you both make.';
  const tonePhrase = tone.challengeFraming || 'honest reminder';
  const frameWord = frameVocab[0] || 'connection';
  guidance += `\n\nFor you${nameInline || ''} this is a ${tonePhrase}, inviting ${frameWord}-level dialogue about how you both want to participate.`;

  sections.push(
    recordSection(guidance, {
      type: 'relationship-guidance',
      cards: actionSources
    })
  );

  const supportingSummary = buildSupportingPositionsSummary(prioritized, spreadName);
  if (supportingSummary) {
    sections.push(supportingSummary);
  }

  if (reflectionsText && reflectionsText.trim()) {
    sections.push(buildReflectionsSection(reflectionsText));
  }

  const patternSection = buildPatternSynthesis(themes);
  if (patternSection) {
    sections.push(patternSection);
  }

  // Additional guidance with elemental remedies
  const additionalGuidance = await buildRelationshipAdditionalGuidance(normalizedCards, themes, context, remedyRotationIndex);
  if (additionalGuidance) {
    sections.push(
      recordSection(additionalGuidance, {
        type: 'relationship-support',
        cards: normalizedCards
      })
    );
  }

  const full = sections.filter(Boolean).join('\n\n');
  const validation = validateReadingNarrative(full);
  if (!validation.isValid) {
    console.debug('Relationship narrative spine suggestions:', validation.suggestions || validation.sectionAnalyses);
  }

  const closing = buildPersonalizedClosing(personalization);
  const narrative = closing ? `${full}\n\n${closing}` : full;

  if (reversalReminderEmbedded) {
    return narrative;
  }

  return appendReversalReminder(narrative, cardsInfo, themes);
}

function buildRelationshipElementalTakeaway(elemental, youCard, themCard) {
  if (!elemental || !elemental.relationship) {
    return '';
  }

  const youName = youCard?.card || 'your card';
  const themName = themCard?.card || 'their card';

  switch (elemental.relationship) {
    case 'supportive':
      return `Lean into this cooperative current by naming what ${youName} and ${themName} each need, then offer one concrete gesture that supports both.`;
    case 'tension':
      return `If friction flares between ${youName} and ${themName}, pause to acknowledge it aloud and agree on one boundary or adjustment that keeps the exchange balanced.`;
    case 'amplified':
      return `Because both cards amplify the same element, channel that intensity intentionally—co-create a ritual or conversation that directs this shared energy toward something constructive.`;
    default:
      return 'Stay curious about how each of you is showing up today and keep checking in so the energy stays responsive, not reactive.';
  }
}

async function buildRelationshipAdditionalGuidance(cardsInfo, themes, context, rotationIndex = 0) {
  // Only add elemental remedies section if there's an imbalance
  if (!themes.elementCounts || !themes.elementalBalance) {
    return null;
  }

  let remedies;
  try {
    const { buildElementalRemedies, shouldOfferElementalRemedies } = await import('../helpers.js');
    if (!shouldOfferElementalRemedies(themes.elementCounts, cardsInfo.length)) {
      return null;
    }

    remedies = buildElementalRemedies(themes.elementCounts, cardsInfo.length, context, {
      rotationIndex
    });
  } catch (err) {
    console.error('[Relationship] Elemental remedies unavailable:', err.message);
    return null;
  }
  if (!remedies) {
    return null;
  }

  let section = `### Supporting Your Connection\n\n`;
  section += `${themes.elementalBalance}\n\n`;
  section += `${remedies}\n\n`;
  section += `These practices can help each of you show up more fully, bringing balance to the energies present in this reading.`;

  return section;
}
</file>

<file path="functions/lib/narrative/spreads/singleCard.js">
import { enhanceSection, validateReadingNarrative } from '../../narrativeSpine.js';
import {
  appendReversalReminder,
  buildPositionCardText,
  getPositionOptions,
  buildContextReminder
} from '../helpers.js';
import { getToneStyle, getFrameVocabulary, buildNameClause, buildPersonalizedClosing } from '../styleHelpers.js';

export function buildSingleCardReading({
  cardsInfo,
  userQuestion,
  reflectionsText,
  themes,
  context
}, options = {}) {
  const collectValidation =
    typeof options.collectValidation === 'function'
      ? options.collectValidation
      : null;
  const personalization = options.personalization || null;
  const tone = getToneStyle(personalization?.readingTone);
  const frameVocab = getFrameVocabulary(personalization?.spiritualFrame);
  const nameOpening = buildNameClause(personalization?.displayName, 'opening');
  const nameInline = buildNameClause(personalization?.displayName, 'inline');

  if (!Array.isArray(cardsInfo) || cardsInfo.length === 0 || !cardsInfo[0]) {
    return '### One-Card Insight\n\nNo card data was provided. Please draw at least one card to receive a focused message.';
  }

  const card = cardsInfo[0];
  const positionOptions = getPositionOptions(themes, context);

  let narrative = `### One-Card Insight\n\n`;

  if (userQuestion && userQuestion.trim()) {
    const subject = nameOpening ? `${nameOpening}this card` : 'This card';
    narrative += `${subject} offers a ${tone.openingAdjectives[0] || 'thoughtful'} snapshot on your question "${userQuestion.trim()}".\n\n`;
  } else {
    const subject = nameOpening ? `${nameOpening}this single card` : 'This single card';
    narrative += `${subject} offers a ${tone.openingAdjectives[0] || 'grounded'} glimpse of the energy around you right now.\n\n`;
  }

  const contextReminder = buildContextReminder(context);
  if (contextReminder) {
    narrative += `${contextReminder}\n\n`;
  }

  // Core section with WHAT → WHY → WHAT'S NEXT flavor
  const positionLabel = card.position || 'Theme / Guidance of the Moment';
  const baseText = buildPositionCardText(card, positionLabel, positionOptions);

  narrative += `${baseText}\n\n`;
  narrative +=
    "In simple terms: notice what this theme is asking you to acknowledge (WHAT), reflect on why it might be surfacing now (WHY), and choose one small, aligned next step that honors your agency (WHAT'S NEXT). Therefore, treat this insight as a living moment, not a fixed verdict—a trajectory you actively shape.";
  if (nameInline) {
    narrative += ` For you${nameInline || ''} this is a ${tone.challengeFraming || 'gentle prompt'} to move with your own ${frameVocab[0] || 'wisdom'} rather than against it.`;
  }

  if (reflectionsText && reflectionsText.trim()) {
    narrative += `\n\n### Your Reflections\n\n${reflectionsText.trim()}`;
  }

  const closing = buildPersonalizedClosing(personalization);
  if (closing) {
    narrative += `\n\n${closing}`;
  }

  const result = enhanceSection(narrative, {
    type: 'single-card',
    cards: cardsInfo
  });

  if (collectValidation) {
    collectValidation({
      text: result.text,
      metadata: { type: 'single-card', cards: cardsInfo },
      validation: result.validation || null
    });
  }

  const validation = validateReadingNarrative(result.text);
  if (!validation.isValid) {
    console.debug('Single-card narrative spine suggestions:', validation.suggestions || validation.sectionAnalyses);
  }

  return appendReversalReminder(result.text, cardsInfo, themes);
}

/**
 * Three-card builder using [`POSITION_WEIGHTS`](functions/lib/positionWeights.js:6) for emphasis.
 */
</file>

<file path="functions/lib/narrative/spreads/threeCard.js">
import { enhanceSection, validateReadingNarrative } from '../../narrativeSpine.js';
import { sortCardsByImportance, getPositionWeight } from '../../positionWeights.js';
import {
  appendReversalReminder,
  buildOpening,
  buildPositionCardText,
  getPositionOptions,
  buildWeightAttentionIntro,
  buildWeightNote,
  buildSupportingPositionsSummary,
  buildReflectionsSection,
  buildPatternSynthesis,
  getConnector,
  getContextDescriptor,
  buildReversalGuidance,
  DEFAULT_WEIGHT_DETAIL_THRESHOLD,
  computeRemedyRotationIndex
} from '../helpers.js';
import { getToneStyle, getFrameVocabulary, buildNameClause, buildPersonalizedClosing } from '../styleHelpers.js';

export async function buildThreeCardReading({
  cardsInfo,
  userQuestion,
  reflectionsText,
  threeCardAnalysis,
  themes,
  context,
  spreadInfo
}, options = {}) {
  const sections = [];
  const personalization = options.personalization || null;
  const tone = getToneStyle(personalization?.readingTone);
  const frameVocab = getFrameVocabulary(personalization?.spiritualFrame);
  const nameInline = buildNameClause(personalization?.displayName, 'inline');
  const collectValidation =
    typeof options.collectValidation === 'function'
      ? options.collectValidation
      : null;

  const recordSection = (text, metadata = {}) => {
    const result = enhanceSection(text, metadata);
    if (collectValidation) {
      collectValidation({
        text: result.text,
        metadata,
        validation: result.validation || null
      });
    }
    return result.text;
  };

  sections.push(
    buildOpening(
      'Three-Card Story (Past · Present · Future)',
      userQuestion,
      context,
      { personalization: options.personalization }
    )
  );

  const [past, present, future] = cardsInfo;
  const prioritized = sortCardsByImportance(cardsInfo, 'threeCard');
  const positionOptions = getPositionOptions(themes, context);
  const remedyRotationIndex = computeRemedyRotationIndex({ cardsInfo, userQuestion, spreadInfo });

  const attentionNote = buildWeightAttentionIntro(prioritized, 'Three-Card Story');
  if (attentionNote) {
    sections.push(attentionNote);
  }

  let narrative = `### The Story\n\n`;

  const pastPosition = past.position || 'Past — influences that led here';
  const presentPosition = present.position || 'Present — where you stand now';
  const futurePosition = future.position || 'Future — trajectory if nothing shifts';

  // Past card
  narrative += `${buildPositionCardText(past, pastPosition, positionOptions)}\n\n`;
  const pastWeightNote = buildWeightNote('threeCard', 0, pastPosition);
  if (pastWeightNote) {
    narrative += `${pastWeightNote}\n\n`;
  }

  // Present card with connector and elemental imagery
  const firstToSecond = threeCardAnalysis?.transitions?.firstToSecond;
  const presentConnector = getConnector(presentPosition, 'toPrev');
  narrative += `${presentConnector} ${buildPositionCardText(present, presentPosition, {
    ...positionOptions,
    prevElementalRelationship: firstToSecond
  })}\n\n`;
  const presentWeightNote = buildWeightNote('threeCard', 1, presentPosition);
  if (presentWeightNote) {
    narrative += `${presentWeightNote}\n\n`;
  }

  // Future card with connector and elemental imagery
  const secondToThird = threeCardAnalysis?.transitions?.secondToThird;
  const futureConnector = getConnector(futurePosition, 'toPrev');
  narrative += `${futureConnector} ${buildPositionCardText(future, futurePosition, {
    ...positionOptions,
    prevElementalRelationship: secondToThird
  })}\n\n`;
  const futureWeightNote = buildWeightNote('threeCard', 2, futurePosition);
  if (futureWeightNote) {
    narrative += `${futureWeightNote}\n\n`;
  }

  if (threeCardAnalysis && threeCardAnalysis.narrative) {
    narrative += threeCardAnalysis.narrative;
  }

  sections.push(
    recordSection(narrative, {
      type: 'story',
      cards: [past, present, future]
    })
  );

  if (reflectionsText && reflectionsText.trim()) {
    sections.push(buildReflectionsSection(reflectionsText));
  }

  const patternSection = buildPatternSynthesis(themes);
  if (patternSection) {
    sections.push(patternSection);
  }

  const supportingSummary = buildSupportingPositionsSummary(prioritized, 'Three-Card Story');
  if (supportingSummary) {
    sections.push(supportingSummary);
  }

  let guidanceSection = await buildThreeCardSynthesis(cardsInfo, themes, userQuestion, context, remedyRotationIndex);
  if (guidanceSection) {
    const tonePhrase = tone.challengeFraming || 'clear next step';
    const frameWord = frameVocab[0] || 'insight';
    guidanceSection += `\n\nFor you${nameInline || ''} this reads as a ${tonePhrase}, inviting ${frameWord} in motion.`;
  }
  if (guidanceSection) {
    sections.push(
      recordSection(guidanceSection, {
        type: 'guidance',
        cards: [future]
      })
    );
  }

  const full = sections.filter(Boolean).join('\n\n');
  const closing = buildPersonalizedClosing(personalization);
  const narrativeWithClosing = closing ? `${full}\n\n${closing}` : full;
  const validation = validateReadingNarrative(full);
  if (!validation.isValid) {
    console.debug('Three-card narrative spine suggestions:', validation.suggestions || validation.sectionAnalyses);
  }
  return appendReversalReminder(narrativeWithClosing, cardsInfo, themes);
}

async function buildThreeCardSynthesis(cardsInfo, themes, userQuestion, context, rotationIndex = 0) {
  let section = `### Guidance\n\n`;

  if (context && context !== 'general') {
    section += `Focus: Interpreting the path ahead through ${getContextDescriptor(context)}.\n\n`;
  }

  if (themes.suitFocus) {
    section += `${themes.suitFocus}\n\n`;
  }

  // Elemental remedies if imbalanced
  if (themes.elementCounts && themes.elementalBalance) {
    try {
      const { buildElementalRemedies, shouldOfferElementalRemedies } = await import('../helpers.js');
      if (shouldOfferElementalRemedies(themes.elementCounts, cardsInfo.length)) {
        const remedies = buildElementalRemedies(themes.elementCounts, cardsInfo.length, context, {
          rotationIndex
        });
        if (remedies) {
          section += `${themes.elementalBalance}\n\n${remedies}\n\n`;
        }
      }
    } catch (err) {
      console.error('[Three-Card] Elemental remedies unavailable:', err.message);
    }
  }

  // Timing profile (if available)
  if (themes.timingProfile === 'near-term-tilt') {
    section += `Pace: Signals here lean toward shifts in the nearer term, provided you participate with them.\n\n`;
  } else if (themes.timingProfile === 'longer-arc-tilt') {
    section += `Pace: This story speaks to a longer process that asks patience and steady engagement.\n\n`;
  } else if (themes.timingProfile === 'developing-arc') {
    section += `Pace: Expect this to unfold across a meaningful chapter rather than in a single moment.\n\n`;
  }

  const future = cardsInfo[2];
  const futureWeight = getPositionWeight('threeCard', 2);
  const presentWeight = getPositionWeight('threeCard', 1);
  section += `The path ahead shows ${future.card} ${future.orientation}.`;

  if ((future.orientation || '').toLowerCase() === 'reversed' && themes?.reversalDescription) {
    section += ` ${buildReversalGuidance(themes.reversalDescription)}`;
  }

  section += ` This is not fixed fate, but the trajectory of current momentum. Your awareness and choices shape what comes next.`;

  if (futureWeight >= DEFAULT_WEIGHT_DETAIL_THRESHOLD) {
    section += ` The Future position carries a weight of ${futureWeight.toFixed(2)}, so its voice leads the guidance.`;
  } else if (presentWeight >= DEFAULT_WEIGHT_DETAIL_THRESHOLD) {
    section += ` With the Present sitting at weight ${presentWeight.toFixed(2)}, your current stance remains the main lever for change.`;
  }

  section += '\n\nAltogether, these threads suggest your next supportive step and point toward how to walk this path with agency.';

  return section;
}
</file>

<file path="functions/lib/narrative/helpers.js">
/**
 * Shared narrative helpers for tarot spread builders.
 */
import { getImageryHook, isMajorArcana, getElementalImagery, getMinorImageryHook } from '../imageryHooks.js';
import { buildMinorSummary } from '../minorMeta.js';
import { getPositionWeight } from '../positionWeights.js';
import { getToneStyle, buildNameClause } from './styleHelpers.js';
import {
  getAstroForCard,
  getQabalahForCard,
  shouldSurfaceAstroLens,
  shouldSurfaceQabalahLens
} from '../esotericMeta.js';
import { getDeckAlias } from '../../../shared/vision/deckAssets.js';

const CONTEXT_DESCRIPTORS = {
  love: 'relationships and heart-centered experiences',
  career: 'career, calling, and material pathways',
  self: 'personal growth and inner landscape',
  spiritual: 'spiritual practice and meaning-making',
  general: 'overall life path'
};

const SUIT_CONTEXT_LENSES = {
  love: {
    Wands: 'In relationships, this encourages shared passion and momentum you cultivate together.',
    Cups: 'In relationships, this highlights emotional reciprocity, listening, and care.',
    Swords: 'In relationships, this invites honest dialogue, clear boundaries, and thoughtful communication.',
    Pentacles: 'In relationships, this focuses on steady support, daily rituals, and building something lasting.'
  },
  career: {
    Wands: 'In your career, this points to initiative, leadership, and courageous momentum.',
    Cups: 'In your career, this speaks to collaborative rapport, emotional intelligence, and people care.',
    Swords: 'In your career, this stresses strategy, communication, and decisive clarity.',
    Pentacles: 'In your career, this underscores planning, resources, and tangible results.'
  },
  self: {
    Wands: 'For personal growth, this asks you to kindle motivation and follow what energizes you.',
    Cups: 'For personal growth, this centers emotional processing, self-compassion, and heart work.',
    Swords: 'For personal growth, this supports mental clarity, journaling, and reframing stories.',
    Pentacles: 'For personal growth, this recommends embodiment, somatic practice, and grounding routines.'
  },
  spiritual: {
    Wands: 'In your spiritual practice, this channels devotional fire and inspired action.',
    Cups: 'In your spiritual practice, this deepens receptive listening and intuitive flow.',
    Swords: 'In your spiritual practice, this sharpens discernment, study, and sacred speech.',
    Pentacles: 'In your spiritual practice, this roots insight into ritual, service, and stewardship.'
  }
};

const MAJOR_CONTEXT_LENSES = {
  love: 'In relationships, let this archetype illuminate the dynamics asking for attention.',
  career: 'In your career, treat this archetype as guidance for how you show up in your work and collaborations.',
  self: 'For personal growth, let this archetype mirror the inner work unfolding.',
  spiritual: 'In your spiritual path, let this archetype frame the lesson seeking integration.'
};

const CARD_SPECIFIC_CONTEXT = {
  love: {
    'two of cups': 'In relationships, this affirms mutual devotion, attentive listening, and balanced give-and-take.',
    'three of pentacles': 'In relationships, this often looks like co-creating plans and valuing each person’s contribution.',
    'ten of pentacles': 'In relationships, this reflects building a lasting sense of home, legacy, and shared support.',
    'the hermit': 'In relationships, this can signal honoring sacred space so deeper connection can emerge.',
    'the tower': 'In relationships, this may surface ruptures that ultimately clear the way for honest connection.'
  },
  career: {
    'two of cups': 'In your career, this can indicate a supportive partnership, aligned collaborator, or trusted client bond.',
    'three of pentacles': 'In your career, this emphasizes teamwork, craftsmanship, and being recognized for your expertise.',
    'ten of pentacles': 'In your career, this points to long-term stability, succession planning, and sustainable prosperity.',
    'the hermit': 'In your career, this invites strategic retreat to refine mastery before reengaging.',
    'the tower': 'In your career, this flags sudden change that ultimately clears space for a truer trajectory.'
  },
  self: {
    'three of swords': 'For personal growth, this encourages tending to the wound with compassion, integration, and honest acknowledgement.',
    'nine of swords': 'For personal growth, this highlights working with anxious narratives through grounding practices and support.',
    'the hermit': 'For personal growth, this supports contemplative solitude and inner listening.',
    'wheel of fortune': 'For personal growth, this reminds you to trust cycles and notice what is shifting within.'
  },
  spiritual: {
    'the hermit': 'In your spiritual path, this deepens the call toward contemplative retreat, sacred study, and inner guidance.',
    'wheel of fortune': 'In your spiritual path, this points to trusting the greater pattern and aligning with the turning of time.',
    'temperance': 'In your spiritual path, this celebrates alchemy, ritual balance, and embodied integration.'
  }
};

function deckAwareCardName(cardInfo, deckStyle = 'rws-1909') {
  const fallback = cardInfo?.card || cardInfo?.name || 'this card';
  if (!deckStyle || deckStyle === 'rws-1909') {
    return fallback;
  }

  const aliasInput = {
    number: cardInfo?.number,
    name: cardInfo?.card || cardInfo?.name,
    suit: cardInfo?.suit,
    rank: cardInfo?.rank,
    rankValue: cardInfo?.rankValue
  };
  const alias = getDeckAlias(aliasInput, deckStyle);
  if (!alias || alias === fallback) {
    return fallback || alias || 'this card';
  }

  if (fallback && alias) {
    return `${alias} (RWS: ${fallback})`;
  }

  return alias || fallback;
}

const MINOR_SUITS = ['Wands', 'Cups', 'Swords', 'Pentacles'];

function pickOne(value) {
  if (!value) return '';
  if (Array.isArray(value) && value.length > 0) {
    return value[Math.floor(Math.random() * value.length)];
  }
  return value;
}

const VALID_CONTEXTS = ['love', 'career', 'self', 'spiritual', 'general'];

function normalizeContext(context, { onUnknown } = {}) {
  if (!context || typeof context !== 'string') return 'general';
  const key = context.trim().toLowerCase();
  if (VALID_CONTEXTS.includes(key)) {
    return key;
  }
  // Surface an explicit signal instead of silently downgrading.
  const message = `[narrative] Unknown context "${context}"; falling back to "general".`;
  if (typeof onUnknown === 'function') {
    onUnknown(message);
  } else if (typeof console !== 'undefined' && console.warn) {
    console.warn(message);
  }
  return 'general';
}

function getContextDescriptor(context) {
  return CONTEXT_DESCRIPTORS[normalizeContext(context)] || CONTEXT_DESCRIPTORS.general;
}

function resolveSuitForContext(cardInfo = {}) {
  if (cardInfo.suit && MINOR_SUITS.includes(cardInfo.suit)) {
    return cardInfo.suit;
  }
  const name = typeof cardInfo.card === 'string' ? cardInfo.card : '';
  return MINOR_SUITS.find(suit => name.includes(suit)) || null;
}

function buildContextualClause(cardInfo = {}, context) {
  const normalized = normalizeContext(context);
  if (normalized === 'general') return '';

  const cardName = (cardInfo.card || '').toLowerCase();
  const specificMap = CARD_SPECIFIC_CONTEXT[normalized];
  if (specificMap && specificMap[cardName]) {
    return specificMap[cardName];
  }

  const isMajor =
    typeof cardInfo.number === 'number' &&
    cardInfo.number >= 0 &&
    cardInfo.number <= 21;

  if (isMajor) {
    return MAJOR_CONTEXT_LENSES[normalized] || '';
  }

  const suit = resolveSuitForContext(cardInfo);
  if (suit && SUIT_CONTEXT_LENSES[normalized]?.[suit]) {
    return SUIT_CONTEXT_LENSES[normalized][suit];
  }

  return MAJOR_CONTEXT_LENSES[normalized] || '';
}

function buildContextReminder(context) {
  const normalized = normalizeContext(context);
  if (normalized === 'general') return '';
  return `We’ll ground this reading in your ${getContextDescriptor(normalized)}, while keeping each card rooted in its Rider–Waite–Smith lineage.`;
}

const DEFAULT_WEIGHT_DETAIL_THRESHOLD = 0.75;
const SUPPORTING_WEIGHT_THRESHOLD = 0.65;

function shouldEmphasizePosition(spreadKey, positionIndex, threshold = DEFAULT_WEIGHT_DETAIL_THRESHOLD) {
  return getPositionWeight(spreadKey, positionIndex) >= threshold;
}

function buildWeightNote(spreadKey, positionIndex, label) {
  const weight = getPositionWeight(spreadKey, positionIndex);
  if (weight < DEFAULT_WEIGHT_DETAIL_THRESHOLD) return '';
  return `*${label} carries an attention weight of ${weight.toFixed(2)}, so it receives extended focus here.*`;
}

function buildWeightAttentionIntro(prioritized, spreadName, threshold = DEFAULT_WEIGHT_DETAIL_THRESHOLD) {
  if (!Array.isArray(prioritized) || prioritized.length === 0) return '';
  const focal = prioritized.filter(card => card.weight >= threshold);
  if (!focal.length) return '';
  const cardMentions = focal
    .slice(0, 3)
    .map(card => `${card.position || `Card ${card.originalIndex + 1}`} (${card.card}) at weight ${card.weight.toFixed(2)}`)
    .join(', ');
  return `*Attention weighting (${spreadName}): ${cardMentions}. Lower-weight cards filter into synthesis summaries so the narrative mirrors what matters most.*`;
}

function buildSupportingPositionsSummary(prioritized, spreadName, threshold = SUPPORTING_WEIGHT_THRESHOLD) {
  if (!Array.isArray(prioritized)) return '';
  const supporting = prioritized.filter(card => card.card && card.weight < threshold);
  if (!supporting.length) return '';
  const bullets = supporting
    .map(card => `- ${card.position || `Card ${card.originalIndex + 1}`}: ${card.card} (weight ${card.weight.toFixed(2)}) is summarized as connective tissue rather than extended prose.`)
    .join('\n');
  return `### Supporting Positions\n\nThese ${spreadName} cards carry lighter weighting, so their insights weave into connectors and synthesis:\n${bullets}`;
}

/**
 * Position-specific language templates
 *
 * These templates ensure the same card reads differently based on its position,
 * following professional tarot methodology where position acts as a "question lens"
 *
 * Enhanced with:
 * - connectorToPrev: Phrase to connect to previous position (e.g., "Because...")
 * - connectorToNext: Phrase to connect to next position (e.g., "Therefore...")
 * - useImagery: Whether to pull imagery hooks for Major Arcana cards
 */
const POSITION_LANGUAGE = {
  // Celtic Cross positions
  'Present — core situation (Card 1)': {
    intro: [
      (card, orientation) => `At the heart of this moment stands ${card} ${orientation}.`,
      (card, orientation) => `Right now, your story is colored by ${card} ${orientation}.`,
      (card, orientation) => `The core tone of this moment comes through ${card} ${orientation}.`
    ],
    frame: [
      'This card sketches the atmosphere you’re moving through right now.',
      'It points to what feels most alive, charged, or pressing in your experience.',
      'Treat this as a snapshot of how things feel from the inside out.'
    ],
    connectorToPrev: ['Because of this foundation,', 'Because of what has led you here,'],
    useImagery: true
  },

  'Challenge — crossing / tension (Card 2)': {
    intro: [
      (card, orientation) => `Crossing this, the challenge manifests as ${card} ${orientation}.`,
      (card, orientation) => `In tension with that, ${card} ${orientation} shows where things snag.`,
      (card, orientation) => `${card} ${orientation} highlights the knot in the story—the part that feels tight or testing.`
    ],
    frame: [
      'This points to the friction, obstacle, or dynamic that asks for integration.',
      'Here we see where effort, honesty, or adjustment may be needed.',
      'Treat this not as doom, but as the leverage point where change is possible.'
    ],
    connectorToPrev: ['However,', 'However, at the same time,', 'However, in contrast,'],
    useImagery: true
  },

  'Past — what lies behind (Card 3)': {
    intro: [
      (card, orientation) => `Looking to what lies behind, the past shows ${card} ${orientation}.`,
      (card, orientation) => `In the background, ${card} ${orientation} colors how you arrived here.`,
      (card, orientation) => `The roots of this story reach back to ${card} ${orientation}.`
    ],
    frame: [
      'This surfaces the experiences and patterns that set the stage for now.',
      'It names what you’re carrying forward, consciously or not.',
      'Noticing this past context helps you choose what to keep and what to release.'
    ],
    connectorToNext: ['Because of this,', 'Because of this history,', 'Because of this groundwork,'],
    useImagery: true
  },

  'Near Future — what lies before (Card 4)': {
    intro: [
      (card, orientation) => `What lies ahead in the near future: ${card} ${orientation}.`,
      (card, orientation) => `As the next chapter, ${card} ${orientation} comes into view.`,
      (card, orientation) => `Soon, the story leans into ${card} ${orientation}.`
    ],
    frame: [
      'This hints at near-term developments on your current trajectory, not a final verdict.',
      'See this as the next visible step if nothing major shifts.',
      'It sketches the emerging tone of what you’re stepping into.'
    ],
    connectorToPrev: ['Therefore,', 'Therefore, looking ahead,', 'Therefore, as this unfolds,'],
    useImagery: true
  },

  'Conscious — goals & focus (Card 5)': {
    intro: [
      (card, orientation) => `Your conscious goal, what you aspire toward: ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} speaks to what you know you’re reaching for.`,
      (card, orientation) => `In your conscious mind, ${card} ${orientation} names your current aims.`
    ],
    frame: [
      'This reflects the intentions you can already name and the outcomes you’re trying to move toward.',
      'It shows where your focus naturally goes when you think about this situation.',
      'Let it clarify what “doing well” here genuinely means to you.'
    ],
    useImagery: true
  },

  'Subconscious — roots / hidden forces (Card 6)': {
    intro: [
      (card, orientation) => `Hidden beneath awareness, in the subconscious realm: ${card} ${orientation}.`,
      (card, orientation) => `Below the surface, ${card} ${orientation} stirs quietly.`,
      (card, orientation) => `In the deeper layers, ${card} ${orientation} speaks to what’s moving you from within.`
    ],
    frame: [
      'This points to needs, fears, or loyalties that operate behind your conscious choices.',
      'Understanding this layer helps you respond with more self-compassion.',
      'Treat this as gentle intel about your inner landscape, not a judgment.'
    ],
    connectorToNext: ['Yet beneath the surface,', 'Yet beneath the surface, it all gathers,'],
    useImagery: true
  },

  'Self / Advice — how to meet this (Card 7)': {
    intro: [
      (card, orientation) => `Guidance on how to meet this situation comes through ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} offers a way you might show up for yourself here.`,
      (card, orientation) => `As counsel, ${card} ${orientation} sketches a stance that could support you.`
    ],
    frame: [
      'This suggests practical attitudes or small actions that are available to you.',
      'It highlights resources, boundaries, or habits that can anchor you.',
      'Take it as an invitation, not a command: notice what feels workable.'
    ],
    connectorToPrev: ['Therefore, to navigate this landscape,', 'Because of all of this,'],
    useImagery: true
  },

  'External Influences — people & environment (Card 8)': {
    intro: [
      (card, orientation) => `External influences, people and forces beyond your control: ${card} ${orientation}.`,
      (card, orientation) => `Around you, ${card} ${orientation} reflects other people and conditions in play.`,
      (card, orientation) => `In the wider field, ${card} ${orientation} points to what’s happening around you rather than inside you.`
    ],
    frame: [
      'This shows dynamics you can respond to, but not fully control.',
      'It’s a reminder to distinguish between your work and what belongs to others.',
      'Let this help you choose where to engage and where to release.'
    ],
    connectorToPrev: ['Meanwhile, in the external world,', 'Meanwhile, around you,'],
    useImagery: true
  },

  'Hopes & Fears — deepest wishes & worries (Card 9)': {
    intro: [
      (card, orientation) => `Your hopes and fears intertwine in ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} sits where desire and worry overlap.`,
      (card, orientation) => `This position, held by ${card} ${orientation}, tracks what you long for and what you guard against.`
    ],
    frame: [
      'It often names ambivalence—wanting something and fearing its cost at the same time.',
      'Let this clarify what your heart is truly asking for beneath the anxiety.',
      'Being honest here can soften inner pressure and inform kinder choices.'
    ],
    connectorToPrev: ['Meanwhile, emotionally,', 'And so, on an emotional level,'],
    useImagery: true
  },

  'Outcome — likely path if unchanged (Card 10)': {
    intro: [
      (card, orientation) => `The likely outcome, if the current path continues: ${card} ${orientation}.`,
      (card, orientation) => `If nothing major shifts, ${card} ${orientation} sketches where this could be heading.`,
      (card, orientation) => `As things stand, ${card} ${orientation} maps a plausible direction of travel.`
    ],
    frame: [
      'This is a trajectory based on current patterns, not a fixed fate.',
      'Use it as feedback about where your present choices may lead.',
      'If you don’t love this picture, that awareness is an invitation to course-correct.'
    ],
    connectorToPrev: ['Therefore, all of this converges toward', 'Therefore, taken together, this leans toward'],
    useImagery: true
  },

  // Three-Card positions
  'Past — influences that led here': {
    intro: [
      (card, orientation) => `The past, showing what has led to this moment: ${card} ${orientation}.`,
      (card, orientation) => `Behind you, ${card} ${orientation} outlines the experiences that fed into this chapter.`,
      (card, orientation) => `Looking back, ${card} ${orientation} traces the threads that shaped the current landscape.`
    ],
    frame: [
      'This represents the foundation, causes, and influences that set the stage for where you stand now.',
      'Noticing this helps you decide what you’re done carrying and what still serves.'
    ],
    connectorToNext: ['Because of this foundation,', 'Because of this backdrop,'],
    useImagery: true
  },

  'Present — where you stand now': {
    intro: [
      (card, orientation) => `The present moment, where you stand right now: ${card} ${orientation}.`,
      (card, orientation) => `Right now, ${card} ${orientation} mirrors the live dynamics you’re moving through.`,
      (card, orientation) => `In this moment, ${card} ${orientation} captures the tone of your experience.`
    ],
    frame: [
      'This is the current energy and active dynamic you are navigating.',
      'Treat it as a snapshot, not a sentence—a view of what’s here so you can choose how to meet it.'
    ],
    connectorToPrev: ['And so,', 'And so, from here,'],
    connectorToNext: ['This sets the stage for', 'This sets the stage for the path leaning toward'],
    useImagery: true
  },

  'Future — trajectory if nothing shifts': {
    intro: [
      (card, orientation) => `The future, the trajectory ahead: ${card} ${orientation}.`,
      (card, orientation) => `If nothing major shifts, ${card} ${orientation} suggests where this might be heading.`,
      (card, orientation) => `Looking ahead, ${card} ${orientation} outlines a likely path of momentum.`
    ],
    frame: [
      'This shows where things are tending if you maintain your current course.',
      'Hold it as a forecast of trajectory, always adjustable through your choices.'
    ],
    connectorToPrev: ['Therefore,', 'Therefore, on this trajectory,'],
    useImagery: true
  },

  // Five-Card positions
  'Core of the matter': {
    intro: [
      (card, orientation) => `At the core of the matter: ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} sits at the center of this situation.`,
      (card, orientation) => `Here, ${card} ${orientation} names the heart of what you’re really exploring.`
    ],
    frame: [
      'This is the central issue—the thread that, if tended to, shifts the whole pattern.',
      'Let it help you focus on what truly matters beneath surface details.'
    ],
    useImagery: true
  },

  'Challenge or tension': {
    intro: [
      (card, orientation) => `The challenge or tension: ${card} ${orientation}.`,
      (card, orientation) => `Here, ${card} ${orientation} shows where things snag or feel demanding.`,
      (card, orientation) => `${card} ${orientation} highlights the friction that wants attention.`
    ],
    frame: [
      'This marks the obstacle or knot to work with—not a verdict, but an invitation to adjust.',
      'Naming this tension can make it more workable.'
    ],
    connectorToPrev: ['However,', 'However, in contrast,'],
    useImagery: true
  },

  'Hidden / subconscious influence': {
    intro: [
      (card, orientation) => `Hidden from view, the subconscious influence: ${card} ${orientation}.`,
      (card, orientation) => `Beneath the surface, ${card} ${orientation} moves quietly.`,
      (card, orientation) => `In the unseen layers, ${card} ${orientation} signals stories or needs that aren’t fully voiced.`
    ],
    frame: [
      'This reveals influences beneath awareness—unspoken fears, hopes, or loyalties.',
      'Seeing this gives you more compassionate context for your reactions.'
    ],
    connectorToPrev: ['Yet beneath the surface,', 'Yet beneath the surface, quietly,'],
    useImagery: true
  },

  'Support / helpful energy': {
    intro: [
      (card, orientation) => `Support and helpful energy come through: ${card} ${orientation}.`,
      (card, orientation) => `Here, ${card} ${orientation} shows what has your back.`,
      (card, orientation) => `${card} ${orientation} highlights resources, allies, or inner strengths available now.`
    ],
    frame: [
      'This is what you can lean on as you navigate the situation.',
      'Let this remind you that you are not moving through this empty-handed.'
    ],
    connectorToPrev: ['Meanwhile,', 'Meanwhile, alongside the challenge,'],
    connectorToNext: ['Therefore, drawing on this support,', 'And so, if you lean into this support,'],
    useImagery: true
  },

  'Likely direction on current path': {
    intro: [
      (card, orientation) => `The likely direction, if you continue as you are: ${card} ${orientation}.`,
      (card, orientation) => `On this current path, ${card} ${orientation} sketches a probable trajectory.`,
      (card, orientation) => `If patterns hold, ${card} ${orientation} hints at where things may be heading.`
    ],
    frame: [
      'This is not fixed fate—only the path of current momentum.',
      'Use it as feedback about how your present choices echo forward.'
    ],
    connectorToPrev: ['Therefore,', 'Therefore, taken together,'],
    useImagery: true
  },

  // Single card
  'Theme / Guidance of the Moment': {
    intro: [
      (card, orientation) => `This card shows: ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} offers a simple snapshot for right now.`,
      (card, orientation) => `For this moment, ${card} ${orientation} steps forward.`
    ],
    frame: [
      'This distills the essence of what wants your awareness.',
      'Hold it as a gentle focal point rather than a rigid rule.'
    ],
    useImagery: true
  },

  // Relationship spread positions
  'You / your energy': {
    intro: [
      (card, orientation) => `Your energy in this dynamic: ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} reflects how you’re currently arriving in this connection.`,
      (card, orientation) => `Here, ${card} ${orientation} mirrors your stance, needs, or patterns.`
    ],
    frame: [
      'This invites honest, compassionate self-recognition.',
      'Use it to notice how you participate, without blaming yourself.'
    ],
    connectorToNext: ['And so,', 'And so, from your side,'],
    useImagery: true
  },

  'Them / their energy': {
    intro: [
      (card, orientation) => `Their energy in this dynamic: ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} reflects how they’re currently arriving in this connection.`,
      (card, orientation) => `Here, ${card} ${orientation} sketches their stance, needs, or patterns in the bond.`
    ],
    frame: [
      'This offers a snapshot of how they may be engaging, without claiming to read their mind.',
      'Treat it as information about the dynamic—not a verdict on their character.'
    ],
    connectorToPrev: ['Meanwhile,', 'Meanwhile, alongside your energy,'],
    connectorToNext: ['Therefore, together, these energies create', 'And so, in combination, these currents shape'],
    useImagery: true
  },

  'The connection / shared lesson': {
    intro: [
      (card, orientation) => `The connection itself, the shared lesson: ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} gives language to what this bond is asking of you both.`,
      (card, orientation) => `Here, ${card} ${orientation} frames the relationship as its own living entity.`
    ],
    frame: [
      'This card speaks to the shared lesson, patterns, and potentials alive between you.',
      'Let it name what this connection is teaching, without overstating what must happen next.'
    ],
    connectorToPrev: ['Therefore,', 'Therefore, taken together,'],
    useImagery: true
  },

  // Extended relationship positions (for custom/extended relationship spreads)
  'Dynamics / guidance': {
    intro: [
      (card, orientation) => `The dynamics and guidance for this connection: ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} illuminates the active patterns and suggests how to engage with them.`,
      (card, orientation) => `Here, ${card} ${orientation} offers guidance on how to navigate the current dynamic.`
    ],
    frame: [
      'This card points toward how the relationship is moving and what awareness might help.',
      'Let it suggest attitudes or small shifts that could support healthier engagement.'
    ],
    connectorToPrev: ['Therefore, in this dynamic,', 'And so, given all of this,'],
    useImagery: true
  },

  'Outcome / what this can become': {
    intro: [
      (card, orientation) => `What this connection can become: ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} sketches a possible evolution of this bond.`,
      (card, orientation) => `Looking ahead, ${card} ${orientation} hints at where this relationship may grow.`
    ],
    frame: [
      'This is not a fixed fate, but a trajectory shaped by how you both choose to show up.',
      'Hold it as an invitation to co-create consciously, not a verdict on what must be.'
    ],
    connectorToPrev: ['Therefore,', 'Therefore, if you both lean in,'],
    useImagery: true
  },

  // Decision spread positions
  'Heart of the decision': {
    intro: [
      (card, orientation) => `At the heart of this decision: ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} shows what this choice is truly circling around.`,
      (card, orientation) => `Here, ${card} ${orientation} distills the core question beneath the logistics.`
    ],
    frame: [
      'This reveals what genuinely matters most as you consider your options.',
      'Let it help you name the values and needs that deserve to lead.'
    ],
    connectorToNext: ['Therefore, with this understanding,', 'And so, from this center,'],
    useImagery: true
  },

  'Path A — energy & likely outcome': {
    intro: [
      (card, orientation) => `Path A, its energy and likely outcome: ${card} ${orientation}.`,
      (card, orientation) => `If you lean into Path A, ${card} ${orientation} sketches how this route may feel.`,
      (card, orientation) => `As one possibility, Path A under ${card} ${orientation} outlines a distinct flavor of growth.`
    ],
    frame: [
      'This shows the character, challenges, and probable results of moving this way.',
      'Hold it as one trajectory among many, shaped by your choices.'
    ],
    connectorToPrev: ['Because this option emerges,', 'Because we are looking at one route,'],
    useImagery: true
  },

  'Path B — energy & likely outcome': {
    intro: [
      (card, orientation) => `Path B, its energy and likely outcome: ${card} ${orientation}.`,
      (card, orientation) => `If you lean into Path B, ${card} ${orientation} traces a different way this could unfold.`,
      (card, orientation) => `As another possibility, Path B under ${card} ${orientation} brings its own tone and lessons.`
    ],
    frame: [
      'This shows an alternate character and set of challenges to consider.',
      'Compare it with Path A by how your body and ethics respond, not from fear.'
    ],
    connectorToPrev: ['However, alternatively,', 'However, on the other hand,'],
    useImagery: true
  },

  'What clarifies the best path': {
    intro: [
      (card, orientation) => `What clarifies the best path forward: ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} adds perspective on how each option aligns with your real needs.`,
      (card, orientation) => `Here, ${card} ${orientation} softens confusion and highlights what rings true.`
    ],
    frame: [
      'This card offers perspective to help you discern which direction serves your integrity and wellbeing.',
      'Use it as a clarifying lens, not as a command.'
    ],
    connectorToPrev: ['This sets the stage for clarity,', 'This sets the stage for this clarifying view,'],
    useImagery: true
  },

  'What to remember about your free will': {
    intro: [
      (card, orientation) => `Remember about your free will and agency: ${card} ${orientation}.`,
      (card, orientation) => `${card} ${orientation} underscores that your choices remain central here.`,
      (card, orientation) => `This position, held by ${card} ${orientation}, is a reminder that no card overrides your consent or agency.`
    ],
    frame: [
      'This reminds you of your power to choose and re-choose as new information emerges.',
      'Let it anchor you in the understanding that you co-create outcomes.'
    ],
    connectorToPrev: ['Meanwhile,', 'And so, above all,'],
    useImagery: true
  }
};

/**
 * Build a position-aware card description with optional imagery hooks
 */
function buildPositionCardText(cardInfo, position, options = {}) {
  const template = POSITION_LANGUAGE[position];
  const prevElementalRelationship = options.prevElementalRelationship; // For elemental imagery
  const normalizedContext = normalizeContext(options.context);

  if (!template) {
    // Fallback for unknown positions (defensive defaults)
    const safeCard = deckAwareCardName(cardInfo, options.deckStyle);
    const safeOrientation =
      typeof cardInfo.orientation === 'string' && cardInfo.orientation.trim()
        ? ` ${cardInfo.orientation}`
        : '';
    const meaning = formatMeaningForPosition(cardInfo.meaning || '', position);
    return `${position}: ${safeCard}${safeOrientation}. ${meaning}`;
  }

  const safeCard = deckAwareCardName(cardInfo, options.deckStyle);
  const safeOrientation =
    typeof cardInfo.orientation === 'string' && cardInfo.orientation.trim()
      ? cardInfo.orientation
      : '';
  const introTemplate = pickOne(template.intro);
  const intro =
    typeof introTemplate === 'function'
      ? introTemplate(safeCard, safeOrientation)
      : introTemplate || `${position}: ${safeCard} ${safeOrientation}.`;
  const meaning = formatMeaningForPosition(cardInfo.meaning || '', position);

  const contextClause = buildContextualClause(cardInfo, options.context);

  const allowEsoteric =
    normalizedContext === 'spiritual' ||
    normalizedContext === 'self' ||
    normalizedContext === 'general';

  let esotericClause = '';

  if (allowEsoteric && shouldSurfaceAstroLens(cardInfo)) {
    const astro = getAstroForCard(cardInfo);
    if (astro?.label && astro?.focus) {
      esotericClause = `On a symbolic level, some readers link this card to ${astro.label}, ${astro.focus}; treat that as color, not a command.`;
    }
  }

  if (allowEsoteric && !esotericClause && shouldSurfaceQabalahLens(cardInfo)) {
    const qabalah = getQabalahForCard(cardInfo);
    if (qabalah?.label && qabalah?.focus) {
      esotericClause = `On a symbolic level, some readers relate this card to ${qabalah.label}, ${qabalah.focus}; treat that as color, not a command.`;
    }
  }

  const occultFlavor = allowEsoteric ? buildOccultFlavor(cardInfo) : '';
  const enrichedMeaning = [meaning, contextClause, esotericClause, occultFlavor].filter(Boolean).join(' ');

  // Add imagery hook for Major Arcana if enabled
  let imagery = '';
  if (template.useImagery && isMajorArcana(cardInfo.number)) {
    const hook = getImageryHook(cardInfo.number, cardInfo.orientation);
    if (hook && hook.interpretation) {
      imagery = ` ${hook.interpretation}`;
    }
  }

  // Minor Arcana: suit/rank-aware enrichment plus optional light imagery hook.
  let minorContextText = '';
  if (!isMajorArcana(cardInfo.number)) {
    const minorSummary = buildMinorSummary({
      card: cardInfo.card,
      name: cardInfo.card,
      suit: cardInfo.suit,
      rank: cardInfo.rank,
      rankValue: cardInfo.rankValue
    });
    if (minorSummary) {
      minorContextText = ` ${minorSummary}`;
    }

    const minorHook = getMinorImageryHook({
      card: cardInfo.card,
      suit: cardInfo.suit,
      rank: cardInfo.rank,
      orientation: cardInfo.orientation
    });
    if (minorHook && minorHook.visual) {
      minorContextText += ` Picture ${minorHook.visual}—this subtly colors how this suit's lesson shows up here.`;
    }
  }

  // Add elemental sensory imagery if elemental relationship exists
  let elementalImagery = '';
  if (prevElementalRelationship && prevElementalRelationship.elements) {
    const [e1, e2] = prevElementalRelationship.elements;
    const sensoryCue = getElementalImagery(e1, e2);
    if (sensoryCue && sensoryCue.imagery) {
      elementalImagery = ` ${sensoryCue.imagery}`;
    }
  }

  const frameText = pickOne(template.frame) || '';
  const safeElemental = elementalImagery || '';
  const positionLabel = position ? `${position}: ` : '';
  return `${positionLabel}${intro} ${enrichedMeaning}${imagery}${minorContextText} ${frameText}${safeElemental}`;
}

function buildReversalGuidance(reversalDescription) {
  return `Within the ${reversalDescription.name} lens, ${reversalDescription.guidance}`;
}

export function formatReversalLens(themes, options = {}) {
  const {
    includeExamples = true,
    includeReminder = true,
    cache = true,
    refresh = false
  } = options;

  if (!themes) return { lines: [], text: '' };

  const description = themes.reversalDescription || themes;
  if (!description) return { lines: [], text: '' };

  if (cache !== false && description.formattedLens && !refresh) {
    return {
      lines: description.formattedLens.split('\n'),
      text: description.formattedLens
    };
  }

  const lines = [];
  const name = description.name || 'Reversal lens';
  lines.push(`- Reversal lens: “${name}”.${description.description ? ` ${description.description}` : ''}`);

  if (description.guidance) {
    lines.push(`- Guidance: ${description.guidance}`);
  }

  if (includeExamples && description.examples && Object.keys(description.examples).length > 0) {
    lines.push('- Example applications:');
    Object.entries(description.examples).forEach(([card, interpretation]) => {
      lines.push(`  - ${card} reversed: ${interpretation}`);
    });
  }

  if (includeReminder) {
    lines.push('- Keep this lens consistent for all reversed cards in this spread.');
  }

  if (themes?.reversalCount === 0) {
    lines.push('- All cards appear upright in this reading.');
  }

  const text = lines.join('\n');
  if (cache !== false) {
    description.formattedLens = text;
  }

  return { lines, text };
}

function getPositionOptions(themes, context) {
  const options = {};
  if (themes && themes.reversalDescription) {
    options.reversalDescription = themes.reversalDescription;
  }
  if (themes && themes.deckStyle) {
    options.deckStyle = themes.deckStyle;
  }
  if (typeof context !== 'undefined') {
    options.context = context;
  }
  return options;
}

function getCrossCheckReversalNote(position, themes) {
  if (!position || !themes || !themes.reversalDescription) return '';
  if ((position.orientation || '').toLowerCase() !== 'reversed') return '';
  const guidance = buildReversalGuidance(themes.reversalDescription);
  const positionName = position.name || 'Position';
  return `${positionName} (${position.card} ${position.orientation}): ${guidance}`;
}

function formatMeaningForPosition(meaning, position) {
  const firstClause = meaning.includes('.') ? meaning.split('.')[0] : meaning;
  const lowered = firstClause.toLowerCase();

  if (position.includes('Challenge') || position.includes('tension')) {
    return `The friction here shows how it centers on ${lowered}.`;
  }

  if (position.includes('Advice') || position.includes('how to meet') || position.includes('Self / Advice')) {
    return `This shows how it may help to lean into ${lowered}.`;
  }

  if (position.includes('Outcome') || position.includes('direction') || position.includes('Future')) {
    return `If things continue as they are, this shows how the trajectory leans toward ${lowered}.`;
  }

  if (position.includes('Subconscious') || position.includes('Hidden') || position.includes('Below')) {
    return `This reveals how, beneath awareness, part of you is still relating to ${lowered}.`;
  }

  if (position.includes('External')) {
    return `This shows that around you, circumstances echo ${lowered}.`;
  }

  if (position.includes('Hopes & Fears')) {
    return `This reveals both longing and worry around ${lowered}.`;
  }

  return `This shows ${lowered} as a live theme.`;
}

function buildOpening(spreadName, userQuestion, context, options = {}) {
  const personalization = options.personalization || null;
  const tone = getToneStyle(personalization?.readingTone);
  const question = userQuestion && userQuestion.trim();
  const spreadLabel = spreadName || 'your chosen spread';
  const descriptor = tone.openingAdjectives?.[0] || 'thoughtful';
  const nameOpening = buildNameClause(personalization?.displayName, 'opening');
  const subject = nameOpening ? `${nameOpening}the cards` : 'The cards';

  const responseLead = question
    ? `${subject} offer a ${descriptor} response through the ${spreadLabel} to your question: "${question}".`
    : `${subject} share a ${descriptor} impression of what the ${spreadLabel.toLowerCase()} reveals around you.`;

  const followUp = 'They honor both seen and unseen influences while centering your agency.';
  const base = `${responseLead}\n\n${followUp}`;

  const contextReminder = buildContextReminder(context);
  return contextReminder ? `${base}\n\n${contextReminder}` : base;
}

function appendReversalReminder(text, cardsInfo, themes) {
  if (!text) return text;

  if (!themes?.reversalDescription) {
    return text;
  }

  const reminder = `*Reversal lens reminder: ${buildReversalGuidance(themes.reversalDescription)}*`;
  if (text.includes(reminder)) {
    return text;
  }

  return `${text}\n\n${reminder}`;
}

function getConnector(position, direction = 'toPrev') {
  const template = POSITION_LANGUAGE[position];
  if (!template) return '';

  if (direction === 'toPrev' && template.connectorToPrev) {
    return pickOne(template.connectorToPrev);
  }

  if (direction === 'toNext' && template.connectorToNext) {
    return pickOne(template.connectorToNext);
  }

  return '';
}

function buildCrossCheckSynthesis(crossCheck) {
  const { position1, position2, elementalRelationship, alignmentType } = crossCheck;

  let synthesis = `${position1.name} (${position1.card} ${position1.orientation}) and ${position2.name} (${position2.card} ${position2.orientation}): `;

  // Add elemental dynamic description
  if (elementalRelationship?.description) {
    synthesis += elementalRelationship.description + '. ';
  }

  // Add alignment-based interpretation
  const alignmentPhrases = {
    'unified': 'Both cards share the same elemental energy, creating a unified and intensified theme.',
    'harmonious': 'These positions work together harmoniously, supporting the same trajectory.',
    'evolving-support': 'The supportive elemental flow suggests evolution from one state to the next.',
    'parallel-tension': 'Both positions share orientation, indicating tension that runs consistently through this axis.',
    'dynamic-shift': 'Different orientations signal a dynamic shift or transformation between these positions.',
    'complex': 'The relationship between these positions shows nuanced dynamics worth exploring.'
  };

  synthesis += alignmentPhrases[alignmentType] || 'These positions relate in complex ways.';

  return synthesis;
}

function formatCrossCheck(label, crossCheck, themes) {
  if (!crossCheck) {
    return `${label}: No comparative insight available.`;
  }

  const relationship = crossCheck.elementalRelationship?.relationship;
  let indicator = '';

  if (relationship === 'tension') {
    indicator = '⚠️ Elemental tension signals friction that needs balancing.';
  } else if (relationship === 'supportive') {
    indicator = '✓ Elemental harmony supports this pathway.';
  } else if (relationship === 'amplified') {
    indicator = 'Elemental repetition amplifies this theme significantly.';
  }

  const reversalNotes = [
    getCrossCheckReversalNote(crossCheck.position1, themes),
    getCrossCheckReversalNote(crossCheck.position2, themes)
  ].filter(Boolean);

  const parts = [];
  if (indicator) parts.push(indicator);
  parts.push(buildCrossCheckSynthesis(crossCheck).trim());
  if (reversalNotes.length > 0) {
    parts.push(reversalNotes.join(' '));
  }

  return `${label}: ${parts.join(' ')}`.trim();
}

function buildReflectionsSection(reflectionsText) {
  return `### Your Reflections\n\nThis reflection shows how this reading lands in your lived experience.\n\n${reflectionsText.trim()}\n\nYour intuitive impressions are valid and add personal meaning to this reading.`;
}

function buildOccultFlavor(cardInfo) {
  if (!cardInfo || !isMajorArcana(cardInfo.number)) return '';

  const astro = getAstroForCard(cardInfo);
  const qabalah = getQabalahForCard(cardInfo);

  const bits = [];

  if (astro?.label) {
    const detail = astro.focus ? `, ${astro.focus}` : '';
    bits.push(`${astro.label}${detail}`);
  }

  if (qabalah?.label) {
    const detail = qabalah.focus ? `, ${qabalah.focus}` : '';
    bits.push(`${qabalah.label}${detail}`);
  }

  if (!bits.length) return '';

  return ` On a symbolic level, some readers link this card to ${bits.join(' and ')}; treat that as color, not a command.`;
}

function _buildReflectionPrompt(cardInfo, position) {
  const name = (cardInfo.card || 'this card').toLowerCase();
  const pos = (position || '').toLowerCase();

  if (pos.includes('challenge') || pos.includes('tension')) {
    return `Where do you notice a similar tension or pattern to ${name} in your current experience?`;
  }

  if (pos.includes('advice') || pos.includes('self')) {
    return `What small, doable experiment this week would express the spirit of ${name} in your life?`;
  }

  if (pos.includes('outcome') || pos.includes('direction') || pos.includes('future')) {
    return `If this trajectory unfolded, what part of you would feel relieved, and what part might hesitate?`;
  }

  if (pos.includes('subconscious') || pos.includes('hidden')) {
    return `Does anything in this card’s theme quietly resonate with feelings you rarely say out loud?`;
  }

  return `What, if anything, in your current life feels most like the energy of ${name}?`;
}

function buildGuidanceActionPrompt(cardInfo, themes) {
  if (!cardInfo) return '';

  const cardName = cardInfo.card || 'This card';
  const clause = extractCoreTheme(cardInfo.meaning);
  if (!clause) return '';

  const clauseLower = decapitalize(clause);
  const isReversed = (cardInfo.orientation || '').toLowerCase() === 'reversed';

  if (isReversed) {
    const lensName = themes?.reversalDescription?.name;
    const lensPrefix = lensName ? `Within the ${lensName} lens, ` : '';
    return `${lensPrefix}${cardName} reversed asks you to notice where ${clauseLower} feels blocked and to agree on one practical step that eases the pressure.`;
  }

  return `${cardName} invites you to practice ${clauseLower} together—pick one specific action or conversation that expresses it this week.`;
}

function buildInlineReversalNote(cardInfo, themes, { shouldIncludeReminder = false } = {}) {
  if (
    !cardInfo ||
    (cardInfo.orientation || '').toLowerCase() !== 'reversed' ||
    !themes?.reversalDescription
  ) {
    return null;
  }

  const clause = extractCoreTheme(cardInfo.meaning);
  const clauseLower = clause ? decapitalize(clause) : 'the blocked lesson';
  const cardName = cardInfo.card || 'This card';

  if (shouldIncludeReminder) {
    const lensGuidance = buildReversalGuidance(themes.reversalDescription);
    return {
      text: `*Reversal lens reminder: ${lensGuidance} For ${cardName}, focus on where ${clauseLower} needs gentle attention before momentum can return.*`,
      includesReminder: true
    };
  }

  return {
    text: `*${cardName} reversed spotlights where ${clauseLower} needs gentle attention before momentum can return.*`,
    includesReminder: false
  };
}

function extractCoreTheme(meaning) {
  if (!meaning || typeof meaning !== 'string') return '';
  const firstClause = meaning.split(/[.;]/)[0];
  return firstClause.trim();
}

function decapitalize(text) {
  if (!text) return '';
  return text.charAt(0).toLowerCase() + text.slice(1);
}

function buildPatternSynthesis(themes) {
  const highlights = themes?.knowledgeGraph?.narrativeHighlights;
  if (!Array.isArray(highlights) || highlights.length === 0) {
    return '';
  }

  const featured = highlights.slice(0, 3);
  let section = `### Deeper Patterns\n\n`;
  section += `Beyond the individual positions, your cards reveal larger archetypal movements:\n\n`;

  featured.forEach((highlight) => {
    const sanitized = typeof highlight.text === 'string'
      ? highlight.text.replace(/\*\*/g, '')
      : '';
    section += `- ${sanitized}\n`;
  });

  return `${section}\n`.trimEnd();
}

/**
 * ELEMENTAL REMEDIES
 * Concrete practices to balance underrepresented elemental energies
 */

const ELEMENTAL_REMEDIES_BY_CONTEXT = {
  Fire: {
    love: [
      'Plan a spontaneous date or shared adventure',
      'Have an honest conversation about what excites you both',
      'Try something new together that gets your hearts racing'
    ],
    career: [
      'Pitch that idea you have been sitting on',
      'Take initiative on a project without waiting for permission',
      'Network with someone who inspires you'
    ],
    self: [
      'Move your body—take a walk, stretch, or dance to music',
      'Start that creative project you have been thinking about',
      'Do something that scares you a little in a good way'
    ],
    spiritual: [
      'Practice devotional movement (sacred dance, yoga, tai chi)',
      'Engage with your spiritual practice through action (ritual, service)',
      'Channel inspiration into creative expression of your beliefs'
    ],
    general: [
      'Move your body—take a walk, stretch, or dance to music',
      'Take one decisive action on something you have been considering',
      'Create something with your hands—cook, draw, rearrange a space'
    ]
  },

  Water: {
    love: [
      'Share a vulnerable feeling with your partner',
      'Create space to really listen without planning your response',
      'Express appreciation for something you often take for granted'
    ],
    career: [
      'Check in with how you feel about your work, not just what you think',
      'Reach out to a colleague with genuine care, not just networking',
      'Notice and honor your emotional needs around work boundaries'
    ],
    self: [
      'Journal your feelings without censoring or editing',
      'Practice self-compassion when difficult emotions arise',
      'Let yourself cry, laugh, or feel without trying to fix it'
    ],
    spiritual: [
      'Spend time in receptive prayer or meditation',
      'Engage with sacred texts or teachings that move you emotionally',
      'Practice loving-kindness meditation for yourself and others'
    ],
    general: [
      'Journal your feelings without censoring or editing',
      'Spend time near water or take a mindful bath',
      'Talk with someone who holds space for your emotions without trying to fix them'
    ]
  },

  Air: {
    love: [
      'Ask a question you have been afraid to ask',
      'Talk through a misunderstanding without defensiveness',
      'Share an idea or perspective you usually keep to yourself'
    ],
    career: [
      'Clarify expectations in a key work relationship',
      'Ask for the feedback you need to grow',
      'Articulate your vision or goals to someone who can help'
    ],
    self: [
      'Write out your thoughts to gain perspective on what feels confusing',
      'Talk through your inner dialogue with a trusted friend',
      'Question an assumption you have been carrying'
    ],
    spiritual: [
      'Study a teaching or text that challenges your understanding',
      'Engage in dialogue with someone whose beliefs differ from yours',
      'Write or speak your prayers aloud to clarify your intentions'
    ],
    general: [
      'Discuss your thoughts with a trusted friend or mentor',
      'Write out your thoughts to gain perspective on what feels confusing',
      'Learn something new that sparks your curiosity'
    ]
  },

  Earth: {
    love: [
      'Create a small daily ritual you do together (morning coffee, evening walk)',
      'Tend to the practical, unglamorous foundations of your relationship',
      'Show love through concrete actions, not just words'
    ],
    career: [
      'Organize your workspace or schedule for better flow',
      'Complete one small task that has been lingering',
      'Build a sustainable routine that supports your energy'
    ],
    self: [
      'Establish one grounding daily ritual (morning tea, evening walk, bedtime routine)',
      'Tend to your body\'s basic needs (sleep, nourishing food, gentle movement)',
      'Spend time in nature or with your hands in soil'
    ],
    spiritual: [
      'Create a physical altar or sacred space in your home',
      'Engage in embodied practice (walking meditation, sacred gardening)',
      'Ground your beliefs in daily ritual and tangible acts of service'
    ],
    general: [
      'Establish one grounding daily ritual (morning tea, evening walk, bedtime routine)',
      'Organize a small physical space to create order',
      'Work with your hands—garden, cook, craft, or repair something tangible'
    ]
  }
};

/**
 * Select context-appropriate remedy for an element
 * Implements fallback chain: context → general → first available
 *
 * @param {string} element - Fire, Water, Air, Earth
 * @param {string} context - love, career, self, spiritual, general
 * @param {number} index - Which remedy to pick (0-2, rotates for variety)
 * @returns {string} Context-appropriate remedy
 */
function selectContextAwareRemedy(element, context, index = 0) {
  const contextRemedies = ELEMENTAL_REMEDIES_BY_CONTEXT[element];
  if (!contextRemedies) return null;

  // Try context-specific first
  let remedyList = contextRemedies[context];

  // Fallback to general
  if (!remedyList || remedyList.length === 0) {
    remedyList = contextRemedies.general;
  }

  // Fallback to first available
  if (!remedyList || remedyList.length === 0) {
    const firstAvailable = Object.values(contextRemedies).find(
      list => list && list.length > 0
    );
    remedyList = firstAvailable || [];
  }

  if (remedyList.length === 0) return null;

  // Rotate through options
  const selectedIndex = index % remedyList.length;
  return remedyList[selectedIndex];
}

/**
 * Generate actionable remedies for underrepresented elements
 * Now with context-aware selection
 *
 * @param {Object} elementCounts - Counts of each element {Fire: 2, Water: 0, Air: 1, Earth: 0}
 * @param {number} totalCards - Total number of cards in spread
 * @param {string} context - Reading context (love, career, self, spiritual, general)
 * @param {Object} options - Additional options
 * @param {number} options.rotationIndex - Index for rotating through remedies (default: 0)
 * @returns {string|null} Formatted remedy guidance or null if balanced
 */
function buildElementalRemedies(elementCounts, totalCards, context = 'general', options = {}) {
  if (!elementCounts || !totalCards || totalCards < 3) return null;

  const rotationIndex = Number.isFinite(options.rotationIndex)
    ? Math.abs(Math.floor(options.rotationIndex))
    : 0;

  // Calculate which elements are underrepresented (< 15% of spread)
  const threshold = 0.15;
  const underrepresented = Object.entries(elementCounts)
    .filter(([_element, count]) => {
      const ratio = count / totalCards;
      return ratio < threshold && count < totalCards; // Exclude if element = 100%
    })
    .map(([element]) => element)
    .filter(element => ELEMENTAL_REMEDIES_BY_CONTEXT[element]); // Only elements with remedies

  if (underrepresented.length === 0) return null;

  // Build remedy text with context-aware selection
  const remedies = underrepresented
    .map(element => {
      const remedy = selectContextAwareRemedy(element, context, rotationIndex);
      if (!remedy) return null;
      return `- ${element}: ${remedy}`;
    })
    .filter(Boolean);

  if (remedies.length === 0) return null;

  return `To bring in underrepresented energies:\n${remedies.join('\n')}`;
}

function computeRemedyRotationIndex({ cardsInfo = [], userQuestion = '', spreadInfo = {} } = {}) {
  const segments = [];

  if (spreadInfo?.name) segments.push(spreadInfo.name);
  if (spreadInfo?.key) segments.push(spreadInfo.key);
  if (spreadInfo?.deckStyle) segments.push(spreadInfo.deckStyle);
  if (userQuestion) segments.push(userQuestion);

  if (Array.isArray(cardsInfo)) {
    cardsInfo.forEach((card) => {
      if (card?.canonicalName) {
        segments.push(card.canonicalName);
      } else if (card?.card) {
        segments.push(card.card);
      }
    });
  }

  const composite = segments.join('|').trim();
  if (!composite) return 0;

  let hash = 0;
  for (let i = 0; i < composite.length; i += 1) {
    hash = (hash << 5) - hash + composite.charCodeAt(i);
    hash |= 0; // Convert to 32-bit int
  }

  return Math.abs(hash);
}

/**
 * Check if elemental remedies should be offered
 * True when one element dominates (≥50%) or elements are very sparse
 * Only applies to spreads with 3+ cards (single/two-card spreads too small to meaningfully balance)
 */
function shouldOfferElementalRemedies(elementCounts, totalCards) {
  if (!elementCounts || !totalCards || totalCards < 3) return false;

  const counts = Object.values(elementCounts);
  const maxCount = Math.max(...counts);
  const maxRatio = maxCount / totalCards;

  // Offer remedies if:
  // 1. One element dominates (≥50%)
  // 2. OR 2 or fewer active elements (sparse coverage)
  if (maxRatio >= 0.5) return true;

  const activeElements = counts.filter(c => c > 0).length;
  return activeElements <= 2;
}

export {
  DEFAULT_WEIGHT_DETAIL_THRESHOLD,
  SUPPORTING_WEIGHT_THRESHOLD,
  normalizeContext,
  getContextDescriptor,
  buildContextReminder,
  shouldEmphasizePosition,
  buildWeightNote,
  buildWeightAttentionIntro,
  buildSupportingPositionsSummary,
  buildPositionCardText,
  buildReversalGuidance,
  getPositionOptions,
  getCrossCheckReversalNote,
  buildOpening,
  appendReversalReminder,
  getConnector,
  buildCrossCheckSynthesis,
  formatCrossCheck,
  buildReflectionsSection,
  buildGuidanceActionPrompt,
  buildInlineReversalNote,
  buildPatternSynthesis,
  buildElementalRemedies,
  shouldOfferElementalRemedies,
  selectContextAwareRemedy,
  computeRemedyRotationIndex
};
</file>

<file path="functions/lib/narrative/prompts.js">
import { getImageryHook, isMajorArcana, getElementalImagery } from '../imageryHooks.js';
import {
  normalizeContext,
  getContextDescriptor,
  buildPositionCardText,
  getPositionOptions,
  formatReversalLens,
  getCrossCheckReversalNote,
  buildCrossCheckSynthesis,
  getConnector,
  DEFAULT_WEIGHT_DETAIL_THRESHOLD
} from './helpers.js';
import {
  buildAstrologicalWeatherSection,
  buildCardTransitNotes,
  buildForecastSection,
  generateTimingGuidance
} from '../ephemerisIntegration.js';
import { getDeckProfile } from '../../../shared/vision/deckProfiles.js';
import { THOTH_MINOR_TITLES, MARSEILLE_NUMERICAL_THEMES } from '../../../src/data/knowledgeGraphData.js';
import {
  isGraphRAGEnabled,
  retrievePassages,
  formatPassagesForPrompt,
  getPassageCountForSpread,
  buildRetrievalSummary,
  rankPassagesForPrompt
} from '../graphRAG.js';
import { getPositionWeight } from '../positionWeights.js';
import { formatVisionLabelForPrompt } from '../visionLabels.js';
import { getDepthProfile } from './styleHelpers.js';

// Heuristic: decide when astrological context is relevant enough to surface
// in the reading prompts. Uses card anchors + spread/graph signals + user intent
// to avoid spraying astro notes when the spread is more practical/grounded.
export function shouldIncludeAstroInsights(cardsInfo = [], themes = {}, userQuestion = '') {
  const names = (Array.isArray(cardsInfo) ? cardsInfo : [])
    .map((c) => (c?.card || '').toLowerCase());

  // Cards that strongly imply celestial / timing context
  const astroAnchors = ['the sun', 'the moon', 'the star', 'wheel of fortune', 'judgement', 'temperance', 'the world'];
  const hasAnchor = names.some((n) => astroAnchors.some((anchor) => n.includes(anchor)));

  // Dense Major presence keeps astro relevant
  const majorHeavy = typeof themes?.majorRatio === 'number' && themes.majorRatio >= 0.5;

  // GraphRAG combos (triads / Fool's Journey) are archetypal and pair well with astro timing
  const graphKeys = themes?.knowledgeGraph?.graphKeys || {};
  const hasGraphCombos = Boolean((graphKeys.completeTriadIds?.length || 0) > 0 || graphKeys.foolsJourneyStageKey);

  // Timing profile hints at longer arcs (weekly/seasonal) where astro adds value
  const timingType = themes?.timingProfile?.type;
  const timingSuggestsAstro = ['seasonal', 'long', 'medium'].includes(timingType);

  // User intent: explicit astro/time keywords force opt-in
  const intent = (userQuestion || '').toLowerCase();
  const astroKeywords = [
    'astrology', 'planet', 'planets', 'transit', 'transits', 'retrograde', 'mercury retrograde',
    'eclipse', 'moon', 'full moon', 'new moon', 'lunar', 'solar return', 'horoscope',
    'zodiac', 'sign', 'season', 'equinox', 'solstice'
  ];
  const intentAstro = astroKeywords.some((kw) => intent.includes(kw));

  let score = 0;
  if (hasAnchor) score += 2;          // Strong signal
  if (majorHeavy) score += 1;
  if (hasGraphCombos) score += 1;
  if (timingSuggestsAstro) score += 1;
  if (intentAstro) score += 3;        // strong override from user intent

  // Require at least two signals, or a single strong anchor, to include astro
  return score >= 2;
}

const DECK_STYLE_TIPS = {
  'thoth-a1': [
    'Use Crowley/Harris titles when they differ from Rider–Waite (Adjustment ↔ Justice, Lust ↔ Strength, Art ↔ Temperance).',
    'Reference the Minor epithets (Dominion, Peace, Swiftness, etc.) when they clarify the suit story.',
    'Let the tone lean into prismatic, alchemical imagery when it helps the querent visualize the card.'
  ],
  'marseille-classic': [
    'Refer to the suits as Batons, Cups, Swords, and Coins (instead of Wands/Pentacles).',
    'Describe Minor Arcana through number patterns, symmetry, and directional cues because pip cards are non-scenic.',
    'Call out when repeated motifs (flowers, petals, crossed blades) change the energy of a pip card.'
  ]
};

const TOKEN_ESTIMATE_DIVISOR = 4; // Rough heuristic: ~4 characters per token
const MAX_REFLECTION_TEXT_LENGTH = 600;
const DEFAULT_REVERSAL_DESCRIPTION = {
  name: 'Upright Emphasis',
  description: 'No specific reversal framework supplied for this reading.',
  guidance: 'If a card appears reversed, treat it as an internalized or blocked expression rather than an ominous inversion.'
};

const TONE_GUIDANCE = {
  gentle: `Use warm, nurturing language throughout. Lead with validation before addressing challenges. Frame difficulties as growth opportunities rather than obstacles. Avoid harsh absolutes or alarming language. Emphasize possibilities, hope, and the querent's inner wisdom.`,
  balanced: `Be honest but kind. Acknowledge both challenges and opportunities with equal weight. Balance difficult truths with encouragement. Use measured language that neither sugarcoats nor dramatizes. Trust the querent to handle nuanced information.`,
  blunt: `Be direct and clear. Skip softening phrases like "perhaps" or "you might consider." State observations plainly without hedging. Focus on clarity over comfort. Assume the querent prefers straightforward guidance over diplomatic cushioning.`
};

const FRAME_GUIDANCE = {
  psychological: `Interpret through Jungian archetypes, shadow work, and behavioral patterns. Use language of the psyche: projection, integration, individuation. Ground insights in observable patterns and personal development frameworks.`,
  spiritual: `Embrace intuitive, mystical language. Reference cosmic cycles, soul contracts, and energetic resonance. Honor the sacred dimension of the reading. Use terms like "spirit guides," "higher self," and "universal wisdom" where appropriate.`,
  mixed: `Blend psychological insight with spiritual symbolism naturally. Move fluidly between archetypal psychology and mystical language based on what serves each card's message. This is the default approach when no preference is specified.`,
  playful: `Keep it light, fun, and exploratory. Use humor where appropriate. Frame the reading as a curious adventure rather than a solemn ritual. Avoid heavy language even for challenging cards. Maintain wonder and levity throughout.`
};

function readEnvNumber(value) {
  if (value === undefined || value === null) return null;
  const parsed = Number(value);
  return Number.isFinite(parsed) && parsed > 0 ? parsed : null;
}

export function estimateTokenCount(text = '') {
  const safe = typeof text === 'string' ? text : String(text || '');
  return Math.ceil(safe.length / TOKEN_ESTIMATE_DIVISOR);
}

// Default token budgets per provider - used if no env var is set
// These are conservative estimates based on typical context windows
const DEFAULT_BUDGETS = {
  azure: 12000,   // GPT-5 has ~128k context, but we keep prompts reasonable
  claude: 16000,  // Claude has ~200k context, allow slightly larger prompts
  default: 8000   // Fallback for unknown providers
};

// Hard caps - prompts will be truncated if they exceed these after all slimming
const HARD_CAP_BUDGETS = {
  azure: 20000,
  claude: 25000,
  default: 15000
};

export function getPromptBudgetForTarget(target = 'default', options = {}) {
  const env = options.env || (typeof process !== 'undefined' && process.env ? process.env : {});
  const normalizedTarget = (target || 'default').toLowerCase();

  let raw = null;
  if (normalizedTarget === 'azure') {
    raw = env.PROMPT_BUDGET_AZURE ?? env.PROMPT_BUDGET_DEFAULT;
  } else if (normalizedTarget === 'claude') {
    raw = env.PROMPT_BUDGET_CLAUDE ?? env.PROMPT_BUDGET_DEFAULT;
  } else {
    raw = env.PROMPT_BUDGET_DEFAULT;
  }

  const envBudget = readEnvNumber(raw);

  // If no env budget is set, use sensible defaults
  if (!envBudget) {
    return DEFAULT_BUDGETS[normalizedTarget] || DEFAULT_BUDGETS.default;
  }

  return envBudget;
}

export function getHardCapBudget(target = 'default') {
  const normalizedTarget = (target || 'default').toLowerCase();
  return HARD_CAP_BUDGETS[normalizedTarget] || HARD_CAP_BUDGETS.default;
}

/**
 * Truncate prompt text to fit within a token budget
 * Preserves structure by truncating from the end
 *
 * @param {string} text - Text to truncate
 * @param {number} maxTokens - Maximum tokens allowed
 * @returns {{ text: string, truncated: boolean, originalTokens: number }}
 */
function truncateToTokenBudget(text, maxTokens) {
  if (!text || typeof text !== 'string') {
    return { text: '', truncated: false, originalTokens: 0 };
  }

  const originalTokens = estimateTokenCount(text);
  if (originalTokens <= maxTokens) {
    return { text, truncated: false, originalTokens };
  }

  // Estimate character limit based on token count
  const targetChars = Math.floor(maxTokens * TOKEN_ESTIMATE_DIVISOR * 0.95); // 5% safety margin

  // Try to truncate at a paragraph boundary
  let truncated = text.slice(0, targetChars);
  const lastParagraph = truncated.lastIndexOf('\n\n');

  if (lastParagraph > targetChars * 0.7) {
    truncated = truncated.slice(0, lastParagraph);
  }

  truncated = truncated.trim() + '\n\n[...prompt truncated to fit context window...]';

  return {
    text: truncated,
    truncated: true,
    originalTokens
  };
}

function getDeckStyleNotes(deckStyle = 'rws-1909') {
  const profile = getDeckProfile(deckStyle);
  if (!profile) return null;
  return {
    label: profile.label,
    cue: profile.promptCue,
    palette: Array.isArray(profile.palette) ? profile.palette.join(', ') : null,
    tips: DECK_STYLE_TIPS[deckStyle] || []
  };
}

export function buildEnhancedClaudePrompt({
  spreadInfo,
  cardsInfo,
  userQuestion,
  reflectionsText,
  themes,
  spreadAnalysis,
  context,
  visionInsights,
  deckStyle = 'rws-1909',
  graphRAGPayload = null,
  ephemerisContext = null,
  ephemerisForecast = null,
  transitResonances = [],
  budgetTarget = 'claude',
  contextDiagnostics = [],
  promptBudgetEnv = null,
  personalization = null,
  enableSemanticScoring = null
}) {
  const baseThemes = typeof themes === 'object' && themes !== null ? themes : {};
  const activeThemes = baseThemes.reversalDescription
    ? baseThemes
    : { ...baseThemes, reversalDescription: { ...DEFAULT_REVERSAL_DESCRIPTION } };

  const spreadKey = getSpreadKeyFromName(spreadInfo.name);
  const diagnostics = Array.isArray(contextDiagnostics) ? contextDiagnostics : [];

  const normalizedContext = normalizeContext(context, {
    onUnknown: (message) => diagnostics.push(message)
  });

  const promptBudget = getPromptBudgetForTarget(budgetTarget, { env: promptBudgetEnv });

  // Determine if astro context is relevant enough to surface
  const astroRelevant = shouldIncludeAstroInsights(cardsInfo, activeThemes, userQuestion);
  const astroContext = astroRelevant ? ephemerisContext : null;
  const astroForecast = astroRelevant ? ephemerisForecast : null;
  const astroTransits = astroRelevant ? transitResonances : [];

  // Pre-fetch GraphRAG payload if not already provided
  // This ensures a single retrieval even across slimming passes
  let effectiveGraphRAGPayload = graphRAGPayload;
  if (!effectiveGraphRAGPayload && isGraphRAGEnabled(promptBudgetEnv) && activeThemes?.knowledgeGraph?.graphKeys) {
    const effectiveSpreadKey = spreadKey || 'general';
    const maxPassages = getPassageCountForSpread(effectiveSpreadKey);

    // Check if semantic scoring was requested
    // If enableSemanticScoring is explicitly true but we're doing sync retrieval,
    // log a warning since async retrieval is required for embeddings
    const requestedSemanticScoring = enableSemanticScoring === true;

    if (requestedSemanticScoring) {
      console.warn('[GraphRAG] Semantic scoring requested but graphRAGPayload not pre-computed. ' +
        'For semantic scoring, pre-compute the payload with retrievePassagesWithQuality() ' +
        'in performSpreadAnalysis(). Falling back to keyword-only retrieval.');
    }

    try {
      // Keyword-only synchronous retrieval
      // Semantic scoring requires async retrievePassagesWithQuality() which should
      // be called in performSpreadAnalysis() and passed via graphRAGPayload
      const retrievedPassages = retrievePassages(activeThemes.knowledgeGraph.graphKeys, {
        maxPassages,
        userQuery: userQuestion
      });

      const retrievalSummary = buildRetrievalSummary(activeThemes.knowledgeGraph.graphKeys, retrievedPassages);
      const semanticScoringUsed = Boolean(retrievalSummary?.qualityMetrics?.semanticScoringUsed);
      const semanticScoringFallback = requestedSemanticScoring && !semanticScoringUsed;

      effectiveGraphRAGPayload = {
        passages: retrievedPassages,
        initialPassageCount: retrievedPassages.length,
        formattedBlock: null,
        retrievalSummary: {
          ...retrievalSummary,
          semanticScoringRequested: requestedSemanticScoring,
          semanticScoringUsed,
          semanticScoringFallback
        },
        // Track whether semantic scoring was requested vs what we could deliver
        enableSemanticScoring: false,
        rankingStrategy: 'keyword',
        semanticScoringRequested: requestedSemanticScoring,
        semanticScoringFallback
      };
    } catch (err) {
      console.error('[GraphRAG] Pre-fetch failed:', err.message);
    }
  }

  const baseControls = {
    graphRAGPayload: effectiveGraphRAGPayload,
    ephemerisContext: astroContext,
    ephemerisForecast: astroForecast,
    transitResonances: astroTransits,
    includeGraphRAG: true,
    includeEphemeris: astroRelevant,
    includeForecast: astroRelevant,
    includeDeckContext: true,
    includeDiagnostics: true,
    omitLowWeightImagery: false,
    enableSemanticScoring,
    env: promptBudgetEnv
  };

  const buildWithControls = (controls) => {
    const systemPrompt = buildSystemPrompt(
      spreadKey,
      activeThemes,
      normalizedContext,
      deckStyle,
      userQuestion,
      {
        ...controls,
        personalization,
        maxTokenBudget: promptBudget
      }
    );

    const userPrompt = buildUserPrompt(
      spreadKey,
      cardsInfo,
      userQuestion,
      reflectionsText,
      activeThemes,
      spreadAnalysis,
      normalizedContext,
      visionInsights,
      deckStyle,
      {
        ...controls,
        personalization
      }
    );

    const systemTokens = estimateTokenCount(systemPrompt);
    const userTokens = estimateTokenCount(userPrompt);

    return {
      systemPrompt,
      userPrompt,
      systemTokens,
      userTokens,
      totalTokens: systemTokens + userTokens
    };
  };

  let controls = { ...baseControls };
  let built = buildWithControls(controls);
  const slimmingSteps = [];

  // Check if prompt slimming/truncation is disabled via env
  const disableSlimming = promptBudgetEnv?.DISABLE_PROMPT_SLIMMING === 'true' ||
    promptBudgetEnv?.DISABLE_PROMPT_SLIMMING === true;

  const maybeSlim = (label, updater) => {
    if (disableSlimming) return; // Skip all slimming when disabled
    if (!promptBudget) return;
    if (built.totalTokens <= promptBudget) return;
    updater();
    built = buildWithControls(controls);
    slimmingSteps.push(label);
  };

  // Step 1: Drop imagery/vision sub-points for lower-weight cards
  maybeSlim('drop-low-weight-imagery', () => {
    controls = { ...controls, omitLowWeightImagery: true };
  });

  // Step 2: Remove forecast (future events) if over budget
  maybeSlim('drop-forecast', () => {
    controls = { ...controls, includeForecast: false };
  });

  // Step 3: Remove ephemeris/astrological context if over budget
  maybeSlim('drop-ephemeris', () => {
    controls = { ...controls, includeEphemeris: false };
  });

  // Step 3.5: Trim GraphRAG passages before dropping the block entirely
  maybeSlim('trim-graphrag-passages', () => {
    if (controls.includeGraphRAG === false) return;
    const payload = controls.graphRAGPayload;
    if (!payload?.passages || payload.passages.length <= 1) return;

    const effectiveSpreadKey = spreadKey || 'general';
    const baselineMax = payload.maxPassages || getPassageCountForSpread(effectiveSpreadKey);
    const currentCount = payload.passages.length;
    const targetCount = Math.max(
      1,
      Math.min(currentCount - 1, Math.ceil(baselineMax / 2))
    );

    if (targetCount >= currentCount) return;

    const { passages: rankedPassages, strategy } = rankPassagesForPrompt(payload.passages, {
      limit: targetCount
    });

    if (!rankedPassages || rankedPassages.length >= currentCount) return;

    const trimmedCount = currentCount - rankedPassages.length;
    const initialPassageCount =
      typeof payload.initialPassageCount === 'number'
        ? payload.initialPassageCount
        : currentCount;

    controls = {
      ...controls,
      graphRAGPayload: {
        ...payload,
        passages: rankedPassages,
        formattedBlock: null,
        initialPassageCount,
        budgetTrimmed: true,
        budgetTrimmedCount: (payload.budgetTrimmedCount || 0) + trimmedCount,
        budgetTrimmedFrom:
          typeof payload.budgetTrimmedFrom === 'number'
            ? payload.budgetTrimmedFrom
            : initialPassageCount,
        budgetTrimmedTo: rankedPassages.length,
        rankingStrategy: strategy || payload.rankingStrategy || null
      }
    };
  });

  // Step 4: Remove GraphRAG block if still over budget
  maybeSlim('drop-graphrag-block', () => {
    controls = { ...controls, includeGraphRAG: false };
  });

  // Step 5: Remove deck geometry/context tables (Thoth/Marseille)
  maybeSlim('drop-deck-geometry', () => {
    controls = { ...controls, includeDeckContext: false };
  });

  // Step 6: Remove diagnostics (vision validation, verbose notes)
  maybeSlim('drop-diagnostics', () => {
    controls = { ...controls, includeDiagnostics: false };
  });

  // Step 7: HARD CAP - If still over budget after all slimming, truncate
  // This ensures we never send prompts that exceed context windows
  const hardCap = getHardCapBudget(budgetTarget);
  let finalSystem = built.systemPrompt;
  let finalUser = built.userPrompt;
  let systemTruncated = false;
  let userTruncated = false;

  // Skip hard cap truncation when slimming is disabled
  if (!disableSlimming && built.totalTokens > hardCap) {
    console.warn(`[Prompt Budget] Exceeded hard cap after slimming: ${built.totalTokens} > ${hardCap} tokens`);

    // Calculate how many tokens we need to shed
    const excessTokens = built.totalTokens - hardCap;

    // Prefer truncating user prompt first (system prompt has core instructions)
    const userTargetTokens = Math.max(
      built.userTokens - excessTokens,
      Math.floor(hardCap * 0.3) // Keep at least 30% of budget for user prompt
    );

    const userResult = truncateToTokenBudget(built.userPrompt, userTargetTokens);
    finalUser = userResult.text;
    userTruncated = userResult.truncated;

    // If user truncation wasn't enough, truncate system prompt too
    const newUserTokens = estimateTokenCount(finalUser);
    const remainingBudget = hardCap - newUserTokens;

    if (built.systemTokens > remainingBudget) {
      const systemResult = truncateToTokenBudget(built.systemPrompt, remainingBudget);
      finalSystem = systemResult.text;
      systemTruncated = systemResult.truncated;
    }

    slimmingSteps.push('hard-cap-truncation');
  }

  const finalSystemTokens = estimateTokenCount(finalSystem);
  const finalUserTokens = estimateTokenCount(finalUser);
  const finalTotalTokens = finalSystemTokens + finalUserTokens;

  const promptMeta = {
    estimatedTokens: {
      system: finalSystemTokens,
      user: finalUserTokens,
      total: finalTotalTokens,
      budget: promptBudget,
      hardCap,
      budgetTarget,
      overBudget: Boolean(promptBudget && finalTotalTokens > promptBudget),
      truncated: systemTruncated || userTruncated
    },
    slimmingSteps,
    appliedOptions: {
      omitLowWeightImagery: Boolean(controls.omitLowWeightImagery),
      includeForecast: Boolean(controls.includeForecast),
      includeEphemeris: Boolean(controls.includeEphemeris),
      includeGraphRAG: Boolean(controls.includeGraphRAG),
      includeDeckContext: Boolean(controls.includeDeckContext),
      includeDiagnostics: Boolean(controls.includeDiagnostics)
    },
    truncation: (systemTruncated || userTruncated) ? {
      systemTruncated,
      userTruncated,
      originalSystemTokens: built.systemTokens,
      originalUserTokens: built.userTokens,
      originalTotalTokens: built.totalTokens
    } : null
  };

  if (controls.graphRAGPayload?.retrievalSummary) {
    const payload = controls.graphRAGPayload;
    const retrievalSummary = { ...payload.retrievalSummary };
    const passagesAfterSlimming = Array.isArray(payload.passages)
      ? payload.passages.length
      : 0;
    const initialPassageCount = typeof payload.initialPassageCount === 'number'
      ? payload.initialPassageCount
      : passagesAfterSlimming;
    const graphRAGIncluded = controls.includeGraphRAG !== false && passagesAfterSlimming > 0;
    const passagesUsed = graphRAGIncluded ? passagesAfterSlimming : 0;
    const trimmedCount = Math.max(0, initialPassageCount - passagesUsed);

    const semanticScoringUsed = Boolean(
      retrievalSummary.qualityMetrics?.semanticScoringUsed ||
      retrievalSummary.semanticScoringUsed
    );
    const semanticScoringRequested = Boolean(
      controls.graphRAGPayload.semanticScoringRequested ||
      retrievalSummary.semanticScoringRequested ||
      controls.enableSemanticScoring === true ||
      controls.graphRAGPayload.enableSemanticScoring === true
    );
    const semanticScoringFallback =
      controls.graphRAGPayload.semanticScoringFallback === true ||
      retrievalSummary.semanticScoringFallback === true ||
      (semanticScoringRequested && semanticScoringUsed === false);

    retrievalSummary.semanticScoringRequested = semanticScoringRequested;
    retrievalSummary.semanticScoringUsed = semanticScoringUsed;
    if (semanticScoringFallback) {
      retrievalSummary.semanticScoringFallback = true;
    }

    retrievalSummary.passagesProvided = initialPassageCount;
    retrievalSummary.passagesUsedInPrompt = passagesUsed;
    if (trimmedCount > 0) {
      retrievalSummary.truncatedPassages = trimmedCount;
    }
    if (payload.budgetTrimmedCount) {
      retrievalSummary.truncatedForBudget = true;
      retrievalSummary.budgetTrimmedFrom = payload.budgetTrimmedFrom ?? initialPassageCount;
      retrievalSummary.budgetTrimmedTo = payload.budgetTrimmedTo ?? passagesUsed;
      if (payload.rankingStrategy) {
        retrievalSummary.budgetTrimmedStrategy = payload.rankingStrategy;
      }
    }
    retrievalSummary.includedInPrompt = graphRAGIncluded;

    promptMeta.graphRAG = retrievalSummary;
  }

  if (controls.ephemerisContext?.available) {
    promptMeta.ephemeris = {
      available: true,
      moonPhase: controls.ephemerisContext.moonPhase?.phaseName,
      retrogradeCount: controls.ephemerisContext.retrogrades?.length || 0,
      transitResonances: controls.transitResonances?.length || 0
    };
  }

  if (controls.ephemerisForecast?.available) {
    promptMeta.forecast = {
      available: true,
      days: controls.ephemerisForecast.forecastDays,
      eventCount: controls.ephemerisForecast.events?.length || 0
    };
  }

  // Return final prompts (potentially truncated to fit hard cap)
  return { systemPrompt: finalSystem, userPrompt: finalUser, promptMeta, contextDiagnostics: diagnostics };
}

function getSpreadKeyFromName(name) {
  const map = {
    'Celtic Cross (Classic 10-Card)': 'celtic',
    'Three-Card Story (Past · Present · Future)': 'threeCard',
    'Five-Card Clarity': 'fiveCard',
    'One-Card Insight': 'single',
    'Relationship Snapshot': 'relationship',
    'Decision / Two-Path': 'decision'
  };
  return map[name] || 'general';
}

function buildSystemPrompt(spreadKey, themes, context, deckStyle, _userQuestion = '', options = {}) {
  const personalization = options.personalization || null;
  const depthPreference = personalization?.preferredSpreadDepth;
  const depthProfile = depthPreference ? getDepthProfile(depthPreference) : null;
  const isDeepDive = depthProfile?.key === 'deep';

  const lines = [
    'You are an agency-forward, trauma-informed tarot storyteller.',
    '',
    'CORE PRINCIPLES',
    '- Keep the querent’s agency and consent at the center. Emphasize trajectories and choices, not fixed fate.',
    '- In each section, loosely follow a story spine: name what is happening (WHAT), why it matters or how it arose (WHY), and what might be next in terms of options or small steps (WHAT’S NEXT). You can signal these shifts with connective phrases such as "Because...", "Therefore...", or "However..." where helpful.',
    '- Begin the Opening with 2–3 sentences naming the felt experience before introducing frameworks (elemental map, spread overview, positional lenses).',
    '- Speak in warm, grounded language. Avoid heavy jargon; use brief astrological or Qabalah notes only when they clearly support the card\'s core Rider–Waite–Smith meaning.',
    '- Only reference cards explicitly provided in the spread. Do not introduce or imply additional cards (e.g., never claim The Fool appears unless it is actually in the spread).',
    '- When using Fool’s Journey or other archetypal stages, treat them as developmental context only—not as evidence that The Fool card is present.',
    '- Never offer medical, mental health, legal, financial, or abuse-safety directives. When those themes surface, gently encourage seeking qualified professional or community support.',
    '- Treat reversals according to the selected framework for this reading (see Reversal Framework below) and keep that lens consistent throughout.',
    '- If depth and brevity ever conflict, favor depth and clarity (especially for deep-dive preferences); hit the spirit of the guidance even if the exact word target flexes.'
  ];

  const includeDeckContext = options.includeDeckContext !== false;

  lines.push(
    '',
    'FORMATTING',
    '- Use Markdown with clear `###` section headings for major beats (for example, “### Opening”, “### The Story”, “### Guidance”, “### Gentle Next Steps”, “### Closing”).',
    '- Bold each card name the first time it appears.',
    '- For multi-card spreads, aim for ~120–160 words per card while respecting the total length guidance.',
    '- Prefer 4–6 moderately sized paragraphs plus one short bullet list of practical steps. Avoid filler.',
    '- Keep paragraphs to about 2–4 sentences; break up anything longer for readability.',
    '- Within each card section, you may use mini labels **WHAT**, **WHY**, **WHAT’S NEXT** to signal the spine; vary at least one card by opening with WHAT’S NEXT before backfilling WHAT and WHY to avoid a repetitive cadence.',
    '- OUTPUT STYLE: Do NOT preface the reading with "Here is your reading" or "I have analyzed the cards." Start directly with the Opening section or the first header.'
  );

  lines.push(
    '',
    'ESOTERIC LAYERS (OPTIONAL)',
    '- You may briefly reference astrology or Qabalah only when it clarifies the card’s core meaning for this querent.',
    '- For very practical questions (for example, career logistics or daily check-ins), prioritize concrete, grounded language over esoteric detail.',
    '- When you do mention these correspondences, keep them to one short sentence and avoid repeating the same formula for every card.',
    '- If the depth preference is deep, weave at most one reinforcing esoteric thread across the spread; otherwise keep esoteric notes optional and minimal.'
  );

  // Spread-specific flow hints
  if (spreadKey === 'celtic') {
    lines.push(
      '',
      'CELTIC CROSS FLOW: Move through Nucleus (1–2) → Timeline (3–1–4) → Consciousness (6–1–5) → Staff (7–10) → Cross-checks → Synthesis, so the story feels like one unfolding chapter rather than ten separate blurbs.'
    );
  } else if (spreadKey === 'threeCard') {
    lines.push(
      '',
      'THREE-CARD FLOW: Past → Present → Future. Show how each card leads into the next and note elemental support or tension along the way.'
    );
  } else if (spreadKey === 'relationship') {
    lines.push(
      '',
      'RELATIONSHIP FLOW: Explore the interplay between "You" and "Them" cards, then the Connection card as shared lesson. Include specific examples of communication, boundaries, and relational practices without telling the querent to stay or leave.'
    );
  }

  // Spread-proportional length guidance
  const SPREAD_LENGTH_GUIDANCE = {
    single: 'LENGTH: This is a single-card reading. Aim for ~300-400 words total—a focused insight rather than an exhaustive essay.',
    threeCard: 'LENGTH: This is a 3-card spread. Aim for ~500-700 words total—enough depth for each position without excessive elaboration.',
    fiveCard: 'LENGTH: This is a 5-card spread. Aim for ~700-900 words total—give each card meaningful attention while maintaining narrative flow.',
    decision: 'LENGTH: This is a 5-card decision spread. Aim for ~700-900 words total—ensure both paths receive balanced treatment.',
    relationship: 'LENGTH: This is a 3-card relationship spread. Aim for ~500-700 words total—explore each energy with care but stay concise.',
    celtic: 'LENGTH: This is a 10-card Celtic Cross. Aim for ~1000-1400 words total—weave the positions into a cohesive narrative rather than ten separate mini-readings.'
  };
  const lengthGuidance = SPREAD_LENGTH_GUIDANCE[spreadKey];
  if (lengthGuidance) {
    lines.push('', lengthGuidance);
    if (isDeepDive) {
      lines.push(
        'DEEP DIVE LENGTH: When the querent prefers deep dives, allow ~1500–1900 words. If the narrative exceeds ~1000 words, append a 120–150 word **Concise Recap** summarizing the arc and next steps.',
        'LENGTH PRIORITY: If depth and brevity conflict, prioritize depth and clarity over strict counts.'
      );
    } else {
      lines.push('LENGTH PRIORITY: If depth and brevity conflict, preserve clarity while staying close to the target band.');
    }
  }

  const reversalLens = formatReversalLens(themes, { includeExamples: true, includeReminder: true });
  if (reversalLens.lines.length) {
    lines.push('', 'REVERSAL FRAMEWORK', ...reversalLens.lines, '');
  }

  const includeGraphRAG = options.includeGraphRAG !== false;

  // GraphRAG: Inject traditional wisdom passages from pre-fetched payload
  if (includeGraphRAG && isGraphRAGEnabled(options.env) && themes?.knowledgeGraph?.graphKeys) {
    try {
      // Use pre-fetched payload from options (computed in buildEnhancedClaudePrompt)
      const payload = options.graphRAGPayload || themes?.knowledgeGraph?.graphRAGPayload || null;
      let retrievedPassages = Array.isArray(payload?.passages) && payload.passages.length
        ? payload.passages
        : null;

      if (retrievedPassages && retrievedPassages.length > 0) {
        // Adaptive passage count based on spread complexity
        const effectiveSpreadKey = spreadKey || 'general';
        const maxPassages = getPassageCountForSpread(effectiveSpreadKey);

        // Trim if needed
        if (retrievedPassages.length > maxPassages) {
          retrievedPassages = retrievedPassages.slice(0, maxPassages);
        }

        // Log quality metrics if passages have relevance scores
        const hasRelevanceScores = retrievedPassages.some(p => typeof p.relevanceScore === 'number');
        if (hasRelevanceScores) {
          const avgRelevance = retrievedPassages.reduce((sum, p) => sum + (p.relevanceScore || 0), 0) / retrievedPassages.length;
          console.log(`[GraphRAG] Injecting ${retrievedPassages.length} passages (avg relevance: ${(avgRelevance * 100).toFixed(1)}%)`);
        }

        let formattedPassages = payload.formattedBlock;
        if (!formattedPassages) {
          formattedPassages = formatPassagesForPrompt(retrievedPassages, {
            includeSource: true,
            markdown: true
          });
        }

        if (formattedPassages) {
          lines.push(
            '## TRADITIONAL WISDOM (GraphRAG)',
            '',
            formattedPassages,
            'INTEGRATION: Ground your interpretation in this traditional wisdom. These passages provide',
            'archetypal context from respected tarot literature. Weave their insights naturally',
            'into your narrative—don\'t quote verbatim, but let them inform your understanding',
            'of the patterns present in this spread.',
            'CARD GUARDRAIL: Do not add cards that are not in the spread. If a journey stage is mentioned, treat it as context only and do not assert that The Fool (or any other absent card) appears.',
            ''
          );
        }
      }
    } catch (err) {
      // GraphRAG failure should not break readings; log and continue
      console.error('[GraphRAG] Passage injection failed:', err.message);
    }
  }

  // Archetypal patterns are reading-specific - they go in user prompt only

  // Ephemeris: Real-time astrological context
  const includeEphemeris = options.includeEphemeris !== false;
  if (includeEphemeris && options.ephemerisContext?.available) {
    try {
      const astroSection = buildAstrologicalWeatherSection(options.ephemerisContext);
      if (astroSection) {
        lines.push('', astroSection, '');
      }
    } catch (err) {
      console.error('[Ephemeris] Astrological context build failed:', err.message);
    }
  }

  // Ephemeris Forecast: Upcoming astrological events (for seasonal/monthly questions)
  const includeForecast = options.includeForecast !== false;
  if (includeForecast && options.ephemerisForecast?.available) {
    try {
      const forecastSection = buildForecastSection(options.ephemerisForecast);
      if (forecastSection) {
        lines.push('', forecastSection, '');
      }
    } catch (err) {
      console.error('[Ephemeris] Forecast section build failed:', err.message);
    }
  }

  lines.push(
    '',
    'ETHICS',
    '- Emphasize choice, agency, and trajectory language; forbid deterministic guarantees or fatalism.',
    '- Do NOT provide diagnosis, treatment, or directives about medical, mental health, legal, financial, or abuse-safety matters.',
    '- When restricted themes surface, gently suggest consulting qualified professionals or trusted support resources.'
  );

  if (context && context !== 'general') {
    lines.push(
      '',
      `CONTEXT LENS: The query falls within the ${getContextDescriptor(context)} realm. Ensure interpretations address this context while prioritizing the specific nuances of the user's actual text.`
    );
  }

  const deckNotes = getDeckStyleNotes(deckStyle);
  if (deckNotes && includeDeckContext) {
    lines.push(
      '',
      `DECK STYLE: ${deckNotes.label}. ${deckNotes.cue || ''}`.trim(),
      deckNotes.palette ? `Palette cues: ${deckNotes.palette}.` : ''
    );
    if (deckNotes.tips.length > 0) {
      lines.push('', 'Follow these deck-specific nuances:');
      deckNotes.tips.forEach((tip) => lines.push(`- ${tip}`));
    }
  }

  lines.push(
    '',
    'SYNTHESIS RULE: Use the **Traditional Wisdom** (GraphRAG) to understand the core archetype (the "What"). Use the **Visual Profile** (Vision) to determine the specific manifestation or emotional texture (the "How"). If the Visual Profile contradicts the Traditional Wisdom (e.g., a dark Sun card), explicitly acknowledge this tension in the narrative if it adds depth—interpret it as the archetype expressing itself through that specific visual lens (e.g., "joy found in darkness").',
    '',
    'GPT-5.1 DIRECTIVES:',
    '- PLAN FIRST: Before drafting, briefly plan the arc (sections, card order, actionable bulleted micro-steps) so the final response flows logically.',
    '- PERSIST UNTIL COMPLETE: Carry the reading through analysis, synthesis, and a short closing encouragement without stopping early or punting back to the user unless critical information is missing.',
    '- SELF-VERIFY: After composing, quickly scan to ensure each referenced card/position is accurate, reversal instructions are obeyed, and the specific *visual profile* (tone/emotion) of the user\'s deck is reflected in the descriptive language before producing the final answer.'
  );

  const toneKey = personalization?.readingTone;
  const frameKey = personalization?.spiritualFrame;
  const hasToneSection = toneKey && TONE_GUIDANCE[toneKey];
  const hasFrameSection = frameKey && FRAME_GUIDANCE[frameKey];

  if (hasToneSection || hasFrameSection) {
    const basePrompt = lines.join('\n');
    const maxTokenBudget = Number.isFinite(options.maxTokenBudget) ? options.maxTokenBudget : null;
    const baseTokens = estimateTokenCount(basePrompt);
    const remainingBudget = maxTokenBudget ? maxTokenBudget - baseTokens : Infinity;
    if (remainingBudget > 400) {
      if (hasToneSection) {
        lines.push('', '## Reading Tone', TONE_GUIDANCE[toneKey], '');
      }
      if (hasFrameSection) {
        lines.push('', '## Interpretive Frame', FRAME_GUIDANCE[frameKey], '');
      }
    }
  }

  if (depthProfile && depthProfile.systemGuidance && depthProfile.key !== 'standard') {
    lines.push('', '## Narrative Depth Preference', depthProfile.systemGuidance, '');
  }

  return lines.join('\n');
}

function buildUserPrompt(
  spreadKey,
  cardsInfo,
  userQuestion,
  reflectionsText,
  themes = {},
  spreadAnalysis,
  context,
  visionInsights,
  deckStyle,
  promptOptions = {}
) {
  const personalization = promptOptions.personalization || null;
  const displayName =
    typeof personalization?.displayName === 'string'
      ? personalization.displayName.trim()
      : '';
  const depthPreference = personalization?.preferredSpreadDepth;
  const depthProfile = depthPreference ? getDepthProfile(depthPreference) : null;
  const activeThemes = typeof themes === 'object' && themes !== null ? themes : {};
  const reversalDescriptor = activeThemes.reversalDescription || { ...DEFAULT_REVERSAL_DESCRIPTION };
  let prompt = ``;

  const includeDeckContext = promptOptions.includeDeckContext !== false;
  const includeDiagnostics = promptOptions.includeDiagnostics !== false;

  // Question
  let questionLine = userQuestion || '(No explicit question; speak to the energy most present for the querent.)';
  if (displayName && userQuestion) {
    questionLine = `${displayName}, you asked: ${userQuestion}`;
  } else if (displayName && !userQuestion) {
    questionLine = `${displayName} did not pose a question—attune to the energy most present for them.`;
  }
  prompt += `**Question**: ${questionLine}\n\n`;

  if (displayName) {
    prompt += `**Name Usage**:\n- Weave the querent's name naturally in key transitions (for example, "For you, ${displayName}, this suggests...").\n- Open with a direct acknowledgement such as "${displayName}, you asked..." and close with "Remember, ${displayName}, ..." to keep the reading personal without overusing the name.\n\n`;
  }

  if (depthProfile && depthProfile.promptReminder && depthProfile.key !== 'standard') {
    prompt += `**Depth Preference**: ${depthProfile.promptReminder}\n\n`;
  }

  // Deck style name only - detailed tips are in system prompt
  const deckNotes = getDeckStyleNotes(deckStyle);
  if (deckNotes && deckStyle !== 'rws-1909') {
    prompt += `**Deck Style**: ${deckNotes.label} (see system prompt for interpretation guidelines)\n\n`;
  }

  // Thematic context
  const thematicLines = [];
  if (context && context !== 'general') {
    thematicLines.push(`- Context lens: Focus the narrative through ${getContextDescriptor(context)}`);
  }
  if (activeThemes.suitFocus) thematicLines.push(`- ${activeThemes.suitFocus}`);
  if (activeThemes.archetypeDescription) thematicLines.push(`- ${activeThemes.archetypeDescription}`);
  if (activeThemes.elementalBalance) thematicLines.push(`- ${activeThemes.elementalBalance}`);
  if (Array.isArray(personalization?.focusAreas) && personalization.focusAreas.length > 0) {
    const focusList = personalization.focusAreas.slice(0, 5).join(', ');
    thematicLines.push(`- Focus areas (from onboarding): ${focusList}`);
  }
  if (activeThemes.timingProfile) {
    const timingDescriptions = {
      'near-term-tilt': 'Timing: This reading leans toward near-term shifts if you engage actively with the guidance.',
      'longer-arc-tilt': 'Timing: This pattern unfolds across a longer structural arc requiring patience and sustained attention.',
      'developing-arc': 'Timing: Expect this to emerge as a meaningful chapter rather than a single moment.'
    };
    const timingText = timingDescriptions[activeThemes.timingProfile];
    if (timingText) {
      thematicLines.push(`- ${timingText}`);
    }
  }
  thematicLines.push(`- Reversal framework: ${reversalDescriptor.name}`);
  prompt += `**Thematic Context**:\n${thematicLines.join('\n')}\n\n`;

  if (activeThemes?.knowledgeGraph?.narrativeHighlights?.length) {
    prompt += '**Archetypal Patterns** (weave naturally, not mechanically):\n';
    activeThemes.knowledgeGraph.narrativeHighlights.slice(0, 5).forEach((highlight, _index) => {
      const label = highlight?.text || '';
      if (!label) return;
      prompt += `- ${label}\n`;
    });
    prompt += '\n';
  }

  // Transit resonances from ephemeris
  const includeEphemeris = promptOptions.includeEphemeris !== false;
  if (includeEphemeris && promptOptions.transitResonances?.length > 0) {
    const transitNotes = buildCardTransitNotes(promptOptions.transitResonances);
    if (transitNotes) {
      prompt += transitNotes + '\n\n';
    }
  }

  // Timing guidance from ephemeris
  if (includeEphemeris && promptOptions.ephemerisContext?.available) {
    const timingHints = generateTimingGuidance(promptOptions.ephemerisContext, spreadKey);
    if (timingHints?.length > 0) {
      prompt += '**Astrological Timing**:\n';
      timingHints.forEach(hint => {
        prompt += `- ${hint}\n`;
      });
      prompt += '\n';
    }
  }

  // Spread-specific card presentation
  if (spreadKey === 'celtic' && spreadAnalysis) {
    prompt += buildCelticCrossPromptCards(cardsInfo, spreadAnalysis, activeThemes, context, userQuestion, visionInsights, promptOptions);
  } else if (spreadKey === 'threeCard' && spreadAnalysis) {
    prompt += buildThreeCardPromptCards(cardsInfo, spreadAnalysis, activeThemes, context, userQuestion, visionInsights, promptOptions);
  } else if (spreadKey === 'fiveCard' && spreadAnalysis) {
    prompt += buildFiveCardPromptCards(cardsInfo, spreadAnalysis, activeThemes, context, visionInsights, promptOptions);
  } else if (spreadKey === 'relationship') {
    prompt += buildRelationshipPromptCards(cardsInfo, activeThemes, context, visionInsights, promptOptions);
  } else if (spreadKey === 'decision') {
    prompt += buildDecisionPromptCards(cardsInfo, activeThemes, context, visionInsights, promptOptions);
  } else if (spreadKey === 'single') {
    prompt += buildSingleCardPrompt(cardsInfo, activeThemes, context, visionInsights, promptOptions);
  } else {
    prompt += buildStandardPromptCards(spreadKey, cardsInfo, activeThemes, context, visionInsights, promptOptions);
  }

  const deckSpecificContext = buildDeckSpecificContext(deckStyle, cardsInfo, { includeDeckContext });
  if (deckSpecificContext) {
    prompt += deckSpecificContext;
  }

  // Reflections (Fallback for legacy/aggregate usage)
  const hasPerCardReflections = cardsInfo.some(c => c.userReflection);
  if (!hasPerCardReflections && reflectionsText && reflectionsText.trim()) {
    const sanitizedReflections = sanitizeAndTruncate(reflectionsText, MAX_REFLECTION_TEXT_LENGTH);
    if (sanitizedReflections) {
      prompt += `\n**Querent's Reflections**:\n${sanitizedReflections}\n\n`;
    }
  }

  const visionSection = buildVisionValidationSection(visionInsights, { includeDiagnostics });
  if (visionSection) {
    prompt += visionSection;
  }

  // Instructions (minimal - detailed rules are in system prompt)
  prompt += `\nPlease now write the reading following the system prompt guidelines. Ensure you:
- Do not introduce any card names beyond the provided spread; treat Fool’s Journey references as stage context only.
- Reference each card by name at least once
- Close with a trajectory reminder (choices shape outcomes)
- Apply the reversal lens consistently throughout`;

  return prompt;
}

function buildVisionValidationSection(visionInsights, options = {}) {
  if (options.includeDiagnostics === false) {
    return '';
  }

  if (!Array.isArray(visionInsights) || visionInsights.length === 0) {
    return '';
  }

  const safeEntries = visionInsights.slice(0, 5);
  const verifiedMatches = safeEntries.filter((entry) => entry.matchesDrawnCard === true).length;
  const mismatches = safeEntries.filter((entry) => entry.matchesDrawnCard === false).length;
  const unverified = safeEntries.length - verifiedMatches - mismatches;

  let coverageLine = 'Vision uploads include verification notes below.';
  if (mismatches === 0 && unverified === 0) {
    coverageLine = 'All uploaded cards align with the declared spread.';
  } else {
    const parts = [];
    if (mismatches > 0) {
      parts.push(`${mismatches} upload(s) did not match the selected cards—address gently if relevant.`);
    }
    if (unverified > 0) {
      parts.push(`${unverified} upload(s) could not be verified against the drawn spread; treat these as unverified evidence if you reference them.`);
    }
    coverageLine = parts.join(' ');
  }

  const lines = ['\n**Vision Validation**:', coverageLine];

  safeEntries.forEach((entry) => {
    const safeLabel = formatVisionLabelForPrompt(entry.label);
    const confidenceText = typeof entry.confidence === 'number'
      ? `${(entry.confidence * 100).toFixed(1)}%`
      : 'confidence unavailable';
    const basisText = entry.basis ? ` via ${entry.basis}` : '';
    let validationNote = '';
    if (entry.matchesDrawnCard === false) {
      validationNote = ' [not in drawn spread]';
    } else if (entry.matchesDrawnCard === null || typeof entry.matchesDrawnCard === 'undefined') {
      validationNote = ' [unverified upload]';
    }
    lines.push(`- ${safeLabel}: recognized as ${entry.predictedCard}${basisText} (${confidenceText})${validationNote}`);

    if (entry.symbolVerification && typeof entry.symbolVerification === 'object') {
      const sv = entry.symbolVerification;
      const matchRate = typeof sv.matchRate === 'number' ? `${(sv.matchRate * 100).toFixed(1)}% symbol alignment` : null;
      const missingList = Array.isArray(sv.missingSymbols) && sv.missingSymbols.length
        ? `missing: ${sv.missingSymbols.join(', ')}`
        : null;
      const symbolLine = [matchRate, missingList].filter(Boolean).join(' | ');
      if (symbolLine) {
        lines.push(`  · Symbol check: ${symbolLine}`);
      }
    }

    if (Array.isArray(entry.matches) && entry.matches.length) {
      const preview = entry.matches
        .slice(0, 2)
        .map((match) => {
          if (!match?.card) return null;
          if (typeof match.score === 'number') {
            return `${match.card} ${(match.score * 100).toFixed(1)}%`;
          }
          return match.card;
        })
        .filter(Boolean)
        .join('; ');
      if (preview) {
        lines.push(`  · Secondary matches: ${preview}`);
      }
    }

    if (entry.visualProfile) {
      const tone = Array.isArray(entry.visualProfile.tone) ? entry.visualProfile.tone.slice(0, 2).join(', ') : '';
      const emotion = Array.isArray(entry.visualProfile.emotion) ? entry.visualProfile.emotion.slice(0, 2).join(', ') : '';
      const parts = [];
      if (tone) parts.push(`Tone: [${tone}]`);
      if (emotion) parts.push(`Emotion: [${emotion}]`);

      if (parts.length > 0) {
        lines.push(`  · Visual Profile: ${parts.join(' | ')}`);
      }
    }
  });

  lines.push('');
  return `${lines.join('\n')}\n`;
}

function sanitizeAndTruncate(text = '', maxLength = 100) {
  if (!text || typeof text !== 'string') return '';
  const truncated = text.length > maxLength
    ? text.slice(0, maxLength).trim() + '...'
    : text.trim();
  return truncated
    .replace(/[#*`_[\]]/g, '')
    .replace(/\s+/g, ' ');
}

function buildCelticCrossPromptCards(cardsInfo, analysis, themes, context, userQuestion, visionInsights, promptOptions = {}) {
  const baseOptions = { ...getPositionOptions(themes, context), visionInsights };
  const optionsFor = (index, extra = {}) => ({
    ...makeCardOptions('celtic', index, baseOptions, promptOptions),
    ...extra
  });

  let cards = `**NUCLEUS** (Heart of the Matter):\n`;
  cards += buildCardWithImagery(cardsInfo[0], cardsInfo[0].position || 'Present — core situation (Card 1)', optionsFor(0));
  cards += buildCardWithImagery(cardsInfo[1], cardsInfo[1].position || 'Challenge — crossing / tension (Card 2)', optionsFor(1));
  cards += `Relationship insight: ${analysis.nucleus.synthesis}\n`;
  cards += getElementalImageryText(analysis.nucleus.elementalDynamic) + '\n\n';

  cards += `**TIMELINE**:\n`;
  cards += buildCardWithImagery(cardsInfo[2], cardsInfo[2].position || 'Past — what lies behind (Card 3)', optionsFor(2));

  const presentPosition = cardsInfo[0].position || 'Present — core situation (Card 1)';
  cards += buildCardWithImagery(
    cardsInfo[0],
    presentPosition,
    optionsFor(0, { prevElementalRelationship: analysis.timeline.pastToPresent }),
    getConnector(presentPosition, 'toPrev')
  );

  const futurePosition = cardsInfo[3].position || 'Near Future — what lies before (Card 4)';
  cards += buildCardWithImagery(
    cardsInfo[3],
    futurePosition,
    optionsFor(3, { prevElementalRelationship: analysis.timeline.presentToFuture }),
    getConnector(futurePosition, 'toPrev')
  );
  cards += `Flow insight: ${analysis.timeline.causality}\n`;
  cards += getElementalImageryText(analysis.timeline.pastToPresent) + '\n';
  cards += getElementalImageryText(analysis.timeline.presentToFuture) + '\n\n';

  cards += `**CONSCIOUSNESS**:\n`;
  cards += buildCardWithImagery(cardsInfo[5], cardsInfo[5].position || 'Subconscious — roots / hidden forces (Card 6)', optionsFor(5));
  cards += buildCardWithImagery(cardsInfo[4], cardsInfo[4].position || 'Conscious — goals & focus (Card 5)', optionsFor(4));
  cards += `Alignment insight: ${analysis.consciousness.synthesis}\n`;
  cards += getElementalImageryText(analysis.consciousness.elementalRelationship) + '\n\n';

  cards += `**STAFF** (Context & Outcome):\n`;
  cards += buildCardWithImagery(cardsInfo[6], cardsInfo[6].position || 'Self / Advice — how to meet this (Card 7)', optionsFor(6));
  cards += buildCardWithImagery(cardsInfo[7], cardsInfo[7].position || 'External Influences — people & environment (Card 8)', optionsFor(7));
  cards += buildCardWithImagery(cardsInfo[8], cardsInfo[8].position || 'Hopes & Fears — deepest wishes & worries (Card 9)', optionsFor(8));

  const outcomeLabel = userQuestion
    ? `Outcome — likely path for "${sanitizeAndTruncate(userQuestion)}" if unchanged (Card 10)`
    : 'Outcome — likely path if unchanged (Card 10)';

  cards += buildCardWithImagery(cardsInfo[9], cardsInfo[9].position || outcomeLabel, optionsFor(9));
  cards += `Advice-to-outcome insight: ${analysis.staff.adviceImpact}\n`;
  cards += getElementalImageryText(analysis.staff.adviceToOutcome) + '\n\n';

  cards += `**KEY CROSS-CHECKS**:\n`;
  cards += buildPromptCrossChecks(analysis.crossChecks, themes);

  cards += `\n\n**POSITION INTERPRETATION NOTES**:\n`;
  cards += `- Present (1): Anchor for all axes; core atmosphere of this moment\n`;
  cards += `- Challenge (2): Obstacle to integrate, not to defeat\n`;
  cards += `- Past (3): Foundation influencing current state\n`;
  cards += `- Near Future (4): Next chapter; cross-check with Outcome\n`;
  cards += `- Conscious (5): Stated goals; verify alignment with Outcome\n`;
  cards += `- Subconscious (6): Hidden drivers; mirror with Hopes/Fears\n`;
  cards += `- Advice (7): Active guidance; assess impact on Outcome\n`;
  cards += `- External (8): Environmental context, not command\n`;
  cards += `- Hopes/Fears (9): Mixed desires/anxieties\n`;
  cards += `- Outcome (10): Trajectory if unchanged, never deterministic\n`;

  return cards;
}

function buildThreeCardPromptCards(cardsInfo, analysis, themes, context, userQuestion, visionInsights, promptOptions = {}) {
  const baseOptions = { ...getPositionOptions(themes, context), visionInsights };
  const optionsFor = (index, extra = {}) => ({
    ...makeCardOptions('threeCard', index, baseOptions, promptOptions),
    ...extra
  });
  const [past, present, future] = cardsInfo;

  let cards = `**THREE-CARD STORY STRUCTURE**\n`;
  cards += `- Past foundation\n- Present dynamics\n- Future trajectory if nothing shifts\n\n`;

  cards += buildCardWithImagery(
    past,
    past.position || 'Past — influences that led here',
    optionsFor(0)
  );

  const presentPosition = present.position || 'Present — where you stand now';
  cards += buildCardWithImagery(
    present,
    presentPosition,
    optionsFor(1, {
      prevElementalRelationship: analysis?.transitions?.firstToSecond
    }),
    getConnector(presentPosition, 'toPrev')
  );

  const futureLabel = userQuestion
    ? `Future — likely trajectory for "${sanitizeAndTruncate(userQuestion)}" if nothing shifts`
    : 'Future — trajectory if nothing shifts';

  const futurePosition = future.position || futureLabel;
  cards += buildCardWithImagery(
    future,
    futurePosition,
    optionsFor(2, {
      prevElementalRelationship: analysis?.transitions?.secondToThird
    }),
    getConnector(futurePosition, 'toPrev')
  );

  if (analysis?.narrative) {
    cards += `\n${analysis.narrative.trim()}\n`;
  }

  cards += '\nThis future position points toward the most likely trajectory if nothing shifts, inviting you to adjust your path with intention.';

  return cards;
}

/**
 * Find vision insight for a specific card by matching card name
 */
function findVisionInsightForCard(cardName, visionInsights) {
  if (!Array.isArray(visionInsights) || !cardName) return null;

  const normalized = cardName.toLowerCase().trim();
  return visionInsights.find(
    insight => insight?.predictedCard?.toLowerCase().trim() === normalized
  );
}

function shouldIncludeImageryForPosition(spreadKey, positionIndex, promptOptions = {}) {
  if (!promptOptions.omitLowWeightImagery) return true;
  return getPositionWeight(spreadKey, positionIndex) >= DEFAULT_WEIGHT_DETAIL_THRESHOLD;
}

function makeCardOptions(spreadKey, positionIndex, baseOptions, promptOptions = {}) {
  const includeImagery = shouldIncludeImageryForPosition(spreadKey, positionIndex, promptOptions);
  return {
    ...baseOptions,
    omitImagery: !includeImagery
  };
}

/**
 * Build card text with imagery hook for prompts
 * Now includes vision-detected visual profile (tone/emotion) when available
 */
function buildCardWithImagery(cardInfo, position, options, prefix = '') {
  const safeOptions = options || {};
  const base = buildPositionCardText(cardInfo, position, safeOptions);
  const lead = prefix ? `${prefix} ${base}` : base;
  let text = `${lead}\n`;

  // Check if vision profile exists for this card
  const visionInsight = findVisionInsightForCard(cardInfo.card, safeOptions.visionInsights);
  const visualProfile = visionInsight?.visualProfile;
  const allowImagery = !safeOptions.omitImagery;

  // Add imagery hook if Major Arcana
  if (allowImagery && isMajorArcana(cardInfo.number)) {
    const hook = getImageryHook(cardInfo.number, cardInfo.orientation);
    if (hook) {
      text += `*Imagery: ${hook.visual}*\n`;
      text += `*Sensory: ${hook.sensory}*\n`;

      // NEW: Add vision-detected tone if available
      if (visualProfile?.tone?.length) {
        const toneDescriptors = visualProfile.tone.slice(0, 2).join(', ');
        text += `*Vision-detected tone: ${toneDescriptors} — interpret the archetype through this visual lens*\n`;
      }

      // NEW: Add vision-detected emotion if available
      if (visualProfile?.emotion?.length) {
        const emotionDescriptors = visualProfile.emotion.slice(0, 2).join(', ');
        text += `*Emotional quality: ${emotionDescriptors}*\n`;
      }
    }
  } else if (allowImagery && cardInfo.suit && cardInfo.rank) {
    const suitElements = {
      Wands: 'Fire',
      Cups: 'Water',
      Swords: 'Air',
      Pentacles: 'Earth'
    };
    const element = suitElements[cardInfo.suit];
    if (element) {
      text += `*Minor Arcana: ${cardInfo.suit} (${element}) — ${cardInfo.rank}*\n`;

      // NEW: Add vision-detected emotional quality for Minor cards
      if (visualProfile?.emotion?.length) {
        const emotionDescriptors = visualProfile.emotion.slice(0, 2).join(', ');
        text += `*Vision-detected emotion: ${emotionDescriptors}*\n`;
      }
    }
  }

  if (cardInfo.userReflection) {
    text += `*Querent's Reflection: "${sanitizeAndTruncate(cardInfo.userReflection)}"*\n`;
  }

  return text;
}

function buildDeckSpecificContext(deckStyle, cardsInfo, options = {}) {
  if (options.includeDeckContext === false) return '';

  if (!Array.isArray(cardsInfo) || cardsInfo.length === 0) {
    return '';
  }

  if (deckStyle === 'thoth-a1') {
    const lines = cardsInfo
      .map((card) => {
        const key = (card?.card || card?.name || '').trim();
        if (!key) return null;
        const info = THOTH_MINOR_TITLES[key];
        if (!info) return null;
        const header = card.position ? `${card.position}` : key;
        const astrology = info.astrology ? ` (${info.astrology})` : '';
        return `- ${header}: **${info.title}**${astrology} — ${info.description}`;
      })
      .filter(Boolean);
    if (!lines.length) {
      return '';
    }
    return `\n**Thoth Titles & Decans**:\n${lines.join('\n')}\n\n`;
  }

  if (deckStyle === 'marseille-classic') {
    const lines = cardsInfo
      .map((card) => {
        const rankValue = typeof card?.rankValue === 'number' ? card.rankValue : null;
        const theme = rankValue ? MARSEILLE_NUMERICAL_THEMES[rankValue] : null;
        if (!theme) return null;
        const header = card.position ? `${card.position}` : (card.card || `Pip ${rankValue}`);
        return `- ${header}: Pip ${rankValue} (${theme.keyword}) — ${theme.description}`;
      })
      .filter(Boolean);
    if (!lines.length) {
      return '';
    }
    return `\n**Marseille Pip Geometry**:\n${lines.join('\n')}\n\n`;
  }

  return '';
}

/**
 * Get elemental imagery text for prompts
 */
function getElementalImageryText(elementalRelationship) {
  if (!elementalRelationship || !elementalRelationship.elements) {
    return '';
  }

  const [e1, e2] = elementalRelationship.elements;
  const imagery = getElementalImagery(e1, e2);

  if (imagery && imagery.imagery) {
    return `*Elemental imagery: ${imagery.imagery}*`;
  }

  return '';
}

function buildFiveCardPromptCards(cardsInfo, fiveCardAnalysis, themes, context, visionInsights, promptOptions = {}) {
  const baseOptions = { ...getPositionOptions(themes, context), visionInsights };
  const optionsFor = (index, extra = {}) => ({
    ...makeCardOptions('fiveCard', index, baseOptions, promptOptions),
    ...extra
  });
  const [core, challenge, hidden, support, direction] = cardsInfo;

  let out = `**FIVE-CARD CLARITY STRUCTURE**\n`;
  out += `- Core of the matter\n- Challenge or tension\n- Hidden / subconscious influence\n- Support / helpful energy\n- Likely direction on current path\n\n`;

  out += buildCardWithImagery(core, core.position || 'Core of the matter', optionsFor(0));
  out += buildCardWithImagery(challenge, challenge.position || 'Challenge or tension', optionsFor(1, {
    prevElementalRelationship: fiveCardAnalysis?.coreVsChallenge
  }));
  out += buildCardWithImagery(hidden, hidden.position || 'Hidden / subconscious influence', optionsFor(2));
  out += buildCardWithImagery(support, support.position || 'Support / helpful energy', optionsFor(3));
  out += buildCardWithImagery(direction, direction.position || 'Likely direction on current path', optionsFor(4, {
    prevElementalRelationship: fiveCardAnalysis?.supportVsDirection
  }));

  return out;
}

function buildRelationshipPromptCards(cardsInfo, themes, context, visionInsights, promptOptions = {}) {
  const baseOptions = { ...getPositionOptions(themes, context), visionInsights };
  const optionsFor = (index, extra = {}) => ({
    ...makeCardOptions('relationship', index, baseOptions, promptOptions),
    ...extra
  });

  const [youCard, themCard, connectionCard, ...extraCards] = cardsInfo;

  let out = `**RELATIONSHIP SNAPSHOT STRUCTURE**\n`;
  out += `- You / your energy\n- Them / their energy\n- The connection / shared lesson\n\n`;

  if (youCard) {
    out += buildCardWithImagery(youCard, youCard.position || 'You / your energy', optionsFor(0));
  }
  if (themCard) {
    out += buildCardWithImagery(themCard, themCard.position || 'Them / their energy', optionsFor(1));
  }
  if (connectionCard) {
    out += buildCardWithImagery(
      connectionCard,
      connectionCard.position || 'The connection / shared lesson',
      optionsFor(2)
    );
  }

  if (extraCards.length > 0) {
    out += `\n**ADDITIONAL INSIGHT CARDS**\n`;
    extraCards.forEach((card, idx) => {
      if (!card) return;
      const label = card.position || `Additional insight ${idx + 1}`;
      out += buildCardWithImagery(card, label, optionsFor(idx + 3));
    });
  }

  return out;
}

function buildDecisionPromptCards(cardsInfo, themes, context, visionInsights, promptOptions = {}) {
  const baseOptions = { ...getPositionOptions(themes, context), visionInsights };
  const optionsFor = (index, extra = {}) => ({
    ...makeCardOptions('decision', index, baseOptions, promptOptions),
    ...extra
  });

  const [heart, pathA, pathB, clarifier, freeWill] = cardsInfo;

  let out = `**DECISION / TWO-PATH STRUCTURE**\n`;
  out += `- Heart of the decision\n- Path A — energy & likely outcome\n- Path B — energy & likely outcome\n- What clarifies the best path\n- What to remember about your free will\n\n`;

  if (heart) {
    out += buildCardWithImagery(
      heart,
      heart.position || 'Heart of the decision',
      optionsFor(0)
    );
  }
  if (pathA) {
    out += buildCardWithImagery(
      pathA,
      pathA.position || 'Path A — energy & likely outcome',
      optionsFor(1)
    );
  }
  if (pathB) {
    out += buildCardWithImagery(
      pathB,
      pathB.position || 'Path B — energy & likely outcome',
      optionsFor(2)
    );
  }
  if (clarifier) {
    out += buildCardWithImagery(
      clarifier,
      clarifier.position || 'What clarifies the best path',
      optionsFor(3)
    );
  }
  if (freeWill) {
    out += buildCardWithImagery(
      freeWill,
      freeWill.position || 'What to remember about your free will',
      optionsFor(4)
    );
  }

  return out;
}

function buildSingleCardPrompt(cardsInfo, themes, context, visionInsights, promptOptions = {}) {
  const baseOptions = { ...getPositionOptions(themes, context), visionInsights };
  const optionsFor = makeCardOptions('single', 0, baseOptions, promptOptions);
  const card = cardsInfo[0];
  if (!card) return '';

  let out = `**ONE-CARD INSIGHT STRUCTURE**\n`;
  out += `- Theme / Guidance of the Moment\n\n`;
  out += buildCardWithImagery(
    card,
    card.position || 'Theme / Guidance of the Moment',
    optionsFor
  );
  return out;
}

function buildStandardPromptCards(spreadKey, cardsInfo, themes, context, visionInsights, promptOptions = {}) {
  const baseOptions = { ...getPositionOptions(themes, context), visionInsights };

  return cardsInfo
    .map((card, idx) => {
      const position = card.position || `Card ${idx + 1}`;
      const options = makeCardOptions(spreadKey, idx, baseOptions, promptOptions);
      return buildCardWithImagery(card, position, options);
    })
    .join('\n') + '\n';
}

function buildPromptCrossChecks(crossChecks, themes) {
  const entries = [
    ['Goal vs Outcome', crossChecks.goalVsOutcome],
    ['Advice vs Outcome', crossChecks.adviceVsOutcome],
    ['Near Future vs Outcome', crossChecks.nearFutureVsOutcome],
    ['Subconscious vs Hopes/Fears', crossChecks.subconsciousVsHopesFears]
  ];

  return entries
    .map(([label, value]) => {
      if (!value) {
        return `- ${label}: No comparative insight available.`;
      }

      const shortenMeaning = meaning => {
        if (!meaning || typeof meaning !== 'string') return '';
        const firstClause = meaning.split(/[.!?]/)[0].trim();
        if (!firstClause) return '';
        return firstClause.length > 90 ? `${firstClause.slice(0, 87)}...` : firstClause;
      };

      const summarizePosition = position => {
        if (!position) return null;
        const base = `${position.name}: ${position.card} ${position.orientation}`.trim();
        const snippet = shortenMeaning(position.meaning);
        return snippet ? `${base} — ${snippet}` : base;
      };

      const reversalNotes = [
        getCrossCheckReversalNote(value.position1, themes),
        getCrossCheckReversalNote(value.position2, themes)
      ].filter(Boolean);

      const details = [];
      if (value.elementalRelationship?.relationship === 'tension') {
        details.push('⚠️ Elemental tension present.');
      } else if (value.elementalRelationship?.relationship === 'supportive') {
        details.push('✓ Elemental harmony present.');
      } else if (value.elementalRelationship?.relationship === 'amplified') {
        details.push('Elemental energies amplified.');
      }

      if (reversalNotes.length > 0) {
        details.push(reversalNotes.join(' '));
      }

      // Surface position summaries for clarity
      const positionsText = [summarizePosition(value.position1), summarizePosition(value.position2)]
        .filter(Boolean)
        .join(' | ');

      // Generate synthesis from structured data
      const synthesis = buildCrossCheckSynthesis(value);

      const parts = [`- ${label}: ${synthesis.trim()}`];
      if (positionsText) {
        parts.push(`(Positions: ${positionsText})`);
      }
      if (details.length > 0) {
        parts.push(details.join(' '));
      }

      return parts.join(' ');
    })
    .join('\n');
}

function _formatMeaning(meaning) {
  const sentence = meaning.includes('.') ? meaning.split('.')[0] : meaning;
  const lowerCased = sentence.trim();
  if (!lowerCased) {
    return 'fresh perspectives that are still unfolding';
  }
  return lowerCased.charAt(0).toLowerCase() + lowerCased.slice(1);
}
</file>

<file path="functions/lib/narrative/styleHelpers.js">
const DEFAULT_TONE = 'balanced';
const DEFAULT_FRAME = 'mixed';
const DEFAULT_DEPTH = 'standard';

export const TONE_STYLES = {
  gentle: {
    openingAdjectives: ['nurturing', 'supportive', 'encouraging'],
    challengeFraming: 'growth opportunity',
    closingTone: 'warm reassurance'
  },
  balanced: {
    openingAdjectives: ['thoughtful', 'measured', 'clear'],
    challengeFraming: 'honest acknowledgment',
    closingTone: 'grounded encouragement'
  },
  blunt: {
    openingAdjectives: ['direct', 'straightforward', 'clear-eyed'],
    challengeFraming: 'plain truth',
    closingTone: 'actionable clarity'
  }
};

export const FRAME_VOCABULARY = {
  psychological: ['archetype', 'shadow', 'integration', 'projection', 'individuation'],
  spiritual: ['soul', 'divine', 'sacred', 'cosmic', 'higher self'],
  mixed: ['energy', 'wisdom', 'insight', 'journey', 'growth'],
  playful: ['adventure', 'curious', 'explore', 'discover', 'wonder']
};

const DEPTH_STYLES = {
  short: {
    key: 'short',
    label: 'Quick check-in',
    cardDetail: 'concise',
    cardsHeading: '**Quick Card Highlights**',
    cardsNote: '_Condensed for a fast check-in. Return for a longer dive whenever you want more detail._',
    openingPreface: 'Quick check-in preference noted—here is the distilled throughline.',
    synthesisReminder: 'Because you prefer quick check-ins, focus on the single thread that sparks the most momentum and capture one actionable takeaway before you move on.',
    closingReminder: 'Keep it light; a single intentional step is enough for now.',
    systemGuidance: 'The querent prefers quick check-ins. Keep the reading lean: Opening → Throughline → One actionable Next Step. Limit paragraphs to 2–3 sentences and highlight the clearest immediate leverage point instead of exhaustive card-by-card essays.',
    promptReminder: 'Condensed check-in requested—hit the core tension, the lesson, and one micro action and avoid long digressions.'
  },
  standard: {
    key: 'standard',
    label: 'Balanced depth',
    cardDetail: 'standard',
    cardsHeading: null,
    cardsNote: '',
    openingPreface: '',
    synthesisReminder: '',
    closingReminder: '',
    systemGuidance: '',
    promptReminder: ''
  },
  deep: {
    key: 'deep',
    label: 'Deep dive',
    cardDetail: 'expansive',
    cardsHeading: '**Layered Card Weaving**',
    cardsNote: '_Extra layers included for your deep-dive preference so you can trace every thread._',
    openingPreface: 'Deep-dive preference noted—let’s walk through each layer with care.',
    synthesisReminder: 'Since you prefer deep dives, spend time journaling on the repeating symbols and consider pairing the guidance with ritual or somatic practice.',
    closingReminder: 'Give yourself space to sit with these layers and let them unfold at their own pace.',
    systemGuidance: 'The querent prefers deep dives. Offer a multi-layered narrative that traces positional relationships, elemental dynamics, and symbolism. Include journaling prompts or ritual suggestions when they add clarity.',
    promptReminder: 'Deep dive requested—trace card relationships, elemental/visual textures, and end with reflection or ritual prompts.'
  }
};

export function resolveToneKey(value) {
  return Object.prototype.hasOwnProperty.call(TONE_STYLES, value) ? value : DEFAULT_TONE;
}

export function resolveFrameKey(value) {
  return Object.prototype.hasOwnProperty.call(FRAME_VOCABULARY, value) ? value : DEFAULT_FRAME;
}

function resolveDepthKey(value) {
  return Object.prototype.hasOwnProperty.call(DEPTH_STYLES, value) ? value : DEFAULT_DEPTH;
}

export function getDepthProfile(value) {
  const key = resolveDepthKey(value);
  return DEPTH_STYLES[key] || DEPTH_STYLES[DEFAULT_DEPTH];
}

export function buildNameClause(displayName, position = 'inline') {
  if (typeof displayName !== 'string') return '';
  const trimmed = displayName.trim();
  if (!trimmed) return '';

  switch (position) {
    case 'opening':
      return `${trimmed}, `;
    case 'closing':
      return `, ${trimmed}`;
    case 'inline':
    default:
      return `, ${trimmed},`;
  }
}

export function getToneStyle(toneKey) {
  const key = resolveToneKey(toneKey);
  return TONE_STYLES[key] || TONE_STYLES[DEFAULT_TONE];
}

export function getFrameVocabulary(frameKey) {
  const key = resolveFrameKey(frameKey);
  return FRAME_VOCABULARY[key] || FRAME_VOCABULARY[DEFAULT_FRAME];
}

export function buildPersonalizedClosing(personalization) {
  if (!personalization) return '';
  const vocab = getFrameVocabulary(personalization.spiritualFrame);
  const tone = getToneStyle(personalization.readingTone);
  const closingName = buildNameClause(personalization.displayName, 'closing');
  const anchorWord = vocab[0] || 'wisdom';
  const toneDescriptor = tone.closingTone || 'steady encouragement';
  const depthProfile = getDepthProfile(personalization.preferredSpreadDepth);
  const base = `Remember${closingName || ''} the ${anchorWord} you already carry—let that ${toneDescriptor} shape what unfolds next.`;
  return depthProfile?.closingReminder ? `${base} ${depthProfile.closingReminder}` : base;
}
</file>

<file path="functions/lib/apiKeys.js">
/**
 * API Key management library for Mystic Tarot
 *
 * Handles generation, hashing, and validation of API keys.
 * Keys are stored as SHA-256 hashes.
 */

/**
 * Generate a new API key
 * Format: sk_<64 hex chars>
 * @returns {string} The raw API key (do not store this!)
 */
export function generateApiKey() {
  const randomBytes = new Uint8Array(32);
  crypto.getRandomValues(randomBytes);
  const hexString = Array.from(randomBytes).map(b => b.toString(16).padStart(2, '0')).join('');
  return `sk_${hexString}`;
}

/**
 * Hash an API key for storage
 * @param {string} key - The raw API key
 * @returns {Promise<string>} Hex-encoded SHA-256 hash
 */
export async function hashApiKey(key) {
  const encoder = new TextEncoder();
  const data = encoder.encode(key);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * Validate an API key
 * @param {D1Database} db - D1 database binding
 * @param {string} key - The raw API key to check
 * @returns {Promise<object|null>} The key record (with user_id) if valid, null otherwise
 */
export async function validateApiKey(db, key) {
  if (!key || !key.startsWith('sk_')) return null;

  const hash = await hashApiKey(key);
  
  const result = await db.prepare(`
    SELECT k.*, u.email, u.username
    FROM api_keys k
    JOIN users u ON k.user_id = u.id
    WHERE k.key_hash = ? AND k.is_active = 1
  `)
  .bind(hash)
  .first();

  if (!result) return null;

  // Check expiration
  if (result.expires_at && result.expires_at < Math.floor(Date.now() / 1000)) {
    return null;
  }

  // Update last_used_at
  // Note: In high concurrency, this write might be a bottleneck. 
  // Consider moving stats to KV or sampling updates if this becomes an issue.
  const now = Math.floor(Date.now() / 1000);
  await db.prepare('UPDATE api_keys SET last_used_at = ? WHERE id = ?')
    .bind(now, result.id)
    .run();

  return result;
}
</file>

<file path="functions/lib/auth.js">
import { validateApiKey } from './apiKeys.js';

/**
 * Authentication library for Mystic Tarot
 *
 * Uses Cloudflare Workers Web Crypto API with PBKDF2 for secure password hashing
 * and HTTP-only cookies for session management.
 *
 * Security features:
 * - PBKDF2 with 100,000 iterations (OWASP recommended)
 * - Cryptographically secure random salts
 * - HTTP-only, SameSite cookies
 * - Session expiration (30 days)
 */

const SESSION_DURATION = 30 * 24 * 60 * 60; // 30 days in seconds
const PBKDF2_ITERATIONS = 100000; // OWASP recommended minimum

/**
 * Hash a password using PBKDF2
 * @param {string} password - Plain text password
 * @param {Uint8Array} [salt] - Optional salt (generates new one if not provided)
 * @returns {Promise<{hash: string, salt: string}>} Hex-encoded hash and salt
 */
export async function hashPassword(password, salt) {
  // Generate salt if not provided
  if (!salt) {
    salt = crypto.getRandomValues(new Uint8Array(16));
  }

  // Convert password to ArrayBuffer
  const encoder = new TextEncoder();
  const passwordBuffer = encoder.encode(password);

  // Import password as key material
  const keyMaterial = await crypto.subtle.importKey(
    'raw',
    passwordBuffer,
    'PBKDF2',
    false,
    ['deriveBits']
  );

  // Derive key using PBKDF2
  const derivedBits = await crypto.subtle.deriveBits(
    {
      name: 'PBKDF2',
      salt: salt,
      iterations: PBKDF2_ITERATIONS,
      hash: 'SHA-256'
    },
    keyMaterial,
    256 // 32 bytes = 256 bits
  );

  // Convert to hex strings
  const hashArray = Array.from(new Uint8Array(derivedBits));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

  const saltArray = Array.from(salt);
  const saltHex = saltArray.map(b => b.toString(16).padStart(2, '0')).join('');

  return {
    hash: hashHex,
    salt: saltHex
  };
}

/**
 * Verify a password against a stored hash
 * @param {string} password - Plain text password to verify
 * @param {string} storedHash - Hex-encoded hash from database
 * @param {string} storedSalt - Hex-encoded salt from database
 * @returns {Promise<boolean>} True if password matches
 */
export async function verifyPassword(password, storedHash, storedSalt) {
  // Convert hex salt back to Uint8Array
  const saltBytes = new Uint8Array(
    storedSalt.match(/.{1,2}/g).map(byte => parseInt(byte, 16))
  );

  // Hash the provided password with the stored salt
  const { hash } = await hashPassword(password, saltBytes);

  // Timing-safe comparison (prevents timing attacks)
  return hash === storedHash;
}

/**
 * Generate a new session token
 * @returns {string} UUID v4 session token
 */
export function generateSessionToken() {
  return crypto.randomUUID();
}

/**
 * Create a session in the database
 * @param {D1Database} db - D1 database binding
 * @param {string} userId - User ID
 * @param {object} metadata - Optional session metadata (userAgent, ipAddress)
 * @returns {Promise<{token: string, expiresAt: number}>}
 */
export async function createSession(db, userId, metadata = {}) {
  const token = generateSessionToken();
  const now = Math.floor(Date.now() / 1000);
  const expiresAt = now + SESSION_DURATION;

  await db
    .prepare(`
      INSERT INTO sessions (id, user_id, created_at, expires_at, last_used_at, user_agent, ip_address)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `)
    .bind(
      token,
      userId,
      now,
      expiresAt,
      now,
      metadata.userAgent || null,
      metadata.ipAddress || null
    )
    .run();

  return { token, expiresAt };
}

/**
 * Validate a session token and return user info
 * @param {D1Database} db - D1 database binding
 * @param {string} token - Session token
 * @returns {Promise<object|null>} User object or null if invalid
 */
export async function validateSession(db, token) {
  if (!token) return null;

  const now = Math.floor(Date.now() / 1000);

  // Get session and join with user data
  const result = await db
    .prepare(`
      SELECT
        s.id as session_id,
        s.user_id,
        s.expires_at,
        u.id,
        u.email,
        u.username,
        u.is_active
      FROM sessions s
      JOIN users u ON s.user_id = u.id
      WHERE s.id = ? AND s.expires_at > ? AND u.is_active = 1
    `)
    .bind(token, now)
    .first();

  if (!result) return null;

  // Update last_used_at
  await db
    .prepare('UPDATE sessions SET last_used_at = ? WHERE id = ?')
    .bind(now, token)
    .run();

  return {
    id: result.user_id,
    email: result.email,
    username: result.username,
    sessionId: result.session_id
  };
}

/**
 * Delete a session (logout)
 * @param {D1Database} db - D1 database binding
 * @param {string} token - Session token
 * @returns {Promise<void>}
 */
export async function deleteSession(db, token) {
  await db
    .prepare('DELETE FROM sessions WHERE id = ?')
    .bind(token)
    .run();
}

/**
 * Delete all sessions for a user
 * @param {D1Database} db - D1 database binding
 * @param {string} userId - User ID
 * @returns {Promise<void>}
 */
export async function deleteAllUserSessions(db, userId) {
  await db
    .prepare('DELETE FROM sessions WHERE user_id = ?')
    .bind(userId)
    .run();
}

/**
 * Clean up expired sessions (should be run periodically)
 * @param {D1Database} db - D1 database binding
 * @returns {Promise<number>} Number of sessions deleted
 */
export async function cleanupExpiredSessions(db) {
  const now = Math.floor(Date.now() / 1000);

  const result = await db
    .prepare('DELETE FROM sessions WHERE expires_at <= ?')
    .bind(now)
    .run();

  return result.meta.changes || 0;
}

/**
 * Extract session token from cookie header
 * @param {string} cookieHeader - Cookie header string
 * @returns {string|null} Session token or null
 */
export function getSessionFromCookie(cookieHeader) {
  if (!cookieHeader) return null;

  const cookies = cookieHeader.split(';').map(c => c.trim());
  const sessionCookie = cookies.find(c => c.startsWith('session='));

  if (!sessionCookie) return null;

  return sessionCookie.split('=')[1];
}

/**
 * Create a secure session cookie header
 * @param {string} token - Session token
 * @param {number} expiresAt - Unix timestamp when session expires
 * @returns {string} Set-Cookie header value
 */
export function createSessionCookie(token, expiresAt) {
  const maxAge = expiresAt - Math.floor(Date.now() / 1000);

  return [
    `session=${token}`,
    'HttpOnly',
    'SameSite=Lax',
    'Secure',
    `Max-Age=${maxAge}`,
    'Path=/'
  ].join('; ');
}

/**
 * Create a cookie to clear the session
 * @returns {string} Set-Cookie header value
 */
export function clearSessionCookie() {
  return 'session=; HttpOnly; SameSite=Lax; Secure; Max-Age=0; Path=/';
}

/**
 * Validate email format
 * @param {string} email - Email address
 * @returns {boolean}
 */
export function isValidEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

/**
 * Validate username format (3-30 chars, alphanumeric + underscore)
 * @param {string} username - Username
 * @returns {boolean}
 */
export function isValidUsername(username) {
  const usernameRegex = /^[a-zA-Z0-9_]{3,30}$/;
  return usernameRegex.test(username);
}

/**
 * Validate password strength (min 8 chars)
 * @param {string} password - Password
 * @returns {boolean}
 */
export function isValidPassword(password) {
  return password && password.length >= 8;
}

/**
 * Resolve the authenticated user from a Request.
 * Supports Bearer session tokens, API keys, and session cookies.
 * @param {Request} request
 * @param {object} env - Environment bindings (requires env.DB)
 * @returns {Promise<object|null>} User object or null if unauthenticated
 */
export async function getUserFromRequest(request, env) {
  const authHeader = request.headers.get('Authorization');

  // Authorization: Bearer <token>
  if (authHeader && authHeader.startsWith('Bearer ')) {
    const token = authHeader.split(' ')[1];

    // API key path (Bearer sk_...)
    if (token && token.startsWith('sk_')) {
      const apiKeyRecord = await validateApiKey(env.DB, token);
      if (apiKeyRecord) {
        return {
          id: apiKeyRecord.user_id,
          email: apiKeyRecord.email,
          username: apiKeyRecord.username
        };
      }
    }

    // Session token path (Bearer <session>)
    const userFromHeader = await validateSession(env.DB, token);
    if (userFromHeader) {
      return userFromHeader;
    }
  }

  // Fallback to session cookie
  const cookieHeader = request.headers.get('Cookie');
  const sessionToken = getSessionFromCookie(cookieHeader);
  if (!sessionToken) return null;

  return validateSession(env.DB, sessionToken);
}
</file>

<file path="functions/lib/azureResponses.js">
export function ensureAzureConfig(env) {
  const endpoint = (env.AZURE_OPENAI_ENDPOINT || '').replace(/\/+$/, '');
  const apiKey = env.AZURE_OPENAI_API_KEY;
  const model = env.AZURE_OPENAI_GPT5_MODEL;

  if (!endpoint || !apiKey || !model) {
    throw new Error('Azure OpenAI configuration is missing.');
  }

  const apiVersion = env.AZURE_OPENAI_RESPONSES_API_VERSION || env.AZURE_OPENAI_API_VERSION || 'v1';

  return {
    endpoint,
    apiKey,
    model,
    apiVersion
  };
}

export async function callAzureResponses(env, { instructions, input, maxTokens = 900, reasoningEffort = 'medium', verbosity = 'medium' }) {
  const { endpoint, apiKey, model, apiVersion } = ensureAzureConfig(env);
  const url = `${endpoint}/openai/v1/responses?api-version=${encodeURIComponent(apiVersion)}`;

  // NOTE:
  // We intentionally DO NOT set the `reasoning` field here.
  // When `reasoning` is enabled, the model can consume the entire
  // `max_output_tokens` budget on reasoning tokens only, returning
  // only a `reasoning` block with `status: "incomplete"` and no
  // `output_text` / message content (as seen in the logs).
  //
  // For this endpoint we just want the final question text, so we
  // rely on the default behavior and request only text output.
  const body = {
    model,
    instructions,
    input,
    max_output_tokens: maxTokens,
    text: { verbosity }
  };

  // Debug logging for request metadata (no secrets)
  console.log('[azureResponses] Requesting Responses API', {
    url,
    model,
    apiVersion,
    maxTokens,
    reasoningEffort,
    verbosity
  });

  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'api-key': apiKey,
      'content-type': 'application/json'
    },
    body: JSON.stringify(body)
  });

  if (!response.ok) {
    const errText = await response.text().catch(() => '');
    console.warn('[azureResponses] Non-OK HTTP status from Azure Responses API', {
      status: response.status,
      statusText: response.statusText,
      bodyPreview: errText.slice(0, 500)
    });
    throw new Error(`Azure Responses API error ${response.status}: ${errText}`);
  }

  const data = await response.json();

  // Snapshot of the raw payload shape for debugging
  try {
    console.log('[azureResponses] Raw Azure Responses payload snapshot', {
      id: data.id,
      model: data.model,
      created: data.created,
      outputTypes: Array.isArray(data.output) ? data.output.map(block => block?.type) : typeof data.output,
      hasMessageBlocks: Array.isArray(data.output)
        ? data.output.some(block => block?.type === 'message')
        : false,
      hasOutputTextField: typeof data.output_text === 'string' && data.output_text.trim().length > 0
    });
  } catch (logError) {
    console.warn('[azureResponses] Failed to log Azure payload snapshot', logError);
  }

  if (data.output && Array.isArray(data.output)) {
    for (const block of data.output) {
      if (block.type === 'message') {
        const messagePieces = Array.isArray(block.content) ? block.content : [];
        for (const piece of messagePieces) {
          if (piece.type === 'output_text' && piece.text) {
            return piece.text.trim();
          }
        }
      }
    }
  }

  if (typeof data.output_text === 'string' && data.output_text.trim()) {
    return data.output_text.trim();
  }

  const serialized = JSON.stringify(data, null, 2);
  console.warn('[azureResponses] No output_text returned. Raw payload:', serialized?.slice(0, 2000));
  throw new Error('Azure Responses API returned no text content.');
}
</file>

<file path="functions/lib/cardContextDetection.js">
/**
 * Card context detection utilities
 * 
 * Provides functions for detecting explicit card references in text
 * while avoiding false positives from common vocabulary usage.
 */

/**
 * Escape special regex characters in a string
 * @param {string} text - Text to escape
 * @returns {string} Escaped text safe for use in RegExp
 */
export function escapeRegex(text = '') {
  return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

/**
 * Card names that are also common vocabulary and prone to false positives
 * when scanning free-form narrative text.
 */
export const AMBIGUOUS_CARD_NAMES = new Set([
  'justice',
  'strength',
  'temperance',
  'death',
  'judgement'
]);

/**
 * Phrases that reference card names in tarot terminology but are NOT
 * actual card references (e.g., "Fool's Journey" refers to the archetypal
 * journey through the Major Arcana, not The Fool card itself).
 */
export const TAROT_TERMINOLOGY_EXCLUSIONS = [
  /fool['\u2019]?s\s+journey/gi,   // "Fool's Journey" - handles both ' and ' (U+2019) apostrophes
  /major\s+arcana\s+journey/gi,    // "Major Arcana journey"
  /hero['\u2019]?s\s+journey/gi,   // "Hero's Journey" (related concept)
  /journey\s+(?:of|through)\s+(?:the\s+)?fool/gi  // "journey of the Fool"
];

/**
 * Require explicit "card-like" context around ambiguous names so that phrases like
 * "restore a sense of justice in how you negotiate" do not count as hallucinated
 * mentions of the Justice card.
 *
 * Detects card mentions via:
 * - Explicit card reference: "Justice card", "the Death card"
 * - Major Arcana context: "Justice (Major Arcana)", "Major Arcana: Death"
 * - Archetypal framing: "The Death archetype", "Strength archetype"
 * - Orientation markers: "Death reversed", "Justice upright"
 * - Markdown formatting: "**Death**", "**Justice**" (bold card names)
 * - Position labels: "Present: Death", "Card 1: Justice", "Outcome — Death"
 * 
 * @param {string} text - The text to search
 * @param {string} name - The card name to look for
 * @returns {boolean} True if explicit card context is found
 */
export function hasExplicitCardContext(text = '', name = '') {
  if (!text || !name) return false;

  const namePattern = escapeRegex(name);

  const patterns = [
    // "Justice card", "Death card", "the Strength card", etc.
    new RegExp(`\\b(?:the\\s+)?${namePattern}\\s+card\\b`, 'i'),

    // "Justice (Major Arcana)", "Major Arcana Justice", "Major Arcana: Death"
    new RegExp(`\\b${namePattern}\\b[^\\n]{0,40}\\bmajor arcana\\b`, 'i'),
    new RegExp(`\\bmajor arcana\\b[^\\n]{0,40}\\b${namePattern}\\b`, 'i'),

    // "The Death archetype", "Strength archetype", "archetype of Death"
    new RegExp(`\\b(?:the\\s+)?${namePattern}\\s+archetype\\b`, 'i'),
    new RegExp(`\\barchetype\\s+(?:of\\s+)?(?:the\\s+)?${namePattern}\\b`, 'i'),

    // "Death reversed", "Justice upright", "Strength (reversed)"
    new RegExp(`\\b${namePattern}\\s+(?:reversed|upright)\\b`, 'i'),
    new RegExp(`\\b${namePattern}\\s*\\(\\s*(?:reversed|upright)\\s*\\)`, 'i'),

    // Markdown bold formatting: "**Death**", "**Justice**"
    new RegExp(`\\*\\*${namePattern}\\*\\*`, 'i'),

    // Position labels: "Present: Death", "Card 1: Justice", "Outcome — Death"
    // Common position words followed by colon/dash and the card name
    new RegExp(`\\b(?:present|past|future|challenge|outcome|advice|anchor|core|heart|theme|guidance|position|card\\s*\\d+)\\s*[:\\-–—]\\s*(?:the\\s+)?${namePattern}\\b`, 'i'),

    // Card name followed by position context: "Death in the Present position"
    new RegExp(`\\b${namePattern}\\s+(?:in\\s+(?:the\\s+)?)?(?:present|past|future|challenge|outcome|advice|anchor)\\s+position\\b`, 'i')
  ];

  return patterns.some((regex) => regex.test(text));
}

/**
 * Normalize a card name for comparison
 * @param {string} value - Card name to normalize
 * @returns {string} Normalized (trimmed, lowercase) name
 */
export function normalizeCardName(value = '') {
  return value.trim().toLowerCase();
}

/**
 * Check if a card name is ambiguous (also common vocabulary)
 * @param {string} name - Card name to check
 * @returns {boolean} True if the name is ambiguous
 */
export function isAmbiguousCardName(name) {
  return AMBIGUOUS_CARD_NAMES.has(normalizeCardName(name));
}
</file>

<file path="functions/lib/contextDetection.js">
import { normalizeContext } from './narrative/helpers.js';

const SPREAD_CONTEXT_DEFAULTS = {
  relationship: 'love'
};

const CONTEXT_KEYWORDS = {
  love: [
    'relationship',
    'relationships',
    'romance',
    'romantic',
    'love',
    'partner',
    'partnership',
    'marriage',
    'married',
    'spouse',
    'crush',
    'dating',
    'soulmate',
    'twin flame',
    'connection',
    'couple',
    'lover',
    'feelings',
    'intimacy'
  ],
  career: [
    'career',
    'job',
    'work',
    'working',
    'boss',
    'coworker',
    'manager',
    'business',
    'client',
    'project',
    'promotion',
    'salary',
    'money',
    'finance',
    'finances',
    'income',
    'profession',
    'entrepreneur',
    'company',
    'office',
    'team',
    'coworkers'
  ],
  self: [
    'self',
    'myself',
    'personal',
    'healing',
    'heal',
    'wellbeing',
    'well-being',
    'wellness',
    'growth',
    'confidence',
    'mindset',
    'mental health',
    'boundary',
    'boundaries',
    'shadow',
    'inner child',
    'therapy',
    'habit',
    'habits',
    'self-care',
    'self care'
  ],
  spiritual: [
    'spiritual',
    'spirit',
    'soul',
    'soulpath',
    'purpose',
    'mission',
    'intuition',
    'psychic',
    'meditation',
    'meditate',
    'prayer',
    'ritual',
    'energy',
    'energetic',
    'chakra',
    'astrology',
    'ancestor',
    'guides',
    'universe',
    'divine'
  ]
};

function sanitizeQuestion(question) {
  return typeof question === 'string' ? question.trim().toLowerCase() : '';
}

function countMatches(text, keywords) {
  if (!text) return 0;
  let score = 0;
  for (const keyword of keywords) {
    if (keyword.includes(' ')) {
      if (text.includes(keyword)) {
        score += 3;
      }
    } else if (text.includes(keyword)) {
      score += 2;
    }
  }
  return score;
}

export function inferContext(userQuestion, spreadKey, options = {}) {
  const { onUnknown } = options;
  const normalizedSpreadKey = typeof spreadKey === 'string' ? spreadKey.toLowerCase() : '';
  const defaultContext = SPREAD_CONTEXT_DEFAULTS[normalizedSpreadKey] || null;

  const text = sanitizeQuestion(userQuestion);
  const scores = {
    love: 0,
    career: 0,
    self: 0,
    spiritual: 0
  };

  for (const [context, keywords] of Object.entries(CONTEXT_KEYWORDS)) {
    scores[context] = countMatches(text, keywords);
  }

  // Weight spread default slightly to break ties when relevant
  if (defaultContext) {
    scores[defaultContext] += 1;
  }

  let bestContext = 'general';
  let bestScore = 0;

  for (const [context, score] of Object.entries(scores)) {
    if (score > bestScore) {
      bestScore = score;
      bestContext = context;
    } else if (score === bestScore && score > 0) {
      // Tie-breaker priority: love > career > self > spiritual
      const priority = ['love', 'career', 'self', 'spiritual'];
      if (priority.indexOf(context) < priority.indexOf(bestContext)) {
        bestContext = context;
      }
    }
  }

  if (bestScore === 0 && defaultContext) {
    return normalizeContext(defaultContext, { onUnknown });
  }

  const detected = bestScore > 0 ? bestContext : 'general';
  return normalizeContext(detected, { onUnknown });
}
</file>

<file path="functions/lib/embeddings.js">
// functions/lib/embeddings.js
// Embeddings utility for GraphRAG quality filtering
//
// Provides text embedding via Azure OpenAI and cosine similarity calculation.
// Used by graphRAG.js for semantic scoring of passage relevance.

/**
 * Calculate cosine similarity between two vectors.
 * Returns 0-1 where 1 is identical direction.
 *
 * @param {number[]} a - First vector (normalized or unnormalized)
 * @param {number[]} b - Second vector (normalized or unnormalized)
 * @returns {number} Cosine similarity score (0-1)
 */
export function cosineSimilarity(a, b) {
  if (!a || !b || a.length !== b.length || a.length === 0) {
    return 0;
  }

  let dot = 0;
  let normA = 0;
  let normB = 0;

  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i];
    normA += a[i] * a[i];
    normB += b[i] * b[i];
  }

  const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
  if (magnitude === 0) {
    return 0;
  }

  // Clamp to [0, 1] to handle floating point imprecision
  return Math.max(0, Math.min(1, dot / magnitude));
}

/**
 * Normalize a vector to unit length.
 *
 * @param {number[]} vector - Input vector
 * @returns {number[]} Normalized vector
 */
export function normalizeVector(vector) {
  if (!vector || vector.length === 0) {
    return vector;
  }

  const norm = Math.sqrt(vector.reduce((sum, value) => sum + value * value, 0));
  if (!norm || Number.isNaN(norm)) {
    return vector;
  }

  return vector.map((value) => value / norm);
}

// Module-level cache for embeddings to avoid redundant API calls
const embeddingCache = new Map();
const MAX_CACHE_SIZE = 100;

/**
 * Get embedding for text using Azure OpenAI embeddings API.
 * Falls back to a simple hash-based pseudo-embedding if API is unavailable.
 *
 * @param {string} text - Text to embed
 * @param {Object} [options] - Options
 * @param {Object} [options.env] - Environment variables (for Cloudflare Workers)
 * @returns {Promise<number[]>} Embedding vector
 */
export async function embedText(text, options = {}) {
  if (!text || typeof text !== 'string') {
    return generateFallbackEmbedding('');
  }

  const trimmed = text.trim().slice(0, 8000); // Limit input length
  if (!trimmed) {
    return generateFallbackEmbedding('');
  }

  // Check cache first
  const cacheKey = trimmed.slice(0, 200); // Use prefix as cache key
  if (embeddingCache.has(cacheKey)) {
    return embeddingCache.get(cacheKey);
  }

  // Try Azure OpenAI embeddings
  const env = options.env || (typeof process !== 'undefined' && process.env ? process.env : {});
  const embedding = await fetchAzureEmbedding(trimmed, env);

  if (embedding) {
    // Cache the result
    if (embeddingCache.size >= MAX_CACHE_SIZE) {
      // Remove oldest entry (first key)
      const firstKey = embeddingCache.keys().next().value;
      embeddingCache.delete(firstKey);
    }
    embeddingCache.set(cacheKey, embedding);
    return embedding;
  }

  // Fallback to hash-based pseudo-embedding
  return generateFallbackEmbedding(trimmed);
}

/**
 * Fetch embedding from Azure OpenAI embeddings API.
 *
 * Uses the v1 API format for consistency with the Responses API.
 * See: https://learn.microsoft.com/en-us/azure/ai-foundry/openai/how-to/embeddings
 *
 * @param {string} text - Text to embed
 * @param {Object} env - Environment variables
 * @returns {Promise<number[]|null>} Embedding vector or null if unavailable
 */
async function fetchAzureEmbedding(text, env) {
  const endpoint = env?.AZURE_OPENAI_ENDPOINT;
  const apiKey = env?.AZURE_OPENAI_API_KEY;
  const embeddingModel = env?.AZURE_OPENAI_EMBEDDING_MODEL || 'text-embedding-3-large';
  // Azure OpenAI v1 embeddings path requires api-version=preview (literal string)
  // This is different from deployment-based paths which use date-based versions
  const apiVersion = env?.AZURE_OPENAI_EMBEDDINGS_API_VERSION || 'preview';

  if (!endpoint || !apiKey) {
    return null;
  }

  try {
    // Normalize endpoint: strip trailing slashes and any existing /openai/v1 path
    const normalizedEndpoint = endpoint
      .replace(/\/+$/, '')
      .replace(/\/openai\/v1\/?$/, '')
      .replace(/\/openai\/?$/, '');

    // V1 embeddings path with api-version=preview (required for this path)
    const url = `${normalizedEndpoint}/openai/v1/embeddings?api-version=${encodeURIComponent(apiVersion)}`;

    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'api-key': apiKey,
        'content-type': 'application/json'
      },
      body: JSON.stringify({
        input: text,
        model: embeddingModel
      })
    });

    if (!response.ok) {
      const errText = await response.text().catch(() => '');
      console.warn(`[Embeddings] Azure v1 API error ${response.status}: ${errText}`);
      return null;
    }

    const data = await response.json();
    const embedding = data?.data?.[0]?.embedding;

    if (Array.isArray(embedding) && embedding.length > 0) {
      return normalizeVector(embedding);
    }

    return null;
  } catch (err) {
    console.warn('[Embeddings] Azure embedding fetch failed:', err.message);
    return null;
  }
}

/**
 * Generate a fallback pseudo-embedding using simple text features.
 * This is NOT a real embedding but provides basic similarity detection
 * when the embeddings API is unavailable.
 *
 * @param {string} text - Text to process
 * @returns {number[]} Pseudo-embedding vector (128 dimensions)
 */
function generateFallbackEmbedding(text) {
  const DIMENSIONS = 128;
  const vector = new Array(DIMENSIONS).fill(0);

  if (!text) {
    return vector;
  }

  const normalized = text.toLowerCase();
  const words = normalized.match(/\w+/g) || [];

  // Feature 1: Character frequency distribution (26 dimensions)
  for (const char of normalized) {
    const code = char.charCodeAt(0);
    if (code >= 97 && code <= 122) {
      // a-z
      vector[code - 97] += 1;
    }
  }

  // Feature 2: Word length distribution (10 dimensions)
  for (const word of words) {
    const lengthBucket = Math.min(word.length, 10) - 1;
    if (lengthBucket >= 0) {
      vector[26 + lengthBucket] += 1;
    }
  }

  // Feature 3: Common word indicators (semantic hints, 32 dimensions)
  const semanticTerms = [
    'love', 'career', 'health', 'money', 'family', 'future', 'past', 'present',
    'change', 'growth', 'challenge', 'opportunity', 'fear', 'hope', 'strength', 'wisdom',
    'journey', 'path', 'decision', 'choice', 'relationship', 'work', 'spiritual', 'emotional',
    'mental', 'physical', 'energy', 'balance', 'transformation', 'healing', 'guidance', 'insight'
  ];

  for (let i = 0; i < semanticTerms.length && i < 32; i++) {
    if (normalized.includes(semanticTerms[i])) {
      vector[36 + i] = 1;
    }
  }

  // Feature 4: Tarot-specific terms (60 dimensions)
  const tarotTerms = [
    'fool', 'magician', 'priestess', 'empress', 'emperor', 'hierophant', 'lovers', 'chariot',
    'strength', 'hermit', 'wheel', 'justice', 'hanged', 'death', 'temperance', 'devil',
    'tower', 'star', 'moon', 'sun', 'judgement', 'world', 'wands', 'cups',
    'swords', 'pentacles', 'ace', 'two', 'three', 'four', 'five', 'six',
    'seven', 'eight', 'nine', 'ten', 'page', 'knight', 'queen', 'king',
    'reversed', 'upright', 'spread', 'reading', 'card', 'position', 'meaning', 'interpretation',
    'archetype', 'symbol', 'element', 'fire', 'water', 'air', 'earth', 'major',
    'minor', 'arcana', 'triad', 'dyad'
  ];

  for (let i = 0; i < tarotTerms.length && i < 60; i++) {
    if (normalized.includes(tarotTerms[i])) {
      vector[68 + i] = 1;
    }
  }

  // Normalize the vector
  return normalizeVector(vector);
}

/**
 * Clear the embedding cache (useful for testing)
 */
export function clearEmbeddingCache() {
  embeddingCache.clear();
}

/**
 * Get cache statistics (useful for monitoring)
 *
 * @returns {Object} Cache stats
 */
export function getEmbeddingCacheStats() {
  return {
    size: embeddingCache.size,
    maxSize: MAX_CACHE_SIZE
  };
}
</file>

<file path="functions/lib/ephemerisIntegration.js">
/**
 * Ephemeris Integration Module
 * Connects real-time astrological data to the tarot narrative builder system.
 *
 * Uses astronomy-engine (pure JavaScript) for Workers-compatible calculations.
 * No native Node.js addons required - works in Cloudflare Workers V8 isolates.
 */

import { getAstroForCard } from './esotericMeta.js';
import * as ephemerisWorkers from './ephemerisWorkers.js';

// Planet name normalization for matching
const PLANET_ALIASES = {
  'Sun': ['Sun', 'Solar'],
  'Moon': ['Moon', 'Luna', 'Lunar', 'The Moon'],
  'Mercury': ['Mercury'],
  'Venus': ['Venus'],
  'Mars': ['Mars'],
  'Jupiter': ['Jupiter'],
  'Saturn': ['Saturn'],
  'Uranus': ['Uranus'],
  'Neptune': ['Neptune'],
  'Pluto': ['Pluto']
};

// Sign name normalization
const SIGN_NAMES = [
  'Aries', 'Taurus', 'Gemini', 'Cancer', 'Leo', 'Virgo',
  'Libra', 'Scorpio', 'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces'
];

/**
 * Extract planet and sign from a card's astrological correspondence
 * e.g., "Mars in Aries" -> { planet: 'Mars', sign: 'Aries' }
 * e.g., "Mercury" -> { planet: 'Mercury', sign: null }
 * e.g., "Scorpio" -> { planet: null, sign: 'Scorpio' }
 */
function parseAstroLabel(label) {
  if (!label) return { planet: null, sign: null };

  // Check for "Planet in Sign" pattern
  const inMatch = label.match(/^(\w+)\s+in\s+(\w+)/i);
  if (inMatch) {
    return { planet: inMatch[1], sign: inMatch[2] };
  }

  // Check if it's just a planet
  for (const [planet] of Object.entries(PLANET_ALIASES)) {
    if (label.includes(planet)) {
      return { planet, sign: null };
    }
  }

  // Check if it's just a sign
  for (const sign of SIGN_NAMES) {
    if (label.includes(sign)) {
      return { planet: null, sign };
    }
  }

  return { planet: null, sign: null };
}

/**
 * Fetch ephemeris context using Workers-compatible astronomy-engine
 * Pure JavaScript - no native addons, works in V8 isolates
 */
export async function fetchEphemerisContext(timestamp = null, _options = {}) {
  try {
    const date = timestamp ? new Date(timestamp) : new Date();
    const isoTimestamp = date.toISOString();

    // Use Workers-compatible ephemeris module (astronomy-engine)
    const [positionsPayload, moonPhase, aspects, retrogrades] = await Promise.all([
      Promise.resolve(ephemerisWorkers.getCurrentPositions(isoTimestamp)),
      Promise.resolve(ephemerisWorkers.getMoonPhase(isoTimestamp)),
      Promise.resolve(ephemerisWorkers.getPlanetaryAspects(isoTimestamp, 5)), // 5° orb for tight aspects
      Promise.resolve(ephemerisWorkers.getRetrogradePlanets(isoTimestamp))
    ]);

    // Extract positions from payload
    const planetPositions = positionsPayload?.positions || positionsPayload || null;
    const positionsMeta = positionsPayload?.positions ? {
      timestamp: positionsPayload.timestamp
    } : null;

    return {
      timestamp: isoTimestamp,
      positions: planetPositions,
      positionsMeta,
      moonPhase,
      aspects,
      retrogrades,
      available: true,
      source: 'astronomy-engine' // Indicates pure JS source
    };
  } catch (err) {
    console.warn('[ephemerisIntegration] Failed to fetch ephemeris data:', err.message);
    return {
      timestamp: new Date().toISOString(),
      positions: null,
      moonPhase: null,
      aspects: null,
      retrogrades: null,
      available: false,
      error: err.message
    };
  }
}

/**
 * Match current transits to drawn cards
 * Returns resonance data for cards with active astrological alignments
 */
export function matchTransitsToCards(cardsInfo, ephemerisContext) {
  if (!ephemerisContext?.available || !cardsInfo?.length) {
    return [];
  }

  const resonances = [];
  const { positions, retrogrades } = ephemerisContext;

  // Build lookup maps
  const retrogradeSet = new Set(
    (retrogrades || []).map(r => r.planet?.toLowerCase())
  );

  const currentPlanetSigns = {};
  if (positions) {
    for (const [planet, data] of Object.entries(positions)) {
      currentPlanetSigns[planet.toLowerCase()] = data.sign;
    }
  }

  for (const cardInfo of cardsInfo) {
    const astro = getAstroForCard(cardInfo);
    if (!astro?.label) continue;

    const { planet, sign } = parseAstroLabel(astro.label);
    const cardName = cardInfo.card || cardInfo.name || 'Unknown';
    const position = cardInfo.position || '';

    // Check for planet retrograde match
    if (planet && retrogradeSet.has(planet.toLowerCase())) {
      const retroData = retrogrades.find(r =>
        r.planet?.toLowerCase() === planet.toLowerCase()
      );

      resonances.push({
        card: cardName,
        position,
        type: 'retrograde',
        planet,
        currentSign: retroData?.sign,
        cardCorrespondence: astro.label,
        interpretation: buildRetrogradeResonance(planet, cardInfo, retroData)
      });
    }

    // Check for planet-sign alignment
    if (planet && currentPlanetSigns[planet.toLowerCase()]) {
      const currentSign = currentPlanetSigns[planet.toLowerCase()];
      const isExactMatch = sign && currentSign.toLowerCase() === sign.toLowerCase();

      if (isExactMatch) {
        resonances.push({
          card: cardName,
          position,
          type: 'exact-transit',
          planet,
          currentSign,
          cardCorrespondence: astro.label,
          interpretation: buildExactTransitResonance(planet, sign, cardInfo)
        });
      } else if (!sign) {
        // Card corresponds to planet, planet is active
        resonances.push({
          card: cardName,
          position,
          type: 'planetary-emphasis',
          planet,
          currentSign,
          cardCorrespondence: astro.label,
          interpretation: buildPlanetaryEmphasis(planet, currentSign, cardInfo)
        });
      }
    }

    // Check for sign emphasis (Sun or other planets in the card's sign)
    if (sign && !planet) {
      const sunSign = currentPlanetSigns['sun'];
      if (sunSign?.toLowerCase() === sign.toLowerCase()) {
        resonances.push({
          card: cardName,
          position,
          type: 'solar-season',
          sign,
          interpretation: `The Sun currently transits ${sign}, amplifying ${cardName}'s themes`
        });
      }
    }
  }

  return resonances;
}

/**
 * Build interpretation text for retrograde resonance
 */
function buildRetrogradeResonance(planet, cardInfo, retroData) {
  const cardName = cardInfo.card || cardInfo.name;
  const isReversed = cardInfo.orientation?.toLowerCase() === 'reversed';

  const retroThemes = {
    Mercury: 'communication, planning, and mental clarity',
    Venus: 'relationships, values, and creative expression',
    Mars: 'action, drive, and assertiveness',
    Jupiter: 'expansion, beliefs, and opportunities',
    Saturn: 'structures, responsibilities, and long-term plans',
    Uranus: 'innovation, freedom, and sudden changes',
    Neptune: 'intuition, dreams, and spiritual matters',
    Pluto: 'transformation, power dynamics, and deep change'
  };

  const theme = retroThemes[planet] || 'its associated themes';

  if (isReversed) {
    return `${planet} retrograde in ${retroData?.sign || 'the heavens'} doubles the reflective quality of ${cardName} reversed—a strong call to review ${theme}`;
  }

  return `${planet} retrograde emphasizes ${cardName}'s invitation to revisit and reconsider ${theme}`;
}

/**
 * Build interpretation text for exact transit match
 */
function buildExactTransitResonance(planet, sign, cardInfo) {
  const cardName = cardInfo.card || cardInfo.name;
  return `${planet} currently transits ${sign}—the exact correspondence of ${cardName}—strengthening this card's influence in your reading`;
}

/**
 * Build interpretation for general planetary emphasis
 */
function buildPlanetaryEmphasis(planet, currentSign, cardInfo) {
  const cardName = cardInfo.card || cardInfo.name;
  return `${planet} (ruling ${cardName}) currently moves through ${currentSign}, coloring this card's expression`;
}

/**
 * Build the astrological weather section for the system prompt
 */
export function buildAstrologicalWeatherSection(ephemerisContext) {
  if (!ephemerisContext?.available) {
    return null;
  }

  const lines = ['## CURRENT ASTROLOGICAL CONTEXT'];
  const { moonPhase, retrogrades, aspects, positions } = ephemerisContext;

  // Moon phase
  if (moonPhase) {
    lines.push(`- **Lunar Phase**: ${moonPhase.phaseName} (${moonPhase.illumination}% illumination) in ${moonPhase.sign}`);
    if (moonPhase.interpretation) {
      lines.push(`  - ${moonPhase.interpretation}`);
    }
  }

  // Sun sign (current season)
  if (positions?.Sun) {
    lines.push(`- **Solar Season**: Sun in ${positions.Sun.sign} at ${positions.Sun.degree.toFixed(1)}°`);
  }

  // Retrogrades
  if (retrogrades?.length > 0) {
    const retroList = retrogrades.map(r => `${r.planet} in ${r.sign}`).join(', ');
    lines.push(`- **Retrograde Planets** (${retrogrades.length}): ${retroList}`);
    lines.push('  - Retrogrades suggest review, reflection, and revisiting rather than initiating');
  }

  // Tight aspects (orb < 2°)
  const tightAspects = (aspects || []).filter(a => a.orb < 2);
  if (tightAspects.length > 0) {
    lines.push('- **Active Aspects**:');
    for (const aspect of tightAspects.slice(0, 3)) {
      lines.push(`  - ${aspect.planet1} ${aspect.type} ${aspect.planet2} (${aspect.orb.toFixed(1)}° orb)`);
    }
  }

  lines.push('');
  lines.push('Use this astrological context to enrich timing guidance and thematic resonance, but keep the cards as the primary focus of the reading.');

  return lines.join('\n');
}

/**
 * Build card-specific transit notes for the user prompt
 */
export function buildCardTransitNotes(resonances) {
  if (!resonances?.length) {
    return null;
  }

  const lines = ['**Current Transit Resonances**:'];

  for (const res of resonances) {
    lines.push(`- ${res.card}: ${res.interpretation}`);
  }

  return lines.join('\n');
}

/**
 * Generate timing guidance based on moon phase and retrogrades
 */
export function generateTimingGuidance(ephemerisContext, spreadKey) {
  if (!ephemerisContext?.available) {
    return null;
  }

  const guidance = [];
  const { moonPhase, retrogrades } = ephemerisContext;

  // Moon phase timing
  if (moonPhase) {
    const phase = moonPhase.phaseName?.toLowerCase() || '';

    if (phase.includes('new')) {
      guidance.push('New Moon energy favors setting intentions and beginning inner work');
    } else if (phase.includes('waxing crescent') || phase.includes('waxing gibbous')) {
      guidance.push('Waxing Moon supports building momentum and taking gradual action');
    } else if (phase.includes('full')) {
      guidance.push('Full Moon illuminates what needs to be seen and supports completion');
    } else if (phase.includes('waning')) {
      guidance.push('Waning Moon favors release, reflection, and letting go');
    }
  }

  // Retrograde timing (especially for decision spreads)
  if (retrogrades?.length > 0) {
    const hasCommRetro = retrogrades.some(r =>
      ['Mercury', 'Venus'].includes(r.planet)
    );

    if (spreadKey === 'decision' && hasCommRetro) {
      guidance.push('With communication/relationship planets retrograde, consider gathering more information before finalizing decisions');
    }

    if (retrogrades.length >= 4) {
      guidance.push('Multiple retrogrades suggest this is a time for internal processing rather than external action');
    }
  }

  return guidance.length > 0 ? guidance : null;
}

/**
 * Fetch ephemeris forecast for upcoming days
 * Detects key events: moon phases, retrograde stations, sign ingresses
 *
 * Uses adaptive sampling to balance accuracy with performance:
 * - Short forecasts (≤14 days): daily sampling for moon phase precision
 * - Medium forecasts (15-30 days): every 2 days
 * - Long forecasts (31-90 days): every 3 days
 */
export async function fetchEphemerisForecast(days = 30, _options = {}) {
  try {
    const now = new Date();
    const events = [];

    // Adaptive sampling interval based on forecast length
    const sampleInterval = days <= 14 ? 1 : days <= 30 ? 2 : 3;

    let prevMoonPhase = null;
    let prevPositions = null;
    let prevRetrogrades = null;

    for (let dayOffset = 0; dayOffset <= days; dayOffset += sampleInterval) {
      const sampleDate = new Date(now);
      sampleDate.setDate(sampleDate.getDate() + dayOffset);
      const isoDate = sampleDate.toISOString();

      // Use Workers-compatible ephemeris module
      const positionsPayload = ephemerisWorkers.getCurrentPositions(isoDate);
      const positions = positionsPayload?.positions || positionsPayload || null;
      const moonPhase = ephemerisWorkers.getMoonPhase(isoDate);
      const retrogrades = ephemerisWorkers.getRetrogradePlanets(isoDate);

      // Detect New Moon / Full Moon transitions
      if (prevMoonPhase) {
        const prevPhase = prevMoonPhase.phaseName?.toLowerCase() || '';
        const currPhase = moonPhase.phaseName?.toLowerCase() || '';

        if (currPhase.includes('new moon') && !prevPhase.includes('new moon')) {
          events.push({
            type: 'new-moon',
            date: isoDate,
            dayOffset,
            description: `New Moon in ${moonPhase.sign}`,
            guidance: 'Ideal for setting intentions and beginning new cycles'
          });
        }
        if (currPhase.includes('full moon') && !prevPhase.includes('full moon')) {
          events.push({
            type: 'full-moon',
            date: isoDate,
            dayOffset,
            description: `Full Moon in ${moonPhase.sign}`,
            guidance: 'Time of illumination, culmination, and release'
          });
        }
      }

      // Detect retrograde stations (planet goes direct)
      if (prevRetrogrades && retrogrades) {
        const prevRetroSet = new Set(prevRetrogrades.map(r => r.planet));
        const currRetroSet = new Set(retrogrades.map(r => r.planet));

        // Planet went direct (was retrograde, now isn't)
        for (const planet of prevRetroSet) {
          if (!currRetroSet.has(planet)) {
            events.push({
              type: 'station-direct',
              date: isoDate,
              dayOffset,
              planet,
              description: `${planet} stations direct`,
              guidance: getDirectStationGuidance(planet)
            });
          }
        }

        // Planet went retrograde (wasn't retrograde, now is)
        for (const planet of currRetroSet) {
          if (!prevRetroSet.has(planet)) {
            events.push({
              type: 'station-retrograde',
              date: isoDate,
              dayOffset,
              planet,
              description: `${planet} stations retrograde`,
              guidance: getRetrogradeStationGuidance(planet)
            });
          }
        }
      }

      // Detect Sun sign ingress (season change)
      if (prevPositions?.Sun && positions?.Sun) {
        if (prevPositions.Sun.sign !== positions.Sun.sign) {
          events.push({
            type: 'sun-ingress',
            date: isoDate,
            dayOffset,
            sign: positions.Sun.sign,
            description: `Sun enters ${positions.Sun.sign}`,
            guidance: getSeasonGuidance(positions.Sun.sign)
          });
        }
      }

      prevMoonPhase = moonPhase;
      prevPositions = positions;
      prevRetrogrades = retrogrades;
    }

    // Get current state for context
    const currentContext = await fetchEphemerisContext();

    return {
      available: true,
      forecastDays: days,
      startDate: now.toISOString(),
      endDate: new Date(now.getTime() + days * 24 * 60 * 60 * 1000).toISOString(),
      events: events.sort((a, b) => a.dayOffset - b.dayOffset),
      currentContext,
      source: 'astronomy-engine'
    };
  } catch (err) {
    console.warn('[ephemerisIntegration] Failed to fetch forecast:', err.message);
    return {
      available: false,
      error: err.message,
      events: []
    };
  }
}

function getDirectStationGuidance(planet) {
  const guidance = {
    Mercury: 'Communication clears, plans can move forward, good time to sign agreements',
    Venus: 'Relationships clarify, creative projects gain momentum',
    Mars: 'Action energy returns, projects stalled can restart',
    Jupiter: 'Expansion resumes, opportunities open up',
    Saturn: 'Structures solidify, responsibilities become clearer',
    Uranus: 'Change accelerates, breakthroughs possible',
    Neptune: 'Clarity emerges from confusion, spiritual insights manifest',
    Pluto: 'Transformation completes a phase, power dynamics shift'
  };
  return guidance[planet] || 'Forward momentum returns';
}

function getRetrogradeStationGuidance(planet) {
  const guidance = {
    Mercury: 'Review communications, avoid signing contracts, backup data',
    Venus: 'Reflect on relationships and values, past connections may resurface',
    Mars: 'Slow down, redirect energy inward, avoid forcing action',
    Jupiter: 'Internal growth phase, reassess beliefs and goals',
    Saturn: 'Review commitments and structures, karmic lessons surface',
    Uranus: 'Internal revolution, question assumptions about freedom',
    Neptune: 'Deepen spiritual practice, dreams become significant',
    Pluto: 'Deep psychological work, transform from within'
  };
  return guidance[planet] || 'Time for reflection and review';
}

function getSeasonGuidance(sign) {
  const guidance = {
    Aries: 'Spring energy: initiative, new beginnings, bold action',
    Taurus: 'Grounding time: stability, pleasure, building resources',
    Gemini: 'Communication peak: learning, connections, versatility',
    Cancer: 'Nurturing focus: home, family, emotional security',
    Leo: 'Creative expression: confidence, joy, self-expression',
    Virgo: 'Refinement period: health, service, practical improvements',
    Libra: 'Balance seeking: relationships, harmony, aesthetics',
    Scorpio: 'Depth work: transformation, intimacy, hidden truths',
    Sagittarius: 'Expansion time: adventure, philosophy, higher learning',
    Capricorn: 'Achievement focus: goals, structure, responsibility',
    Aquarius: 'Innovation period: community, ideals, future vision',
    Pisces: 'Spiritual closing: intuition, compassion, release'
  };
  return guidance[sign] || 'New seasonal energy emerging';
}

/**
 * Build forecast section for prompts
 */
export function buildForecastSection(forecast) {
  if (!forecast?.available || !forecast.events?.length) {
    return null;
  }

  const lines = ['## UPCOMING ASTROLOGICAL EVENTS'];
  lines.push(`Forecast period: next ${forecast.forecastDays} days`);
  lines.push('');

  for (const event of forecast.events.slice(0, 6)) {
    const inDays = event.dayOffset === 0 ? 'today' :
                   event.dayOffset === 1 ? 'tomorrow' :
                   `in ${event.dayOffset} days`;
    lines.push(`- **${event.description}** (${inDays})`);
    lines.push(`  - ${event.guidance}`);
  }

  lines.push('');
  lines.push('Use these upcoming events to inform timing guidance in the reading.');

  return lines.join('\n');
}

/**
 * Get a concise ephemeris summary for the reading context line
 */
export function getEphemerisSummary(ephemerisContext) {
  if (!ephemerisContext?.available) {
    return null;
  }

  const parts = [];
  const { moonPhase, retrogrades, positions } = ephemerisContext;

  if (moonPhase) {
    parts.push(`Moon: ${moonPhase.phaseName} in ${moonPhase.sign}`);
  }

  if (positions?.Sun) {
    parts.push(`Sun: ${positions.Sun.sign}`);
  }

  if (retrogrades?.length > 0) {
    parts.push(`${retrogrades.length} retrograde${retrogrades.length > 1 ? 's' : ''}`);
  }

  return parts.join(' | ');
}

/**
 * Build concise highlight strings for medium/long-range intention coaching
 * Keeps to a small number of bullets for prompt+UI use.
 */
export function formatForecastHighlights(forecast, maxItems = 4) {
  if (!forecast?.available) return [];

  const highlights = [];
  const events = Array.isArray(forecast.events) ? forecast.events : [];

  for (const event of events) {
    if (highlights.length >= maxItems) break;

    const inDays = event.dayOffset === 0 ? 'today'
      : event.dayOffset === 1 ? 'in 1 day'
      : `in ${event.dayOffset} days`;

    const desc = event.description || 'Astrological event';
    highlights.push(`${desc} (${inDays})`);
  }

  // Add current retrogrades context if space remains
  if (highlights.length < maxItems && forecast.currentContext?.retrogrades?.length) {
    const retroList = forecast.currentContext.retrogrades
      .map(r => r.planet)
      .filter(Boolean)
      .join(', ');
    if (retroList) {
      highlights.push(`Retrogrades active now: ${retroList}`);
    }
  }

  return highlights;
}

export default {
  fetchEphemerisContext,
  fetchEphemerisForecast,
  matchTransitsToCards,
  buildAstrologicalWeatherSection,
  buildCardTransitNotes,
  buildForecastSection,
  generateTimingGuidance,
  getEphemerisSummary,
  formatForecastHighlights
};
</file>

<file path="functions/lib/ephemerisWorkers.js">
/**
 * Workers-Compatible Ephemeris Module
 *
 * Pure JavaScript astronomical calculations using astronomy-engine.
 * This module works in Cloudflare Workers V8 isolates (no native addons).
 *
 * Provides: planetary positions, moon phases, aspects, retrogrades
 */

import * as Astronomy from 'astronomy-engine';

const ZODIAC_SIGNS = [
  'Aries', 'Taurus', 'Gemini', 'Cancer',
  'Leo', 'Virgo', 'Libra', 'Scorpio',
  'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces'
];

const PLANETS = [
  { name: 'Sun', body: Astronomy.Body.Sun },
  { name: 'Moon', body: Astronomy.Body.Moon },
  { name: 'Mercury', body: Astronomy.Body.Mercury },
  { name: 'Venus', body: Astronomy.Body.Venus },
  { name: 'Mars', body: Astronomy.Body.Mars },
  { name: 'Jupiter', body: Astronomy.Body.Jupiter },
  { name: 'Saturn', body: Astronomy.Body.Saturn },
  { name: 'Uranus', body: Astronomy.Body.Uranus },
  { name: 'Neptune', body: Astronomy.Body.Neptune },
  { name: 'Pluto', body: Astronomy.Body.Pluto }
];

// Planets that can go retrograde (not Sun/Moon)
const RETROGRADE_PLANETS = PLANETS.filter(p =>
  !['Sun', 'Moon'].includes(p.name)
);

/**
 * Convert ecliptic longitude to zodiac sign and degree
 */
function longitudeToZodiac(longitude) {
  // Normalize to 0-360
  const normalizedLon = ((longitude % 360) + 360) % 360;
  const signIndex = Math.floor(normalizedLon / 30);
  const degree = normalizedLon % 30;

  return {
    sign: ZODIAC_SIGNS[signIndex],
    degree: parseFloat(degree.toFixed(2)),
    longitude: parseFloat(normalizedLon.toFixed(2))
  };
}

/**
 * Get longitude for a body at a given time
 * Handles Sun and Moon specially since EclipticLongitude doesn't work for them
 */
function getLongitudeForBody(body, planetName, time) {
  if (planetName === 'Sun') {
    return Astronomy.SunPosition(time).elon;
  } else if (planetName === 'Moon') {
    return Astronomy.EclipticGeoMoon(time).lon;
  } else {
    return Astronomy.EclipticLongitude(body, time);
  }
}

/**
 * Calculate daily motion (speed) for a planet
 * Positive = direct motion, Negative = retrograde
 */
function calculateSpeed(body, planetName, date) {
  const time = Astronomy.MakeTime(date);
  const dayBefore = Astronomy.MakeTime(new Date(date.getTime() - 86400000));

  try {
    const lonNow = getLongitudeForBody(body, planetName, time);
    const lonBefore = getLongitudeForBody(body, planetName, dayBefore);

    // Handle wrap-around at 360°
    let speed = lonNow - lonBefore;
    if (speed > 180) speed -= 360;
    if (speed < -180) speed += 360;

    return parseFloat(speed.toFixed(4));
  } catch {
    return 0;
  }
}

/**
 * Get current planetary positions
 * @param {string|null} dateString - ISO date string or null for now
 * @returns {Object} Positions data
 */
export function getCurrentPositions(dateString = null) {
  const date = dateString ? new Date(dateString) : new Date();
  const time = Astronomy.MakeTime(date);
  const positions = {};

  for (const planet of PLANETS) {
    try {
      let longitude;

      if (planet.name === 'Sun') {
        const sunPos = Astronomy.SunPosition(time);
        longitude = sunPos.elon;
      } else if (planet.name === 'Moon') {
        const moonPos = Astronomy.EclipticGeoMoon(time);
        longitude = moonPos.lon;
      } else {
        longitude = Astronomy.EclipticLongitude(planet.body, time);
      }

      const zodiacInfo = longitudeToZodiac(longitude);
      const speed = calculateSpeed(planet.body, planet.name, date);

      positions[planet.name] = {
        sign: zodiacInfo.sign,
        degree: zodiacInfo.degree,
        longitude: zodiacInfo.longitude,
        speed,
        isDirect: speed >= 0
      };
    } catch (err) {
      console.warn(`[ephemerisWorkers] Error calculating ${planet.name}:`, err.message);
    }
  }

  return {
    timestamp: date.toISOString(),
    positions
  };
}

/**
 * Get moon phase information
 * @param {string|null} dateString - ISO date string or null for now
 * @returns {Object} Moon phase data
 */
export function getMoonPhase(dateString = null) {
  const date = dateString ? new Date(dateString) : new Date();
  const time = Astronomy.MakeTime(date);

  try {
    // MoonPhase returns angle 0-360 where:
    // 0° = New Moon, 90° = First Quarter, 180° = Full Moon, 270° = Last Quarter
    const phaseAngle = Astronomy.MoonPhase(time);

    // Calculate illumination (0-100%)
    const illumination = (1 - Math.cos((phaseAngle * Math.PI) / 180)) / 2 * 100;

    // Determine phase name
    let phaseName;
    if (phaseAngle < 22.5 || phaseAngle >= 337.5) phaseName = 'New Moon';
    else if (phaseAngle < 67.5) phaseName = 'Waxing Crescent';
    else if (phaseAngle < 112.5) phaseName = 'First Quarter';
    else if (phaseAngle < 157.5) phaseName = 'Waxing Gibbous';
    else if (phaseAngle < 202.5) phaseName = 'Full Moon';
    else if (phaseAngle < 247.5) phaseName = 'Waning Gibbous';
    else if (phaseAngle < 292.5) phaseName = 'Last Quarter';
    else phaseName = 'Waning Crescent';

    // Get Moon's zodiac position
    const moonPos = Astronomy.EclipticGeoMoon(time);
    const zodiacInfo = longitudeToZodiac(moonPos.lon);

    return {
      timestamp: date.toISOString(),
      phaseName,
      phaseAngle: parseFloat(phaseAngle.toFixed(2)),
      illumination: parseFloat(illumination.toFixed(1)),
      sign: zodiacInfo.sign,
      degree: zodiacInfo.degree,
      isWaxing: phaseAngle < 180,
      interpretation: getMoonPhaseInterpretation(phaseName, zodiacInfo.sign)
    };
  } catch (err) {
    console.error('[ephemerisWorkers] Error calculating moon phase:', err.message);
    throw err;
  }
}

/**
 * Get planetary aspects (angular relationships between planets)
 * @param {string|null} dateString - ISO date string or null for now
 * @param {number} orb - Maximum orb for aspects (default 8°)
 * @returns {Array} List of active aspects
 */
export function getPlanetaryAspects(dateString = null, orb = 8) {
  const positions = getCurrentPositions(dateString).positions;
  const aspects = [];

  const planetNames = Object.keys(positions);

  // Aspect definitions
  const aspectTypes = [
    { name: 'conjunction', angle: 0, orb, symbol: '☌' },
    { name: 'opposition', angle: 180, orb, symbol: '☍' },
    { name: 'trine', angle: 120, orb, symbol: '△' },
    { name: 'square', angle: 90, orb, symbol: '□' },
    { name: 'sextile', angle: 60, orb: 6, symbol: '⚹' }
  ];

  // Check all planet pairs
  for (let i = 0; i < planetNames.length; i++) {
    for (let j = i + 1; j < planetNames.length; j++) {
      const planet1 = planetNames[i];
      const planet2 = planetNames[j];

      const lon1 = positions[planet1].longitude;
      const lon2 = positions[planet2].longitude;

      let angle = Math.abs(lon1 - lon2);
      if (angle > 180) angle = 360 - angle;

      // Check against each aspect type
      for (const aspectType of aspectTypes) {
        const diff = Math.abs(angle - aspectType.angle);
        if (diff <= aspectType.orb) {
          aspects.push({
            planet1,
            planet2,
            type: aspectType.name,
            symbol: aspectType.symbol,
            angle: parseFloat(angle.toFixed(2)),
            orb: parseFloat(diff.toFixed(2)),
            applying: isAspectApplying(positions[planet1], positions[planet2]),
            interpretation: getAspectInterpretation(planet1, planet2, aspectType.name)
          });
        }
      }
    }
  }

  return aspects.sort((a, b) => a.orb - b.orb);
}

/**
 * Check if an aspect is applying (getting tighter) or separating
 */
function isAspectApplying(pos1, pos2) {
  // If the faster planet is approaching the slower, aspect is applying
  const speedDiff = Math.abs(pos1.speed) - Math.abs(pos2.speed);
  return speedDiff > 0;
}

/**
 * Get planets currently in retrograde
 * @param {string|null} dateString - ISO date string or null for now
 * @returns {Array} List of retrograde planets
 */
export function getRetrogradePlanets(dateString = null) {
  const positions = getCurrentPositions(dateString).positions;
  const retrogrades = [];

  for (const planet of RETROGRADE_PLANETS) {
    const pos = positions[planet.name];
    if (pos && pos.speed < 0) {
      retrogrades.push({
        planet: planet.name,
        sign: pos.sign,
        degree: pos.degree,
        speed: pos.speed,
        interpretation: getRetrogradeInterpretation(planet.name)
      });
    }
  }

  return retrogrades;
}

/**
 * Get complete ephemeris snapshot for a reading
 * @param {string} timestamp - ISO date string
 * @returns {Object} Complete ephemeris data
 */
export function getEphemerisForReading(timestamp) {
  const date = new Date(timestamp);

  return {
    timestamp: date.toISOString(),
    positions: getCurrentPositions(timestamp).positions,
    moon: getMoonPhase(timestamp),
    aspects: getPlanetaryAspects(timestamp),
    retrogrades: getRetrogradePlanets(timestamp),
    readingContext: generateReadingContext(date),
    source: 'astronomy-engine' // Indicates pure JS source
  };
}

/**
 * Generate astrological context summary for a reading
 */
function generateReadingContext(date) {
  const positions = getCurrentPositions(date.toISOString()).positions;
  const moon = getMoonPhase(date.toISOString());
  const aspects = getPlanetaryAspects(date.toISOString());
  const retrogrades = getRetrogradePlanets(date.toISOString());

  const context = [];

  // Moon phase context
  context.push(`Moon: ${moon.phaseName} in ${moon.sign}`);

  // Sun sign
  if (positions.Sun) {
    context.push(`Sun: ${positions.Sun.sign}`);
  }

  // Key tight aspects (orb < 3°)
  const tightAspects = aspects.filter(a => a.orb < 3);
  if (tightAspects.length > 0) {
    const aspectList = tightAspects.slice(0, 3)
      .map(a => `${a.planet1} ${a.symbol} ${a.planet2}`)
      .join(', ');
    context.push(`Aspects: ${aspectList}`);
  }

  // Retrogrades
  if (retrogrades.length > 0) {
    context.push(`Rx: ${retrogrades.map(r => r.planet).join(', ')}`);
  }

  return context.join(' | ');
}

/**
 * Interpretation helpers
 */
function getMoonPhaseInterpretation(phaseName, sign) {
  const phaseInterpretations = {
    'New Moon': 'Beginnings, seeds, intentions',
    'Waxing Crescent': 'Initial growth, faith required',
    'First Quarter': 'Action, decision, commitment',
    'Waxing Gibbous': 'Refinement, adjustment, development',
    'Full Moon': 'Culmination, revelation, illumination',
    'Waning Gibbous': 'Gratitude, sharing, dissemination',
    'Last Quarter': 'Re-orientation, release, surrender',
    'Waning Crescent': 'Rest, reflection, transition'
  };

  return `${phaseInterpretations[phaseName] || phaseName} in ${sign}`;
}

function getAspectInterpretation(planet1, planet2, aspectType) {
  const interpretations = {
    conjunction: 'fusion, intensification, new cycle',
    opposition: 'awareness, balance, integration needed',
    trine: 'flow, ease, natural talent',
    square: 'tension, growth catalyst, breakthrough potential',
    sextile: 'opportunity, cooperation, skill development'
  };

  return `${planet1}-${planet2}: ${interpretations[aspectType] || aspectType}`;
}

function getRetrogradeInterpretation(planet) {
  const interpretations = {
    Mercury: 'Review communication, revisit plans, reflect on decisions',
    Venus: 'Reassess relationships, reconsider values, reconnect with past',
    Mars: 'Redirect energy inward, reconsider actions, patience required',
    Jupiter: 'Internal expansion, philosophical review, beliefs examined',
    Saturn: 'Structural review, karmic lessons, responsibility reassessed',
    Uranus: 'Internal revolution, personal awakening, authenticity questioned',
    Neptune: 'Spiritual deepening, illusions dissolving, dreams significant',
    Pluto: 'Deep transformation, power reclaimed, shadow work intensified'
  };

  return interpretations[planet] || 'Reflective, inward-focused energy';
}

/**
 * Get daily astrological weather summary
 * @param {string|null} dateString - ISO date string or null for now
 * @returns {Object} Daily weather summary
 */
export function getDailyAstrologicalWeather(dateString = null) {
  const date = dateString ? new Date(dateString) : new Date();
  const positions = getCurrentPositions(dateString);
  const moon = getMoonPhase(dateString);
  const aspects = getPlanetaryAspects(dateString);
  const retrogrades = getRetrogradePlanets(dateString);

  // Identify dominant themes
  const themes = [];

  // Moon phase theme
  if (moon.phaseName.includes('New')) {
    themes.push('beginnings');
  } else if (moon.phaseName.includes('Full')) {
    themes.push('culmination');
  } else if (moon.isWaxing) {
    themes.push('building');
  } else {
    themes.push('releasing');
  }

  // Retrograde themes
  if (retrogrades.some(r => r.planet === 'Mercury')) {
    themes.push('communication review');
  }
  if (retrogrades.length >= 3) {
    themes.push('introspection');
  }

  // Aspect themes
  const squares = aspects.filter(a => a.type === 'square' && a.orb < 3);
  if (squares.length > 0) {
    themes.push('dynamic tension');
  }

  const trines = aspects.filter(a => a.type === 'trine' && a.orb < 3);
  if (trines.length > 0) {
    themes.push('flowing support');
  }

  return {
    date: date.toISOString().split('T')[0],
    moon: {
      phase: moon.phaseName,
      sign: moon.sign,
      illumination: moon.illumination
    },
    sun: positions.positions.Sun,
    retrogradeCount: retrogrades.length,
    retrogradePlanets: retrogrades.map(r => r.planet),
    tightAspects: aspects.filter(a => a.orb < 3).slice(0, 5),
    themes,
    summary: generateReadingContext(date)
  };
}

export default {
  getCurrentPositions,
  getMoonPhase,
  getPlanetaryAspects,
  getRetrogradePlanets,
  getEphemerisForReading,
  getDailyAstrologicalWeather
};
</file>

<file path="functions/lib/esotericMeta.js">
const MAJOR_ARCANA_ASTRO = {
  0: {
    label: 'Air — the elemental current of Aleph',
    focus: 'inviting openness, experimentation, and trust in the unfolding journey'
  },
  1: {
    label: 'Mercury',
    focus: 'supporting skillful communication and intentional manifestation'
  },
  2: {
    label: 'The Moon',
    focus: 'drawing you toward intuition, dreams, and liminal wisdom'
  },
  3: {
    label: 'Venus',
    focus: 'celebrating fertility, creativity, and receptive abundance'
  },
  4: {
    label: 'Aries',
    focus: 'emphasizing decisive leadership, structure, and sovereign agency'
  },
  5: {
    label: 'Taurus',
    focus: 'rooting guidance in steady devotion, embodiment, and values'
  },
  6: {
    label: 'Gemini',
    focus: 'highlighting choice, dialogue, and mirrored understanding'
  },
  7: {
    label: 'Cancer',
    focus: 'centering emotional protection, belonging, and purposeful movement'
  },
  8: {
    label: 'Leo',
    focus: 'calling up heart-led courage and radiant self-expression'
  },
  9: {
    label: 'Virgo',
    focus: 'favoring discernment, service, and grounded reflection'
  },
  10: {
    label: 'Jupiter',
    focus: 'opening cycles of expansion, fortune, and recalibration'
  },
  11: {
    label: 'Libra',
    focus: 'balancing fairness, equilibrium, and relational harmony'
  },
  12: {
    label: 'Water — the elemental path of Mem',
    focus: 'guiding surrender, sacrifice, and spiritual attunement'
  },
  13: {
    label: 'Scorpio',
    focus: 'navigating profound transformation and regenerative endings'
  },
  14: {
    label: 'Sagittarius',
    focus: 'encouraging synthesis, aim, and philosophical integration'
  },
  15: {
    label: 'Capricorn',
    focus: 'confronting structures, contracts, and mastery of material bonds'
  },
  16: {
    label: 'Mars',
    focus: 'igniting sudden change, liberation, and necessary disruption'
  },
  17: {
    label: 'Aquarius',
    focus: 'channeling vision, hope, and communal renewal'
  },
  18: {
    label: 'Pisces',
    focus: 'immersing you in intuition, dreams, and mystery'
  },
  19: {
    label: 'The Sun',
    focus: 'radiating vitality, clarity, and conscious joy'
  },
  20: {
    label: 'Fire — the elemental path of Shin',
    focus: 'stirring rebirth, awakening, and spiritual callings'
  },
  21: {
    label: 'Saturn with an Earth resonance',
    focus: 'grounding completion, responsibility, and embodied wholeness'
  }
};

const MINOR_DECANS = {
  Wands: {
    Two: {
      label: 'Mars in Aries',
      focus: 'energizing bold planning and confident choice'
    },
    Three: {
      label: 'Sun in Aries',
      focus: 'illuminating momentum and visible expansion'
    },
    Four: {
      label: 'Venus in Aries',
      focus: 'warming celebration, community, and milestone anchoring'
    },
    Five: {
      label: 'Saturn in Leo',
      focus: 'testing resilience through spirited friction'
    },
    Six: {
      label: 'Jupiter in Leo',
      focus: 'rewarding leadership with recognition and support'
    },
    Seven: {
      label: 'Mars in Leo',
      focus: 'fueling courageous defense of personal vision'
    },
    Eight: {
      label: 'Mercury in Sagittarius',
      focus: 'quickening communication and swift progress'
    },
    Nine: {
      label: 'Moon in Sagittarius',
      focus: 'sustaining vigilance, intuition, and endurance'
    },
    Ten: {
      label: 'Saturn in Sagittarius',
      focus: 'asking for disciplined effort and meaningful closure'
    }
  },
  Cups: {
    Two: {
      label: 'Venus in Cancer',
      focus: 'nurturing bonds, reciprocity, and shared care'
    },
    Three: {
      label: 'Mercury in Cancer',
      focus: 'weaving heartfelt conversations and community'
    },
    Four: {
      label: 'Moon in Cancer',
      focus: 'drawing attention to interior tides and emotional safety'
    },
    Five: {
      label: 'Mars in Scorpio',
      focus: 'exposing intense feelings that crave transformation'
    },
    Six: {
      label: 'Sun in Scorpio',
      focus: 'reviving soulful loyalty, memory, and devotion'
    },
    Seven: {
      label: 'Venus in Scorpio',
      focus: 'casting alluring visions that call for discernment'
    },
    Eight: {
      label: 'Saturn in Pisces',
      focus: 'prompting sober release and spiritual maturity'
    },
    Nine: {
      label: 'Jupiter in Pisces',
      focus: 'expanding compassion, blessings, and wish fulfillment'
    },
    Ten: {
      label: 'Mars in Pisces',
      focus: 'motivating active devotion to shared dreams'
    }
  },
  Swords: {
    Two: {
      label: 'Moon in Libra',
      focus: 'seeking balanced choices through quiet reflection'
    },
    Three: {
      label: 'Saturn in Libra',
      focus: 'underscoring accountability, truth, and hard-won clarity'
    },
    Four: {
      label: 'Jupiter in Libra',
      focus: 'encouraging restorative pause and perspective'
    },
    Five: {
      label: 'Venus in Aquarius',
      focus: 'questioning alignments within communal ideals'
    },
    Six: {
      label: 'Mercury in Aquarius',
      focus: 'guiding strategic transitions into clearer mental space'
    },
    Seven: {
      label: 'Moon in Aquarius',
      focus: 'amplifying independent strategy and emotional detachment'
    },
    Eight: {
      label: 'Jupiter in Gemini',
      focus: 'magnifying mental loops that can still stretch open'
    },
    Nine: {
      label: 'Mars in Gemini',
      focus: 'stirring restless analyses that need compassionate focus'
    },
    Ten: {
      label: 'Sun in Gemini',
      focus: 'revealing full illumination after a cycle of thought concludes'
    }
  },
  Pentacles: {
    Two: {
      label: 'Jupiter in Capricorn',
      focus: 'supporting adaptable resourcefulness within structure'
    },
    Three: {
      label: 'Mars in Capricorn',
      focus: 'activating collaborative mastery through effort'
    },
    Four: {
      label: 'Sun in Capricorn',
      focus: 'spotlighting stewardship, stability, and long-term plans'
    },
    Five: {
      label: 'Mercury in Taurus',
      focus: 'calling attention to mindset shifts amid material strain'
    },
    Six: {
      label: 'Moon in Taurus',
      focus: 'encouraging reciprocal care and tangible nourishment'
    },
    Seven: {
      label: 'Saturn in Taurus',
      focus: 'highlighting patience, pruning, and deliberate progress'
    },
    Eight: {
      label: 'Sun in Virgo',
      focus: 'emphasizing craftsmanship, practice, and refinement'
    },
    Nine: {
      label: 'Venus in Virgo',
      focus: 'celebrating self-sufficiency and cultivated pleasures'
    },
    Ten: {
      label: 'Mercury in Virgo',
      focus: 'harmonizing legacy-building with practical intelligence'
    }
  }
};

const MAJOR_PATHS = {
  0: {
    label: 'Path Aleph (Kether ↔ Chokmah)',
    focus: 'channeling pure potential into first breath and awareness'
  },
  1: {
    label: 'Path Beth (Kether ↔ Binah)',
    focus: 'guiding intention to take form through focused will'
  },
  2: {
    label: 'Path Gimel (Kether ↔ Tiphareth)',
    focus: 'carrying mystery from crown to the heart-center'
  },
  3: {
    label: 'Path Daleth (Chokmah ↔ Binah)',
    focus: 'bridging electric insight with receptive understanding'
  },
  4: {
    label: 'Path Heh (Chokmah ↔ Tiphareth)',
    focus: 'seeding visionary fire into purposeful action'
  },
  5: {
    label: 'Path Vav (Chokmah ↔ Chesed)',
    focus: 'extending divine impulse into benevolent structure'
  },
  6: {
    label: 'Path Zayin (Binah ↔ Tiphareth)',
    focus: 'harmonizing discernment, choice, and soulful union'
  },
  7: {
    label: 'Path Cheth (Binah ↔ Geburah)',
    focus: 'armoring compassion with disciplined courage'
  },
  8: {
    label: 'Path Teth (Chesed ↔ Geburah)',
    focus: 'taming power through heart-centered strength'
  },
  9: {
    label: 'Path Yod (Chesed ↔ Tiphareth)',
    focus: 'refining devotion through mindful service'
  },
  10: {
    label: 'Path Kaph (Chesed ↔ Netzach)',
    focus: 'turning opportunity through the wheel of fortune'
  },
  11: {
    label: 'Path Lamed (Geburah ↔ Tiphareth)',
    focus: 'measuring balance, justice, and ethical alignment'
  },
  12: {
    label: 'Path Mem (Geburah ↔ Hod)',
    focus: 'inviting surrender that purifies perception'
  },
  13: {
    label: 'Path Nun (Tiphareth ↔ Netzach)',
    focus: 'moving lifeforce toward profound transformation'
  },
  14: {
    label: 'Path Samekh (Tiphareth ↔ Yesod)',
    focus: 'tempering experience into integrated wholeness'
  },
  15: {
    label: 'Path Ayin (Tiphareth ↔ Hod)',
    focus: 'revealing shadow attachments for mindful release'
  },
  16: {
    label: 'Path Peh (Netzach ↔ Hod)',
    focus: 'breaking open stale structures to free vitality'
  },
  17: {
    label: 'Path Tzaddi (Netzach ↔ Yesod)',
    focus: 'catching starlight inspirations for embodied hope'
  },
  18: {
    label: 'Path Qoph (Netzach ↔ Malkuth)',
    focus: 'guiding dreamscapes toward compassionate embodiment'
  },
  19: {
    label: 'Path Resh (Hod ↔ Yesod)',
    focus: 'illuminating clarity that animates the self'
  },
  20: {
    label: 'Path Shin (Hod ↔ Malkuth)',
    focus: 'sparking resurrection fire within lived reality'
  },
  21: {
    label: 'Path Tav (Yesod ↔ Malkuth)',
    focus: 'grounding spiritual insight into the physical world'
  }
};

const RANK_TO_SEPHIROTH = {
  Ace: {
    label: 'Kether — Crown',
    focus: 'pure seed potential entering this suit'
  },
  Two: {
    label: 'Chokmah — Wisdom',
    focus: 'dynamic surge of expanding energy'
  },
  Three: {
    label: 'Binah — Understanding',
    focus: 'shaping structure, pattern, and containment'
  },
  Four: {
    label: 'Chesed — Mercy',
    focus: 'stabilizing growth with generosity and order'
  },
  Five: {
    label: 'Geburah — Severity',
    focus: 'applying discernment, challenge, and recalibration'
  },
  Six: {
    label: 'Tiphareth — Beauty',
    focus: 'harmonizing the suit around its radiant heart'
  },
  Seven: {
    label: 'Netzach — Victory',
    focus: 'moving through desire, artistry, and endurance'
  },
  Eight: {
    label: 'Hod — Splendor',
    focus: 'refining intellect, craft, and communication'
  },
  Nine: {
    label: 'Yesod — Foundation',
    focus: 'coalescing the suit’s energy into lived patterns'
  },
  Ten: {
    label: 'Malkuth — Kingdom',
    focus: 'manifesting tangible results and embodiment'
  }
};

const SUIT_TO_WORLD = {
  Wands: 'Atziluth (Fire) — archetypal impulse',
  Cups: 'Briah (Water) — creative formation',
  Swords: 'Yetzirah (Air) — mental shaping',
  Pentacles: 'Assiah (Earth) — material expression'
};

const ASTRO_MINOR_PREFERRED_RANKS = new Set(['Two', 'Three', 'Six', 'Nine']);
const QABALAH_MINOR_PREFERRED_RANKS = new Set(['Ace', 'Six', 'Ten']);

const RANK_NAME_BY_VALUE = {
  1: 'Ace',
  2: 'Two',
  3: 'Three',
  4: 'Four',
  5: 'Five',
  6: 'Six',
  7: 'Seven',
  8: 'Eight',
  9: 'Nine',
  10: 'Ten',
  11: 'Page',
  12: 'Knight',
  13: 'Queen',
  14: 'King'
};

const SUITS = ['Wands', 'Cups', 'Swords', 'Pentacles'];

function normalizeRank(rawRank) {
  if (!rawRank) return null;
  const key = rawRank.toString().trim().toLowerCase();
  switch (key) {
    case 'ace':
      return 'Ace';
    case 'two':
      return 'Two';
    case 'three':
      return 'Three';
    case 'four':
      return 'Four';
    case 'five':
      return 'Five';
    case 'six':
      return 'Six';
    case 'seven':
      return 'Seven';
    case 'eight':
      return 'Eight';
    case 'nine':
      return 'Nine';
    case 'ten':
      return 'Ten';
    case 'page':
      return 'Page';
    case 'knight':
      return 'Knight';
    case 'queen':
      return 'Queen';
    case 'king':
      return 'King';
    default:
      return null;
  }
}

function inferRankFromName(cardName) {
  if (typeof cardName !== 'string') return null;
  const parts = cardName.split(' of ');
  if (!parts[0]) return null;
  return normalizeRank(parts[0]);
}

function getRankKey(cardInfo) {
  const directRank = normalizeRank(cardInfo?.rank);
  if (directRank) return directRank;

  if (typeof cardInfo?.rankValue === 'number') {
    const mapped = RANK_NAME_BY_VALUE[cardInfo.rankValue];
    if (mapped) return mapped;
  }

  return inferRankFromName(cardInfo?.card || '');
}

function resolveSuit(cardInfo) {
  if (cardInfo?.suit) return cardInfo.suit;
  if (typeof cardInfo?.card !== 'string') return null;
  return SUITS.find(suit => cardInfo.card.includes(suit)) || null;
}

export const ASTRO_ASSOCIATIONS = {
  majors: MAJOR_ARCANA_ASTRO,
  minors: MINOR_DECANS
};

export function getAstroForCard(cardInfo = {}) {
  if (typeof cardInfo.number === 'number' && cardInfo.number >= 0 && cardInfo.number <= 21) {
    return MAJOR_ARCANA_ASTRO[cardInfo.number] || null;
  }

  const suit = resolveSuit(cardInfo);
  const rankKey = getRankKey(cardInfo);

  if (suit && rankKey && MINOR_DECANS[suit] && MINOR_DECANS[suit][rankKey]) {
    return MINOR_DECANS[suit][rankKey];
  }

  return null;
}

export const QABALAH_PATHS = {
  majors: MAJOR_PATHS,
  minors: RANK_TO_SEPHIROTH
};

export function getQabalahForCard(cardInfo = {}) {
  if (typeof cardInfo.number === 'number' && cardInfo.number >= 0 && cardInfo.number <= 21) {
    return MAJOR_PATHS[cardInfo.number] || null;
  }

  const suit = resolveSuit(cardInfo);
  const rankKey = getRankKey(cardInfo);
  const sephirothMeta = rankKey ? RANK_TO_SEPHIROTH[rankKey] : null;

  if (sephirothMeta) {
    const world = suit ? SUIT_TO_WORLD[suit] : null;
    return {
      label: sephirothMeta.label,
      focus: world ? `${sephirothMeta.focus} within ${world}` : sephirothMeta.focus
    };
  }

  return null;
}

export function shouldSurfaceAstroLens(cardInfo = {}) {
  if (typeof cardInfo.number === 'number' && cardInfo.number >= 0 && cardInfo.number <= 21) {
    return true;
  }

  const rankKey = getRankKey(cardInfo);
  return ASTRO_MINOR_PREFERRED_RANKS.has(rankKey || '');
}

export function shouldSurfaceQabalahLens(cardInfo = {}) {
  if (typeof cardInfo.number === 'number' && cardInfo.number >= 0 && cardInfo.number <= 21) {
    return true;
  }

  const rankKey = getRankKey(cardInfo);
  return QABALAH_MINOR_PREFERRED_RANKS.has(rankKey || '');
}
</file>

<file path="functions/lib/graphContext.js">
// Graph-aware context helper for tarot spreads
//
// This module centralizes how we derive archetypal pattern context from the
// tarot knowledge graph. It is intentionally small and declarative so that
// higher-level consumers (spread analysis, narrative builders, LLM prompts)
// can depend on a stable shape when asking for "graph context" rather than
// re-implementing detection logic.
//
// NOTE: This is *not* a full GraphRAG implementation – it is a lightweight
// wrapper over the existing rule-based pattern detectors in knowledgeGraph.js.
// It can be extended in the future to attach richer retrieval metadata
// (e.g., external passages keyed by pattern id) without changing callers.

import { detectAllPatterns, getPriorityPatternNarratives } from './knowledgeGraph.js';

function buildGraphKeys(patterns) {
    if (!patterns || typeof patterns !== 'object') {
        return null;
    }

    const keys = {};

    // Fool's Journey: expose both the human-friendly stage label and the
    // underlying key used in FOOLS_JOURNEY so retrieval/training can use
    // stable identifiers.
    if (patterns.foolsJourney) {
        keys.foolsJourneyStageKey = patterns.foolsJourney.stageKey || null;
        keys.foolsJourneyStage = patterns.foolsJourney.stage || null;
    }

    // Triads: stable ids plus completeness for GraphRAG and evaluation.
    if (Array.isArray(patterns.triads) && patterns.triads.length > 0) {
        keys.triadIds = patterns.triads
            .map((triad) => triad.id)
            .filter(Boolean);
        keys.completeTriadIds = patterns.triads
            .filter((triad) => triad.isComplete)
            .map((triad) => triad.id)
            .filter(Boolean);
    } else {
        keys.triadIds = [];
        keys.completeTriadIds = [];
    }

    // Dyads: capture numeric card pairs plus semantic category and significance.
    if (Array.isArray(patterns.dyads) && patterns.dyads.length > 0) {
        keys.dyadPairs = patterns.dyads.map((dyad) => ({
            cards: dyad.cards,
            category: dyad.category || null,
            significance: dyad.significance || null
        }));
    } else {
        keys.dyadPairs = [];
    }

    // Suit progressions: suit + stage signature for Minor Arcana arcs.
    if (Array.isArray(patterns.suitProgressions) && patterns.suitProgressions.length > 0) {
        keys.suitProgressions = patterns.suitProgressions.map((prog) => ({
            suit: prog.suit,
            stage: prog.stage,
            significance: prog.significance
        }));
    } else {
        keys.suitProgressions = [];
    }

    // Court lineages: suit + significance (council vs alliance).
    if (Array.isArray(patterns.courtLineages) && patterns.courtLineages.length > 0) {
        keys.courtLineages = patterns.courtLineages.map((lineage) => ({
            suit: lineage.suit,
            significance: lineage.significance
        }));
    } else {
        keys.courtLineages = [];
    }

    // Deck-specific Thoth and Marseille signals.
    if (patterns.thothEpithets) {
        if (Array.isArray(patterns.thothEpithets.suitHighlights) && patterns.thothEpithets.suitHighlights.length > 0) {
            keys.thothSuits = patterns.thothEpithets.suitHighlights.map((h) => h.suit);
        } else if (Array.isArray(patterns.thothEpithets.entries) && patterns.thothEpithets.entries.length > 0) {
            keys.thothEntries = patterns.thothEpithets.entries.map((entry) => entry.card);
        }
    }

    if (patterns.marseillePip?.numerologyClusters?.length) {
        keys.marseilleRanks = patterns.marseillePip.numerologyClusters.map((cluster) => cluster.rankValue);
    }

    return keys;
}

/**
 * Build archetypal graph context for a spread.
 *
 * @param {Array<Object>} cardsInfo - Spread cards (as passed to analyzeSpreadThemes)
 * @param {Object} [options]
 * @param {string} [options.deckStyle='rws-1909'] - Deck style key used for
 *   deck-aware naming and pattern selection.
 * @returns {Object|null} An object with the detected `patterns`,
 *   `narrativeHighlights`, and stable `graphKeys`, or null when no patterns
 *   are found.
 */
export function buildGraphContext(cardsInfo, options = {}) {
    const deckStyle = options.deckStyle || 'rws-1909';

    if (!Array.isArray(cardsInfo) || cardsInfo.length === 0) {
        return null;
    }

    const patterns = detectAllPatterns(cardsInfo, { deckStyle });
    if (!patterns) {
        return null;
    }

    const narrativeHighlights = getPriorityPatternNarratives(patterns, deckStyle) || [];
    const graphKeys = buildGraphKeys(patterns);

    return {
        patterns,
        narrativeHighlights,
        graphKeys
    };
}
</file>

<file path="functions/lib/graphRAG.js">
// functions/lib/graphRAG.js
// GraphRAG (Graph-Enhanced Retrieval-Augmented Generation) for tarot readings
//
// This module implements a lightweight GraphRAG system that:
// 1. Takes graph keys from pattern detection (triads, dyads, journey stages)
// 2. Retrieves relevant passages from the curated knowledge base
// 3. Ranks and formats passages for injection into LLM prompts
// 4. Scores passage relevance using keyword + semantic similarity
//
// Architecture:
//   graphKeys → retrievePassages() → scored passages → quality filter → formatForPrompt()
//
// Quality filtering enhancements:
// - Keyword overlap scoring (fast, cheap)
// - Semantic similarity via embeddings (optional, requires API)
// - Deduplication of similar passages
// - Relevance threshold filtering

import {
  getPassagesForPattern,
  getKnowledgeBaseStats
} from './knowledgeBase.js';
import { cosineSimilarity, embedText } from './embeddings.js';

/**
 * Determine the number of passages to retrieve based on spread complexity.
 * Centralized here so prompts and server-side memoization stay in sync.
 *
 * @param {string} spreadKey
 * @returns {number}
 */
export function getPassageCountForSpread(spreadKey) {
  const limits = {
    single: 1,        // One-card = 1 passage (focused)
    threeCard: 2,     // Simple spread = 2 passages
    fiveCard: 3,      // Medium spread = 3 passages
    celtic: 5,        // Complex spread = 5 passages (rich context needed)
    decision: 3,      // Decision spread = 3 passages
    relationship: 2,  // Relationship = 2 passages
    general: 3        // Default fallback
  };

  return limits[spreadKey] || limits.general;
}

/**
 * Retrieve relevant passages based on detected graph patterns
 *
 * @param {Object} graphKeys - Graph keys from buildGraphContext()
 * @param {Object} [options]
 * @param {number} [options.maxPassages=3] - Maximum passages to return
 * @param {boolean} [options.includeMetadata=false] - Include pattern metadata
 * @returns {Array<Object>} Ranked passages with priority and metadata
 *
 * @example
 * const graphKeys = {
 *   completeTriadIds: ['death-temperance-star'],
 *   foolsJourneyStageKey: 'integration'
 * };
 * const passages = retrievePassages(graphKeys, { maxPassages: 3 });
 */
export function retrievePassages(graphKeys, options = {}) {
  const maxPassages = options.maxPassages || 3;
  const includeMetadata = options.includeMetadata || false;

  if (!graphKeys || typeof graphKeys !== 'object') {
    return [];
  }

  const passages = [];

  // Priority 1: Complete triads (highest narrative value)
  // Only take first passage per triad to avoid duplicate titles in UI
  if (Array.isArray(graphKeys.completeTriadIds) && graphKeys.completeTriadIds.length > 0) {
    graphKeys.completeTriadIds.forEach((triadId) => {
      const entry = getPassagesForPattern('triad', triadId);
      if (entry && entry.passages && entry.passages.length > 0) {
        const passage = entry.passages[0];
        passages.push({
          priority: 1,
          type: 'triad',
          patternId: triadId,
          title: entry.title,
          theme: entry.theme,
          ...passage,
          ...(includeMetadata ? { metadata: { triadId, isComplete: true } } : {})
        });
      }
    });
  }

  // Priority 2: Fool's Journey stage (developmental context)
  // Only take first passage per stage to avoid duplicate titles in UI
  if (graphKeys.foolsJourneyStageKey) {
    const entry = getPassagesForPattern('fools-journey', graphKeys.foolsJourneyStageKey);
    if (entry && entry.passages && entry.passages.length > 0) {
      const passage = entry.passages[0];
      passages.push({
        priority: 2,
        type: 'fools-journey',
        patternId: graphKeys.foolsJourneyStageKey,
        title: entry.title,
        theme: entry.theme,
        stage: entry.stage,
        ...passage,
        ...(includeMetadata
          ? { metadata: { stageKey: graphKeys.foolsJourneyStageKey } }
          : {})
      });
    }
  }

  // Priority 3: High-significance dyads (powerful two-card synergies)
  // Only take first passage per dyad to avoid duplicate titles in UI
  if (Array.isArray(graphKeys.dyadPairs) && graphKeys.dyadPairs.length > 0) {
    graphKeys.dyadPairs
      .filter((dyad) => dyad.significance === 'high')
      .forEach((dyad) => {
        const dyadKey = dyad.cards.join('-');
        const entry = getPassagesForPattern('dyad', dyadKey);
        if (entry && entry.passages && entry.passages.length > 0) {
          const passage = entry.passages[0];
          passages.push({
            priority: 3,
            type: 'dyad',
            patternId: dyadKey,
            theme: entry.theme,
            cardNumbers: dyad.cards,
            cardNames: entry.names,
            ...passage,
            ...(includeMetadata
              ? { metadata: { cards: dyad.cards, category: dyad.category } }
              : {})
          });
        }
      });
  }

  // Priority 4: Strong suit progressions (Minor Arcana developmental arcs)
  // Only take first passage per progression to avoid duplicate titles in UI
  if (Array.isArray(graphKeys.suitProgressions) && graphKeys.suitProgressions.length > 0) {
    graphKeys.suitProgressions
      .filter((prog) => prog.significance === 'strong-progression')
      .forEach((prog) => {
        const progKey = `${prog.suit}:${prog.stage}`;
        const entry = getPassagesForPattern('suit-progression', progKey);
        if (entry && entry.passages && entry.passages.length > 0) {
          const passage = entry.passages[0];
          passages.push({
            priority: 4,
            type: 'suit-progression',
            patternId: progKey,
            title: entry.title,
            suit: prog.suit,
            stage: prog.stage,
            ...passage,
            ...(includeMetadata ? { metadata: { suit: prog.suit, stage: prog.stage } } : {})
          });
        }
      });
  }

  // Sort by priority (lower number = higher priority) and relevance to user query
  const keywords = (options.userQuery || '').toLowerCase().match(/\w+/g) || [];
  const significantKeywords = keywords.filter(w => w.length > 3 && !['what', 'when', 'where', 'which', 'this', 'that', 'have', 'from', 'with', 'about', 'card', 'reading'].includes(w));

  passages.forEach(p => {
    p.relevance = 0;
    const text = (p.text + ' ' + (p.title || '') + ' ' + (p.theme || '')).toLowerCase();
    significantKeywords.forEach(kw => {
      if (text.includes(kw)) p.relevance += 1;
    });
  });

  const ranked = passages
    .sort((a, b) => {
      // Boost priority by 2.0 per keyword match (lower score is better)
      const scoreA = a.priority - (a.relevance * 2.0);
      const scoreB = b.priority - (b.relevance * 2.0);
      return scoreA - scoreB;
    })
    .slice(0, maxPassages);

  return ranked;
}

/**
 * Format retrieved passages for injection into LLM prompts
 *
 * @param {Array<Object>} passages - Retrieved passages from retrievePassages()
 * @param {Object} [options]
 * @param {boolean} [options.includeSource=true] - Show passage sources
 * @param {boolean} [options.markdown=true] - Format as markdown
 * @returns {string} Formatted passages ready for prompt injection
 *
 * @example
 * const formatted = formatPassagesForPrompt(passages);
 * // Returns formatted markdown with section header and passages
 */
export function formatPassagesForPrompt(passages, options = {}) {
  const includeSource = options.includeSource !== false;
  const markdown = options.markdown !== false;

  if (!Array.isArray(passages) || passages.length === 0) {
    return '';
  }

  const lines = [];

  if (markdown) {
    lines.push('**Retrieved Wisdom from Tarot Tradition:**');
    lines.push('');
  } else {
    lines.push('Retrieved Wisdom from Tarot Tradition:');
    lines.push('');
  }

  passages.forEach((passage, index) => {
    const number = index + 1;

    // Title line
    if (passage.title) {
      if (markdown) {
        lines.push(`${number}. **${passage.title}**`);
      } else {
        lines.push(`${number}. ${passage.title}`);
      }
    } else if (passage.theme) {
      if (markdown) {
        lines.push(`${number}. **${passage.theme}**`);
      } else {
        lines.push(`${number}. ${passage.theme}`);
      }
    }

    // Passage text
    if (passage.text) {
      const indent = '   ';
      if (markdown) {
        lines.push(`${indent}"${passage.text}"`);
      } else {
        lines.push(`${indent}${passage.text}`);
      }
    }

    // Source attribution
    if (includeSource && passage.source) {
      const indent = '   ';
      if (markdown) {
        lines.push(`${indent}— ${passage.source}`);
      } else {
        lines.push(`${indent}(Source: ${passage.source})`);
      }
    }

    lines.push('');
  });

  return lines.join('\n');
}

/**
 * Build a retrieval summary for debugging/telemetry
 *
 * @param {Object} graphKeys - Graph keys from buildGraphContext()
 * @param {Array<Object>} passages - Retrieved passages
 * @returns {Object} Summary of retrieval results
 */
export function buildRetrievalSummary(graphKeys, passages) {
  const summary = {
    graphKeysProvided: !!graphKeys,
    patternsDetected: {
      completeTriads: graphKeys?.completeTriadIds?.length || 0,
      partialTriads: (graphKeys?.triadIds?.length || 0) - (graphKeys?.completeTriadIds?.length || 0),
      foolsJourneyStage: graphKeys?.foolsJourneyStageKey || null,
      highDyads: graphKeys?.dyadPairs?.filter((d) => d.significance === 'high').length || 0,
      strongSuitProgressions:
        graphKeys?.suitProgressions?.filter((p) => p.significance === 'strong-progression')
          .length || 0
    },
    passagesRetrieved: passages?.length || 0,
    passagesByType: passages?.reduce((acc, p) => {
      acc[p.type] = (acc[p.type] || 0) + 1;
      return acc;
    }, {}),
    passagesByPriority: passages?.reduce((acc, p) => {
      const key = `priority${p.priority}`;
      acc[key] = (acc[key] || 0) + 1;
      return acc;
    }, {})
  };

  return summary;
}

/**
 * Check if GraphRAG is enabled via environment
 *
 * @param {Object} [env] - Environment object (e.g., Cloudflare Worker env or process.env)
 * @returns {boolean} True if GraphRAG should be used
 */
export function isGraphRAGEnabled(env) {
  // Prefer provided env (for Workers), fall back to process.env (for Node.js)
  let effectiveEnv = env;
  
  if (!effectiveEnv) {
    if (typeof process !== 'undefined' && process.env) {
      effectiveEnv = process.env;
    } else {
      // No env available - default to enabled
      return true;
    }
  }

  // Check GRAPHRAG_ENABLED first (preferred), fall back to legacy KNOWLEDGE_GRAPH_ENABLED
  const envValue = effectiveEnv.GRAPHRAG_ENABLED ?? effectiveEnv.KNOWLEDGE_GRAPH_ENABLED;

  // Explicitly disabled
  if (envValue === 'false' || envValue === '0') {
    return false;
  }

  // Explicitly enabled
  if (envValue === 'true' || envValue === '1') {
    return true;
  }

  // Default: enabled (opt-out rather than opt-in for prototype)
  return true;
}

/**
 * Get knowledge base statistics for monitoring
 *
 * @returns {Object} Knowledge base coverage stats
 */
export function getKnowledgeBaseInfo() {
  return getKnowledgeBaseStats();
}

// ============================================================================
// QUALITY FILTERING ENHANCEMENTS
// ============================================================================

/**
 * Score passage relevance against user query.
 * Combines fast keyword matching with optional semantic similarity.
 *
 * @param {string} passage - The passage text
 * @param {string} userQuery - User's question
 * @param {Object} [options] - Scoring options
 * @param {number} [options.keywordWeight=0.3] - Weight for keyword score
 * @param {number} [options.semanticWeight=0.7] - Weight for semantic score
 * @param {boolean} [options.enableSemanticScoring=false] - Use embeddings API
 * @param {Object} [options.env] - Environment variables for API calls
 * @returns {Promise<number>} Relevance score 0-1
 *
 * @example
 * const score = await scorePassageRelevance(
 *   "The Fool represents new beginnings...",
 *   "What does this new chapter hold for me?",
 *   { enableSemanticScoring: true }
 * );
 * // Returns ~0.75 (high relevance)
 */
export async function scorePassageRelevance(passage, userQuery, options = {}) {
  const { keywordWeight = 0.3, semanticWeight = 0.7 } = options;

  if (!userQuery || !passage) {
    return 0.5; // Default neutral score
  }

  const queryText = typeof userQuery === 'string' ? userQuery : '';
  const passageText = typeof passage === 'string' ? passage : '';

  if (!queryText.trim() || !passageText.trim()) {
    return 0.5;
  }

  // Keyword overlap scoring (fast, cheap)
  const queryTerms = queryText
    .toLowerCase()
    .split(/\W+/)
    .filter((t) => t.length > 3);
  const passageLower = passageText.toLowerCase();
  const keywordMatches = queryTerms.filter((term) =>
    passageLower.includes(term)
  );
  const keywordScore =
    queryTerms.length > 0 ? keywordMatches.length / queryTerms.length : 0;

  // Semantic similarity (requires embeddings API)
  let semanticScore = 0.5; // Default to neutral if semantic scoring disabled/fails
  if (options.enableSemanticScoring) {
    try {
      const [queryEmbed, passageEmbed] = await Promise.all([
        embedText(queryText, { env: options.env }),
        embedText(passageText.slice(0, 500), { env: options.env }) // Truncate for efficiency
      ]);
      semanticScore = cosineSimilarity(queryEmbed, passageEmbed);
    } catch (err) {
      console.warn('[GraphRAG] Semantic scoring failed:', err.message);
      // Fall back to keyword-only scoring
      return keywordScore;
    }
  }

  return keywordScore * keywordWeight + semanticScore * semanticWeight;
}

/**
 * Remove passages with high content overlap.
 * Uses a simple fingerprint-based approach for efficiency.
 *
 * @param {Array<Object>} passages - Passages to deduplicate
 * @param {Object} [options] - Deduplication options
 * @param {number} [options.fingerprintLength=100] - Characters to use for fingerprint
 * @returns {Array<Object>} Deduplicated passages
 *
 * @example
 * const unique = deduplicatePassages(passages);
 */
export function deduplicatePassages(passages, options = {}) {
  const fingerprintLength = options.fingerprintLength || 100;

  if (!Array.isArray(passages) || passages.length === 0) {
    return [];
  }

  const seen = new Set();

  return passages.filter((passage) => {
    if (!passage || typeof passage.text !== 'string') {
      return true; // Keep passages without text (shouldn't happen but be safe)
    }

    // Generate content fingerprint (normalized first N chars)
    const fingerprint = passage.text
      .toLowerCase()
      .replace(/\s+/g, ' ')
      .trim()
      .slice(0, fingerprintLength);

    if (seen.has(fingerprint)) {
      return false; // Duplicate, filter out
    }

    seen.add(fingerprint);
    return true;
  });
}

/**
 * Rank passages for prompt injection, prioritizing semantic relevance when available.
 * Falls back to keyword overlap, then priority ordering.
 *
 * @param {Array<Object>} passages
 * @param {Object} [options]
 * @param {number} [options.limit] - Optional limit for returned passages
 * @returns {{passages: Array<Object>, strategy: string}}
 */
export function rankPassagesForPrompt(passages, options = {}) {
  if (!Array.isArray(passages) || passages.length === 0) {
    return { passages: [], strategy: 'none' };
  }

  const limit = Math.min(
    Math.max(1, options.limit || passages.length),
    passages.length
  );

  const strategy = determineRankingStrategy(passages);
  const ranked = [...passages]
    .sort((a, b) => comparePassagesForPrompt(a, b, strategy))
    .slice(0, limit);

  return { passages: ranked, strategy };
}

function determineRankingStrategy(passages) {
  if (passages.some((p) => typeof p?.relevanceScore === 'number')) {
    return 'semantic';
  }
  if (passages.some((p) => typeof p?.relevance === 'number')) {
    return 'keyword';
  }
  return 'priority';
}

function getPrimaryScore(passage, strategy) {
  if (strategy === 'semantic') {
    return typeof passage.relevanceScore === 'number' ? passage.relevanceScore : 0;
  }
  if (strategy === 'keyword') {
    return typeof passage.relevance === 'number' ? passage.relevance : 0;
  }

  // Priority: lower numbers are higher priority, so invert for comparison
  const priority = typeof passage.priority === 'number' ? passage.priority : Infinity;
  return priority === Infinity ? 0 : 1 / (1 + priority);
}

function comparePassagesForPrompt(a, b, strategy) {
  const scoreA = getPrimaryScore(a, strategy);
  const scoreB = getPrimaryScore(b, strategy);
  if (scoreA !== scoreB) {
    return scoreB - scoreA;
  }

  const keywordA = typeof a.relevance === 'number' ? a.relevance : 0;
  const keywordB = typeof b.relevance === 'number' ? b.relevance : 0;
  if (keywordA !== keywordB) {
    return keywordB - keywordA;
  }

  const priorityA = typeof a.priority === 'number' ? a.priority : Infinity;
  const priorityB = typeof b.priority === 'number' ? b.priority : Infinity;
  if (priorityA !== priorityB) {
    return priorityA - priorityB;
  }

  return 0;
}

/**
 * Enhanced retrieval with quality filtering.
 * Builds on retrievePassages() but adds:
 * - Relevance scoring (keyword + semantic)
 * - Quality threshold filtering
 * - Deduplication
 *
 * @param {Object} graphKeys - Graph keys from buildGraphContext()
 * @param {Object} [options] - Retrieval options
 * @param {number} [options.maxPassages=5] - Maximum passages to return
 * @param {string} [options.userQuery=''] - User's question for relevance scoring
 * @param {number} [options.minRelevanceScore=0.3] - Minimum relevance to include
 * @param {boolean} [options.enableDeduplication=true] - Remove similar passages
 * @param {boolean} [options.enableSemanticScoring=false] - Use embeddings API
 * @param {Object} [options.env] - Environment variables for API calls
 * @returns {Promise<Array<Object>>} Quality-filtered, scored passages
 *
 * @example
 * const passages = await retrievePassagesWithQuality(
 *   themes.knowledgeGraph.graphKeys,
 *   {
 *     maxPassages: 5,
 *     userQuery: "What does this new chapter hold?",
 *     minRelevanceScore: 0.35,
 *     enableSemanticScoring: true
 *   }
 * );
 */
export async function retrievePassagesWithQuality(graphKeys, options = {}) {
  const {
    maxPassages = 5,
    userQuery = '',
    minRelevanceScore = 0.3,
    enableDeduplication = true,
    enableSemanticScoring = false,
    env = null
  } = options;

  // Check if quality filtering is disabled via env
  const disableQualityFiltering = env?.DISABLE_PROMPT_SLIMMING === 'true' ||
    env?.DISABLE_PROMPT_SLIMMING === true;

  // Get raw passages (retrieve 2x to allow for filtering, unless filtering disabled)
  const rawPassages = retrievePassages(graphKeys, {
    maxPassages: disableQualityFiltering ? maxPassages : maxPassages * 2,
    userQuery,
    includeMetadata: true
  });

  if (!rawPassages || rawPassages.length === 0) {
    return [];
  }

  // If quality filtering is disabled, return raw passages directly
  if (disableQualityFiltering) {
    return rawPassages.map(p => ({
      ...p,
      relevanceScore: 1.0, // Mark as fully relevant (no filtering applied)
      _qualityFilteringDisabled: true
    }));
  }

  // Score each passage for relevance
  const scoredPassages = await Promise.all(
    rawPassages.map(async (passage) => {
      const relevanceScore = await scorePassageRelevance(
        passage.text,
        userQuery,
        {
          enableSemanticScoring,
          env
        }
      );
      return {
        ...passage,
        relevanceScore,
        // Track whether semantic scoring was enabled for this retrieval
        _semanticScoringEnabled: enableSemanticScoring
      };
    })
  );

  // Filter by quality threshold
  let filtered = scoredPassages.filter(
    (p) => p.relevanceScore >= minRelevanceScore
  );

  // Deduplicate similar passages
  if (enableDeduplication) {
    filtered = deduplicatePassages(filtered);
  }

  // Sort by relevance score (highest first) and take top N
  const ranked = filtered
    .sort((a, b) => b.relevanceScore - a.relevanceScore)
    .slice(0, maxPassages);

  return ranked;
}

/**
 * Build enhanced retrieval summary including quality metrics.
 *
 * @param {Object} graphKeys - Graph keys from buildGraphContext()
 * @param {Array<Object>} passages - Retrieved passages with relevance scores
 * @returns {Object} Summary with quality metrics
 */
export function buildQualityRetrievalSummary(graphKeys, passages) {
  const baseSummary = buildRetrievalSummary(graphKeys, passages);

  // Add quality metrics
  const qualityMetrics = {
    averageRelevance: 0,
    minRelevance: 0,
    maxRelevance: 0,
    semanticScoringUsed: false
  };

  if (Array.isArray(passages) && passages.length > 0) {
    const scores = passages
      .map((p) => p.relevanceScore)
      .filter((s) => typeof s === 'number' && !Number.isNaN(s));

    if (scores.length > 0) {
      qualityMetrics.averageRelevance =
        scores.reduce((sum, s) => sum + s, 0) / scores.length;
      qualityMetrics.minRelevance = Math.min(...scores);
      qualityMetrics.maxRelevance = Math.max(...scores);
    }

    // Check if semantic scoring was enabled for any passage retrieval
    // Uses the _semanticScoringEnabled flag set by retrievePassagesWithQuality
    qualityMetrics.semanticScoringUsed = passages.some(
      (p) => p._semanticScoringEnabled === true
    );
  }

  return {
    ...baseSummary,
    qualityMetrics
  };
}

/**
 * Check if semantic scoring is available (API configured).
 *
 * @param {Object} [env] - Environment variables. Pass null to explicitly check without env.
 * @returns {boolean} True if semantic scoring can be used
 */
export function isSemanticScoringAvailable(env) {
  // If null is explicitly passed, don't fall back to process.env
  if (env === null) {
    return false;
  }
  
  const effectiveEnv = env || (typeof process !== 'undefined' && process.env ? process.env : {});
  return Boolean(effectiveEnv?.AZURE_OPENAI_ENDPOINT && effectiveEnv?.AZURE_OPENAI_API_KEY);
}
</file>

<file path="functions/lib/imageryHooks.js">
import { PIP_NUMEROLOGY, SUIT_THEMES } from './minorMeta.js';

/**
 * Imagery Hooks for Major Arcana
 *
 * Provides visual symbolism and imagery prompts to enrich narrative flow.
 * Each card entry includes:
 * - visual: Key visual elements and symbolism to reference
 * - upright: Imagery interpretation for upright orientation
 * - reversed: Imagery interpretation for reversed orientation
 * - sensory: Sensory language to evoke the card's essence
 *
 * Minor Arcana currently receive suit/rank-aware narrative enrichment via
 * buildMinorSummary() in [`functions/lib/minorMeta.js`](functions/lib/minorMeta.js:1).
 *
 * To reduce Major bias and gently surface Minor context, we add a lightweight
 * imagery layer for Minors focused on:
 * - Court cards: dynamic, character-like imagery prompts
 * - Generic suit-level hooks for pips (Aces–Tens) when needed
 *
 * This uses a conservative, RWS-consistent vocabulary to avoid hallucinations.
 */

export const MINOR_ARCANA_IMAGERY = {
  'Page of Wands': {
    visual: 'Youthful figure holding a sprouting wand in a barren landscape',
    sensory: 'First spark of curiosity, warm breeze of inspiration',
    interpretation: 'Early-stage creative messages, exploring desire with playful courage.'
  },
  'Knight of Wands': {
    visual: 'Rider charging forward on a rearing horse with wand raised',
    sensory: 'Rushing heat, drums of motion, sand kicked up by fast hooves',
    interpretation: 'Bold, impulsive action; pursuing passion quickly and visibly.'
  },
  'Queen of Wands': {
    visual: 'Throne with lions and sunflowers, black cat at her feet',
    sensory: 'Confident warmth, steady firelight, magnetic presence',
    interpretation: 'Confident, charismatic leadership; tending creative fire with assurance.'
  },
  'King of Wands': {
    visual: 'Throne decorated with lions and salamanders, wand flowering',
    sensory: 'Commanding warmth, steady blaze, visionary gaze',
    interpretation: 'Visionary direction and decisive will in creative or entrepreneurial realms.'
  },
  'Page of Cups': {
    visual: 'Youthful figure contemplating a cup with a small fish emerging',
    sensory: 'Soft tide against shore, shy smile, gentle surprise',
    interpretation: 'Tentative emotional openings, messages of the heart, intuitive nudges.'
  },
  'Knight of Cups': {
    visual: 'Armored figure carrying a cup, horse stepping carefully',
    sensory: 'Calm river, invitation in motion, poetic sincerity',
    interpretation: 'Romantic or idealistic pursuit; moving toward emotional or creative offers.'
  },
  'Queen of Cups': {
    visual: 'Throne by the sea, ornate covered cup held with devotion',
    sensory: 'Quiet waves, deep listening, comforting embrace',
    interpretation: 'Emotional depth, empathy, intuitive care; holding space with sensitivity.'
  },
  'King of Cups': {
    visual: 'Throne on the water, waves beneath, cup and scepter balanced',
    sensory: 'Rocking tide, composed breath, storm held kindly',
    interpretation: 'Emotional maturity and steady leadership amid changing feelings.'
  },
  'Page of Swords': {
    visual: 'Youth with raised sword in shifting winds',
    sensory: 'Quick gusts, alert stance, restless thoughts',
    interpretation: 'Curiosity of the mind, questions, watching and learning; messages or ideas emerging.'
  },
  'Knight of Swords': {
    visual: 'Rider charging forward with sword raised, trees bent by wind',
    sensory: 'Cutting wind, urgent hooves, sharp focus',
    interpretation: 'Swift, uncompromising communication or decisions; moving fast on convictions.'
  },
  'Queen of Swords': {
    visual: 'Throne in clear air, sword upright, hand extended',
    sensory: 'Crisp clarity, cool breeze, discerning gaze',
    interpretation: 'Honest insight, boundaries, compassionate but direct truth-telling.'
  },
  'King of Swords': {
    visual: 'Throne high above, sword held with authority',
    sensory: 'Still air before a verdict, precise words, mental order',
    interpretation: 'Strategic thought, clear judgment, accountability through intellect.'
  },
  'Page of Pentacles': {
    visual: 'Youth studying a pentacle in a green field',
    sensory: 'Fresh soil, focused gaze, new sprout',
    interpretation: 'Beginnings in study, work, or health; grounding dreams into first practical steps.'
  },
  'Knight of Pentacles': {
    visual: 'Rider on a still horse, pentacle held steady',
    sensory: 'Slow hoofbeats, patient breath, tilled earth',
    interpretation: 'Steady, methodical progress; diligence, reliability, and follow-through.'
  },
  'Queen of Pentacles': {
    visual: 'Throne amidst vines and wildlife, pentacle cradled',
    sensory: 'Warm hearth, fertile garden, soothing touch',
    interpretation: 'Nurturing practicality; care through tangible support and resourcing.'
  },
  'King of Pentacles': {
    visual: 'Throne adorned with bulls and grapes, city behind',
    sensory: 'Weight of success, rich textures, secure footing',
    interpretation: 'Material mastery; stewardship of resources, legacy, and stability.'
  }
};

export const MINOR_SUIT_IMAGERY = {
  Wands: {
    visual: 'flame, branch, wand, desert heat, campfire glow',
    sensory: 'crackle of fire, rush of momentum, creative spark',
    interpretation: 'Action, will, creativity, desire, initiation.'
  },
  Cups: {
    visual: 'chalice, flowing water, moonlit sea, shared cup',
    sensory: 'cool tides, heart swell, intuitive currents',
    interpretation: 'Emotions, relationships, intuition, care, receptivity.'
  },
  Swords: {
    visual: 'sword, wind, storm clouds, cut of air',
    sensory: 'sharp clarity, mental buzz, cool edge',
    interpretation: 'Mind, truth, decisions, communication, conflict and resolution.'
  },
  Pentacles: {
    visual: 'coin, garden, stone path, roots',
    sensory: 'solid ground, steady heartbeat, tactile focus',
    interpretation: 'Body, work, resources, health, tangible commitments.'
  }
};

const PIP_RANK_VALUES = {
  Ace: 1,
  Two: 2,
  Three: 3,
  Four: 4,
  Five: 5,
  Six: 6,
  Seven: 7,
  Eight: 8,
  Nine: 9,
  Ten: 10
};

function buildPipInterpretation(suit, rank) {
  const rankValue = PIP_RANK_VALUES[rank];
  const numerology = rankValue ? PIP_NUMEROLOGY[rankValue] : null;
  const suitTheme = SUIT_THEMES[suit] || `${suit.toLowerCase()} matters`;
  if (!numerology) {
    return `It deepens the ${suit} story through lived experience.`;
  }
  return `It highlights ${numerology} within ${suitTheme}.`;
}

export const MINOR_PIP_IMAGERY = {
  'Ace of Wands': {
    visual: 'Hand emerging from a cloud presenting a sprouting wand above rolling hills and a distant castle',
    sensory: 'Pulse of heat in the palm, scent of resin and fresh growth on the wind',
    interpretation: buildPipInterpretation('Wands', 'Ace')
  },
  'Two of Wands': {
    visual: 'Figure standing on castle battlements holding a globe with two wands anchoring the space',
    sensory: 'Cool stone beneath boots, breeze carrying distant possibilities',
    interpretation: buildPipInterpretation('Wands', 'Two')
  },
  'Three of Wands': {
    visual: 'Cloaked traveler watching ships depart from a cliff beside three rooted wands',
    sensory: 'Salt air rising with anticipation, cloak catching a steady breeze',
    interpretation: buildPipInterpretation('Wands', 'Three')
  },
  'Four of Wands': {
    visual: 'Garland-draped wands forming a ceremonial arch as figures celebrate beyond it',
    sensory: 'Laughter and music in warm air, scent of flowers and festivity',
    interpretation: buildPipInterpretation('Wands', 'Four')
  },
  'Five of Wands': {
    visual: 'Band of youths brandishing wands in spirited but chaotic competition',
    sensory: 'Wooden staffs clacking, breathless shouts, crackle of spirited rivalry',
    interpretation: buildPipInterpretation('Wands', 'Five')
  },
  'Six of Wands': {
    visual: 'Laureled rider on horseback raising a wand while onlookers hold theirs aloft',
    sensory: 'Cheer of the crowd, rhythmic hoofbeats, triumph warming the chest',
    interpretation: buildPipInterpretation('Wands', 'Six')
  },
  'Seven of Wands': {
    visual: 'Guardian braced on a hilltop thrusting a wand against unseen challengers below',
    sensory: 'Adrenaline-quickened breath, gritty soil underfoot, resistance humming in muscles',
    interpretation: buildPipInterpretation('Wands', 'Seven')
  },
  'Eight of Wands': {
    visual: 'Eight wands streak diagonally through clear sky above distant meadows',
    sensory: 'Rush of wind, momentum whistling forward, anticipation crackling',
    interpretation: buildPipInterpretation('Wands', 'Eight')
  },
  'Nine of Wands': {
    visual: 'Bandaged sentinel gripping a wand while eight others stand like a fence behind',
    sensory: 'Muscles aching yet alert, heartbeat steadying, smell of earth after effort',
    interpretation: buildPipInterpretation('Wands', 'Nine')
  },
  'Ten of Wands': {
    visual: 'Figure hunched beneath the weight of ten bundled wands trudging toward town',
    sensory: 'Strain in shoulders, labored breath, warmth of duty despite fatigue',
    interpretation: buildPipInterpretation('Wands', 'Ten')
  },
  'Ace of Cups': {
    visual: 'Hand emerging from a cloud presenting an overflowing chalice crowned by a dove',
    sensory: 'Cool overflow cascading, heart swelling with gentle pulse of grace',
    interpretation: buildPipInterpretation('Cups', 'Ace')
  },
  'Two of Cups': {
    visual: 'Two figures exchange cups beneath a caduceus and lion-headed emblem',
    sensory: 'Soft exchange of vows, shared heartbeat, warmth of mutual recognition',
    interpretation: buildPipInterpretation('Cups', 'Two')
  },
  'Three of Cups': {
    visual: 'Three women dance in a circle, cups raised amid harvest bounty',
    sensory: 'Clinking cups, joyful laughter, scent of ripe fruit and flowers',
    interpretation: buildPipInterpretation('Cups', 'Three')
  },
  'Four of Cups': {
    visual: 'Seated figure beneath a tree contemplates three cups as a fourth is offered by a cloud',
    sensory: 'Still air, muted heartbeat, cool bark pressing against the back during contemplation',
    interpretation: buildPipInterpretation('Cups', 'Four')
  },
  'Five of Cups': {
    visual: 'Cloaked figure mourns over three spilled cups while two remain standing near a river',
    sensory: 'Cold mist clinging to skin, heaviness in the chest, distant rush of water not yet heard',
    interpretation: buildPipInterpretation('Cups', 'Five')
  },
  'Six of Cups': {
    visual: 'Child offers a flower-filled cup to another within a sunlit courtyard',
    sensory: 'Sweet scent of blossoms, gentle laughter, nostalgia like warm sunlight',
    interpretation: buildPipInterpretation('Cups', 'Six')
  },
  'Seven of Cups': {
    visual: 'Silhouetted figure gazes at seven floating cups filled with fantastical visions',
    sensory: 'Dreamlike haze, shimmering possibilities, dizzying mix of desire and uncertainty',
    interpretation: buildPipInterpretation('Cups', 'Seven')
  },
  'Eight of Cups': {
    visual: 'Traveler climbs away from stacked cups under moonlit sky and distant mountains',
    sensory: 'Cool night air, crunch of gravel underfoot, pull of inner longing guiding the step',
    interpretation: buildPipInterpretation('Cups', 'Eight')
  },
  'Nine of Cups': {
    visual: 'Content figure sits before a curved display of nine cups like trophies',
    sensory: 'Satiated sigh, velvety richness, quiet confidence settling in the belly',
    interpretation: buildPipInterpretation('Cups', 'Nine')
  },
  'Ten of Cups': {
    visual: 'Family rejoices beneath a rainbow of cups arching over a pastoral home',
    sensory: 'Children laughing, harmonized heartbeat of loved ones, gentle rain-washed breeze',
    interpretation: buildPipInterpretation('Cups', 'Ten')
  },
  'Ace of Swords': {
    visual: 'Hand from a cloud raises a crowned sword above jagged mountains',
    sensory: 'Cool rush of clarity, ozone in the air, mind snapping into focus',
    interpretation: buildPipInterpretation('Swords', 'Ace')
  },
  'Two of Swords': {
    visual: 'Blindfolded figure sits at the shoreline with crossed swords under a moonlit sky',
    sensory: 'Still night breeze, tension in shoulders, quiet of suspended decision',
    interpretation: buildPipInterpretation('Swords', 'Two')
  },
  'Three of Swords': {
    visual: 'Heart pierced by three swords against a storm-laden, rain-filled sky',
    sensory: 'Sharp sting of heartbreak, chill of rain, echo of thunder inside the chest',
    interpretation: buildPipInterpretation('Swords', 'Three')
  },
  'Four of Swords': {
    visual: 'Knight rests on a tomb within a chapel, swords hanging on the wall and one beneath',
    sensory: 'Sacred silence, slow measured breath, cool stone supporting stillness',
    interpretation: buildPipInterpretation('Swords', 'Four')
  },
  'Five of Swords': {
    visual: 'Figure gathers swords with a sly grin as defeated figures walk away along the beach',
    sensory: 'Salt wind whipping, hollow victory buzzing in ears, footsteps receding on wet sand',
    interpretation: buildPipInterpretation('Swords', 'Five')
  },
  'Six of Swords': {
    visual: 'Boat ferries cloaked figures across calm water with swords standing in the bow',
    sensory: 'Gentle rocking of the boat, soft lapping water, muted conversation of transition',
    interpretation: buildPipInterpretation('Swords', 'Six')
  },
  'Seven of Swords': {
    visual: 'Sneaking figure tiptoes from a camp carrying five swords, two left behind',
    sensory: 'Rustle of tents, quickened pulse, careful feet on dewy grass',
    interpretation: buildPipInterpretation('Swords', 'Seven')
  },
  'Eight of Swords': {
    visual: 'Blindfolded figure stands bound amid eight swords planted in soggy ground',
    sensory: 'Damp chill around ankles, breath shallow, mind searching for the gap in confinement',
    interpretation: buildPipInterpretation('Swords', 'Eight')
  },
  'Nine of Swords': {
    visual: 'Person bolts upright in bed with hands covering their face, nine swords etched on the wall',
    sensory: 'Nightmare echo, rapid heartbeat, darkness pressing against awareness',
    interpretation: buildPipInterpretation('Swords', 'Nine')
  },
  'Ten of Swords': {
    visual: 'First light dawns behind a figure lying prone with ten swords in their back',
    sensory: 'Cold shock of finality, stillness before sunrise, awareness of inevitable ending',
    interpretation: buildPipInterpretation('Swords', 'Ten')
  },
  'Ace of Pentacles': {
    visual: 'Hand extends a pentacle from a cloud above a flowering garden and open archway',
    sensory: 'Fresh earth scent, solid weight of opportunity in the palm, promise of growth',
    interpretation: buildPipInterpretation('Pentacles', 'Ace')
  },
  'Two of Pentacles': {
    visual: 'Figure juggles two pentacles linked by an infinity loop with ships pitching on waves behind',
    sensory: 'Playful sway under shifting ground, salty breeze, balancing heartbeat keeping time',
    interpretation: buildPipInterpretation('Pentacles', 'Two')
  },
  'Three of Pentacles': {
    visual: 'Craftsman discusses cathedral plans with monk and noble as pentacles decorate the arch',
    sensory: 'Chisel tapping stone, collaborative murmurs, dust motes lit by stained glass',
    interpretation: buildPipInterpretation('Pentacles', 'Three')
  },
  'Four of Pentacles': {
    visual: 'Figure sits guarding pentacles with a cityscape beyond',
    sensory: 'Grip tightening around coin, sturdy seat beneath, city hum muted by guarded focus',
    interpretation: buildPipInterpretation('Pentacles', 'Four')
  },
  'Five of Pentacles': {
    visual: 'Two figures hobble through snow past a stained-glass window filled with pentacles',
    sensory: 'Biting cold on skin, crunch of snow, faint glow of sanctuary just out of reach',
    interpretation: buildPipInterpretation('Pentacles', 'Five')
  },
  'Six of Pentacles': {
    visual: 'Merchant balances scales while giving coins to two kneeling figures',
    sensory: 'Clink of coins, warm generosity flowing, gratitude mingling with need',
    interpretation: buildPipInterpretation('Pentacles', 'Six')
  },
  'Seven of Pentacles': {
    visual: 'Gardener pauses to assess pentacles growing on a vine by his side',
    sensory: 'Earth under boots, patient breath, smell of greenery in slow maturation',
    interpretation: buildPipInterpretation('Pentacles', 'Seven')
  },
  'Eight of Pentacles': {
    visual: 'Craftsman carves pentacles along a workbench with a town in the distance',
    sensory: 'Steady rhythm of hammer and chisel, focused gaze, calloused hands warm with effort',
    interpretation: buildPipInterpretation('Pentacles', 'Eight')
  },
  'Nine of Pentacles': {
    visual: 'Elegant figure in a vineyard holds a falcon with pentacles arrayed behind',
    sensory: 'Silk brushing skin, bird\'s steady heartbeat, sunlit abundance settling calmly',
    interpretation: buildPipInterpretation('Pentacles', 'Nine')
  },
  'Ten of Pentacles': {
    visual: 'Generational scene beneath an archway adorned with pentacles, dogs at an elder\'s feet',
    sensory: 'Home\'s hearth-warmth, gentle murmur of family, legacy felt in every touch',
    interpretation: buildPipInterpretation('Pentacles', 'Ten')
  }
};

export const MAJOR_ARCANA_IMAGERY = {
  0: { // The Fool
    visual: "Figure at cliff's edge, white rose in hand, small dog at heels, sun rising behind",
    upright: "Notice the Fool's gaze toward the horizon—an invitation to step forward into the unknown with trust.",
    reversed: "The figure hesitates at the precipice; the leap requires more preparation before the jump.",
    sensory: "Air fresh with possibility, ground firm yet temporary, the moment before flight"
  },

  1: { // The Magician
    visual: "Figure with infinity symbol overhead, tools of all suits laid before them, one hand to heaven, one to earth",
    upright: "See the Magician's tools arrayed—all resources are present; what matters now is focused will.",
    reversed: "The tools remain, but the connecting current wavers; redirect scattered energy inward.",
    sensory: "Electric potential humming, channel opening, the sensation of power seeking direction"
  },

  2: { // The High Priestess
    visual: "Seated figure between pillars, lunar crown, scroll of hidden knowledge, veil behind",
    upright: "Picture the veil behind the High Priestess—what's concealed will reveal itself through intuition, not force.",
    reversed: "The veil thickens; secrets remain hidden, requiring deeper stillness to penetrate.",
    sensory: "Moonlit silence, whispered knowing, the weight of unspoken truth"
  },

  3: { // The Empress
    visual: "Reclining figure in nature, wheat fields, waterfall, Venus symbol on heart shield",
    upright: "Observe the Empress amid abundance—creativity flows when you nurture rather than push.",
    reversed: "The garden needs tending; creative blocks signal a call to self-care first.",
    sensory: "Rich earth, lush growth, the warmth of sunlight on skin, generative overflow"
  },

  4: { // The Emperor
    visual: "Enthroned figure, ram's head armrests, mountains behind, scepter and orb in hand",
    upright: "Note the Emperor's mountain throne—stability comes through structure, leadership through clarity.",
    reversed: "The throne feels rigid; authority becomes tyranny when divorced from compassion.",
    sensory: "Stone solidity, weight of responsibility, the sharp edges of order"
  },

  5: { // The Hierophant
    visual: "Seated spiritual figure, crossed keys, two acolytes, raised hand in blessing",
    upright: "See the Hierophant's blessing hand—tradition and teaching offer a path, not a prison.",
    reversed: "The keys turn inward; spiritual authority comes from personal truth, not inherited dogma.",
    sensory: "Incense smoke, ancient words, the resonance of collective wisdom"
  },

  6: { // The Lovers
    visual: "Two figures beneath an angel, tree of knowledge behind one, tree of life behind the other",
    upright: "Picture the angel's blessing above the Lovers—alignment of values creates sacred union.",
    reversed: "The figures turn slightly away; misalignment requires honest examination before harmony.",
    sensory: "Magnetic pull, vulnerability exposed, the tremor of choice that shapes destiny"
  },

  7: { // The Chariot
    visual: "Armored figure in chariot, two sphinxes (black and white) pulling, city behind, starry canopy above",
    upright: "Notice the Chariot's opposing sphinxes—mastery comes through directing contrary forces as one.",
    reversed: "The sphinxes pull in different directions; regain control by clarifying where you're heading.",
    sensory: "Reins taut, momentum building, the tension of harnessed power"
  },

  8: { // Strength
    visual: "Figure gently closing or opening lion's mouth, infinity symbol overhead, flowers in hair",
    upright: "See the gentle hand on the lion's jaw—true strength is compassionate persuasion, not domination.",
    reversed: "The lion stirs restlessly; inner courage must be reclaimed through self-compassion first.",
    sensory: "Soft power, warm courage, the paradox of gentle mastery"
  },

  9: { // The Hermit
    visual: "Cloaked figure on mountain peak, lantern held high containing six-pointed star, staff in other hand",
    upright: "Picture the Hermit's lantern piercing darkness—solitude illuminates what crowds obscure.",
    reversed: "The light dims from isolation; balance solitude with connection to avoid withdrawal.",
    sensory: "Crystalline silence, focused beam in darkness, the cold clarity of altitude"
  },

  10: { // Wheel of Fortune
    visual: "Great wheel turning, sphinx atop, snake descending, Anubis rising, Hebrew letters and alchemical symbols",
    upright: "Observe the ever-turning Wheel—cycles change; what rises must descend, what falls will rise again.",
    reversed: "The Wheel resists its turn; clinging to the current phase delays inevitable transformation.",
    sensory: "Momentum shifting, the vertigo of change, fate's hand at the wheel"
  },

  11: { // Justice
    visual: "Seated figure, scales in one hand, sword in the other, purple veil behind, pillars flanking",
    upright: "Notice Justice's balanced scales—truth seeks equilibrium, consequences align with actions.",
    reversed: "The scales tip unfairly; accountability is blurred, requiring honest self-examination.",
    sensory: "Sharp clarity, the weight of truth, balance achieved through precision"
  },

  12: { // The Hanged Man
    visual: "Figure suspended by one foot from living tree, halo around head, peaceful expression, other leg crossed",
    upright: "See the Hanged Man's serene face—surrender inverts perspective, revealing what striving conceals.",
    reversed: "Suspended still, but struggling against the pause; resistance prolongs the waiting.",
    sensory: "Stillness that speaks, inverted clarity, the paradox of progress through pause"
  },

  13: { // Death
    visual: "Armored skeleton on white horse, banner with five-petaled rose, sun rising between towers",
    upright: "Picture the sun rising behind Death—endings clear ground for what must be born next.",
    reversed: "The transformation stalls; inner metamorphosis proceeds privately before outer change manifests.",
    sensory: "Finality's clean cut, composting decay into fertile ground, the phoenix moment"
  },

  14: { // Temperance
    visual: "Angelic figure pouring water between cups, one foot on land, one in water, mountain and rising sun behind",
    upright: "Notice Temperance's flowing water—balance is active mixing, not static division.",
    reversed: "The flow disrupts; excess or deficiency calls for recalibration and patience.",
    sensory: "Alchemical blending, fluid adjustment, the art of measured integration"
  },

  15: { // The Devil
    visual: "Horned figure, inverted pentagram, chained naked figures with tails, torch, raised hand",
    upright: "See the loose chains on the Devil's captives—bondage is often chosen; freedom requires owning the key you hold.",
    reversed: "The chains loosen; awareness of patterns begins liberation from shadow attachments.",
    sensory: "Seductive weight, the comfort of familiar bindings, sulfur and shadow"
  },

  16: { // The Tower
    visual: "Lightning strikes crown of tower, figures falling, flaming debris, gray sky",
    upright: "Notice the Tower's lightning—sudden upheaval shatters false structures, clearing space for truth.",
    reversed: "The strike lands internally; transformation proceeds through private revelation rather than external crisis.",
    sensory: "Thunderclap revelation, foundations crumbling, the vertigo of necessary collapse"
  },

  17: { // The Star
    visual: "Naked figure kneeling, pouring water into pool and onto land, large star overhead, seven smaller stars, bird in tree",
    upright: "Picture the Star's flowing water—hope replenishes when you pour yourself into purpose and trust.",
    reversed: "The water hesitates; renew faith by reconnecting to what you truly believe in.",
    sensory: "Luminous hope, cool renewal, the quiet return of faith"
  },

  18: { // The Moon
    visual: "Full moon with face, two towers, dog and wolf howling, crayfish emerging from water, winding path",
    upright: "See the Moon's deceptive path—navigate uncertainty by trusting intuition when clarity is absent.",
    reversed: "Illusions begin to thin; repressed emotions surface, bringing difficult clarity.",
    sensory: "Silver ambiguity, shifting shadows, the howl of primal emotion"
  },

  19: { // The Sun
    visual: "Radiant sun with face, naked child on white horse, sunflowers, red banner, wall behind",
    upright: "Notice the child's unguarded joy on the Sun's horse—authenticity shines when pretense falls away.",
    reversed: "The light feels too bright or not quite reaching; reconnect with simple pleasures to restore vitality.",
    sensory: "Radiant warmth, innocent delight, golden clarity without shadow"
  },

  20: { // Judgement
    visual: "Angel blowing trumpet, naked figures rising from coffins with arms outstretched, mountains and water",
    upright: "Picture Judgement's trumpet call—reckoning invites you to rise to your highest calling, absolved and renewed.",
    reversed: "The call sounds, but you hesitate; inner critic delays answering what you know you must do.",
    sensory: "Clarion summons, resurrection pull, the weight lifting from old shame"
  },

  21: { // The World
    visual: "Dancer with wreath, wands in hands, surrounded by wreath, four fixed signs in corners",
    upright: "See the World's dancing figure within the wreath—completion celebrates wholeness before the next cycle begins.",
    reversed: "The dance slows near the end; closure delays, or shortcuts prevent true integration.",
    sensory: "Harmonious culmination, the satisfaction of full circle, seeds of the next beginning"
  }
};

/**
 * Get imagery hook for a specific card
 */
export function getImageryHook(cardNumber, orientation = 'upright') {
  const imagery = MAJOR_ARCANA_IMAGERY[cardNumber];
  if (!imagery) return null;

  const isReversed = orientation.toLowerCase() === 'reversed';

  return {
    visual: imagery.visual,
    interpretation: isReversed ? imagery.reversed : imagery.upright,
    sensory: imagery.sensory
  };
}

/**
 * Check if a card is a Major Arcana (0-21)
 */
export function isMajorArcana(cardNumber) {
  return cardNumber !== undefined && cardNumber >= 0 && cardNumber <= 21;
}

/**
 * Get elemental sensory imagery based on elemental relationship
 * These metaphors help illustrate dignity dynamics
 */
export const ELEMENTAL_SENSORY = {
  'Fire-Air': {
    relationship: 'supportive',
    imagery: "Picture a spark fanned into flame—this illustrates how these energies amplify each other's potential."
  },
  'Air-Fire': {
    relationship: 'supportive',
    imagery: "Like wind feeding flame, these forces work together to accelerate momentum and spread influence."
  },
  'Water-Earth': {
    relationship: 'supportive',
    imagery: "As rain nourishes soil, these energies combine to create fertile ground for growth and manifestation."
  },
  'Earth-Water': {
    relationship: 'supportive',
    imagery: "Like riverbanks shaping the flow, these elements guide and contain each other constructively."
  },
  'Fire-Water': {
    relationship: 'tension',
    imagery: "Steam rises where fire meets water—this friction creates obscuring mist that requires skillful navigation."
  },
  'Water-Fire': {
    relationship: 'tension',
    imagery: "Water and flame struggle for dominance; integration requires honoring both emotional depth and passionate drive."
  },
  'Air-Earth': {
    relationship: 'tension',
    imagery: "Wind scatters earth, earth dampens flight—these forces must be consciously balanced to avoid stagnation or chaos."
  },
  'Earth-Air': {
    relationship: 'tension',
    imagery: "Like dust devils in desert, grounded stability and airy ideals create productive friction when held together."
  },
  'Fire-Fire': {
    relationship: 'amplified',
    imagery: "Flame meeting flame intensifies to wildfire—this doubled energy demands conscious direction to avoid burnout."
  },
  'Water-Water': {
    relationship: 'amplified',
    imagery: "Depths upon depths—emotional currents run strong and deep, potentially overwhelming without grounding."
  },
  'Air-Air': {
    relationship: 'amplified',
    imagery: "Thought spirals into thought—mental energy accelerates, brilliant yet requiring earthing to manifest."
  },
  'Earth-Earth': {
    relationship: 'amplified',
    imagery: "Foundation upon foundation builds bedrock stability, though too much weight may resist necessary change."
  }
};

/**
 * Get sensory imagery for elemental relationship
 */
export function getElementalImagery(element1, element2) {
  if (!element1 || !element2) return null;

  const key = `${element1}-${element2}`;
  return ELEMENTAL_SENSORY[key] || null;
}

/**
 * Lightweight Minor Arcana imagery hook.
 *
 * Accepts either:
 * - a full card object: { card, suit, rank, orientation }
 * - or compatible fields via input
 *
 * Returns a conservative imagery descriptor or null if no suitable hook exists.
 */
export function getMinorImageryHook(input) {
  if (!input) return null;

  const {
    card,
    suit,
    rank,
    orientation = 'Upright'
  } = input;

  const name = card || (rank && suit ? `${rank} of ${suit}` : null);
  const isReversed = String(orientation).toLowerCase() === 'reversed';
  const isCourt = ['Page', 'Knight', 'Queen', 'King'].includes(rank);

  // Prefer specific court card hooks
  if (name && MINOR_ARCANA_IMAGERY[name]) {
    const entry = MINOR_ARCANA_IMAGERY[name];
    return {
      visual: entry.visual,
      sensory: entry.sensory,
      interpretation:
        entry.interpretation +
        (isReversed
          ? ' Read this as energy turned inward, delayed, or asking for recalibration.'
          : '')
    };
  }

  if (!isCourt && name && MINOR_PIP_IMAGERY[name]) {
    const pipEntry = MINOR_PIP_IMAGERY[name];
    return {
      visual: pipEntry.visual,
      sensory: pipEntry.sensory,
      interpretation:
        pipEntry.interpretation +
        (isReversed
          ? ' When reversed, notice where this flow turns inward or requests recalibration.'
          : '')
    };
  }

  // Fallback: suit-level hook (for pips and any unlisted minors)
  if (suit && MINOR_SUIT_IMAGERY[suit]) {
    const suitHook = MINOR_SUIT_IMAGERY[suit];
    return {
      visual: suitHook.visual,
      sensory: suitHook.sensory,
      interpretation: suitHook.interpretation
    };
  }

  return null;
}
</file>

<file path="functions/lib/knowledgeBase.js">
// functions/lib/knowledgeBase.js
// Curated tarot wisdom passages for GraphRAG retrieval
//
// This knowledge base provides traditionally-grounded interpretations
// for archetypal patterns detected by the knowledge graph system.
// Each passage is sourced from respected tarot literature and provides
// context that enriches AI-generated readings.
//
// Structure:
// - triads: Complete 3-card narrative arcs
// - foolsJourney: Developmental stage wisdom
// - dyads: Two-card synergies
// - suitProgressions: Minor arcana developmental wisdom

/**
 * Curated passages for archetypal triads
 * Sources: Pollack, Greer, Place, traditional tarot wisdom
 */
export const TRIAD_PASSAGES = {
  'death-temperance-star': {
    title: 'The Healing Arc',
    theme: 'Ending → Integration → Renewal',
    passages: [
      {
        source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom',
        text: 'Death clears away what must die so transformation can begin. Temperance alchemically integrates the lesson, blending opposing forces into harmony. The Star emerges as renewed hope—faith restored after necessary loss. This sequence maps the soul\'s journey through grief into healing.',
        tags: ['transformation', 'grief', 'healing', 'hope', 'alchemy']
      },
      {
        source: 'Mary K. Greer, Tarot for Your Self',
        text: 'When these three appear together, they describe a complete cycle of letting go, processing the change, and emerging with clarity. The ending (Death) is not punishment but preparation. The mixing (Temperance) is not confusion but refinement. The hope (Star) is not naive but earned.',
        tags: ['cycles', 'processing', 'earned-wisdom']
      }
    ]
  },

  'devil-tower-sun': {
    title: 'The Liberation Arc',
    theme: 'Bondage → Rupture → Freedom',
    passages: [
      {
        source: 'Robert Place, The Tarot: History, Symbolism, and Divination',
        text: 'The Devil represents attachment—to substance, to relationships, to beliefs that bind rather than liberate. The Tower is the necessary destruction of those false structures. The Sun reveals the authentic self that was hidden beneath the chains. This arc shows that what feels like catastrophe is often the path to freedom.',
        tags: ['liberation', 'shadow', 'authenticity', 'upheaval', 'freedom']
      },
      {
        source: 'Traditional Golden Dawn interpretation',
        text: 'Bondage perceived, bondage shattered, truth shining clear. The querent recognizes their chains (Devil), experiences the collapse of the prison (Tower), and emerges into unfiltered joy (Sun). Recovery from addiction, leaving toxic dynamics, or breaking from limiting beliefs often follows this pattern.',
        tags: ['addiction', 'recovery', 'breakthrough', 'clarity']
      }
    ]
  },

  'hermit-hangedman-moon': {
    title: 'The Inner Work Arc',
    theme: 'Solitude → Surrender → Mystery',
    passages: [
      {
        source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom',
        text: 'The Hermit withdraws to seek inner truth. The Hanged Man surrenders control and gains new perspective. The Moon takes the seeker into the realm of dreams, symbols, and the unconscious. Together they map a contemplative path—one that requires patience, trust in the process, and willingness to sit with ambiguity.',
        tags: ['contemplation', 'surrender', 'shadow-work', 'unconscious', 'mystery']
      }
    ]
  },

  'magician-chariot-world': {
    title: 'The Mastery Arc',
    theme: 'Skill → Directed Action → Complete Achievement',
    passages: [
      {
        source: 'Mary K. Greer, The Tarot Handbook',
        text: 'The Magician marshals all available resources and recognizes "As above, so below." The Chariot harnesses opposing forces through disciplined will. The World celebrates the integration of all elements into harmonious completion. This is the path of manifestation: potential recognized, effort directed, mastery achieved.',
        tags: ['manifestation', 'mastery', 'integration', 'achievement', 'completion']
      }
    ]
  },

  'empress-lovers-hierophant': {
    title: 'The Values & Commitment Arc',
    theme: 'Abundance → Choice → Sacred Structure',
    passages: [
      {
        source: 'Traditional interpretation',
        text: 'The Empress offers abundance and creative fertility. The Lovers demand a choice aligned with true values. The Hierophant formalizes that choice through commitment, tradition, or teaching. This sequence often appears around relationship milestones, creative projects requiring dedication, or spiritual path selection.',
        tags: ['values', 'commitment', 'choice', 'creativity', 'tradition']
      }
    ]
  },

  'fool-magician-world': {
    title: 'The Complete Manifestation Cycle',
    theme: 'Innocent Beginning → Conscious Skill → Total Integration',
    passages: [
      {
        source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom',
        text: 'Fool, Magician, World: the ouroboros of manifestation. The Fool leaps into pure potential, the Magician channels that energy through conscious will and skill, and the World integrates everything into wholeness. This is the complete creative cycle—from spark to mastery to new beginning. What you start now has the power to transform you entirely.',
        tags: ['manifestation', 'mastery', 'cycles', 'completion', 'wholeness']
      },
      {
        source: 'Mary K. Greer, The Tarot Handbook',
        text: 'When these three appear, you are being shown the full arc of creation: innocence births the vision, skill manifests it, integration completes it. This is not just a project—it is a soul journey. Honor each phase: the not-knowing, the doing, the becoming.',
        tags: ['creation', 'soul-journey', 'process', 'integration']
      }
    ]
  },

  'empress-emperor-hierophant': {
    title: 'The Authority & Structure Arc',
    theme: 'Nurturing Abundance → Order → Traditional Wisdom',
    passages: [
      {
        source: 'Traditional Golden Dawn interpretation',
        text: 'Empress, Emperor, Hierophant form the trinity of earthly authority: nurturing abundance, structured power, and codified wisdom. Together they build institutions—families, organizations, traditions. This arc asks: How do you move from care to structure to teaching? From parent to leader to elder?',
        tags: ['authority', 'structure', 'leadership', 'parenting', 'tradition']
      },
      {
        source: 'Mary K. Greer, Tarot for Your Self',
        text: 'These three cards show the maturation of power: from the Empress\'s fertile abundance through the Emperor\'s disciplined structure to the Hierophant\'s transmission of wisdom to future generations. You are being called to build something lasting.',
        tags: ['power', 'maturation', 'legacy', 'wisdom']
      }
    ]
  },

  'wheel-justice-hangedman': {
    title: 'The Karmic Acceptance Arc',
    theme: 'Fate Turns → Truth Demanded → Surrender to Flow',
    passages: [
      {
        source: 'Robert Place, The Tarot: History, Symbolism, and Divination',
        text: 'Wheel, Justice, Hanged Man: fate spins, truth must be faced, and ultimately surrender is required. This is the path of karmic acceptance—recognizing what lies beyond your control, meeting it with clear eyes, and releasing resistance. Legal matters, relationship patterns, or spiritual reckoning often follow this arc.',
        tags: ['karma', 'acceptance', 'surrender', 'justice', 'fate']
      },
      {
        source: 'Traditional interpretation',
        text: 'When the Wheel turns and Justice arrives, the Hanged Man reminds you: sometimes the most powerful response is to stop fighting. Accept the cycle, honor the truth, release your grip. Wisdom lives in the suspension.',
        tags: ['wisdom', 'release', 'truth', 'cycles']
      }
    ]
  },

  'tower-star-moon': {
    title: 'The Post-Crisis Navigation Arc',
    theme: 'Upheaval → Hope Restored → Navigating Uncertainty',
    passages: [
      {
        source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom',
        text: 'Tower, Star, Moon: the aftermath sequence. The Tower demolishes false structures, the Star offers hope and healing in the rubble, but the Moon reminds you that the path forward is not yet clear. Rebuilding requires faith, patience, and trust in your intuition as you navigate the unknown.',
        tags: ['aftermath', 'healing', 'hope', 'uncertainty', 'faith']
      },
      {
        source: 'Mary K. Greer, The Tarot Handbook',
        text: 'After the Tower\'s upheaval, the Star provides the first breath of relief—hope is not lost. But the Moon cautions: do not rush to clarity. The way forward is mysterious, requiring you to trust what you cannot yet see. This is the liminal space of transformation.',
        tags: ['transformation', 'liminality', 'trust', 'mystery']
      }
    ]
  },

  'strength-hermit-wheel': {
    title: 'The Inner Mastery Through Solitude Arc',
    theme: 'Taming Inner Beasts → Solitary Wisdom → Accepting Cycles',
    passages: [
      {
        source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom',
        text: 'Strength, Hermit, Wheel: the contemplative path. Strength tames inner turmoil through gentleness, the Hermit withdraws to seek truth in solitude, and the Wheel teaches acceptance of life\'s inevitable cycles. This is not passive surrender—it is active wisdom gained through introspection and self-mastery.',
        tags: ['contemplation', 'self-mastery', 'solitude', 'acceptance', 'wisdom']
      },
      {
        source: 'Traditional interpretation',
        text: 'When these three appear together, you are called to a journey inward: master your inner beasts with compassion, seek wisdom in silence, and accept the turning of the Wheel with equanimity. This is the path of the wise hermit who has tamed their own nature.',
        tags: ['inner-work', 'equanimity', 'hermit', 'mastery']
      }
    ]
  }
};

/**
 * Curated passages for Fool's Journey stages
 * Based on Joseph Campbell's Hero's Journey and Jungian individuation
 */
export const FOOLS_JOURNEY_PASSAGES = {
  initiation: {
    title: 'Journey Stage: Initiation (0-7)',
    stage: 'departure',
    theme: 'Building Ego & Identity',
    passages: [
      {
        source: 'Joseph Campbell, The Hero with a Thousand Faces',
        text: 'The initiation stage represents the hero\'s departure into the world—learning who they are, what they value, and how to act with intention. Cards 0-7 show the querent establishing ego structure, encountering archetypal teachers (Magician, High Priestess, Empress, Emperor, Hierophant), making values-based choices (Lovers), and taking disciplined action (Chariot).',
        tags: ['identity', 'ego-formation', 'learning', 'values', 'teachers']
      },
      {
        source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom',
        text: 'When multiple cards fall in the initiation range, the reading centers on foundational questions: Who am I becoming? What am I learning? What structures support or constrain me? This is the work of building a self that can later be transcended.',
        tags: ['foundation', 'self-building', 'identity-formation']
      }
    ]
  },

  integration: {
    title: 'Journey Stage: Integration (8-14)',
    stage: 'initiation',
    theme: 'Shadow Work & Transformation',
    passages: [
      {
        source: 'Carl Jung, Psychology and Alchemy (via tarot interpretation)',
        text: 'The middle journey (Strength through Temperance) represents the soul\'s encounter with shadow, surrender, and necessary endings. This is where the hero faces trials that cannot be overcome through willpower alone. Strength tames the inner beast with compassion. The Hermit seeks solitary wisdom. The Wheel reminds us of cycles beyond control. Justice demands truth. The Hanged Man requires suspension. Death transforms. Temperance integrates.',
        tags: ['shadow', 'surrender', 'transformation', 'integration', 'trials']
      },
      {
        source: 'Mary K. Greer, The Tarot Handbook',
        text: 'Cards 8-14 signal that surface-level solutions won\'t work. The querent must go deeper—releasing control, facing uncomfortable truths, allowing what must die to die, and finding balance through conscious integration rather than forced resolution.',
        tags: ['depth-work', 'letting-go', 'balance', 'conscious-integration']
      }
    ]
  },

  culmination: {
    title: 'Journey Stage: Culmination (15-21)',
    stage: 'return',
    theme: 'Shadow Integration & Cosmic Consciousness',
    passages: [
      {
        source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom',
        text: 'The final seven cards (Devil through World) represent the deepest soul work: confronting shadow (Devil), necessary destruction (Tower), hope restored (Star), navigating illusion (Moon), illumination (Sun), reckoning and rebirth (Judgement), and integration into wholeness (World). When multiple culmination cards appear, the reading touches soul-level themes and life-altering transformations.',
        tags: ['soul-work', 'shadow-integration', 'completion', 'wholeness', 'transcendence']
      },
      {
        source: 'Traditional Golden Dawn interpretation',
        text: 'These final trumps carry the weight of spiritual awakening. They ask the querent to face the deepest darkness and emerge transformed, bringing wisdom back to the world. This is the return phase of the hero\'s journey—integration of all lessons into unified consciousness.',
        tags: ['awakening', 'integration', 'wisdom', 'return', 'cosmic-consciousness']
      }
    ]
  }
};

/**
 * Curated passages for high-significance dyads
 * Two-card synergies that create powerful meaning
 */
export const DYAD_PASSAGES = {
  '13-17': {  // Death + Star
    cards: [13, 17],
    names: ['Death', 'The Star'],
    theme: 'Transformation clearing into hope',
    passages: [
      {
        source: 'Mary K. Greer, Tarot for Your Self',
        text: 'Death and Star together form one of tarot\'s most hopeful pairings. What you\'re releasing (Death) is making space for renewed hope and purpose (Star). The ending is not random loss but intentional clearing. Trust that what falls away does so to make room for healing and inspiration.',
        tags: ['transformation', 'hope', 'renewal', 'trust', 'clearing']
      }
    ]
  },

  '16-19': {  // Tower + Sun
    cards: [16, 19],
    names: ['The Tower', 'The Sun'],
    theme: 'Upheaval revealing clarity',
    passages: [
      {
        source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom',
        text: 'Tower and Sun: what\'s falling apart needed to fall apart so truth and joy could emerge. The Tower destroys false structures; the Sun reveals what was always true beneath the illusions. This combination promises that the upheaval, however painful, clears the path to authentic happiness.',
        tags: ['upheaval', 'truth', 'clarity', 'authenticity', 'revelation']
      }
    ]
  },

  '0-1': {  // Fool + Magician
    cards: [0, 1],
    names: ['The Fool', 'The Magician'],
    theme: 'Innocent potential meeting conscious skill',
    passages: [
      {
        source: 'Traditional interpretation',
        text: 'Fool and Magician together represent beginner\'s mind empowered by mastery. You have both the fresh perspective of a beginner AND the tools to manifest your vision. This is the moment when inspiration (Fool) meets capability (Magician)—a powerful combination for new beginnings grounded in skill.',
        tags: ['beginnings', 'manifestation', 'skill', 'potential', 'empowerment']
      }
    ]
  },

  '15-16': {  // Devil + Tower
    cards: [15, 16],
    names: ['The Devil', 'The Tower'],
    theme: 'Bondage meeting disruption',
    passages: [
      {
        source: 'Mary K. Greer, The Tarot Handbook',
        text: 'Devil and Tower: the chains are breaking whether you\'re ready or not. What felt like security (Devil\'s comfortable bondage) is being forcefully dismantled (Tower\'s upheaval). Embrace the liberation even if it arrives through crisis. This combination often signals freedom from addiction, toxic patterns, or limiting beliefs through dramatic intervention.',
        tags: ['liberation', 'crisis', 'breakthrough', 'addiction', 'freedom']
      }
    ]
  },

  '10-20': {  // Wheel + Judgement
    cards: [10, 20],
    names: ['Wheel of Fortune', 'Judgement'],
    theme: 'Fate meeting conscious reckoning',
    passages: [
      {
        source: 'Traditional Golden Dawn interpretation',
        text: 'Wheel of Fortune and Judgement together mark a karmic cycle completing. The Wheel shows the turn of fate; Judgement calls for conscious integration and evolution. A major cycle is ending—integrate the lesson and rise transformed. This is not random fate but meaningful pattern completion.',
        tags: ['karma', 'cycles', 'reckoning', 'integration', 'completion']
      }
    ]
  },

  '9-2': {  // Hermit + High Priestess
    cards: [9, 2],
    names: ['The Hermit', 'The High Priestess'],
    theme: 'Solitary wisdom accessing intuition',
    passages: [
      {
        source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom',
        text: 'Hermit and High Priestess: solitude creates the quiet space where deep intuitive knowing can finally be heard. The Hermit withdraws from external noise; the High Priestess reveals the wisdom that lives in stillness. Together they counsel: listen within, trust your inner voice, honor the sacred knowledge that emerges in silence.',
        tags: ['solitude', 'intuition', 'inner-wisdom', 'silence', 'listening']
      }
    ]
  },

  '15-6': {  // Devil + Lovers
    cards: [15, 6],
    names: ['The Devil', 'The Lovers'],
    theme: 'Attachment patterns affecting choice',
    passages: [
      {
        source: 'Traditional interpretation',
        text: 'Devil and Lovers together highlight how shadow bondage influences values-based decisions. Attachments, addictions, or fear of loss can distort freedom of choice, especially in relationships. This pairing asks where you may be choosing from compulsion rather than true values, and invites conscious re-alignment.',
        tags: ['attachment', 'shadow', 'relationships', 'choice', 'values']
      }
    ]
  },

  '17-20': {  // Star + Judgement
    cards: [17, 20],
    names: ['The Star', 'Judgement'],
    theme: 'Renewed hope calling forth rebirth',
    passages: [
      {
        source: 'Traditional interpretation',
        text: 'Star and Judgement describe renewed hope calling you into rebirth. The Star restores faith after difficulty; Judgement sounds the call to awaken and respond. Together they suggest that a fresh vision or healing insight is asking you to rise into a higher version of yourself and answer a deeper calling.',
        tags: ['hope', 'rebirth', 'awakening', 'calling', 'healing']
      }
    ]
  },

  '7-21': {  // Chariot + World
    cards: [7, 21],
    names: ['The Chariot', 'The World'],
    theme: 'Determined action reaching completion',
    passages: [
      {
        source: 'Traditional interpretation',
        text: 'Chariot and World together mark determined action reaching completion. The Chariot\'s disciplined will drives toward a goal; the World signals integration and fulfillment. This combination points to sustained effort bearing full fruit, major victories, and the closing of a significant life chapter.',
        tags: ['determination', 'victory', 'completion', 'mastery', 'success']
      }
    ]
  }
};

/**
 * Curated passages for suit progressions
 * Minor Arcana developmental wisdom by suit and stage
 */
export const SUIT_PROGRESSION_PASSAGES = {
  Wands: {
    beginning: {
      title: 'Wands Beginning: Ignition',
      passages: [
        {
          source: 'Mary K. Greer, The Tarot Handbook',
          text: 'Wands Ace through Three represent the ignition phase of creative or professional endeavors. The Ace sparks inspiration, the Two plans with vision, the Three expands with confidence. Multiple cards from this range signal high enthusiasm, early momentum, and the exciting (if sometimes chaotic) energy of new ventures taking off.',
          tags: ['creativity', 'ignition', 'enthusiasm', 'new-ventures', 'momentum']
        }
      ]
    },
    challenge: {
      title: 'Wands Challenge: Testing the Fire',
      passages: [
        {
          source: 'Traditional interpretation',
          text: 'Wands Four through Seven show the testing phase of fire: celebration of early milestones (Four), creative friction and competition (Five), public victory and recognition (Six), and defending what you have built (Seven). When several of these appear together, your creative or professional fire is being tested through competition, visibility, and the need to stand your ground.',
          tags: ['competition', 'recognition', 'defense', 'testing', 'fire']
        }
      ]
    },
    mastery: {
      title: 'Wands Mastery: Culmination',
      passages: [
        {
          source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom',
          text: 'Wands Eight through Ten show the culmination phase: swift momentum (Eight), resilient defense (Nine), and the burden of success (Ten). This is where creative fire reaches peak expression—things move fast, resilience is tested, and the weight of responsibility becomes real. The challenge is sustaining energy without burnout.',
          tags: ['momentum', 'resilience', 'responsibility', 'culmination', 'burnout-risk']
        }
      ]
    }
  },

  Cups: {
    beginning: {
      title: 'Cups Beginning: Emotional Opening',
      passages: [
        {
          source: 'Mary K. Greer, The Tarot Handbook',
          text: 'Cups Ace through Three represent emotional opening—love overflows (Ace), partnership forms (Two), celebration deepens (Three). Multiple cards here suggest the querent is in a phase of receptivity, connection, and joy. The heart is open; relationships are nourishing; community supports growth.',
          tags: ['love', 'connection', 'receptivity', 'joy', 'relationships']
        }
      ]
    },
    challenge: {
      title: 'Cups Challenge: Emotional Complexity',
      passages: [
        {
          source: 'Traditional interpretation',
          text: 'Cups Four through Seven trace emotional complexity: withdrawal or apathy (Four), grief and loss (Five), nostalgia and memory (Six), and the confusion of many options (Seven). When multiple cards from this range appear, feelings are mixed and tender—there is a need to process disappointment, sort through fantasies, and clarify what the heart truly wants.',
          tags: ['grief', 'nostalgia', 'confusion', 'desire', 'discernment']
        }
      ]
    },
    mastery: {
      title: 'Cups Mastery: Emotional Fulfillment',
      passages: [
        {
          source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom',
          text: 'Cups Eight through Ten mark emotional maturity: conscious release (Eight), contentment achieved (Nine), and blessed union (Ten). This phase shows the heart making wise choices—walking away from what no longer nourishes, savoring authentic fulfillment, and building lasting emotional security. The culmination of Cups is deeply satisfying when grounded in truth.',
          tags: ['maturity', 'fulfillment', 'wisdom', 'release', 'authentic-joy']
        }
      ]
    }
  },

  Swords: {
    beginning: {
      title: 'Swords Beginning: Mental Clarity',
      passages: [
        {
          source: 'Traditional interpretation',
          text: 'Swords Ace through Three mark the beginning of mental clarity work: the first piercing insight (Ace), a difficult stalemate of choice (Two), and heartbreak or painful truth (Three). When these cards cluster, the mind is confronting reality, making hard decisions, and acknowledging grief rather than bypassing it.',
          tags: ['truth', 'decision', 'grief', 'clarity', 'beginning']
        }
      ]
    },
    challenge: {
      title: 'Swords Challenge: Mental Struggle',
      passages: [
        {
          source: 'Traditional interpretation',
          text: 'Swords Four through Seven map mental struggle: enforced rest and recovery (Four), conflict and hollow victory (Five), moving toward calmer waters (Six), and strategy or stealth (Seven). Several of these together signal a cycle of conflict, recovery, and strategic adjustment, inviting you to choose peace and clear thinking over winning at any cost.',
          tags: ['conflict', 'rest', 'strategy', 'transition', 'struggle']
        }
      ]
    },
    mastery: {
      title: 'Swords Mastery: Mental Crisis & Liberation',
      passages: [
        {
          source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom',
          text: 'Swords Eight through Ten represent mental crisis before breakthrough: self-imprisonment (Eight), anxiety (Nine), and rock bottom with dawn promised (Ten). The suit of air reaches its most challenging expression here—feeling trapped by thought, overwhelmed by worry, or hit by harsh endings. But Swords\' culmination uniquely promises liberation: the worst is over, and dawn is coming. After the Ten of Swords, only new beginnings remain.',
          tags: ['crisis', 'anxiety', 'breakthrough', 'liberation', 'mental-clarity']
        }
      ]
    }
  },

  Pentacles: {
    beginning: {
      title: 'Pentacles Beginning: Material Foundation',
      passages: [
        {
          source: 'Traditional interpretation',
          text: 'Pentacles Ace through Three represent material foundations: the seed of prosperity (Ace), juggling resources and priorities (Two), and skilled collaboration that builds competence (Three). Multiple cards from this range indicate the start of a tangible project, financial opportunity, or embodiment practice where you are laying groundwork and learning to balance demands.',
          tags: ['resources', 'work', 'foundation', 'collaboration', 'opportunity']
        }
      ]
    },
    challenge: {
      title: 'Pentacles Challenge: Resource Management',
      passages: [
        {
          source: 'Traditional interpretation',
          text: 'Pentacles Four through Seven chart resource management: holding tightly to what you have (Four), experiences of material or spiritual hardship (Five), reciprocity and giving (Six), and patient assessment of results (Seven). When these appear together, money, health, or work themes are under review, inviting more conscious stewardship, generosity, and long-term thinking.',
          tags: ['scarcity', 'generosity', 'assessment', 'stewardship', 'patience']
        }
      ]
    },
    mastery: {
      title: 'Pentacles Mastery: Material Security',
      passages: [
        {
          source: 'Mary K. Greer, The Tarot Handbook',
          text: 'Pentacles Eight through Ten show material mastery: dedicated craftsmanship (Eight), self-sufficiency (Nine), and lasting legacy (Ten). This is where earth energy stabilizes into enduring prosperity—skills refined through practice, independence earned through discipline, and wealth that benefits generations. The Pentacles culmination is the most stable and grounded of all suits.',
          tags: ['mastery', 'stability', 'legacy', 'prosperity', 'discipline']
        }
      ]
    }
  }
};

/**
 * Get all passages for a specific pattern
 */
export function getPassagesForPattern(patternType, patternId) {
  switch (patternType) {
    case 'triad':
      return TRIAD_PASSAGES[patternId] || null;
    case 'fools-journey':
      return FOOLS_JOURNEY_PASSAGES[patternId] || null;
    case 'dyad':
      return DYAD_PASSAGES[patternId] || null;
    case 'suit-progression': {
      const [suit, stage] = patternId.split(':');
      return SUIT_PROGRESSION_PASSAGES[suit]?.[stage] || null;
    }
    default:
      return null;
  }
}

/**
 * Get all available pattern IDs for telemetry/debugging
 */
export function getKnowledgeBaseStats() {
  return {
    triads: Object.keys(TRIAD_PASSAGES).length,
    foolsJourneyStages: Object.keys(FOOLS_JOURNEY_PASSAGES).length,
    dyads: Object.keys(DYAD_PASSAGES).length,
    suitProgressions: Object.keys(SUIT_PROGRESSION_PASSAGES).reduce(
      (sum, suit) => sum + Object.keys(SUIT_PROGRESSION_PASSAGES[suit]).length,
      0
    ),
    totalPassages: [
      ...Object.values(TRIAD_PASSAGES),
      ...Object.values(FOOLS_JOURNEY_PASSAGES),
      ...Object.values(DYAD_PASSAGES),
      ...Object.values(SUIT_PROGRESSION_PASSAGES).flatMap(s => Object.values(s))
    ].reduce((sum, entry) => sum + (entry.passages?.length || 0), 0)
  };
}
</file>

<file path="functions/lib/knowledgeGraph.js">
// functions/lib/knowledgeGraph.js
// Pattern detection logic for archetypal multi-card combinations
// Version 1.0.0

import {
  FOOLS_JOURNEY,
  ARCHETYPAL_TRIADS,
  ARCHETYPAL_DYADS,
  SUIT_PROGRESSIONS,
  THOTH_MINOR_TITLES,
  MARSEILLE_NUMERICAL_THEMES,
  COURT_FAMILY_PATTERNS,
  DECK_STYLE_OVERRIDES
} from '../../src/data/knowledgeGraphData.js';
import { getDeckAlias } from '../../shared/vision/deckAssets.js';
import { parseMinorName } from './minorMeta.js';

const COURT_RANK_LABELS = new Set([
  'Page',
  'Knight',
  'Queen',
  'King',
  'Princess',
  'Prince',
  'Valet',
  'Chevalier',
  'Reine',
  'Roi'
]);

function getDeckMeta(deckStyle = 'rws-1909') {
  return DECK_STYLE_OVERRIDES[deckStyle] || null;
}

function getCardLabel(card) {
  return card?.card || card?.name || card?.title || 'Unknown card';
}

function deckAwareSuitLabel(suit, deckStyle = 'rws-1909') {
  const meta = getDeckMeta(deckStyle);
  if (meta?.suitAliases?.[suit]) {
    return meta.suitAliases[suit];
  }
  return suit;
}

function deckAwareName(card, fallback, deckStyle = 'rws-1909') {
  const baseLabel = fallback || getCardLabel(card);
  const meta = getDeckMeta(deckStyle);

  if (meta) {
    if (typeof card?.number === 'number' && meta.majorAliases?.[card.number]) {
      const alias = meta.majorAliases[card.number];
      if (!alias) {
        return baseLabel;
      }
      if (deckStyle === 'rws-1909' || alias === baseLabel) {
        return alias;
      }
      return `${alias} (RWS: ${baseLabel})`;
    }

    if (card?.suit) {
      const suitAlias = meta.suitAliases?.[card.suit];
      const rankAlias = card.rank && meta.courtAliases?.[card.rank]
        ? meta.courtAliases[card.rank]
        : card.rank;

      if (card.rank && (suitAlias || rankAlias !== card.rank)) {
        const aliased = `${rankAlias} of ${suitAlias || card.suit}`;
        if (deckStyle === 'rws-1909' || aliased === baseLabel) {
          return aliased;
        }
        return `${aliased} (RWS: ${baseLabel})`;
      }

      if (!card.rank && suitAlias && typeof baseLabel === 'string') {
        const updated = baseLabel.replace(card.suit, suitAlias);
        if (updated !== baseLabel) {
          return deckStyle === 'rws-1909' ? updated : `${updated} (RWS: ${baseLabel})`;
        }
      }
    }
  }

  if (!deckStyle || deckStyle === 'rws-1909') {
    return baseLabel;
  }

  const alias = getDeckAlias(card, deckStyle);
  if (!alias || alias === baseLabel) {
    return baseLabel;
  }
  return baseLabel ? `${alias} (RWS: ${baseLabel})` : alias;
}

function deckAwareCourtRank(card, deckStyle = 'rws-1909') {
  const rank = (card?.rank || '').trim();
  if (!rank) return 'Court';
  const meta = getDeckMeta(deckStyle);
  if (!meta?.courtAliases) return rank;
  if (meta.courtAliases[rank]) {
    return meta.courtAliases[rank];
  }
  const alreadyAlias = Object.values(meta.courtAliases).includes(rank);
  return alreadyAlias ? rank : meta.courtAliases[rank] || rank;
}

function resolveSuit(card) {
  if (card?.suit) return card.suit;
  const parsed = parseMinorName(card?.card || card?.name || '');
  return parsed?.suit || null;
}

function isCourtCard(card) {
  if (!card) return false;
  if (typeof card.rankValue === 'number' && card.rankValue >= 11 && card.rankValue <= 14) {
    return true;
  }
  const rank = (card.rank || '').trim();
  if (rank && COURT_RANK_LABELS.has(rank)) {
    return true;
  }
  const parsed = parseMinorName(card.card || card.name || '');
  return parsed ? COURT_RANK_LABELS.has(parsed.rank) : false;
}

/**
 * Detect which stage of the Fool's Journey dominates this spread
 *
 * Analyzes Major Arcana cards (0-21) and determines which of the three
 * journey stages (initiation/integration/culmination) is most represented.
 *
 * @param {Array<Object>} cards - Array of card objects with number property
 * @returns {Object|null} Dominant journey stage with metadata, or null if <2 Majors
 * @example
 * const cards = [
 *   { number: 0, name: 'The Fool' },
 *   { number: 1, name: 'The Magician' },
 *   { number: 7, name: 'The Chariot' }
 * ];
 * const stage = detectFoolsJourneyStage(cards);
 * // Returns: { stage: 'initiation', cardCount: 3, theme: '...', ... }
 */
export function detectFoolsJourneyStage(cards, options = {}) {
  const deckStyle = options.deckStyle || 'rws-1909';
  // Filter to Major Arcana only
  const majorCards = cards.filter(
    (c) => typeof c.number === 'number' && c.number >= 0 && c.number <= 21
  );

  // Need at least 1 Major to provide any archetypal context
  if (majorCards.length < 1) return null;

  const stages = { initiation: [], integration: [], culmination: [] };

  // Categorize each Major card into its journey stage
  majorCards.forEach((card) => {
    if (card.number <= 7) {
      stages.initiation.push(card);
    } else if (card.number <= 14) {
      stages.integration.push(card);
    } else {
      stages.culmination.push(card);
    }
  });

  // Find the dominant stage (most cards)
  const dominant = Object.entries(stages).sort(
    (a, b) => b[1].length - a[1].length
  )[0];

  const stageKey = dominant[0];
  const stageCards = dominant[1];

  // If no clear dominance (all stages tied), return null
  if (stageCards.length === 0) return null;

  // Determine significance level:
  // - 'strong': 3+ cards in one stage (clear thematic cluster)
  // - 'moderate': 2 cards in one stage (notable pattern)
  // - 'minimal': 1 card (basic archetypal presence, useful for enrichment)
  let significance = 'minimal';
  if (stageCards.length >= 3) {
    significance = 'strong';
  } else if (stageCards.length >= 2 || majorCards.length >= 2) {
    significance = 'moderate';
  }

  // Return enriched stage data
  // IMPORTANT: Spread FOOLS_JOURNEY data FIRST, then override with actual spread data
  return {
    stageKey,
    ...FOOLS_JOURNEY[stageKey],
    // Override with actual detected data from this spread:
    cardCount: stageCards.length,
    cards: stageCards, // Actual cards from spread (not static reference)
    totalMajors: majorCards.length,
    significance,
    displayNames: stageCards.map((card) => deckAwareName(card, getCardLabel(card), deckStyle))
  };
}

/**
 * Detect archetypal triads (complete and partial)
 *
 * Scans for complete 3-card triads and partial 2-card combinations.
 * Complete triads receive highest priority; partials are supporting.
 *
 * @param {Array<Object>} cards - Array of card objects with number property
 * @returns {Array<Object>} Detected triads sorted by completeness
 * @example
 * const cards = [
 *   { number: 13, name: 'Death' },
 *   { number: 14, name: 'Temperance' },
 *   { number: 17, name: 'The Star' }
 * ];
 * const triads = detectArchetypalTriads(cards);
 * // Returns: [{ id: 'death-temperance-star', isComplete: true, ... }]
 */
export function detectArchetypalTriads(cards, options = {}) {
  const deckStyle = options.deckStyle || 'rws-1909';
  // Extract Major Arcana numbers
  const numbers = cards
    .filter((c) => typeof c.number === 'number' && c.number >= 0 && c.number <= 21)
    .map((c) => c.number);

  if (numbers.length < 2) return [];

  const detected = [];

  ARCHETYPAL_TRIADS.forEach((triad) => {
    // Find which cards from this triad are present
    const matches = triad.cards.filter((num) => numbers.includes(num));

    if (matches.length >= 2) {
      const completeness = matches.length / triad.cards.length;
      const isComplete = matches.length === 3;

      // Generate narrative based on which cards are present
      let narrative = triad.description;
      if (!isComplete) {
        // Build partial narrative key
        const pairKey = matches
          .map((n) => {
            const index = triad.cards.indexOf(n);
            return triad.names[index].toLowerCase().replace(/^the /, '');
          })
          .sort()
          .join('-');

        narrative = triad.partialNarrative[pairKey] || triad.description;
      }

      detected.push({
        id: triad.id,
        theme: triad.theme,
        matchedCards: matches,
        matchedNames: matches.map((n) => {
          const index = triad.cards.indexOf(n);
          const fallbackName = triad.names[index];
          const card = cards.find((c) => c.number === n);
          return deckAwareName(card, fallbackName, deckStyle);
        }),
        completeness: Math.round(completeness * 100),
        isComplete,
        narrative: isComplete ? triad.narrative : narrative,
        fullDescription: triad.description,
        contexts: triad.contexts,
        significance: isComplete ? 'complete-triad' : 'partial-triad',
        strength: isComplete ? 'major' : 'supporting'
      });
    }
  });

  // Sort by completeness (complete triads first)
  return detected.sort((a, b) => {
    if (a.isComplete !== b.isComplete) return a.isComplete ? -1 : 1;
    return b.matchedCards.length - a.matchedCards.length;
  });
}

/**
 * Detect archetypal dyads (two-card combinations)
 *
 * Scans for powerful two-card synergies. Categorized by significance
 * (high/medium-high/medium) for priority ranking.
 *
 * @param {Array<Object>} cards - Array of card objects with number property
 * @returns {Array<Object>} Detected dyads sorted by significance
 * @example
 * const cards = [
 *   { number: 13, name: 'Death' },
 *   { number: 17, name: 'The Star' }
 * ];
 * const dyads = detectArchetypalDyads(cards);
 * // Returns: [{ cards: [13, 17], theme: 'Transformation clearing into hope', ... }]
 */
export function detectArchetypalDyads(cards, options = {}) {
  const deckStyle = options.deckStyle || 'rws-1909';
  // Extract Major Arcana numbers
  const numbers = cards
    .filter((c) => typeof c.number === 'number' && c.number >= 0 && c.number <= 21)
    .map((c) => c.number);

  if (numbers.length < 2) return [];

  const detected = [];

  ARCHETYPAL_DYADS.forEach((dyad) => {
    // Check if both cards of this dyad are present
    if (dyad.cards.every((num) => numbers.includes(num))) {
      const names = dyad.cards.map((num, index) => {
        const fallback = dyad.names[index];
        const card = cards.find((c) => c.number === num);
        return deckAwareName(card, fallback, deckStyle);
      });

      detected.push({
        cards: dyad.cards,
        names,
        theme: dyad.theme,
        category: dyad.category,
        description: dyad.description,
        narrative: dyad.narrative,
        significance: dyad.significance
      });
    }
  });

  // Sort by significance (high > medium-high > medium)
  const significanceOrder = { high: 3, 'medium-high': 2, medium: 1 };
  return detected.sort(
    (a, b) =>
      (significanceOrder[b.significance] || 0) -
      (significanceOrder[a.significance] || 0)
  );
}

/**
 * Detect Minor Arcana suit progressions (three-stage arcs within each suit)
 *
 * @param {Array<Object>} cards - Spread cards containing suit and rank metadata
 * @returns {Array<Object>} Detected suit progressions with dominance + significance
 */
export function detectSuitProgressions(cards, options = {}) {
  const deckStyle = options.deckStyle || 'rws-1909';
  if (!Array.isArray(cards) || cards.length < 2) return [];

  const minorCards = cards.filter(
    (card) =>
      card &&
      card.suit &&
      typeof card.rankValue === 'number' &&
      card.rankValue >= 1 &&
      card.rankValue <= 10
  );

  if (minorCards.length < 2) return [];

  const groupedBySuit = minorCards.reduce((acc, card) => {
    if (!acc[card.suit]) acc[card.suit] = [];
    acc[card.suit].push(card);
    return acc;
  }, {});

  const detected = [];

  Object.entries(groupedBySuit).forEach(([suit, suitCards]) => {
    if (!Array.isArray(suitCards) || suitCards.length < 2) return;
    const progression = SUIT_PROGRESSIONS[suit];
    if (!progression) return;

    const stageBuckets = {
      beginning: [],
      challenge: [],
      mastery: []
    };

    suitCards.forEach((card) => {
      if (progression.beginning.ranks.includes(card.rankValue)) {
        stageBuckets.beginning.push(card);
      } else if (progression.challenge.ranks.includes(card.rankValue)) {
        stageBuckets.challenge.push(card);
      } else if (progression.mastery.ranks.includes(card.rankValue)) {
        stageBuckets.mastery.push(card);
      }
    });

    const dominantStageEntry = Object.entries(stageBuckets)
      .sort((a, b) => b[1].length - a[1].length)
      .find(([, stageCards]) => stageCards.length >= 2);

    if (!dominantStageEntry) return;

    const [stageKey, stageCards] = dominantStageEntry;
    const stageData = progression[stageKey];
    if (!stageData) return;

    detected.push({
      suit,
      displaySuit: deckAwareSuitLabel(suit, deckStyle),
      element: progression.element,
      domain: progression.domain,
      stage: stageKey,
      theme: stageData.theme,
      narrative: stageData.narrative,
      readingSignificance: stageData.readingSignificance,
      cardCount: suitCards.length,
      stageCardCount: stageCards.length,
      cards: suitCards,
      stageCards,
      ranks: suitCards.map((c) => c.rankValue).sort((a, b) => a - b),
      stageRanks: stageCards.map((c) => c.rankValue).sort((a, b) => a - b),
      distribution: {
        beginning: stageBuckets.beginning.length,
        challenge: stageBuckets.challenge.length,
        mastery: stageBuckets.mastery.length
      },
      significance: stageCards.length >= 3 ? 'strong-progression' : 'emerging-progression'
    });
  });

  return detected;
}

function detectCourtLineages(cards, options = {}) {
  if (!Array.isArray(cards) || cards.length < 2) {
    return [];
  }

  const deckStyle = options.deckStyle || 'rws-1909';
  const courtCards = cards.filter((card) => isCourtCard(card));
  if (courtCards.length < 2) {
    return [];
  }

  const suitBuckets = new Map();
  courtCards.forEach((card) => {
    const suit = resolveSuit(card);
    if (!suit) return;
    if (!suitBuckets.has(suit)) {
      suitBuckets.set(suit, []);
    }
    suitBuckets.get(suit).push(card);
  });

  const patterns = [];
  suitBuckets.forEach((list, suit) => {
    if (!Array.isArray(list) || list.length < 2) {
      return;
    }
    const lineage = COURT_FAMILY_PATTERNS[suit] || {};
    const significance = list.length >= 3 ? 'council' : 'alliance';
    const stageNarrative = significance === 'council' ? lineage.trioNarrative : lineage.duoNarrative;
    const deckNote = lineage.deckNotes?.[deckStyle] || getDeckMeta(deckStyle)?.courtNotes || '';
    const narrative = [stageNarrative, deckNote].filter(Boolean).join(' ').trim();
    const sorted = list
      .slice()
      .sort((a, b) => (a.rankValue ?? Number.MAX_SAFE_INTEGER) - (b.rankValue ?? Number.MAX_SAFE_INTEGER));
    patterns.push({
      suit,
      displaySuit: deckAwareSuitLabel(suit, deckStyle),
      theme: lineage.theme || `${suit} court lineage`,
      element: lineage.element || null,
      significance,
      count: list.length,
      cards: sorted,
      ranks: sorted.map((card) => deckAwareCourtRank(card, deckStyle)),
      narrative: narrative || `Multiple ${deckAwareSuitLabel(suit, deckStyle)} court cards are collaborating.`
    });
  });

  return patterns.sort((a, b) => b.count - a.count);
}

function detectThothEpithets(cards, options = {}) {
  const deckStyle = options.deckStyle || 'rws-1909';
  if (deckStyle !== 'thoth-a1' || !Array.isArray(cards)) {
    return null;
  }

  const entries = [];
  const suitMap = new Map();

  cards.forEach((card) => {
    const key = (card?.card || card?.name || '').trim();
    if (!key) return;
    const info = THOTH_MINOR_TITLES[key];
    if (!info) return;

    const entry = {
      card: key,
      title: info.title,
      suit: info.suit || card.suit || 'Minor',
      rank: info.rank || card.rankValue || null,
      astrology: info.astrology || null,
      description: info.description || ''
    };
    entries.push(entry);

    const suitKey = entry.suit;
    if (!suitMap.has(suitKey)) {
      suitMap.set(suitKey, []);
    }
    suitMap.get(suitKey).push({
      entry,
      originalCard: card
    });
  });

  if (entries.length === 0) {
    return null;
  }

  const suitHighlights = [];
  suitMap.forEach((list, suit) => {
    if (list.length < 2) return;
    suitHighlights.push({
      suit,
      titles: list.map((item) => item.entry.title),
      description: buildThothSuitNarrative(suit, list.map((item) => item.entry)),
      cards: list.map((item) => item.originalCard)
    });
  });

  return {
    entries,
    suitHighlights
  };
}

function buildThothSuitNarrative(suit, entries) {
  const snippets = entries
    .map((entry) => `${entry.title}${entry.astrology ? ` (${entry.astrology})` : ''}`)
    .join(' → ');
  const color = entries
    .map((entry) => entry.description)
    .filter(Boolean)
    .slice(0, 2)
    .join(' | ');
  return `${suit} current flows through ${snippets}, pointing to ${color || 'a defined energetic storyline'}.`;
}

function detectMarseillePipPatterns(cards, options = {}) {
  const deckStyle = options.deckStyle || 'rws-1909';
  if (deckStyle !== 'marseille-classic' || !Array.isArray(cards)) {
    return null;
  }

  const rankBuckets = new Map();
  cards.forEach((card) => {
    const rankValue = normalizeRankValue(card);
    if (!rankValue || !MARSEILLE_NUMERICAL_THEMES[rankValue]) return;
    if (!rankBuckets.has(rankValue)) {
      rankBuckets.set(rankValue, []);
    }
    rankBuckets.get(rankValue).push(card);
  });

  const numerologyClusters = [];
  rankBuckets.forEach((list, rank) => {
    if (list.length < 2) return;
    const theme = MARSEILLE_NUMERICAL_THEMES[rank];
    numerologyClusters.push({
      rankValue: rank,
      keyword: theme.keyword,
      description: theme.description,
      geometry: theme.geometry,
      cards: list
    });
  });

  if (!numerologyClusters.length) {
    return null;
  }

  return { numerologyClusters };
}

function normalizeRankValue(card) {
  if (typeof card?.rankValue === 'number') {
    return card.rankValue;
  }
  const parsed = parseMinorName(card?.card || card?.name || '');
  if (!parsed) return null;
  const pipValues = {
    Ace: 1,
    Two: 2,
    Three: 3,
    Four: 4,
    Five: 5,
    Six: 6,
    Seven: 7,
    Eight: 8,
    Nine: 9,
    Ten: 10
  };
  return pipValues[parsed.rank] || null;
}

/**
 * Master function: Detect all archetypal patterns
 *
 * Runs all detection functions and returns comprehensive pattern analysis.
 * Gracefully handles errors in individual detectors.
 *
 * @param {Array<Object>} cards - Array of card objects
 * @returns {Object|null} All detected patterns, or null if none found
 * @example
 * const patterns = detectAllPatterns(cardsInfo);
 * // Returns: { foolsJourney, triads, dyads }
 */
export function detectAllPatterns(cards, options = {}) {
  if (!cards || !Array.isArray(cards) || cards.length === 0) {
    return null;
  }

  const patterns = {};
  let hasAnyPattern = false;

  // Detect Fool's Journey stage
  try {
    const journey = detectFoolsJourneyStage(cards, options);
    if (journey) {
      patterns.foolsJourney = journey;
      hasAnyPattern = true;
    }
  } catch (err) {
    console.error('Fool\'s Journey detection failed:', err);
  }

  // Detect triads
  try {
    const triads = detectArchetypalTriads(cards, options);
    if (triads.length > 0) {
      patterns.triads = triads;
      hasAnyPattern = true;
    }
  } catch (err) {
    console.error('Triad detection failed:', err);
  }

  // Detect dyads
  try {
    const dyads = detectArchetypalDyads(cards, options);
    if (dyads.length > 0) {
      patterns.dyads = dyads;
      hasAnyPattern = true;
    }
  } catch (err) {
    console.error('Dyad detection failed:', err);
  }

  // Detect suit progressions
  try {
    const suitProgressions = detectSuitProgressions(cards, options);
    if (suitProgressions.length > 0) {
      patterns.suitProgressions = suitProgressions;
      hasAnyPattern = true;
    }
  } catch (err) {
    console.error('Suit progression detection failed:', err);
  }

  // Detect court lineages
  try {
    const courtLineages = detectCourtLineages(cards, options);
    if (courtLineages.length > 0) {
      patterns.courtLineages = courtLineages;
      hasAnyPattern = true;
    }
  } catch (err) {
    console.error('Court lineage detection failed:', err);
  }

  // Deck-specific Thoth epithets
  try {
    const thoth = detectThothEpithets(cards, options);
    if (thoth) {
      patterns.thothEpithets = thoth;
      hasAnyPattern = true;
    }
  } catch (err) {
    console.error('Thoth epithet detection failed:', err);
  }

  // Deck-specific Marseille numerology
  try {
    const marseille = detectMarseillePipPatterns(cards, options);
    if (marseille) {
      patterns.marseillePip = marseille;
      hasAnyPattern = true;
    }
  } catch (err) {
    console.error('Marseille pip detection failed:', err);
  }

  return hasAnyPattern ? patterns : null;
}

/**
 * Get priority pattern narratives for reading synthesis
 *
 * Selects top 3-5 most significant patterns and formats them for inclusion
 * in reading narratives. Enforces priority hierarchy:
 * 1. Complete triads (major)
 * 2. Strong Fool's Journey (3+ cards)
 * 3. High-significance dyads
 * 4. Partial triads (supporting)
 * 5. Medium dyads
 *
 * @param {Object} patterns - Output from detectAllPatterns()
 * @returns {Array<Object>} Priority-ranked narrative highlights (max 5)
 * @example
 * const highlights = getPriorityPatternNarratives(patterns);
 * // Returns: [{ priority: 1, type: 'complete-triad', text: '...', cards: [...] }, ...]
 */
export function getPriorityPatternNarratives(patterns, deckStyle = 'rws-1909') {
  if (!patterns) return [];

  const narratives = [];
  const stageDisplay = {
    beginning: 'Beginning',
    challenge: 'Challenge',
    mastery: 'Mastery'
  };

  // Priority 1: Complete triads
  if (patterns.triads) {
    patterns.triads
      .filter((t) => t.isComplete)
      .forEach((triad) => {
        narratives.push({
          priority: 1,
          type: 'complete-triad',
          text: `**${triad.theme}** ${triad.matchedNames.join(', ')} form a complete narrative arc—${triad.narrative}`,
          cards: triad.matchedCards,
          id: triad.id
        });
      });
  }

  // Priority 2: Strong Fool's Journey (3+ cards in one stage)
  if (patterns.foolsJourney && patterns.foolsJourney.significance === 'strong') {
    const journey = patterns.foolsJourney;
    const journeyNames = Array.isArray(journey.displayNames) && journey.displayNames.length > 0
      ? ` (${journey.displayNames.join(', ')})`
      : '';
    narratives.push({
      priority: 2,
      type: 'fools-journey',
      text: `**Fool's Journey — ${journey.stage.charAt(0).toUpperCase() + journey.stage.slice(1)}** ${journey.cardCount} cards from this stage${journeyNames} suggest ${journey.readingSignificance.toLowerCase()}.`,
      cards: journey.cards.map((c) => c.number),
      stage: journey.stage
    });
  }

  // Priority 4: Moderate Fool's Journey (2 cards in stage or 2+ total Majors)
  if (patterns.foolsJourney && patterns.foolsJourney.significance === 'moderate') {
    const journey = patterns.foolsJourney;
    const journeyNames = Array.isArray(journey.displayNames) && journey.displayNames.length > 0
      ? ` (${journey.displayNames.join(', ')})`
      : '';
    narratives.push({
      priority: 4,
      type: 'fools-journey',
      text: `**Fool's Journey — ${journey.stage.charAt(0).toUpperCase() + journey.stage.slice(1)}** ${journey.cardCount} card${journey.cardCount > 1 ? 's' : ''} from this stage${journeyNames} suggest ${journey.readingSignificance.toLowerCase()}.`,
      cards: journey.cards.map((c) => c.number),
      stage: journey.stage
    });
  }

  // Priority 6: Minimal Fool's Journey (single Major provides basic archetypal context)
  if (patterns.foolsJourney && patterns.foolsJourney.significance === 'minimal') {
    const journey = patterns.foolsJourney;
    const journeyNames = Array.isArray(journey.displayNames) && journey.displayNames.length > 0
      ? journey.displayNames.join(', ')
      : '';
    narratives.push({
      priority: 6,
      type: 'fools-journey-minimal',
      text: `**${journeyNames}** appears in the ${journey.stage} stage of the Fool's Journey, touching on themes of ${journey.theme.toLowerCase()}.`,
      cards: journey.cards.map((c) => c.number),
      stage: journey.stage
    });
  }

  // Priority 3: Strong suit progressions (3+ cards in a stage)
  if (patterns.suitProgressions) {
    patterns.suitProgressions
      .filter((p) => p.significance === 'strong-progression')
      .sort((a, b) => b.stageCardCount - a.stageCardCount)
      .slice(0, 2)
      .forEach((prog) => {
        const suitLabel = prog.displaySuit || prog.suit;
        const label = `${suitLabel} ${stageDisplay[prog.stage] || prog.stage}`;
        const cardList = prog.stageCards
          .map((c) => deckAwareName(c, getCardLabel(c), deckStyle))
          .join(', ');
        const themeDescriptor = typeof prog.theme === 'string'
          ? prog.theme.toLowerCase()
          : 'this stage';
        const significanceText = prog.readingSignificance ? `${prog.readingSignificance} ` : '';
        const stageNarrative = prog.narrative || '';
        narratives.push({
          priority: 3,
          type: 'suit-progression',
          text: `**${label}** ${cardList} highlight the ${themeDescriptor} arc of this suit. ${significanceText}${stageNarrative}`.trim(),
          cards: prog.stageCards.map((card) => card.number ?? card.rankValue ?? null),
          suit: prog.suit,
          stage: prog.stage
        });
      });
  }

  // Court lineages (deck-aware court clusters)
  if (patterns.courtLineages) {
    patterns.courtLineages
      .slice(0, 2)
      .forEach((lineage) => {
        const cardList = lineage.cards
          .map((card) => deckAwareName(card, getCardLabel(card), deckStyle))
          .join(', ');
        const heading = lineage.significance === 'council' ? 'court council' : 'court alliance';
        const summary = lineage.narrative || lineage.theme;
        narratives.push({
          priority: lineage.significance === 'council' ? 3 : 4,
          type: 'court-lineage',
          text: `**${lineage.displaySuit} ${heading}** ${cardList} — ${summary}`.trim(),
          cards: lineage.cards.map((card) => card.number ?? card.rankValue ?? null),
          suit: lineage.suit
        });
      });
  }

  // Deck-specific: Thoth suit clusters or epithets
  if (patterns.thothEpithets?.suitHighlights?.length) {
    patterns.thothEpithets.suitHighlights
      .slice(0, 2)
      .forEach((highlight) => {
        const cardList = highlight.cards
          .map((card) => deckAwareName(card, getCardLabel(card), deckStyle))
          .join(', ');
        narratives.push({
          priority: 3,
          type: 'thoth-suit',
          text: `**Thoth ${highlight.suit} Titles** ${highlight.description} Cards: ${cardList}.`,
          cards: highlight.cards.map((card) => card.number ?? card.rankValue ?? null)
        });
      });
  } else if (patterns.thothEpithets?.entries?.length) {
    patterns.thothEpithets.entries
      .slice(0, 2)
      .forEach((entry) => {
        narratives.push({
          priority: 4,
          type: 'thoth-epithet',
          text: `**${entry.card} → ${entry.title}** ${entry.description}${entry.astrology ? ` (${entry.astrology})` : ''}.`,
          cards: [entry.rank]
        });
      });
  }

  // Priority 3: High-significance dyads
  if (patterns.dyads) {
    patterns.dyads
      .filter((d) => d.significance === 'high')
      .slice(0, 2) // Max 2 high dyads
      .forEach((dyad) => {
        narratives.push({
          priority: 4,
          type: 'high-dyad',
          text: `**${dyad.names.join(' + ')}** ${dyad.narrative}`,
          cards: dyad.cards,
          category: dyad.category
        });
      });
  }

  // Priority 4: Partial triads (if we have space)
  if (narratives.length < 4 && patterns.triads) {
    patterns.triads
      .filter((t) => !t.isComplete)
      .slice(0, 1) // Max 1 partial
      .forEach((triad) => {
        narratives.push({
          priority: 5,
          type: 'partial-triad',
          text: `**${triad.theme} (partial)** ${triad.matchedNames.join(' + ')}—${triad.narrative}`,
          cards: triad.matchedCards,
          id: triad.id
        });
      });
  }

  // Priority 5/6: Emerging suit progressions (2-card signals)
  if (narratives.length < 5 && patterns.suitProgressions) {
    patterns.suitProgressions
      .filter((p) => p.significance === 'emerging-progression')
      .sort((a, b) => b.stageCardCount - a.stageCardCount)
      .slice(0, 1)
      .forEach((prog) => {
        const suitLabel = prog.displaySuit || prog.suit;
        const label = `${suitLabel} ${stageDisplay[prog.stage] || prog.stage} (emerging)`;
        const cardList = prog.stageCards
          .map((c) => deckAwareName(c, getCardLabel(c), deckStyle))
          .join(' + ');
        const insight = prog.readingSignificance || prog.narrative || '';
        narratives.push({
          priority: 6,
          type: 'emerging-suit-progression',
          text: `**${label}** ${cardList} hint that ${insight}`,
          cards: prog.stageCards.map((card) => card.number ?? card.rankValue ?? null),
          suit: prog.suit,
          stage: prog.stage
        });
      });
  }

  // Deck-specific: Marseille numerology clusters
  if (patterns.marseillePip?.numerologyClusters?.length) {
    patterns.marseillePip.numerologyClusters
      .sort((a, b) => b.cards.length - a.cards.length)
      .slice(0, 2)
      .forEach((cluster) => {
        const cardList = cluster.cards
          .map((card) => deckAwareName(card, getCardLabel(card), deckStyle))
          .join(', ');
        narratives.push({
          priority: 6,
          type: 'marseille-numerology',
          text: `**Pip ${cluster.rankValue} — ${cluster.keyword}** ${cluster.description} (Geometry: ${cluster.geometry}). Cards: ${cardList}.`,
          cards: cluster.cards.map((card) => card.rankValue ?? card.number ?? null)
        });
      });
  }

  // Priority 5: Medium-high dyads (if we have space)
  if (narratives.length < 5 && patterns.dyads) {
    patterns.dyads
      .filter((d) => d.significance === 'medium-high')
      .slice(0, 1) // Max 1 medium-high
      .forEach((dyad) => {
        narratives.push({
          priority: 7,
          type: 'medium-high-dyad',
          text: `**${dyad.names.join(' + ')}** ${dyad.narrative}`,
          cards: dyad.cards,
          category: dyad.category
        });
      });
  }

  // Sort by priority and limit to top 5
  return narratives.sort((a, b) => a.priority - b.priority).slice(0, 5);
}
</file>

<file path="functions/lib/middleware.js">
/**
 * Middleware for Authentication and Rate Limiting
 */

import { validateSession, getSessionFromCookie } from './auth.js';
import { validateApiKey } from './apiKeys.js';
import { checkRateLimit, getRateLimitHeaders } from './rateLimit.js';

/**
 * Identify the requester (User, API Key, or Guest)
 * @param {Request} request
 * @param {object} env
 * @returns {Promise<{user: object|null, apiKey: object|null, ip: string, type: 'user'|'api'|'guest'}>}
 */
export async function identifyRequester(request, env) {
  const ip = request.headers.get('CF-Connecting-IP') || 'unknown';

  // 1. Check API Key (Authorization: Bearer sk_...)
  const authHeader = request.headers.get('Authorization');
  if (authHeader && authHeader.startsWith('Bearer sk_')) {
    const key = authHeader.split(' ')[1];
    const apiKeyRecord = await validateApiKey(env.DB, key);
    if (apiKeyRecord) {
      return {
        user: { id: apiKeyRecord.user_id, email: apiKeyRecord.email, username: apiKeyRecord.username },
        apiKey: apiKeyRecord,
        ip,
        type: 'api'
      };
    }
    // If API key provided but invalid, we might want to throw or treat as guest?
    // Usually invalid credentials should fail.
    // For now, we'll return null user to let downstream handle it, or maybe throw.
    // But to be safe, if an explicit attempt to auth fails, we should probably reject.
    // However, for this helper, we just identify.
  }

  // 2. Check Session Cookie
  const cookieHeader = request.headers.get('Cookie');
  const token = getSessionFromCookie(cookieHeader);
  if (token) {
    const user = await validateSession(env.DB, token);
    if (user) {
      return {
        user,
        apiKey: null,
        ip,
        type: 'user'
      };
    }
  }

  // 3. Guest
  return {
    user: null,
    apiKey: null,
    ip,
    type: 'guest'
  };
}

/**
 * Enforce Rate Limiting based on requester type
 * @param {Request} request
 * @param {object} env
 * @param {string} action - e.g., 'reading', 'tts'
 * @returns {Promise<Response|null>} Returns Response if blocked, null if allowed
 */
export async function enforceRateLimit(request, env, action = 'general') {
  const requester = await identifyRequester(request, env);
  
  let limit = 20; // Default guest limit
  let identifier = requester.ip;
  let type = 'guest';

  if (requester.type === 'api') {
    limit = 1000; // Higher limit for API keys
    identifier = requester.apiKey.id;
    type = 'api';
  } else if (requester.type === 'user') {
    limit = 100; // Higher limit for logged-in users
    identifier = requester.user.id;
    type = 'user';
  }

  const result = await checkRateLimit(env.RATELIMIT, identifier, `${action}:${type}`, limit);

  if (!result.success) {
    return new Response(
      JSON.stringify({ error: 'Too many requests' }),
      {
        status: 429,
        headers: {
          'Content-Type': 'application/json',
          ...getRateLimitHeaders(result)
        }
      }
    );
  }
  
  // Attach requester info to request for downstream use (if mutable, else we need another way)
  // Cloudflare Pages Functions don't pass state easily besides request/env.
  // We can return the requester info.
  return null;
}
</file>

<file path="functions/lib/minorMeta.js">
// functions/lib/minorMeta.js
// Shared Minor Arcana metadata + helpers.
// Intentionally aligned with src/data/minorArcana.js and narrative tone guidelines.

export const SUIT_THEMES = {
  Wands:
    'fire, initiative, creativity, desire, and the way you act on your will',
  Cups:
    'water, emotions, relationships, intuition, and how you give and receive care',
  Swords:
    'air, mind, truth, communication, and how you navigate tension or clarity',
  Pentacles:
    'earth, body, work, resources, and the material structures that support you'
};

export const PIP_NUMEROLOGY = {
  1: 'a seed or new spark of this suit’s energy, raw potential and beginnings',
  2: 'duality, choices, early tension or balance within this suit’s themes',
  3: 'growth, first stability, collaboration, and visible development',
  4: 'foundation, consolidation, stability that can comfort or confine',
  5: 'conflict, disruption, tests that stress the pattern and demand adjustment',
  6: 'recognition, victory, and public acknowledgment',
  7: 'assessment, testing, deeper questions about direction and alignment',
  8: 'dedication, focused work, sustained effort in this suit’s domain',
  9: 'fruition, culmination near completion, self-sufficiency in this area',
  10: 'peak expression, legacy, long-term consequence of the suit’s journey'
};

export const COURT_ARCHETYPES = {
  Page:
    'a student or messenger of this suit—curiosity, signals, early expressions of this energy, often within you',
  Knight:
    'movement and pursuit in this suit—how you or another actively chase, defend, or embody this energy',
  Queen:
    'mature, receptive mastery of this suit—embodied wisdom, emotional intelligence, stewardship from within',
  King:
    'mature, directive mastery of this suit—visible leadership, structure, and accountability in this area'
};

export function parseMinorName(name) {
  if (!name || typeof name !== 'string') return null;
  const match = name.match(
    /^(\w+)\s+of\s+(Wands|Cups|Swords|Pentacles)$/
  );
  if (!match) return null;
  const [, rank, suit] = match;
  return { rank, suit };
}

// Normalize a card-like object into structured Minor context if applicable.
export function getMinorContext(cardLike = {}) {
  const rawName = cardLike.card || cardLike.name;

  let suit = cardLike.suit;
  let rank = cardLike.rank;

  if ((!suit || !rank) && rawName) {
    const parsed = parseMinorName(rawName);
    if (parsed) {
      rank = rank || parsed.rank;
      suit = suit || parsed.suit;
    }
  }

  if (!suit || !rank) return null;

  const isCourt = ['Page', 'Knight', 'Queen', 'King'].includes(rank);

  const pipValues = {
    Ace: 1,
    Two: 2,
    Three: 3,
    Four: 4,
    Five: 5,
    Six: 6,
    Seven: 7,
    Eight: 8,
    Nine: 9,
    Ten: 10
  };

  const courtValues = {
    Page: 11,
    Knight: 12,
    Queen: 13,
    King: 14
  };

  const inferredRankValue = isCourt
    ? courtValues[rank]
    : pipValues[rank];

  const rankValue =
    typeof cardLike.rankValue === 'number'
      ? cardLike.rankValue
      : inferredRankValue;

  return {
    suit,
    rank,
    isCourt,
    rankValue,
    suitTheme: SUIT_THEMES[suit],
    pipTheme:
      !isCourt && typeof rankValue === 'number'
        ? PIP_NUMEROLOGY[rankValue]
        : undefined,
    courtTheme: isCourt ? COURT_ARCHETYPES[rank] : undefined
  };
}

// Build a concise narrative summary for a Minor Arcana card.
// Intentionally neutral, reflective, and non-deterministic in tone.
export function buildMinorSummary(cardLike = {}) {
  const ctx = getMinorContext(cardLike);
  if (!ctx) return '';

  const bits = [];

  if (ctx.suitTheme) {
    bits.push(
      `As a ${ctx.suit} card, this speaks to ${ctx.suitTheme}.`
    );
  }

  if (ctx.isCourt && ctx.courtTheme) {
    bits.push(
      `As a ${ctx.rank}, it highlights ${ctx.courtTheme}.`
    );
  } else if (ctx.pipTheme) {
    bits.push(
      `At this rank, it marks ${ctx.pipTheme}.`
    );
  }

  return bits.join(' ');
}
</file>

<file path="functions/lib/narrativeBuilder.js">
/**
 * Narrative builder entrypoint that proxies to modular spread/prompt helpers.
 */
export { buildPositionCardText, buildElementalRemedies, shouldOfferElementalRemedies, formatReversalLens, computeRemedyRotationIndex } from './narrative/helpers.js';
export { buildEnhancedClaudePrompt } from './narrative/prompts.js';
export { buildCelticCrossReading } from './narrative/spreads/celticCross.js';
export { buildFiveCardReading } from './narrative/spreads/fiveCard.js';
export { buildRelationshipReading } from './narrative/spreads/relationship.js';
export { buildDecisionReading } from './narrative/spreads/decision.js';
export { buildSingleCardReading } from './narrative/spreads/singleCard.js';
export { buildThreeCardReading } from './narrative/spreads/threeCard.js';
</file>

<file path="functions/lib/narrativeSpine.js">
/**
 * Narrative Spine Helper
 *
 * Ensures each major reading section follows the story spine structure:
 * 1. WHAT is happening (situation/card)
 * 2. WHY it's happening (connector/cause)
 * 3. WHAT'S NEXT (trajectory/action)
 *
 * This helper validates and enriches narrative sections to maintain
 * flowing, causal storytelling throughout the reading.
 */

/**
 * Narrative spine structure for validation
 */
const SPINE_ELEMENTS = {
  what: {
    name: 'What is happening',
    required: true
  },
  why: {
    name: 'Why/How (connector)',
    required: false // Optional for single-card sections
  },
  whatsNext: {
    name: "What's next",
    required: false // Optional for past-focused positions
  }
};

const MIN_SENTENCE_WORDS = 5;
const CARD_HEADER_PATTERN = /^[\w\s]+[:\-–]/;
const MINOR_ARCANA_PATTERN = /\b(?:ace|two|three|four|five|six|seven|eight|nine|ten|page|knight|queen|king)\s+of\s+(?:wands|cups|swords|pentacles)\b/i;
const MAJOR_ARCANA_NAMES = [
  'fool',
  'magician',
  'high priestess',
  'empress',
  'emperor',
  'hierophant',
  'lovers',
  'chariot',
  'strength',
  'hermit',
  'wheel of fortune',
  'justice',
  'hanged man',
  'death',
  'temperance',
  'devil',
  'tower',
  'star',
  'moon',
  'sun',
  'judgement',
  'judgment',
  'world'
];
const MAJOR_ARCANA_PATTERN = new RegExp(`\\b(?:the\\s+)?(?:${MAJOR_ARCANA_NAMES.join('|')})\\b`, 'i');
const CARD_CONTEXT_PATTERN = /\b(?:card|position|energy|situation|scene|story|thread|theme|anchor|nucleus|timeline|past|present|future|influence|lesson|moment|lens|reflection|reflections|synthesis|guidance|reminder|insight)\b/i;
const DESCRIPTIVE_VERB_PATTERN = /\b(?:is|are|feels|brings|ushers|marks|signals|casts|delivers|grounds|anchors|establishes|opens|presents|reveals|shows|illustrates|demonstrates|highlights|frames|illuminates|expresses|focuses|rests|sits|holds|carries|offers|spotlights|reminds|echoes|emerges|unfolds)\b/i;
const WHY_PATTERNS = [
  /\b(?:because|since|due to|thanks to|as a result|resulting in|which is why|which means)\b/i,
  /\b(?:therefore|thus|hence|so that|so you can|so you might)\b/i,
  /\b(?:stems from|rooted in|comes from|arises from|emerges from)\b/i,
  /\b(?:leads to|creates|sparks|requires|demands)\b/i,
  /,\s*(?:which|that)\s+(?:allows|invites|pushes|nudges|lets)\b/i,
  /\bin turn\b/i
];
const WHATS_NEXT_PATTERNS = [
  /\b(?:what's next|next|future|going forward|the road ahead|ahead|from here|on the horizon)\b/i,
  /\b(?:consider|choose|decide|prepare|plan|commit|focus|lean|move|step)\s+(?:to|into|toward|forward|next)\b/i,
  /\b(?:invites|encourages|calls|asks|urges|prompts|guides)\b/i,
  /\b(?:guidance|advice|trajectory|path|action|step|practice)\b/i,
  /\b(?:you can|you might|you could)\s+(?:now|next|begin|take|start)\b/i
];

function segmentSentences(text) {
  if (!text || typeof text !== 'string') return [];
  return text
    .split(/(?<=[.!?])\s+|\n+/)
    .map(sentence => sentence.trim())
    .filter(Boolean);
}

function hasCardReference(text) {
  if (!text) return false;
  return MINOR_ARCANA_PATTERN.test(text) || MAJOR_ARCANA_PATTERN.test(text);
}

function detectWhatClause(text, sentences) {
  if (!text) return false;
  if (hasCardReference(text)) return true;
  if (sentences.some(sentence => CARD_HEADER_PATTERN.test(sentence))) {
    return true;
  }

  return sentences.some(sentence => {
    const trimmed = sentence.trim();
    if (!trimmed) return false;
    if (trimmed.split(/\s+/).length < MIN_SENTENCE_WORDS) return false;
    return CARD_CONTEXT_PATTERN.test(trimmed) && DESCRIPTIVE_VERB_PATTERN.test(trimmed);
  });
}

function detectWhyClause(text) {
  if (!text) return false;
  return WHY_PATTERNS.some(pattern => pattern.test(text));
}

function detectWhatsNextClause(text) {
  if (!text) return false;
  return WHATS_NEXT_PATTERNS.some(pattern => pattern.test(text));
}

function resolveHint(spineHints = {}, key, detector) {
  if (Object.prototype.hasOwnProperty.call(spineHints, key) && typeof spineHints[key] === 'boolean') {
    return spineHints[key];
  }
  return detector();
}

function detectSpineElements(text, spineHints = {}) {
  const safeText = typeof text === 'string' ? text : '';
  const sentences = segmentSentences(safeText);

  const what = resolveHint(spineHints, 'what', () => detectWhatClause(safeText, sentences));
  const why = resolveHint(spineHints, 'why', () => detectWhyClause(safeText));
  const whatsNext = resolveHint(spineHints, 'whatsNext', () => detectWhatsNextClause(safeText));

  return { what, why, whatsNext };
}

/**
 * Check if a text section contains spine elements
 *
 * @param {string} text - Narrative paragraph to evaluate
 * @param {Object} [options] - Optional detection overrides
 * @param {Object} [options.spineHints] - Explicit hints { what, why, whatsNext }
 */
export function analyzeSpineCompleteness(text, options = {}) {
  if (!text || typeof text !== 'string') {
    return {
      isComplete: false,
      missingElements: ['what', 'why', 'whatsNext'],
      missing: ['what', 'why', 'whatsNext'],
      missingRequired: ['what'],
      present: { what: false, why: false, whatsNext: false },
      suggestions: ['Add concrete description of the card/situation', 'Include causal connector', 'Provide forward-looking guidance']
    };
  }

  const { spineHints } = options;
  const present = detectSpineElements(text, spineHints);
  const missing = [];
  const missingRequired = [];

  for (const [key, element] of Object.entries(SPINE_ELEMENTS)) {
    if (!present[key]) {
      missing.push(key);
      if (element.required) {
        missingRequired.push(key);
      }
    }
  }

  return {
    isComplete: missingRequired.length === 0,
    present,
    missing,
    missingRequired,
    suggestions: missing.map(key => `Consider adding: ${SPINE_ELEMENTS[key].name}`)
  };
}

/**
 * Build a narrative paragraph following the spine structure
 *
 * @param {Object} components - The narrative components
 * @param {string} components.what - What is happening (required)
 * @param {string} components.why - Why/how this happened (optional)
 * @param {string} components.whatsNext - What's next/guidance (optional)
 * @param {string} components.connector - Connector phrase to previous section (optional)
 * @returns {string} Fully formed narrative paragraph
 */
export function buildSpineParagraph({ what, why, whatsNext, connector = '' }) {
  if (!what) {
    throw new Error('Narrative spine requires "what" (the situation description)');
  }

  const parts = [];

  // Add connector if provided
  if (connector) {
    parts.push(connector);
  }

  // Always include WHAT
  parts.push(what);

  // Add WHY if provided (causal connection)
  if (why) {
    parts.push(why);
  }

  // Add WHAT'S NEXT if provided (trajectory/guidance)
  if (whatsNext) {
    parts.push(whatsNext);
  }

  return parts.join(' ');
}

/**
 * Generate "why" connector based on elemental relationship
 */
export function buildWhyFromElemental(elementalRelationship, card1Name, card2Name) {
  if (!elementalRelationship || !elementalRelationship.relationship) {
    return null;
  }

  const safeCard1 = card1Name || 'the first card';
  const safeCard2 = card2Name || 'the second card';
  const { relationship } = elementalRelationship;

  const templates = {
    supportive: `Because ${safeCard1} supports and harmonizes with ${safeCard2}, these energies flow together constructively.`,
    tension: `However, ${safeCard1} creates friction with ${safeCard2}, requiring skillful navigation to integrate both.`,
    amplified: `Because both energies share the same elemental quality, ${safeCard1} and ${safeCard2} intensify this theme significantly.`,
    neutral: `${safeCard1} and ${safeCard2} work together with subtle complexity.`
  };

  return templates[relationship] || templates.neutral;
}

/**
 * Validate and enhance a reading section with spine structure
 *
 * @param {string} section - Raw section text
 * @param {Object} metadata - Section metadata
 * @param {string} metadata.type - Section type (nucleus, timeline, staff, etc.)
 * @param {Object} metadata.cards - Card information
 * @param {Object} metadata.relationships - Elemental/position relationships
 * @returns {Object} Enhanced section with spine validation
 */
export function enhanceSection(section, metadata = {}) {
  const analysis = analyzeSpineCompleteness(section);
  const missingKeys = Array.isArray(analysis.missing)
    ? analysis.missing
    : Array.isArray(analysis.missingElements)
      ? analysis.missingElements
      : [];

  if (missingKeys.length === 0) {
    return {
      text: section,
      validation: { ...analysis, enhanced: false }
    };
  }

  let enhanced = section || '';
  const enhancements = [];
  let detection = analysis.present || detectSpineElements(enhanced);

  const cards = Array.isArray(metadata.cards)
    ? metadata.cards
    : metadata.cards
      ? [metadata.cards]
      : [];

  // Ensure WHAT is anchored by card identification
  if (!detection.what && cards.length > 0) {
    const cardInfo = cards[0];
    if (cardInfo && cardInfo.card && cardInfo.position) {
      const orientation =
        typeof cardInfo.orientation === 'string' && cardInfo.orientation.trim()
          ? ` ${cardInfo.orientation}`
          : '';
      const whatStatement = `${cardInfo.position}: ${cardInfo.card}${orientation}.`;
      enhanced = `${whatStatement} ${enhanced}`.trim();
      enhancements.push('Added card identification');
      detection = detectSpineElements(enhanced);
    }
  }

  // Add WHY connector only when it is still missing
  if (!detection.why && cards.length >= 2 && metadata.relationships?.elementalRelationship) {
    const whyStatement = buildWhyFromElemental(
      metadata.relationships.elementalRelationship,
      cards[0].card,
      cards[1].card
    );
    if (whyStatement) {
      enhanced = enhanced ? `${enhanced} ${whyStatement}` : whyStatement;
      enhancements.push('Added causal connector');
      detection = detectSpineElements(enhanced);
    }
  }

  // Add WHAT'S NEXT guidance for forward-looking sections
  if (!detection.whatsNext && typeof metadata.type === 'string') {
    const forwardTypes = ['timeline', 'outcome', 'future', 'staff'];
    if (forwardTypes.includes(metadata.type.toLowerCase())) {
      const guidancePrompt = 'Consider what this trajectory invites you to do next.';
      enhanced = enhanced ? `${enhanced} ${guidancePrompt}` : guidancePrompt;
      enhancements.push('Added forward-looking guidance');
      detection = detectSpineElements(enhanced);
    }
  }

  const updatedAnalysis = analyzeSpineCompleteness(enhanced);
  const didEnhance = enhancements.length > 0;

  return {
    text: enhanced,
    validation: {
      ...updatedAnalysis,
      enhanced: didEnhance,
      enhancements
    }
  };
}

/**
 * Validate complete reading narrative
 * Checks that all major sections follow spine principles
 */
export function validateReadingNarrative(readingText) {
  if (!readingText || typeof readingText !== 'string') {
    return {
      isValid: false,
      errors: ['Reading text is empty or invalid']
    };
  }

  // Split by major section headers
  // Match: ### Markdown headers OR **Bold text at start of line** (not inline bold)
  const sectionPattern = /(^[ \t]*\*\*([^*]+)\*\*[ \t]*$)|(^#{2,6}\s+(.+)$)/gm;
  const sections = [];
  let match;
  let lastIndex = 0;

  while ((match = sectionPattern.exec(readingText)) !== null) {
    const header = (match[2] || match[4] || '').trim();
    if (!header) {
      lastIndex = sectionPattern.lastIndex;
      continue;
    }

    if (sections.length > 0) {
      const content = readingText.substring(lastIndex, match.index).trim();
      sections[sections.length - 1].content = content;
    }

    sections.push({
      header,
      start: match.index,
      content: ''
    });

    lastIndex = sectionPattern.lastIndex;
  }

  // Capture last section
  if (sections.length > 0) {
    sections[sections.length - 1].content = readingText.substring(lastIndex).trim();
  }

  // Analyze each section
  const analyses = sections.map(section => ({
    header: section.header,
    analysis: analyzeSpineCompleteness(section.content)
  }));

  const incompleteCount = analyses.filter(a => !a.analysis.isComplete).length;

  return {
    isValid: incompleteCount === 0,
    totalSections: sections.length,
    completeSections: sections.length - incompleteCount,
    incompleteSections: incompleteCount,
    sectionAnalyses: analyses,
    suggestions: incompleteCount > 0
      ? ["Review incomplete sections and ensure they include: what is happening, why/how (connector), and what's next"]
      : []
  };
}

/**
 * Build a multi-card narrative flow with spine structure
 * Useful for timeline, staff, or any sequential card sections
 */
export function buildFlowNarrative(cards, relationships, options = {}) {
  if (!cards || cards.length === 0) {
    return '';
  }

  const { includeSynthesis = true, connector: initialConnector = '' } = options;

  const paragraphs = [];

  cards.forEach((card, index) => {
    const isFirst = index === 0;
    const isLast = index === cards.length - 1;

    // Get relationship to previous card
    const prevRelationship = index > 0 && relationships && relationships[index - 1]
      ? relationships[index - 1]
      : null;

    // Build WHAT
    const what = `${card.position}: ${card.card} ${card.orientation}. ${card.meaning}`;

    // Build WHY (from elemental relationship)
    let why = null;
    if (prevRelationship && prevRelationship.elementalRelationship && cards[index - 1]) {
      why = buildWhyFromElemental(
        prevRelationship.elementalRelationship,
        cards[index - 1].card,
        card.card
      );
    }

    // Build WHAT'S NEXT (only for last card or specific positions)
    let whatsNext = null;
    if (isLast && includeSynthesis) {
      whatsNext = 'This trajectory invites conscious choice in how you proceed.';
    }

    // Determine connector
    let connector = isFirst ? initialConnector : '';
    if (!isFirst && prevRelationship) {
      const rel = prevRelationship.elementalRelationship?.relationship;
      if (rel === 'supportive') connector = 'Building on this,';
      else if (rel === 'tension') connector = 'However,';
      else if (rel === 'amplified') connector = 'Intensifying further,';
    }

    const paragraph = buildSpineParagraph({ what, why, whatsNext, connector });
    paragraphs.push(paragraph);
  });

  return paragraphs.join('\n\n');
}
</file>

<file path="functions/lib/positionWeights.js">
/**
 * Position importance weights for narrative emphasis
 * Based on professional reading practice and research recommendations
 */

export const POSITION_WEIGHTS = {
  celtic: {
    0: 1.0,   // Present - anchor card, highest weight
    1: 0.9,   // Challenge - immediate tension
    9: 0.95,  // Outcome - trajectory
    6: 0.85,  // Advice - actionable
    4: 0.75,  // Conscious goal
    5: 0.75,  // Subconscious
    3: 0.7,   // Near future
    8: 0.65,  // Hopes/Fears
    7: 0.6,   // External
    2: 0.6    // Past
  },
  threeCard: {
    1: 1.0,   // Present
    2: 0.9,   // Future
    0: 0.75   // Past
  },
  fiveCard: {
    0: 1.0,   // Core
    1: 0.9,   // Challenge
    4: 0.85,  // Direction
    3: 0.7,   // Support
    2: 0.65   // Hidden
  },
  relationship: {
    0: 0.9,   // You / your energy
    1: 0.9,   // Them / their energy
    2: 1.0    // The connection / shared lesson
  },
  decision: {
    0: 1.0,   // Heart of the decision
    1: 0.8,   // Path A — energy & likely outcome
    2: 0.8,   // Path B — energy & likely outcome
    3: 0.85,  // What clarifies the best path
    4: 0.95   // What to remember about your free will
  }
};

export function getPositionWeight(spreadKey, positionIndex) {
  return POSITION_WEIGHTS[spreadKey]?.[positionIndex] ?? 0.5;
}

export function sortCardsByImportance(cardsInfo, spreadKey) {
  if (!Array.isArray(cardsInfo)) return [];

  return cardsInfo
    .map((card, index) => ({
      ...(card || {}),
      weight: getPositionWeight(spreadKey, index),
      originalIndex: index
    }))
    .sort((a, b) => b.weight - a.weight);
}
</file>

<file path="functions/lib/promptEngineering.js">
/**
 * Prompt Engineering Utilities
 * 
 * Provides utilities for persisting and analyzing LLM prompts:
 * - Hashing for deduplication and A/B grouping
 * - PII redaction for safe storage
 * - Prompt fingerprinting for pattern analysis
 */

/**
 * Generate a SHA-256 hash of text using Web Crypto API
 * @param {string} text - Text to hash
 * @returns {Promise<string>} Hex-encoded hash
 */
export async function hashText(text) {
  if (!text || typeof text !== 'string') {
    return '';
  }
  
  const encoder = new TextEncoder();
  const data = encoder.encode(text);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
}

/**
 * Generate a short fingerprint for quick comparison
 * Uses first 12 chars of SHA-256 hash
 * @param {string} text - Text to fingerprint
 * @returns {Promise<string>} Short hash fingerprint
 */
export async function fingerprint(text) {
  const hash = await hashText(text);
  return hash.slice(0, 12);
}

/**
 * Common PII patterns to redact
 */
const PII_PATTERNS = [
  // Email addresses
  { pattern: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/gi, replacement: '[EMAIL]' },
  // Phone numbers (various formats, optional extension)
  { pattern: /\b(?:\+?1[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}(?:\s*(?:ext\.?|x)\s*\d{1,6})?\b/gi, replacement: '[PHONE]' },
  // Social Security Numbers
  { pattern: /\b\d{3}[-.\s]?\d{2}[-.\s]?\d{4}\b/g, replacement: '[SSN]' },
  // Credit card numbers (basic)
  { pattern: /\b(?:\d{4}[-.\s]?){3}\d{4}\b/g, replacement: '[CARD]' },
  // Dates that might be birthdates (MM/DD/YYYY, DD/MM/YYYY, etc.)
  { pattern: /\b(?:0?[1-9]|1[0-2])[/\-.](?:0?[1-9]|[12]\d|3[01])[/\-.](?:19|20)\d{2}\b/g, replacement: '[DATE]' },
  // ISO-style dates (YYYY-MM-DD or YYYY/MM/DD)
  { pattern: /\b(19|20)\d{2}[-/\.](0?[1-9]|1[0-2])[-/\.](0?[1-9]|[12]\d|3[01])\b/g, replacement: '[DATE]' },
  // URLs with potential tracking params
  { pattern: /https?:\/\/[^\s]+/gi, replacement: '[URL]' },
  // IP addresses
  { pattern: /\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b/g, replacement: '[IP]' },
];

/**
 * Redact PII from text while preserving structure
 * @param {string} text - Text containing potential PII
 * @param {Object} options - Redaction options
 * @param {string} options.displayName - User's display name to redact
 * @param {string[]} options.additionalPatterns - Custom patterns to redact
 * @returns {string} Redacted text
 */
export function redactPII(text, options = {}) {
  if (!text || typeof text !== 'string') {
    return text || '';
  }

  let redacted = text;

  // Apply standard PII patterns
  for (const { pattern, replacement } of PII_PATTERNS) {
    redacted = redacted.replace(pattern, replacement);
  }

  // Redact display name if provided
  // Use Unicode-aware boundaries so we avoid over-redacting substrings (e.g., "Ana" in "analysis")
  // while still matching names with diacritics or non-Latin scripts that \b would miss.
  if (options.displayName && typeof options.displayName === 'string') {
    const name = options.displayName.trim();
    if (name.length > 0) {
      try {
        const escapedName = name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const namePattern = new RegExp(
          `(^|[^\\p{L}\\p{N}_])(${escapedName}(?:['’]s)?)(?![\\p{L}\\p{N}_])`,
          'giu'
        );
        redacted = redacted.replace(namePattern, (_, prefix) => `${prefix}[NAME]`);
      } catch {
        // Invalid regex, skip name redaction
      }
    }
  }

  // Apply additional custom patterns
  // Same Unicode-safe approach: no \b word boundaries
  if (Array.isArray(options.additionalPatterns)) {
    for (const patternStr of options.additionalPatterns) {
      if (typeof patternStr === 'string' && patternStr.trim()) {
        try {
          const escaped = patternStr.trim().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const customPattern = new RegExp(escaped, 'gi');
          redacted = redacted.replace(customPattern, '[REDACTED]');
        } catch {
          // Invalid pattern, skip
        }
      }
    }
  }

  return redacted;
}

/**
 * Extract structural features from a prompt for pattern analysis
 * @param {string} prompt - The prompt text
 * @returns {Object} Structural features
 */
export function extractPromptFeatures(prompt) {
  if (!prompt || typeof prompt !== 'string') {
    return {
      length: 0,
      wordCount: 0,
      lineCount: 0,
      sectionCount: 0,
      hasMarkdown: false,
      hasCodeBlock: false,
      hasListItems: false,
      hasTables: false
    };
  }

  const lines = prompt.split('\n');
  const words = prompt.split(/\s+/).filter(w => w.length > 0);
  
  // Count markdown sections (headers)
  const sectionMatches = prompt.match(/^#+\s+/gm);
  const sectionCount = sectionMatches ? sectionMatches.length : 0;

  // Detect structural elements
  const hasMarkdown = /[*_#`]/.test(prompt);
  const hasCodeBlock = /```[\s\S]*?```/.test(prompt);
  const hasListItems = /^[-*+]\s+/m.test(prompt) || /^\d+\.\s+/m.test(prompt);
  const hasTables = /\|[^|]+\|/.test(prompt);

  return {
    length: prompt.length,
    wordCount: words.length,
    lineCount: lines.length,
    sectionCount,
    hasMarkdown,
    hasCodeBlock,
    hasListItems,
    hasTables
  };
}

/**
 * Build a prompt engineering payload for persistence
 *
 * PRIVACY: This function applies multiple layers of protection:
 * 1. PII pattern redaction (email, phone, SSN, etc.)
 * 2. User content stripping (questions, reflections)
 * 3. Display name redaction
 *
 * @param {Object} params - Prompt parameters
 * @param {string} params.systemPrompt - The system prompt
 * @param {string} params.userPrompt - The user prompt
 * @param {string} params.response - The LLM response
 * @param {Object} params.redactionOptions - Options for PII redaction
 * @param {boolean} params.stripUserContent - Whether to strip user questions/reflections (default: true)
 * @returns {Promise<Object>} Prompt engineering payload
 */
export async function buildPromptEngineeringPayload(params) {
  const {
    systemPrompt,
    userPrompt,
    response,
    redactionOptions = {},
    stripUserContent: shouldStripUserContent = true
  } = params;

  const safeSystem = systemPrompt || '';
  const safeUser = userPrompt || '';
  const safeResponse = response || '';

  // Generate hashes for the raw prompts (for deduplication)
  const combinedPrompt = `${safeSystem}\n---SEPARATOR---\n${safeUser}`;
  const [promptHash, systemHash, userHash, responseHash] = await Promise.all([
    hashText(combinedPrompt),
    fingerprint(safeSystem),
    fingerprint(safeUser),
    fingerprint(safeResponse)
  ]);

  // Layer 1: Strip user-provided content (questions, reflections)
  // This removes potentially sensitive free-form text before PII pattern matching
  let processedSystem = safeSystem;
  let processedUser = safeUser;
  let processedResponse = safeResponse;

  if (shouldStripUserContent) {
    processedSystem = stripUserContent(processedSystem);
    processedUser = stripUserContent(processedUser);
    processedResponse = stripUserContent(processedResponse);
  }

  // Layer 2: Redact PII patterns from prompts and response
  const redactedSystem = redactPII(processedSystem, redactionOptions);
  const redactedUser = redactPII(processedUser, redactionOptions);
  const redactedResponse = redactPII(processedResponse, redactionOptions);

  // Extract structural features (from original for accurate metrics)
  const systemFeatures = extractPromptFeatures(safeSystem);
  const userFeatures = extractPromptFeatures(safeUser);
  const responseFeatures = extractPromptFeatures(safeResponse);

  return {
    // Hashes for deduplication and grouping
    hashes: {
      combined: promptHash,
      system: systemHash,
      user: userHash,
      response: responseHash
    },

    // Redacted content (safe to store)
    redacted: {
      systemPrompt: redactedSystem,
      userPrompt: redactedUser,
      response: redactedResponse
    },

    // Structural analysis
    structure: {
      system: systemFeatures,
      user: userFeatures,
      response: responseFeatures
    },

    // Length metrics (quick reference without loading full text)
    lengths: {
      systemPrompt: safeSystem.length,
      userPrompt: safeUser.length,
      response: safeResponse.length,
      total: safeSystem.length + safeUser.length + safeResponse.length
    },

    // Privacy metadata
    privacy: {
      userContentStripped: shouldStripUserContent,
      piiRedacted: true
    }
  };
}

/**
 * Determine if prompt storage is enabled
 *
 * PRIVACY: This defaults to FALSE (opt-in) because prompts may contain
 * user questions, reflections, and other PII. Storage must be explicitly
 * enabled via PERSIST_PROMPTS=true.
 *
 * @param {Object} env - Environment bindings
 * @returns {boolean} Whether to persist prompts
 */
export function shouldPersistPrompts(env) {
  if (!env) return false;

  // Check for explicit enable/disable - must be explicitly enabled
  if (env.PERSIST_PROMPTS !== undefined) {
    const value = String(env.PERSIST_PROMPTS).toLowerCase();
    return value === 'true' || value === '1';
  }

  // Default to DISABLED for privacy - user data should not be stored
  // without explicit consent/configuration
  return false;
}

/**
 * Strip user-provided content (questions, reflections) from prompts for storage
 * This provides an additional privacy layer beyond PII pattern matching
 *
 * PRIVACY: This function handles multiple patterns where user content appears:
 * 1. Explicit question fields (single and multi-line)
 * 2. Reflections sections (both inline and newline-separated)
 * 3. Questions embedded in card labels (Outcome/Future positions)
 *
 * @param {string} text - Prompt text containing user content
 * @returns {string} Text with user content replaced by placeholders
 */
export function stripUserContent(text) {
  if (!text || typeof text !== 'string') return text || '';

  let result = text;

  // Strip user questions - **Question**: format (multiline support)
  // Matches from **Question**: to the next blank line or next ** header
  result = result.replace(
    /\*\*Question\*\*:\s*["']?[\s\S]*?(?=\n\n|\n\*\*|$)/gi,
    '**Question**: [USER_QUESTION_REDACTED]'
  );

  // Strip user questions - plain "question:", "query:", "asking:" formats
  // Captures the keyword and all subsequent lines until a blank line or new section
  // Uses multiline matching to handle content spanning multiple lines
  result = result.replace(
    /^(question|query|asking)[:\s]+["']?[^\n]*(?:\n(?!\n|\*\*|[A-Z][a-z]+:)[^\n]*)*/gim,
    '[USER_QUESTION_REDACTED]'
  );

  // Strip user reflections - **Querent's Reflections**: format
  // Handles both inline (same line) and newline-separated content
  // Matches until next ** header or blank line
  result = result.replace(
    /\*\*(?:Querent['']s|User['']?s?\s*)?\s*Reflections?\*\*:\s*[\s\S]*?(?=\n\n|\n\*\*|$)/gi,
    '**Reflections**: [USER_REFLECTIONS_REDACTED]'
  );

  // Strip inline reflections - *Querent's Reflection: "..."* format
  // Handles both straight quotes and smart quotes, and both ASCII and curly apostrophes
  result = result.replace(
    /\*(?:Querent['']s|User['']?s?\s*)?\s*Reflection:\s*[""][^""]*[""]\*/gi,
    '*Reflection: [USER_REFLECTION_REDACTED]*'
  );

  // Strip questions embedded in card position labels
  // Pattern: Outcome — likely path for "<question>" if unchanged
  result = result.replace(
    /Outcome\s*[—–-]\s*likely path for\s*[""][^""]*[""]/gi,
    'Outcome — likely path for [USER_QUESTION_REDACTED]'
  );

  // Pattern: Future — likely trajectory for "<question>" if nothing shifts
  result = result.replace(
    /Future\s*[—–-]\s*likely trajectory for\s*[""][^""]*[""]/gi,
    'Future — likely trajectory for [USER_QUESTION_REDACTED]'
  );

  // Strip displayName-prefixed questions: "Name, you asked: <question>"
  // This handles personalized question formats
  result = result.replace(
    /,\s*you asked:\s*[^\n]+/gi,
    ', you asked: [USER_QUESTION_REDACTED]'
  );

  return result;
}

/**
 * Extract user question from prompt (for separate storage with different retention)
 * @param {string} userPrompt - The user prompt
 * @returns {string|null} Extracted question or null
 */
export function extractUserQuestion(userPrompt) {
  if (!userPrompt) return null;

  // Look for question patterns in the prompt
  const questionPatterns = [
    /(?:question|query|asking)[:\s]+["']?([^"'\n]+)["']?/i,
    /(?:the querent asks|user asks)[:\s]+["']?([^"'\n]+)["']?/i,
    /\*\*Question\*\*[:\s]+([^\n]+)/i
  ];

  for (const pattern of questionPatterns) {
    const match = userPrompt.match(pattern);
    if (match && match[1]) {
      return match[1].trim();
    }
  }

  return null;
}
</file>

<file path="functions/lib/rateLimit.js">
/**
 * Rate Limiting Library using Cloudflare KV
 *
 * Implements a fixed-window rate limiting algorithm.
 */

const DEFAULT_WINDOW = 60; // 1 minute
const DEFAULT_LIMIT = 60;  // 60 requests per minute

/**
 * Check if a request exceeds the rate limit
 * @param {KVNamespace} kv - Cloudflare KV binding (RATELIMIT)
 * @param {string} identifier - Unique identifier (IP, User ID, or API Key ID)
 * @param {string} type - Rate limit type (e.g., 'api', 'auth', 'tts')
 * @param {number} [limit] - Max requests per window
 * @param {number} [windowSeconds] - Window size in seconds
 * @returns {Promise<{success: boolean, limit: number, remaining: number, reset: number}>}
 */
export async function checkRateLimit(kv, identifier, type = 'general', limit = DEFAULT_LIMIT, windowSeconds = DEFAULT_WINDOW) {
  if (!kv) {
    console.warn('Rate limiting KV not bound. Skipping check.');
    return { success: true, limit, remaining: limit, reset: 0 };
  }

  const now = Math.floor(Date.now() / 1000);
  const windowKey = Math.floor(now / windowSeconds);
  const key = `ratelimit:${type}:${identifier}:${windowKey}`;
  
  // Calculate time until next window
  const reset = (windowKey + 1) * windowSeconds;

  try {
    // Increment counter
    const { value } = await kv.getWithMetadata(key);
    const currentCount = value ? parseInt(value) : 0;
    
    if (currentCount >= limit) {
      return {
        success: false,
        limit,
        remaining: 0,
        reset
      };
    }

    // Atomic increment is not supported directly in KV without Durable Objects,
    // but for rate limiting, eventual consistency is usually acceptable.
    // Or we can use `put` blindly if we trust the read.
    // A safer approach in KV for strict counting requires DO, but we'll use simple KV put with expiration.
    
    const newCount = currentCount + 1;
    
    // Set new count with expiration (window size + buffer)
    await kv.put(key, newCount.toString(), { expiration: reset + 10 });

    return {
      success: true,
      limit,
      remaining: limit - newCount,
      reset
    };
  } catch (error) {
    console.error('Rate limit error:', error);
    // Fail open to prevent blocking valid traffic on infrastructure errors
    return { success: true, limit, remaining: 1, reset };
  }
}

/**
 * Helper to generate rate limit headers
 * @param {object} result - Result from checkRateLimit
 * @returns {object} Headers object
 */
export function getRateLimitHeaders(result) {
  return {
    'X-RateLimit-Limit': result.limit.toString(),
    'X-RateLimit-Remaining': result.remaining.toString(),
    'X-RateLimit-Reset': result.reset.toString()
  };
}
</file>

<file path="functions/lib/scheduled.js">
/**
 * Scheduled Tasks Handler
 *
 * Handles cron-triggered tasks for the Mystic Tarot application:
 * - Archive metrics from METRICS_DB KV to R2
 * - Archive feedback from FEEDBACK_KV to R2
 * - Clean up expired sessions from D1
 *
 * Cron schedule (configured in wrangler.jsonc):
 * - Daily at 3 AM UTC for archival
 * - Weekly for session cleanup
 */

const ARCHIVE_BATCH_SIZE = 100;
const METRICS_PREFIX = 'reading:';
const FEEDBACK_PREFIX = 'feedback:';

/**
 * Archive KV data to R2 bucket with full pagination support
 * @param {KVNamespace} kv - Source KV namespace
 * @param {R2Bucket} bucket - Destination R2 bucket
 * @param {string} prefix - KV key prefix to archive
 * @param {string} archiveType - Type identifier for archive path
 * @returns {Promise<{archived: number, deleted: number, errors: number, batches: number}>}
 */
async function archiveKVToR2(kv, bucket, prefix, archiveType) {
  const stats = { archived: 0, deleted: 0, errors: 0, batches: 0 };

  if (!kv || !bucket) {
    console.warn(`Skipping ${archiveType} archival: missing KV or R2 binding`);
    return stats;
  }

  try {
    let cursor = null;
    let totalKeys = 0;

    // Paginate through all keys
    do {
      const listOptions = { prefix, limit: ARCHIVE_BATCH_SIZE };
      if (cursor) {
        listOptions.cursor = cursor;
      }

      const listResult = await kv.list(listOptions);
      const keys = listResult.keys || [];
      cursor = listResult.list_complete ? null : listResult.cursor;

      if (keys.length === 0) {
        if (stats.batches === 0) {
          console.log(`No ${archiveType} keys to archive`);
        }
        break;
      }

      totalKeys += keys.length;
      stats.batches++;
      console.log(`Processing batch ${stats.batches}: ${keys.length} ${archiveType} keys`);

      // Collect records for this batch
      const records = [];
      const keysToDelete = [];

      for (const key of keys) {
        try {
          const value = await kv.get(key.name, 'json');
          if (value) {
            records.push({
              key: key.name,
              metadata: key.metadata || {},
              data: value,
              archivedAt: new Date().toISOString()
            });
            keysToDelete.push(key.name);
            stats.archived++;
          }
        } catch (err) {
          console.error(`Failed to read ${key.name}:`, err.message);
          stats.errors++;
        }
      }

      if (records.length === 0) {
        continue;
      }

      // Create archive file in R2 for this batch
      const now = new Date();
      const dateStr = now.toISOString().split('T')[0];
      const timestamp = now.getTime();
      const batchSuffix = stats.batches > 1 ? `-batch${stats.batches}` : '';
      const archivePath = `archives/${archiveType}/${dateStr}/${timestamp}${batchSuffix}.json`;

      const archiveData = {
        type: archiveType,
        archivedAt: now.toISOString(),
        batch: stats.batches,
        recordCount: records.length,
        records
      };

      await bucket.put(archivePath, JSON.stringify(archiveData, null, 2), {
        httpMetadata: {
          contentType: 'application/json'
        },
        customMetadata: {
          archiveType,
          recordCount: records.length.toString(),
          batch: stats.batches.toString(),
          dateArchived: dateStr
        }
      });

      console.log(`Archived ${records.length} ${archiveType} records to ${archivePath}`);

      // Delete archived keys from KV
      for (const keyName of keysToDelete) {
        try {
          await kv.delete(keyName);
          stats.deleted++;
        } catch (err) {
          console.error(`Failed to delete ${keyName}:`, err.message);
          stats.errors++;
        }
      }
    } while (cursor);

    if (totalKeys > 0) {
      console.log(`Completed ${archiveType} archival: ${stats.archived} archived, ${stats.deleted} deleted across ${stats.batches} batch(es)`);
    }

  } catch (error) {
    console.error(`${archiveType} archival failed:`, error);
    stats.errors++;
  }

  return stats;
}

/**
 * Clean up expired sessions from D1
 * @param {D1Database} db - D1 database binding
 * @returns {Promise<number>} Number of sessions deleted
 */
async function cleanupExpiredSessions(db) {
  if (!db) {
    console.warn('Skipping session cleanup: missing DB binding');
    return 0;
  }

  try {
    const now = Math.floor(Date.now() / 1000);

    const result = await db
      .prepare('DELETE FROM sessions WHERE expires_at <= ?')
      .bind(now)
      .run();

    const deleted = result.meta?.changes || 0;
    console.log(`Cleaned up ${deleted} expired sessions`);
    return deleted;
  } catch (error) {
    console.error('Session cleanup failed:', error);
    return 0;
  }
}

/**
 * Generate daily archival summary
 * @param {R2Bucket} bucket - R2 bucket for storing summary
 * @param {object} results - Archival results
 */
async function storeArchivalSummary(bucket, results) {
  if (!bucket) return;

  const now = new Date();
  const dateStr = now.toISOString().split('T')[0];
  const summaryPath = `archives/summaries/${dateStr}.json`;

  const summary = {
    date: dateStr,
    completedAt: now.toISOString(),
    metrics: results.metrics,
    feedback: results.feedback,
    sessions: results.sessions,
    totalArchived: (results.metrics?.archived || 0) + (results.feedback?.archived || 0),
    totalErrors: (results.metrics?.errors || 0) + (results.feedback?.errors || 0)
  };

  try {
    await bucket.put(summaryPath, JSON.stringify(summary, null, 2), {
      httpMetadata: {
        contentType: 'application/json'
      },
      customMetadata: {
        type: 'archival-summary',
        date: dateStr
      }
    });
    console.log(`Stored archival summary at ${summaryPath}`);
  } catch (error) {
    console.error('Failed to store archival summary:', error);
  }
}

/**
 * Main scheduled handler
 * Called by Cloudflare Workers cron trigger
 *
 * @param {ScheduledController} controller - Cron controller with scheduledTime and cron
 * @param {Env} env - Environment bindings
 * @param {ExecutionContext} ctx - Execution context
 */
export async function handleScheduled(controller, env, ctx) {
  const startTime = Date.now();
  const cron = controller.cron;

  console.log(`Scheduled task triggered at ${new Date().toISOString()}`);
  console.log(`Cron pattern: ${cron}`);

  const results = {
    metrics: null,
    feedback: null,
    sessions: null
  };

  try {
    // Run archival tasks in parallel
    const [metricsResult, feedbackResult] = await Promise.all([
      archiveKVToR2(env.METRICS_DB, env.LOGS_BUCKET, METRICS_PREFIX, 'metrics'),
      archiveKVToR2(env.FEEDBACK_KV, env.LOGS_BUCKET, FEEDBACK_PREFIX, 'feedback')
    ]);

    results.metrics = metricsResult;
    results.feedback = feedbackResult;

    // Clean up expired sessions
    const sessionsDeleted = await cleanupExpiredSessions(env.DB);
    results.sessions = { deleted: sessionsDeleted };

    // Store summary in R2
    await storeArchivalSummary(env.LOGS_BUCKET, results);

    const duration = Date.now() - startTime;
    console.log(`Scheduled tasks completed in ${duration}ms`);
    console.log('Results:', JSON.stringify(results));

  } catch (error) {
    console.error('Scheduled task error:', error);
  }
}

/**
 * Manual trigger endpoint for testing archival
 * POST /api/admin/archive
 */
export async function onRequestPost(context) {
  const { request, env } = context;

  // Simple auth check - require admin API key
  const authHeader = request.headers.get('Authorization');
  const adminKey = env.ADMIN_API_KEY;

  if (!adminKey || authHeader !== `Bearer ${adminKey}`) {
    return new Response(JSON.stringify({ error: 'Unauthorized' }), {
      status: 401,
      headers: { 'Content-Type': 'application/json' }
    });
  }

  const startTime = Date.now();

  try {
    const [metricsResult, feedbackResult] = await Promise.all([
      archiveKVToR2(env.METRICS_DB, env.LOGS_BUCKET, METRICS_PREFIX, 'metrics'),
      archiveKVToR2(env.FEEDBACK_KV, env.LOGS_BUCKET, FEEDBACK_PREFIX, 'feedback')
    ]);

    const sessionsDeleted = await cleanupExpiredSessions(env.DB);

    const results = {
      metrics: metricsResult,
      feedback: feedbackResult,
      sessions: { deleted: sessionsDeleted },
      duration: Date.now() - startTime
    };

    await storeArchivalSummary(env.LOGS_BUCKET, results);

    return new Response(JSON.stringify({
      success: true,
      ...results
    }), {
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      error: 'Archival failed',
      message: error.message
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}
</file>

<file path="functions/lib/shareData.js">
import { hydrateJournalEntry } from './shareUtils.js';

function safeJson(value, fallback) {
  if (!value) return fallback;
  try {
    return JSON.parse(value);
  } catch {
    return fallback;
  }
}

export async function loadShareRecord(env, token) {
  const row = await env.DB.prepare(`
    SELECT token, user_id, scope, title, created_at, expires_at, view_count, meta_json
    FROM share_tokens
    WHERE token = ?
  `).bind(token).first();
  if (!row) return null;
  return {
    token: row.token,
    userId: row.user_id,
    scope: row.scope,
    title: row.title,
    createdAt: row.created_at,
    expiresAt: row.expires_at,
    viewCount: row.view_count || 0,
    meta: safeJson(row.meta_json, {})
  };
}

export async function loadShareEntries(env, token) {
  const result = await env.DB.prepare(`
    SELECT je.* , ste.sort_index
    FROM share_token_entries ste
    JOIN journal_entries je ON je.id = ste.entry_id
    WHERE ste.token = ?
    ORDER BY ste.sort_index ASC
  `).bind(token).all();
  return result.results.map(hydrateJournalEntry);
}

export async function loadShareNotes(env, token) {
  const result = await env.DB.prepare(`
    SELECT id, author_name, body, card_position, created_at
    FROM share_notes
    WHERE token = ?
    ORDER BY created_at ASC
  `).bind(token).all();
  return result.results.map((row) => ({
    id: row.id,
    authorName: row.author_name || 'Guest Seeker',
    body: row.body,
    cardPosition: row.card_position || null,
    createdAt: row.created_at * 1000
  }));
}
</file>

<file path="functions/lib/shareUtils.js">
import { computeJournalStats } from '../../shared/journal/stats.js';

export function hydrateJournalEntry(row) {
  if (!row) return null;
  return {
    id: row.id,
    ts: row.created_at ? row.created_at * 1000 : Date.now(),
    spread: row.spread_name,
    spreadKey: row.spread_key,
    question: row.question,
    cards: safeJsonParse(row.cards_json, []),
    personalReading: row.narrative,
    themes: safeJsonParse(row.themes_json, null),
    reflections: safeJsonParse(row.reflections_json, {}),
    context: row.context,
    provider: row.provider,
    sessionSeed: row.session_seed
  };
}

function safeJsonParse(value, fallback) {
  if (!value) return fallback;
  try {
    return JSON.parse(value);
  } catch {
    return fallback;
  }
}

export async function loadEntriesForUser(env, userId, entryIds) {
  if (!Array.isArray(entryIds) || entryIds.length === 0) {
    return [];
  }
  const placeholders = entryIds.map(() => '?').join(', ');
  const query = `
    SELECT id, user_id, created_at, spread_key, spread_name, question, cards_json, narrative,
           themes_json, reflections_json, context, provider, session_seed
    FROM journal_entries
    WHERE user_id = ? AND id IN (${placeholders})
  `;
  const params = [userId, ...entryIds];
  const result = await env.DB.prepare(query).bind(...params).all();
  const mapped = result.results.map(hydrateJournalEntry);
  const byId = new Map(mapped.map((entry) => [entry.id, entry]));
  return entryIds.map((id) => byId.get(id)).filter(Boolean);
}

export async function loadRecentEntries(env, userId, limit = 5) {
  const result = await env.DB.prepare(`
    SELECT id, user_id, created_at, spread_key, spread_name, question, cards_json, narrative,
           themes_json, reflections_json, context, provider, session_seed
    FROM journal_entries
    WHERE user_id = ?
    ORDER BY created_at DESC
    LIMIT ?
  `).bind(userId, limit).all();
  return result.results.map(hydrateJournalEntry);
}

export function buildSharePayload(entries) {
  const stats = computeJournalStats(entries);
  return {
    stats,
    entries
  };
}

function buildContextBreakdown(entries) {
  const contextMap = new Map();
  entries.forEach((entry) => {
    const key = entry?.context || 'general';
    contextMap.set(key, (contextMap.get(key) || 0) + 1);
  });
  return Array.from(contextMap.entries()).map(([name, count]) => ({ name, count }));
}

function deriveLastEntryTimestamp(entries) {
  return entries.reduce((latest, entry) => {
    const ts = typeof entry?.ts === 'number'
      ? entry.ts
      : entry?.created_at
        ? entry.created_at * 1000
        : 0;
    return ts > latest ? ts : latest;
  }, 0);
}

export function buildShareMeta(entries) {
  if (!Array.isArray(entries) || entries.length === 0) {
    return { entryCount: 0, spreadKeys: [], contexts: [], lastEntryTs: null };
  }

  const spreadKeys = Array.from(new Set(entries.map((entry) => entry.spreadKey).filter(Boolean))).slice(0, 6);

  return {
    entryCount: entries.length,
    spreadKeys,
    contexts: buildContextBreakdown(entries),
    lastEntryTs: deriveLastEntryTimestamp(entries)
  };
}
</file>

<file path="functions/lib/spreadAnalysis.js">
/**
 * Spread Analysis Library
 *
 * Canonical server-side analysis engine.
 *
 * Responsibilities:
 * - Elemental correspondences and dignities
 * - Theme analysis (suits, elements, reversals)
 * - Spread-specific structural analysis
 * - Relationships and positional notes for UI + narrative consumers
 *
 * Output from this module is the single source of truth for:
 * - AI prompting (narrativeBuilder)
 * - Frontend Spread Highlights (via /api/tarot-reading spreadAnalysis)
 */

/**
 * Traditional elemental correspondences for Major Arcana
 * Based on Golden Dawn / Rider-Waite-Smith astrological associations
 */
export const MAJOR_ELEMENTS = {
  0: 'Air',      // The Fool (Uranus/Air)
  1: 'Air',      // The Magician (Mercury)
  2: 'Water',    // The High Priestess (Moon)
  3: 'Earth',    // The Empress (Venus)
  4: 'Fire',     // The Emperor (Aries)
  5: 'Earth',    // The Hierophant (Taurus)
  6: 'Air',      // The Lovers (Gemini)
  7: 'Water',    // The Chariot (Cancer)
  8: 'Fire',     // Strength (Leo)
  9: 'Earth',    // The Hermit (Virgo)
  10: 'Fire',    // Wheel of Fortune (Jupiter)
  11: 'Air',     // Justice (Libra)
  12: 'Water',   // The Hanged Man (Neptune)
  13: 'Water',   // Death (Scorpio)
  14: 'Fire',    // Temperance (Sagittarius)
  15: 'Earth',   // The Devil (Capricorn)
  16: 'Fire',    // The Tower (Mars)
  17: 'Air',     // The Star (Aquarius)
  18: 'Water',   // The Moon (Pisces)
  19: 'Fire',    // The Sun (Sun)
  20: 'Fire',    // Judgement (Pluto)
  21: 'Earth'    // The World (Saturn)
};

/**
 * Suit to element mapping (standard)
 */
export const SUIT_ELEMENTS = {
  'Wands': 'Fire',
  'Cups': 'Water',
  'Swords': 'Air',
  'Pentacles': 'Earth'
};

/**
 * Elemental relationship definitions
 * Used for consistent dignity analysis across the module
 */
const ELEMENTAL_RELATIONSHIPS = {
  // Supportive pairs (active or receptive energies work together)
  supportive: [
    'Fire-Air', 'Air-Fire',
    'Water-Earth', 'Earth-Water'
  ],
  // Tension pairs (opposing qualities create friction)
  tension: [
    'Fire-Water', 'Water-Fire',
    'Air-Earth', 'Earth-Air'
  ],
  // Neutral pairs (neither strongly supportive nor tense)
  neutral: [
    'Fire-Earth', 'Earth-Fire',
    'Air-Water', 'Water-Air'
  ]
};

/**
 * Get elemental correspondence for any card
 *
 * @param {string} cardName - Full card name (e.g., "Three of Wands", "The Fool")
 * @param {number} [cardNumber] - Card number (0-21 for Majors)
 * @returns {string|null} Element name or null if not determinable
 */
export function getCardElement(cardName, cardNumber) {
  // Major Arcana (0-21)
  if (cardNumber !== undefined && cardNumber >= 0 && cardNumber <= 21) {
    return MAJOR_ELEMENTS[cardNumber] || null;
  }

  // Minor Arcana - extract suit from card name
  if (typeof cardName === 'string') {
    for (const [suit, element] of Object.entries(SUIT_ELEMENTS)) {
      if (cardName.includes(suit)) {
        return element;
      }
    }
  }

  return null;
}

/**
 * Analyze elemental dignity (interaction between two cards)
 *
 * Traditional elemental dignities:
 * - Fire & Air support each other (active energies)
 * - Water & Earth support each other (receptive energies)
 * - Fire & Water create tension (steam/conflict)
 * - Air & Earth create tension (scattered vs grounded)
 * - Fire & Earth are neutral (neither strongly aligned nor opposed)
 * - Air & Water are neutral (neither strongly aligned nor opposed)
 * - Same element amplifies
 *
 * @param {Object} card1 - First card object with card name and number
 * @param {Object} card2 - Second card object with card name and number
 * @returns {Object} Elemental relationship analysis with:
 *   - relationship: 'amplified' | 'supportive' | 'tension' | 'neutral'
 *   - element/elements: The element(s) involved
 *   - description: Prose description of the elemental dynamic
 *
 * NOTE: For sensory imagery descriptions of elemental relationships,
 * see getElementalImagery() in imageryHooks.js, which provides
 * metaphorical language (e.g., "Steam rises where fire meets water")
 * for use in narrative prompts and reading generation.
 */
export function analyzeElementalDignity(card1, card2) {
  if (!card1 || !card2) {
    return {
      relationship: 'neutral',
      elements: null,
      description: null
    };
  }

  const e1 = getCardElement(card1.card || '', card1.number);
  const e2 = getCardElement(card2.card || '', card2.number);

  if (!e1 || !e2) {
    return {
      relationship: 'neutral',
      elements: null,
      description: null
    };
  }

  // Same element - amplification
  if (e1 === e2) {
    return {
      relationship: 'amplified',
      element: e1,
      elements: [e1, e2],
      description: `Both ${e1} cards reinforce and intensify this elemental energy`
    };
  }

  const pair = `${e1}-${e2}`;

  // Supportive combinations (active or receptive pairs)
  if (ELEMENTAL_RELATIONSHIPS.supportive.includes(pair)) {
    return {
      relationship: 'supportive',
      elements: [e1, e2],
      description: `${e1} and ${e2} work harmoniously together, each supporting the other's expression`
    };
  }

  // Tension combinations (opposing qualities)
  if (ELEMENTAL_RELATIONSHIPS.tension.includes(pair)) {
    return {
      relationship: 'tension',
      elements: [e1, e2],
      description: `${e1} and ${e2} create friction that must be balanced and integrated`
    };
  }

  // Neutral combinations (diagonal elements)
  if (ELEMENTAL_RELATIONSHIPS.neutral.includes(pair)) {
    return {
      relationship: 'neutral',
      elements: [e1, e2],
      description: `${e1} and ${e2} operate independently, neither reinforcing nor opposing each other`
    };
  }

  // Fallback (should not reach here with complete relationship definitions)
  return {
    relationship: 'neutral',
    elements: [e1, e2],
    description: null
  };
}

/**
 * Analyze themes across entire spread
 * Detects suit dominance, elemental balance, Major density, reversal patterns
 *
 * @param {Array} cardsInfo - Array of card objects with card, number, orientation properties
 * @param {Object} [options] - Analysis options
 * @param {string} [options.deckStyle='rws-1909'] - Deck style identifier
 * @param {string} [options.reversalFrameworkOverride] - Force specific reversal framework
 * @param {boolean} [options.enableKnowledgeGraph=true] - Enable knowledge graph pattern detection
 * @param {Object} [options.env] - Environment object for Workers (used for feature flags)
 * @returns {Promise<Object>} Theme analysis results
 */
export async function analyzeSpreadThemes(cardsInfo, options = {}) {
  if (!Array.isArray(cardsInfo) || cardsInfo.length === 0) {
    return {
      deckStyle: options.deckStyle || 'rws-1909',
      suitCounts: { Wands: 0, Cups: 0, Swords: 0, Pentacles: 0 },
      dominantSuit: null,
      suitFocus: null,
      elementCounts: { Fire: 0, Water: 0, Air: 0, Earth: 0 },
      dominantElement: null,
      elementalBalance: 'No elemental data available.',
      majorCount: 0,
      majorRatio: 0,
      archetypeLevel: 'normal',
      archetypeDescription: 'Primarily Minor Arcana, focusing on practical, day-to-day dynamics and immediate concerns.',
      reversalCount: 0,
      reversalRatio: 0,
      reversalFramework: 'none',
      reversalDescription: REVERSAL_FRAMEWORKS.none,
      averageNumber: null,
      lifecycleStage: null,
      timingProfile: null,
      knowledgeGraph: null
    };
  }

  const deckStyle = options.deckStyle || 'rws-1909';
  const suitCounts = { Wands: 0, Cups: 0, Swords: 0, Pentacles: 0 };
  const elementCounts = { Fire: 0, Water: 0, Air: 0, Earth: 0 };
  let majorCount = 0;
  let reversalCount = 0;
  const numbers = [];

  cardsInfo.forEach(card => {
    if (!card) return;

    // Count Majors (numbers 0-21)
    if (typeof card.number === 'number' && card.number >= 0 && card.number <= 21) {
      majorCount++;
    }

    // Count suits
    if (typeof card.card === 'string') {
      for (const suit of Object.keys(suitCounts)) {
        if (card.card.includes(suit)) {
          suitCounts[suit]++;
          break;
        }
      }
    }

    // Count elements
    const element = getCardElement(card.card, card.number);
    if (element && elementCounts[element] !== undefined) {
      elementCounts[element]++;
    }

    // Count reversals (normalized to handle any casing/variants)
    const orientation = String(card.orientation || '').toLowerCase();
    if (orientation === 'reversed') {
      reversalCount++;
    }

    // Collect numbers for lifecycle analysis
    if (typeof card.number === 'number') {
      numbers.push(card.number);
    }
  });

  const totalCards = cardsInfo.length;
  const reversalRatio = totalCards > 0 ? reversalCount / totalCards : 0;
  const majorRatio = totalCards > 0 ? majorCount / totalCards : 0;

  // Find dominant suit
  const sortedSuitEntries = Object.entries(suitCounts)
    .sort((a, b) => b[1] - a[1]);
  const dominantSuitEntry = sortedSuitEntries[0] || [null, 0];
  const secondSuitEntry = sortedSuitEntries[1] || [null, 0];

  // Find dominant element
  const dominantElementEntry = Object.entries(elementCounts)
    .sort((a, b) => b[1] - a[1])[0] || [null, 0];

  // Calculate average card number
  const avgNumber = numbers.length > 0
    ? numbers.reduce((sum, n) => sum + n, 0) / numbers.length
    : null;

  // Select reversal framework (allow explicit override)
  let reversalFramework = selectReversalFramework(reversalRatio, cardsInfo, {
    userQuestion: options.userQuestion
  });
  if (options.reversalFrameworkOverride && REVERSAL_FRAMEWORKS[options.reversalFrameworkOverride]) {
    reversalFramework = options.reversalFrameworkOverride;
  }

  const themes = {
    deckStyle,
    // Suit analysis
    suitCounts,
    dominantSuit: dominantSuitEntry[1] > 0 ? dominantSuitEntry[0] : null,
    suitFocus: getSuitFocusDescription({
      top: dominantSuitEntry,
      second: secondSuitEntry
    }),

    // Elemental analysis
    elementCounts,
    dominantElement: dominantElementEntry[1] > 0 ? dominantElementEntry[0] : null,
    elementalBalance: getMajorAwareElementalBalanceDescription({
      elementCounts,
      totalCards,
      majorRatio
    }),

    // Major Arcana analysis
    majorCount,
    majorRatio,
    archetypeLevel: majorRatio >= 0.5 ? 'high' : majorRatio >= 0.3 ? 'moderate' : 'normal',
    archetypeDescription: getArchetypeDescription(majorRatio),

    // Reversal analysis
    reversalCount,
    reversalRatio,
    reversalFramework,
    reversalDescription: getReversalFrameworkDescription(reversalFramework),

    // Lifecycle/numerology
    averageNumber: avgNumber,
    lifecycleStage: getLifecycleStage(avgNumber),

    // Timing profile (set below)
    timingProfile: null,

    // Knowledge graph (set below if enabled)
    knowledgeGraph: null
  };

  // Soft timing profile (non-deterministic pacing hint)
  try {
    const { getSpreadTimingProfile } = await import('./timingMeta.js');
    themes.timingProfile = getSpreadTimingProfile({ cardsInfo, themes });
  } catch {
    // Graceful degradation: timing profile unavailable
    themes.timingProfile = null;
  }

  // Knowledge Graph pattern detection (archetypal triads, Fool's Journey, dyads)
  const enableKG = options.enableKnowledgeGraph !== false;

  if (enableKG) {
    try {
      const { isGraphRAGEnabled, retrievePassages } = await import('./graphRAG.js');
      const KG_ENABLED = isGraphRAGEnabled(options.env);

      if (KG_ENABLED) {
        const { buildGraphContext } = await import('./graphContext.js');
        const graphContext = buildGraphContext(cardsInfo, { deckStyle });

        if (graphContext) {
          themes.knowledgeGraph = graphContext;

          // Retrieve passages for frontend display
          const passages = retrievePassages(graphContext.graphKeys, {
            maxPassages: 5,
            includeMetadata: true
          });
          themes.knowledgeGraph.retrievedPassages = passages;
        }
      }
    } catch (err) {
      console.error('Knowledge graph detection failed:', err);
      // Graceful degradation: continue without patterns
      themes.knowledgeGraph = null;
    }
  }

  return themes;
}

/**
 * Select appropriate reversal interpretation framework based on patterns
 *
 * @param {number} ratio - Ratio of reversed cards (0-1)
 * @param {Array} cardsInfo - Card array for pattern detection
 * @param {Object} [options] - Additional context
 * @param {string} [options.userQuestion] - User's question for intent detection
 * @returns {string} Framework key
 */
export function selectReversalFramework(ratio, cardsInfo, options = {}) {
  if (ratio === 0) return 'none';

  const { userQuestion } = options;

  if (userQuestion) {
    const q = userQuestion.toLowerCase();
    const shadowKeywords = [
      'afraid',
      'avoid',
      'fear',
      'shadow',
      'hidden',
      'deny',
      'repress',
      'shame',
      'guilt',
      'trigger'
    ];
    const mirrorKeywords = [
      'reflect',
      'mirror',
      'project',
      'attract',
      'pattern',
      'repeat',
      'always'
    ];
    const potentialKeywords = [
      'potential',
      'talent',
      'gift',
      'dormant',
      'untapped',
      'could be',
      'capable'
    ];

    if (shadowKeywords.some(kw => q.includes(kw))) {
      return 'shadow';
    }
    if (mirrorKeywords.some(kw => q.includes(kw))) {
      return 'mirror';
    }
    if (potentialKeywords.some(kw => q.includes(kw))) {
      return 'potentialBlocked';
    }
  }

  // Calculate spread size for threshold adjustments
  const totalCards = Array.isArray(cardsInfo) ? cardsInfo.length : 0;
  const reversalCount = totalCards > 0 ? Math.round(ratio * totalCards) : 0;

  // Check for reversed Major Arcana pattern
  if (Array.isArray(cardsInfo)) {
    const reversedMajors = cardsInfo.filter(
      c =>
        c &&
        (c.orientation || '').toLowerCase() === 'reversed' &&
        typeof c.number === 'number' &&
        c.number >= 0 &&
        c.number <= 21
    );
    if (reversedMajors.length >= 2) {
      return 'potentialBlocked';
    }
  }

  // Spread-aware thresholds: Small spreads (≤5 cards) need adjusted thresholds
  // because 2/3 = 67% would immediately trigger "blocked" which is too aggressive.
  // For small spreads, require higher absolute counts to trigger stronger frameworks.
  if (totalCards > 0 && totalCards <= 5) {
    // Small spread adjustments:
    // - 'blocked' requires 3+ reversals (impossible in 3-card, rare in 5-card)
    // - 'internalized' requires 2+ reversals with ratio >= 0.5
    // - Otherwise use softer frameworks for more nuanced interpretation
    if (reversalCount >= 3) return 'blocked';
    if (reversalCount >= 2 && ratio >= 0.5) return 'internalized';
    if (reversalCount >= 2) return 'delayed';
    if (reversalCount >= 1) return 'contextual';
    return 'contextual';
  }

  // Standard thresholds for larger spreads (6+ cards)
  if (ratio >= 0.6) return 'blocked';
  if (ratio >= 0.4) return 'internalized';
  if (ratio >= 0.2) return 'delayed';
  return 'contextual';
}

/**
 * Reversal framework definitions
 */
export const REVERSAL_FRAMEWORKS = {
  none: {
    name: 'All Upright',
    description: 'All cards appear upright, showing energies flowing freely and directly.',
    guidance: 'Read each card\'s traditional upright meaning in the context of its position.',
    examples: {}
  },
  blocked: {
    name: 'Blocked Energy',
    description: 'Reversed cards show energies present but meeting resistance, obstacles, or internal barriers.',
    guidance: 'Interpret reversals as the same energy encountering blockage that must be addressed before progress.',
    examples: {
      'The Magician': 'Skills and resources are present but meeting external obstacles or internal resistance preventing manifestation',
      'The Chariot': 'Drive and determination exist but are stalled by conflicting priorities or external forces',
      'Three of Pentacles': 'Collaborative work blocked by miscommunication, lack of recognition, or organizational barriers',
      'Eight of Wands': 'Swift momentum halted by delays, bureaucracy, or logistical obstacles requiring patience'
    }
  },
  delayed: {
    name: 'Delayed Timing',
    description: 'Reversed cards indicate timing is not yet ripe; patience and preparation are needed.',
    guidance: 'Read reversals as energies that will manifest later, after certain conditions are met.',
    examples: {
      'The Star': 'Hope and renewal are coming, but the full restoration requires more time and gentle tending',
      'The Sun': 'Success and clarity will arrive after necessary groundwork is complete',
      'Ace of Wands': 'New creative spark is forming but needs incubation before launching externally',
      'Two of Cups': 'Partnership or connection is developing beneath the surface, not yet ready for full expression'
    }
  },
  internalized: {
    name: 'Internal Processing',
    description: 'Reversed cards point to inner work, private processing, and energies working beneath the surface.',
    guidance: 'Interpret reversals as the same themes playing out in the inner world rather than external events.',
    examples: {
      'The Hermit': 'Solitude and reflection happening in private contemplation rather than visible retreat',
      'Justice': 'Seeking inner fairness and self-accountability before external resolution',
      'Five of Cups': 'Grief and loss being processed quietly within, not yet shared or externalized',
      'Knight of Swords': 'Mental clarity and decisiveness operating in internal dialogue and planning'
    }
  },
  contextual: {
    name: 'Context-Dependent',
    description: 'Reversed cards are interpreted individually based on their unique position and relationships.',
    guidance: 'Read each reversal according to what makes most sense for that specific card and position.',
    examples: {
      'The Tower': 'In Challenge position: Avoiding necessary change; in Advice: Transform gradually vs suddenly',
      'The Devil': 'In Subconscious: Releasing limiting beliefs; in External: Others\' attachments affecting you',
      'Seven of Swords': 'In Past: Previous deception being revealed; in Advice: Straightforward honesty needed now',
      'Ten of Pentacles': 'In Outcome: Legacy work still developing; in Hopes/Fears: Ambivalence about stability vs freedom'
    }
  },
  shadow: {
    name: 'Shadow Integration',
    description: 'Reversals reveal disowned emotions, avoided needs, or unconscious habits surfacing for healing and wholeness.',
    guidance: 'Name the hidden feeling, show how it can be witnessed safely, and suggest a micro-practice for reintegration.',
    examples: {
      'The Moon': 'Anxiety eases when you name the fear aloud and create grounding rituals; try writing it down each morning.',
      'Five of Swords': 'Step out of zero-sum thinking by repairing the belief that conflict automatically equals abandonment.',
      'The Tower': 'Resistance to change reveals fear of losing control; acknowledge the grief of letting go as a first step.',
      'The Devil': 'An attachment you judge in yourself deserves compassion; get curious about what need it serves.'
    }
  },
  mirror: {
    name: 'Mirror / Reflection',
    description: 'Reversed cards reflect back what the querent is projecting outward, highlighting unconscious behavior or energy.',
    guidance: 'Ask what aspect of this energy you might be unconsciously expressing, attracting, or projecting onto others.',
    examples: {
      'The Emperor': 'Where might you be overly controlling or rigid without realizing it?',
      'Queen of Cups': 'Are you suppressing your emotional needs while focusing on caring for others?',
      'Knight of Swords': 'Is your mental intensity coming across as aggression to those around you?',
      'The Hermit': 'Are you isolating yourself in ways that others perceive as withdrawal or judgment?'
    }
  },
  potentialBlocked: {
    name: 'Unrealized Potential',
    description: 'Reversed cards show latent gifts, strengths, or capacities that have not yet been activated, claimed, or developed.',
    guidance: 'Treat each reversal as a dormant strength awaiting conscious cultivation and ask what would help this energy emerge fully.',
    examples: {
      'The Magician': 'You have the tools and skills; what belief or circumstance is preventing you from using them fully?',
      'Eight of Pentacles': 'A talent exists that you have not invested time in developing yet; what would daily practice look like?',
      'The Star': 'Hope and inspiration are available but not yet accessed; what would help you reconnect with your vision?',
      'Ace of Wands': 'Creative fire is present but has not been channeled; what outlet would let it take form?'
    }
  }
};

/**
 * Get reversal framework description object
 *
 * @param {string} framework - Framework key
 * @returns {Object} Framework definition
 */
function getReversalFrameworkDescription(framework) {
  return REVERSAL_FRAMEWORKS[framework] || REVERSAL_FRAMEWORKS.contextual;
}

/**
 * Get description of suit focus
 *
 * @param {Object} params - Suit entry data
 * @param {Array} params.top - [suitName, count] for dominant suit
 * @param {Array} params.second - [suitName, count] for second suit
 * @returns {string|null} Description or null if no clear focus
 */
function getSuitFocusDescription({ top, second }) {
  const [topSuit, topCount] = top || [null, 0];
  const [secondSuit, secondCount] = second || [null, 0];

  if (!topSuit || topCount < 2) return null;

  if (topCount === secondCount && topCount > 1 && secondSuit) {
    return `Balanced focus between ${topSuit} and ${secondSuit}, each surfacing ${topCount} times.`;
  }

  const descriptions = {
    Wands: `${topCount} Wands cards suggest a strong focus on action, creativity, passion, drive, and personal will.`,
    Cups: `${topCount} Cups cards indicate emotional matters, relationships, intuition, and heart-centered concerns are central to this reading.`,
    Swords: `${topCount} Swords cards point to mental processes, communication, truth-seeking, conflict resolution, and clarity of thought as key themes.`,
    Pentacles: `${topCount} Pentacles cards highlight practical matters, material resources, work, physical health, and tangible results.`
  };

  return descriptions[topSuit] || null;
}

/**
 * Get description of elemental balance with Major Arcana awareness
 *
 * @param {Object} params - Analysis parameters
 * @param {Object} params.elementCounts - Element count map
 * @param {number} params.totalCards - Total card count
 * @param {number} params.majorRatio - Ratio of Major Arcana cards
 * @returns {string} Elemental balance description
 */
function getMajorAwareElementalBalanceDescription({ elementCounts, totalCards, majorRatio }) {
  if (majorRatio > 0.8) {
    return 'Archetypal energies dominate, transcending elemental themes.';
  }

  return getElementalBalanceDescription(elementCounts, totalCards);
}

/**
 * Get description of elemental balance
 *
 * @param {Object} elementCounts - Element count map
 * @param {number} total - Total card count
 * @returns {string} Elemental balance description
 */
function getElementalBalanceDescription(elementCounts, total) {
  if (total === 0) return 'No elemental data available.';

  const active = Object.entries(elementCounts)
    .filter(([, count]) => count > 0)
    .sort((a, b) => b[1] - a[1]);

  if (active.length === 0) return 'Balanced elemental presence.';
  if (active.length === 1) return `Strong ${active[0][0]} emphasis dominates this reading.`;

  const [dominant] = active;
  const ratio = dominant[1] / total;

  if (ratio >= 0.5) {
    return `${dominant[0]} energy strongly dominates (${dominant[1]}/${total} cards), requiring attention to balance with other elements.`;
  }

  if (ratio >= 0.35) {
    return `${dominant[0]} leads (${dominant[1]}/${total}), with ${active.slice(1).map(([e, c]) => `${e} (${c})`).join(', ')} providing supporting or contrasting energies.`;
  }

  return `Mixed elemental energies: ${active.map(([e, c]) => `${e} (${c})`).join(', ')}.`;
}

/**
 * Get description of Major Arcana density
 *
 * @param {number} ratio - Ratio of Major Arcana cards (0-1)
 * @returns {string} Archetype level description
 */
function getArchetypeDescription(ratio) {
  if (ratio >= 0.5) {
    return 'High Major Arcana presence indicates profound, soul-level themes, karmic patterns, and significant life transitions.';
  }
  if (ratio >= 0.3) {
    return 'Moderate Major Arcana suggests important archetypal lessons woven through everyday matters.';
  }
  return 'Primarily Minor Arcana, focusing on practical, day-to-day dynamics and immediate concerns.';
}

/**
 * Get lifecycle stage based on average card number
 *
 * @param {number|null} avgNumber - Average card number
 * @returns {string|null} Lifecycle stage description or null
 */
function getLifecycleStage(avgNumber) {
  if (avgNumber === null || typeof avgNumber !== 'number') return null;
  if (avgNumber <= 7) return 'new cycles, initiative, fresh beginnings, and reclaiming agency';
  if (avgNumber <= 14) return 'integration, balance, working through challenges, and staying centered amidst change';
  return 'culmination, mastery, completion, and preparing to release what is finished';
}

/* ==========================================================================
 * CELTIC CROSS SPECIFIC ANALYSIS
 *
 * Analyzes the unique position relationships in the Celtic Cross spread:
 * - Nucleus (Cards 1-2): Heart of the matter
 * - Timeline (Cards 3-1-4): Past → Present → Future
 * - Consciousness (Cards 6-1-5): Subconscious → Present → Conscious
 * - Staff (Cards 7-10): Self, External, Hopes/Fears, Outcome
 * - Cross-checks between key positions
 * ========================================================================== */

/**
 * Analyze a Celtic Cross spread
 *
 * @param {Array} cardsInfo - Array of 10 card objects
 * @returns {Object|null} Celtic Cross analysis or null if invalid input
 */
export function analyzeCelticCross(cardsInfo) {
  if (!Array.isArray(cardsInfo) || cardsInfo.length !== 10) {
    return null;
  }

  // Validate all cards exist
  for (let i = 0; i < 10; i++) {
    if (!cardsInfo[i]) return null;
  }

  const nucleus = analyzeNucleus(cardsInfo[0], cardsInfo[1]);
  const timeline = analyzeTimeline(cardsInfo[2], cardsInfo[0], cardsInfo[3]);
  const consciousness = analyzeConsciousness(cardsInfo[5], cardsInfo[0], cardsInfo[4]);
  const staff = analyzeStaff(cardsInfo[6], cardsInfo[7], cardsInfo[8], cardsInfo[9]);

  const crossChecks = {
    goalVsOutcome: comparePositions(
      cardsInfo[4], cardsInfo[9],
      'Conscious Goal (Above)', 'Outcome (Final)'
    ),
    adviceVsOutcome: comparePositions(
      cardsInfo[6], cardsInfo[9],
      'Self/Advice', 'Outcome'
    ),
    subconsciousVsHopesFears: comparePositions(
      cardsInfo[5], cardsInfo[8],
      'Subconscious (Below)', 'Hopes & Fears'
    ),
    nearFutureVsOutcome: comparePositions(
      cardsInfo[3], cardsInfo[9],
      'Near Future', 'Outcome'
    )
  };

  return {
    version: '1.0.0',
    spreadKey: 'celtic',
    themes: null, // Filled by performSpreadAnalysis; kept for normalized shape parity
    relationships: [
      {
        type: 'nucleus',
        summary: nucleus.synthesis,
        positions: [0, 1],
        cards: [nucleus.present, nucleus.challenge]
      },
      {
        type: 'timeline',
        summary: timeline.causality,
        positions: [2, 0, 3],
        cards: [
          { card: timeline.flow.past },
          { card: timeline.flow.present },
          { card: timeline.flow.future }
        ]
      },
      {
        type: 'consciousness-axis',
        axis: 'Subconscious ↔ Conscious',
        summary: consciousness.synthesis,
        positions: [5, 4],
        cards: [consciousness.subconscious, consciousness.conscious]
      },
      {
        type: 'staff-axis',
        axis: 'Self/Advice ↔ Outcome',
        summary: staff.adviceImpact,
        positions: [6, 9],
        cards: [staff.self, staff.outcome]
      },
      {
        type: 'cross-check',
        key: 'goalVsOutcome',
        summary: buildCrossCheckSummary(crossChecks.goalVsOutcome),
        alignmentType: crossChecks.goalVsOutcome.alignmentType,
        elementalRelationship: crossChecks.goalVsOutcome.elementalRelationship,
        orientationAlignment: crossChecks.goalVsOutcome.orientationAlignment,
        cards: [crossChecks.goalVsOutcome.position1, crossChecks.goalVsOutcome.position2]
      },
      {
        type: 'cross-check',
        key: 'adviceVsOutcome',
        summary: buildCrossCheckSummary(crossChecks.adviceVsOutcome),
        alignmentType: crossChecks.adviceVsOutcome.alignmentType,
        elementalRelationship: crossChecks.adviceVsOutcome.elementalRelationship,
        orientationAlignment: crossChecks.adviceVsOutcome.orientationAlignment,
        cards: [crossChecks.adviceVsOutcome.position1, crossChecks.adviceVsOutcome.position2]
      },
      {
        type: 'cross-check',
        key: 'subconsciousVsHopesFears',
        summary: buildCrossCheckSummary(crossChecks.subconsciousVsHopesFears),
        alignmentType: crossChecks.subconsciousVsHopesFears.alignmentType,
        elementalRelationship: crossChecks.subconsciousVsHopesFears.elementalRelationship,
        orientationAlignment: crossChecks.subconsciousVsHopesFears.orientationAlignment,
        cards: [
          crossChecks.subconsciousVsHopesFears.position1,
          crossChecks.subconsciousVsHopesFears.position2
        ]
      },
      {
        type: 'cross-check',
        key: 'nearFutureVsOutcome',
        summary: buildCrossCheckSummary(crossChecks.nearFutureVsOutcome),
        alignmentType: crossChecks.nearFutureVsOutcome.alignmentType,
        elementalRelationship: crossChecks.nearFutureVsOutcome.elementalRelationship,
        orientationAlignment: crossChecks.nearFutureVsOutcome.orientationAlignment,
        cards: [
          crossChecks.nearFutureVsOutcome.position1,
          crossChecks.nearFutureVsOutcome.position2
        ]
      }
    ],
    positionNotes: [
      {
        index: 0,
        label: 'Present',
        notes: ['Core situation; anchor for nucleus and all axes.']
      },
      {
        index: 1,
        label: 'Challenge',
        notes: ['Crossing tension; always read as obstacle to integrate.']
      },
      {
        index: 2,
        label: 'Past',
        notes: ['Foundation feeding into present in the timeline.']
      },
      {
        index: 3,
        label: 'Near Future',
        notes: ['Next chapter, cross-checked against Outcome.']
      },
      {
        index: 4,
        label: 'Conscious',
        notes: ['Stated goals; cross-check with Outcome.']
      },
      {
        index: 5,
        label: 'Subconscious',
        notes: ['Hidden drivers; cross-check with Hopes & Fears.']
      },
      {
        index: 6,
        label: 'Self / Advice',
        notes: ['Active guidance; cross-check with Outcome.']
      },
      {
        index: 7,
        label: 'External',
        notes: ['Environment and others; context, not command.']
      },
      {
        index: 8,
        label: 'Hopes & Fears',
        notes: ['Mixed desires/anxieties; mirrored with Subconscious.']
      },
      {
        index: 9,
        label: 'Outcome',
        notes: ['Trajectory if unchanged; never deterministic.']
      }
    ],
    // Raw components preserved for narrativeBuilder and any future consumers
    nucleus,
    timeline,
    consciousness,
    staff,
    crossChecks
  };
}

/**
 * Analyze the nucleus (Cards 1-2) - the heart of the matter
 *
 * @param {Object} present - Present position card
 * @param {Object} challenge - Challenge/crossing card
 * @returns {Object} Nucleus analysis
 */
function analyzeNucleus(present, challenge) {
  const elemental = analyzeElementalDignity(present, challenge);

  let synthesis;
  switch (elemental.relationship) {
    case 'supportive':
      synthesis = `The energies of ${present.card} and ${challenge.card} can work together constructively once the challenge is integrated.`;
      break;
    case 'tension':
      synthesis = `${present.card} and ${challenge.card} create friction between present state and challenge, requiring careful balance.`;
      break;
    case 'amplified':
      synthesis = `Both cards share ${elemental.element} energy, intensifying this theme at the heart of the matter.`;
      break;
    case 'neutral':
    default:
      synthesis = `${present.card} represents where you stand, while ${challenge.card} crosses as the immediate obstacle.`;
  }

  return {
    theme: 'The Heart of the Matter (Nucleus)',
    present: {
      card: present.card,
      orientation: present.orientation,
      meaning: present.meaning
    },
    challenge: {
      card: challenge.card,
      orientation: challenge.orientation,
      meaning: challenge.meaning
    },
    elementalDynamic: elemental,
    synthesis
  };
}

/**
 * Analyze the timeline (Cards 3-1-4) - past, present, future flow
 *
 * @param {Object} past - Past position card
 * @param {Object} present - Present position card
 * @param {Object} future - Future position card
 * @returns {Object} Timeline analysis
 */
function analyzeTimeline(past, present, future) {
  const pastToPresent = analyzeElementalDignity(past, present);
  const presentToFuture = analyzeElementalDignity(present, future);
  const pastToFuture = analyzeElementalDignity(past, future);

  let causality = `${past.card} in the past has led to ${present.card} in the present.`;

  if (pastToPresent.relationship === 'tension') {
    causality += ` The transition from past to present involved friction and adjustment.`;
  } else if (pastToPresent.relationship === 'supportive') {
    causality += ` The past supports and flows naturally into the present state.`;
  } else if (pastToPresent.relationship === 'amplified') {
    causality += ` The same elemental theme persists from past into present.`;
  }

  causality += ` This is developing toward ${future.card} in the near future.`;

  if (presentToFuture.relationship === 'tension') {
    causality += ` Moving forward will require navigating elemental tension.`;
  } else if (presentToFuture.relationship === 'supportive') {
    causality += ` The trajectory ahead is supported by current energies.`;
  } else if (presentToFuture.relationship === 'amplified') {
    causality += ` The elemental energy intensifies as you move forward.`;
  }

  return {
    theme: 'The Timeline',
    flow: {
      past: past.card,
      present: present.card,
      future: future.card
    },
    causality,
    pastToPresent,
    presentToFuture,
    pastToFuture
  };
}

/**
 * Analyze consciousness flow (Cards 6-1-5) - below, center, above
 *
 * @param {Object} subconscious - Subconscious position card
 * @param {Object} present - Present position card
 * @param {Object} conscious - Conscious position card
 * @returns {Object} Consciousness analysis
 */
function analyzeConsciousness(subconscious, present, conscious) {
  const belowToAbove = analyzeElementalDignity(subconscious, conscious);

  let alignment;
  switch (belowToAbove.relationship) {
    case 'supportive':
      alignment = 'aligned';
      break;
    case 'tension':
      alignment = 'conflicted';
      break;
    case 'amplified':
      alignment = 'intensely unified';
      break;
    default:
      alignment = 'complex';
  }

  let synthesis = `Hidden beneath awareness: ${subconscious.card} ${subconscious.orientation}. `;
  synthesis += `Conscious goal or aspiration: ${conscious.card} ${conscious.orientation}. `;

  switch (alignment) {
    case 'aligned':
      synthesis += `Your subconscious drives and conscious goals are working together harmoniously.`;
      break;
    case 'conflicted':
      synthesis += `There is tension between what you want consciously and what drives you beneath awareness. Integration is needed.`;
      break;
    case 'intensely unified':
      synthesis += `Your inner depths and conscious mind are unified around the same ${belowToAbove.element} theme.`;
      break;
    default:
      synthesis += `Your inner and outer goals show nuanced dynamics worth exploring.`;
  }

  return {
    theme: 'Consciousness Flow (Vertical Axis)',
    alignment,
    subconscious: {
      card: subconscious.card,
      orientation: subconscious.orientation
    },
    conscious: {
      card: conscious.card,
      orientation: conscious.orientation
    },
    elementalRelationship: belowToAbove,
    synthesis
  };
}

/**
 * Analyze the staff (Cards 7-10) - self, external, hopes/fears, outcome
 *
 * @param {Object} self - Self/Advice position card
 * @param {Object} external - External influences card
 * @param {Object} hopesFears - Hopes & Fears card
 * @param {Object} outcome - Outcome card
 * @returns {Object} Staff analysis
 */
function analyzeStaff(self, external, hopesFears, outcome) {
  const adviceToOutcome = analyzeElementalDignity(self, outcome);

  let adviceImpact;
  switch (adviceToOutcome.relationship) {
    case 'supportive':
      adviceImpact = `Following the guidance of ${self.card} actively supports and harmonizes with the likely outcome of ${outcome.card}.`;
      break;
    case 'tension':
      adviceImpact = `Acting on ${self.card} creates dynamic tension with the trajectory toward ${outcome.card}, requiring skillful navigation.`;
      break;
    case 'amplified':
      adviceImpact = `The advice (${self.card}) and outcome (${outcome.card}) share the same ${adviceToOutcome.element} energy, creating a unified path forward.`;
      break;
    default:
      adviceImpact = `The relationship between the advice of ${self.card} and the outcome shows subtle complexity.`;
  }

  return {
    theme: 'The Staff (Context and Trajectory)',
    self: {
      card: self.card,
      orientation: self.orientation
    },
    external: {
      card: external.card,
      orientation: external.orientation
    },
    hopesFears: {
      card: hopesFears.card,
      orientation: hopesFears.orientation
    },
    outcome: {
      card: outcome.card,
      orientation: outcome.orientation
    },
    adviceToOutcome,
    adviceImpact
  };
}

/**
 * Determine alignment type based on elemental relationship and orientation
 *
 * @param {Object} elemental - Elemental relationship object from analyzeElementalDignity
 * @param {boolean} orientationMatch - Whether both cards share the same orientation
 * @returns {string} Alignment type: 'unified' | 'harmonious' | 'evolving-support' |
 *                   'parallel-tension' | 'dynamic-shift' | 'complex'
 */
function determineAlignmentType(elemental, orientationMatch) {
  if (!elemental) return 'complex';

  switch (elemental.relationship) {
    case 'amplified':
      return 'unified';
    case 'supportive':
      return orientationMatch ? 'harmonious' : 'evolving-support';
    case 'tension':
      return orientationMatch ? 'parallel-tension' : 'dynamic-shift';
    default:
      return 'complex';
  }
}

/**
 * Generate summary prose for cross-check relationships
 * Used to populate the summary field needed by UI highlights
 *
 * @param {Object} crossCheck - Cross-check comparison result
 * @returns {string} Summary prose
 */
function buildCrossCheckSummary(crossCheck) {
  if (!crossCheck || !crossCheck.position1 || !crossCheck.position2) {
    return 'Unable to compare these positions.';
  }

  const { position1, position2, elementalRelationship, alignmentType } = crossCheck;

  let summary = `${position1.name} (${position1.card} ${position1.orientation}) compared to ${position2.name} (${position2.card} ${position2.orientation}): `;

  // Add elemental description if available
  if (elementalRelationship?.description) {
    summary += elementalRelationship.description + ' ';
  }

  // Add alignment-based insight
  const alignmentInsights = {
    'unified': 'Both positions share the same elemental theme, creating unified energy.',
    'harmonious': 'These positions support each other harmoniously.',
    'evolving-support': 'Supportive flow suggests evolution between these positions.',
    'parallel-tension': 'Both hold tension in the same direction.',
    'dynamic-shift': 'Different orientations signal a transformative shift.',
    'complex': 'These positions show nuanced interplay.'
  };

  summary += alignmentInsights[alignmentType] || 'These positions relate in subtle ways.';

  return summary;
}

/**
 * Compare two position cards for cross-checks
 *
 * Returns structured data only - prose generation handled by narrative builder.
 * This eliminates redundant synthesis text and centralizes narrative logic.
 *
 * @param {Object} card1 - First card object
 * @param {Object} card2 - Second card object
 * @param {string} pos1Name - First position name
 * @param {string} pos2Name - Second position name
 * @returns {Object} Comparison result with elemental and orientation data
 */
function comparePositions(card1, card2, pos1Name, pos2Name) {
  if (!card1 || !card2) {
    return {
      position1: { name: pos1Name, card: null, orientation: null, meaning: null },
      position2: { name: pos2Name, card: null, orientation: null, meaning: null },
      elementalRelationship: null,
      orientationAlignment: false,
      alignmentType: 'complex'
    };
  }

  const elemental = analyzeElementalDignity(card1, card2);
  const orientationMatch = card1.orientation === card2.orientation;

  return {
    position1: {
      name: pos1Name,
      card: card1.card,
      orientation: card1.orientation,
      meaning: card1.meaning
    },
    position2: {
      name: pos2Name,
      card: card2.card,
      orientation: card2.orientation,
      meaning: card2.meaning
    },
    elementalRelationship: elemental,
    orientationAlignment: orientationMatch,
    alignmentType: determineAlignmentType(elemental, orientationMatch)
  };
}

/* ==========================================================================
 * THREE-CARD ANALYSIS
 *
 * Analyzes Past-Present-Future or Situation-Challenge-Advice patterns
 * ========================================================================== */

/**
 * Analyze a three-card spread
 *
 * @param {Array} cardsInfo - Array of 3 card objects
 * @returns {Object|null} Three-card analysis or null if invalid input
 */
export function analyzeThreeCard(cardsInfo) {
  if (!Array.isArray(cardsInfo) || cardsInfo.length !== 3) {
    return null;
  }

  const [first, second, third] = cardsInfo;

  if (!first || !second || !third) {
    return null;
  }

  // Analyze the causal flow
  const firstToSecond = analyzeElementalDignity(first, second);
  const secondToThird = analyzeElementalDignity(second, third);
  const firstToThird = analyzeElementalDignity(first, third);

  const narrative = buildThreeCardNarrative(first, second, third, firstToSecond, secondToThird);

  return {
    version: '1.0.0',
    spreadKey: 'threeCard',
    relationships: [
      {
        type: 'sequence',
        summary: narrative,
        positions: [0, 1, 2],
        cards: [
          { card: first.card, orientation: first.orientation },
          { card: second.card, orientation: second.orientation },
          { card: third.card, orientation: third.orientation }
        ]
      }
    ],
    positionNotes: [
      { index: 0, label: 'Past', notes: ['Foundation / cause.'] },
      { index: 1, label: 'Present', notes: ['Current state shaped by past.'] },
      { index: 2, label: 'Future', notes: ['Trajectory if nothing shifts.'] }
    ],
    flow: {
      first: first.card,
      second: second.card,
      third: third.card
    },
    transitions: {
      firstToSecond,
      secondToThird,
      firstToThird
    },
    narrative
  };
}

/**
 * Build narrative prose for three-card spread
 *
 * @param {Object} first - First card
 * @param {Object} second - Second card
 * @param {Object} third - Third card
 * @param {Object} trans1 - First to second transition analysis
 * @param {Object} trans2 - Second to third transition analysis
 * @returns {string} Narrative prose
 */
function buildThreeCardNarrative(first, second, third, trans1, trans2) {
  let narrative = `The story unfolds from ${first.card} through ${second.card} to ${third.card}. `;

  if (trans1.relationship === 'supportive') {
    narrative += `The transition from first to second position is harmonious. `;
  } else if (trans1.relationship === 'tension') {
    narrative += `The move from first to second involves friction that shapes the narrative. `;
  } else if (trans1.relationship === 'amplified') {
    narrative += `The same elemental energy intensifies from first to second position. `;
  }

  if (trans2.relationship === 'supportive') {
    narrative += `The path forward from second to third is well-supported.`;
  } else if (trans2.relationship === 'tension') {
    narrative += `Reaching the third position will require navigating dynamic tension.`;
  } else if (trans2.relationship === 'amplified') {
    narrative += `The elemental theme continues to build toward the third position.`;
  }

  return narrative;
}

/* ==========================================================================
 * FIVE-CARD ANALYSIS
 *
 * Analyzes the five-card clarity spread structure
 * ========================================================================== */

/**
 * Analyze a five-card spread
 *
 * @param {Array} cardsInfo - Array of 5 card objects
 * @returns {Object|null} Five-card analysis or null if invalid input
 */
export function analyzeFiveCard(cardsInfo) {
  if (!Array.isArray(cardsInfo) || cardsInfo.length !== 5) {
    return null;
  }

  // Validate all cards exist
  for (let i = 0; i < 5; i++) {
    if (!cardsInfo[i]) return null;
  }

  // Core vs Challenge
  const coreVsChallenge = analyzeElementalDignity(cardsInfo[0], cardsInfo[1]);

  // Support vs Direction
  const supportVsDirection = analyzeElementalDignity(cardsInfo[3], cardsInfo[4]);

  const synthesis = `The core matter (${cardsInfo[0].card}) faces the challenge of ${cardsInfo[1].card}. Support comes through ${cardsInfo[3].card}, pointing toward ${cardsInfo[4].card} as the likely direction.`;

  return {
    version: '1.0.0',
    spreadKey: 'fiveCard',
    relationships: [
      {
        type: 'axis',
        axis: 'Core vs Challenge',
        summary:
          coreVsChallenge.description ||
          'Tension or harmony between core and challenge frames the heart of this spread.',
        positions: [0, 1],
        cards: [
          { card: cardsInfo[0].card, orientation: cardsInfo[0].orientation },
          { card: cardsInfo[1].card, orientation: cardsInfo[1].orientation }
        ]
      },
      {
        type: 'axis',
        axis: 'Support vs Direction',
        summary:
          supportVsDirection.description ||
          'Supportive energies shape how the likely direction can be navigated.',
        positions: [3, 4],
        cards: [
          { card: cardsInfo[3].card, orientation: cardsInfo[3].orientation },
          { card: cardsInfo[4].card, orientation: cardsInfo[4].orientation }
        ]
      }
    ],
    positionNotes: [
      { index: 0, label: 'Core', notes: ['Central issue.'] },
      { index: 1, label: 'Challenge', notes: ['Obstacle / friction.'] },
      { index: 2, label: 'Hidden', notes: ['Subconscious / unseen influence.'] },
      { index: 3, label: 'Support', notes: ['Helpful energy / allies.'] },
      { index: 4, label: 'Direction', notes: ['Likely direction on current path.'] }
    ],
    coreVsChallenge,
    supportVsDirection,
    synthesis
  };
}

/* ==========================================================================
 * RELATIONSHIP SNAPSHOT ANALYSIS
 *
 * Maps the interplay between You ↔ Them and the shared Connection card.
 * ========================================================================== */

/**
 * Analyze a relationship spread
 *
 * @param {Array} cardsInfo - Array of 3+ card objects (You, Them, Connection)
 * @returns {Object|null} Relationship analysis or null if invalid input
 */
export function analyzeRelationship(cardsInfo) {
  if (!Array.isArray(cardsInfo) || cardsInfo.length < 3) {
    return null;
  }

  const [you, them, connection] = cardsInfo;
  if (!you || !them || !connection) {
    return null;
  }

  const youLabel = you.position || 'You / your energy';
  const themLabel = them.position || 'Them / their energy';
  const _connectionLabel = connection.position || 'The connection / shared lesson';

  const youVsThem = comparePositions(you, them, youLabel, themLabel);
  const youBridge = analyzeElementalDignity(connection, you);
  const themBridge = analyzeElementalDignity(connection, them);

  const connectionSummaryParts = [
    `${connection.card} ${connection.orientation} anchors the shared lesson between you.`,
    connection.meaning ? connection.meaning : null,
    youBridge?.description ? `With your card, ${youBridge.description}.` : null,
    themBridge?.description ? `With their card, ${themBridge.description}.` : null
  ].filter(Boolean);

  const relationships = [];

  if (youVsThem) {
    // Generate summary from structured data
    let summary = `${youLabel} (${you.card} ${you.orientation}) and ${themLabel} (${them.card} ${them.orientation}): `;

    if (youVsThem.elementalRelationship?.description) {
      summary += youVsThem.elementalRelationship.description;
    } else {
      switch (youVsThem.alignmentType) {
        case 'unified':
          summary += `The dynamic between you resonates with shared energy.`;
          break;
        case 'harmonious':
          summary += `The dynamic between you flows harmoniously.`;
          break;
        default:
          summary += `The dynamic between you holds creative tension.`;
      }
    }

    relationships.push({
      type: 'axis',
      axis: 'You ↔ Them',
      summary,
      positions: [0, 1],
      cards: [
        { card: you.card, orientation: you.orientation },
        { card: them.card, orientation: them.orientation }
      ],
      elementalRelationship: youVsThem.elementalRelationship,
      alignmentType: youVsThem.alignmentType
    });
  }

  relationships.push({
    type: 'connection',
    summary:
      connectionSummaryParts.join(' ') ||
      `${connection.card} illustrates the shared energy in this connection.`,
    positions: [2],
    cards: [{ card: connection.card, orientation: connection.orientation }],
    bridges: {
      toYou: youBridge,
      toThem: themBridge
    }
  });

  return {
    version: '1.0.0',
    spreadKey: 'relationship',
    relationships,
    positionNotes: [
      { index: 0, label: 'You / your energy', notes: ['How you are currently showing up.'] },
      { index: 1, label: 'Them / their energy', notes: ['How they are approaching the connection.'] },
      { index: 2, label: 'The connection / shared lesson', notes: ['The third energy between you—what the bond is asking from both sides.'] }
    ],
    dyad: {
      you: { card: you.card, orientation: you.orientation },
      them: { card: them.card, orientation: them.orientation },
      elementalRelationship: youVsThem?.elementalRelationship
    },
    connection: {
      card: connection.card,
      orientation: connection.orientation,
      meaning: connection.meaning,
      bridges: {
        toYou: youBridge,
        toThem: themBridge
      }
    }
  };
}

/* ==========================================================================
 * DECISION / TWO-PATH ANALYSIS
 *
 * Compares Path A vs Path B with respect to the heart of the decision
 * and synthesizes clarifier + free-will guidance.
 * ========================================================================== */

/**
 * Analyze a decision/two-path spread
 *
 * @param {Array} cardsInfo - Array of 5 card objects (Heart, PathA, PathB, Clarifier, FreeWill)
 * @returns {Object|null} Decision analysis or null if invalid input
 */
export function analyzeDecision(cardsInfo) {
  if (!Array.isArray(cardsInfo) || cardsInfo.length !== 5) {
    return null;
  }

  const [heart, pathA, pathB, clarifier, freeWill] = cardsInfo;
  if (!heart || !pathA || !pathB) {
    return null;
  }

  const heartLabel = heart.position || 'Heart of the decision';
  const pathALabel = pathA.position || 'Path A — energy & likely outcome';
  const pathBLabel = pathB.position || 'Path B — energy & likely outcome';
  const clarifierLabel = clarifier?.position || 'What clarifies the best path';
  const freeWillLabel = freeWill?.position || 'What to remember about your free will';

  const heartVsA = comparePositions(heart, pathA, heartLabel, pathALabel);
  const heartVsB = comparePositions(heart, pathB, heartLabel, pathBLabel);
  const pathAVsB = comparePositions(pathA, pathB, pathALabel, pathBLabel);

  const relationships = [];

  if (heartVsA) {
    // Generate summary from structured data
    let summary = `${heartLabel} (${heart.card} ${heart.orientation}) and ${pathALabel} (${pathA.card} ${pathA.orientation}): `;

    if (heartVsA.elementalRelationship?.description) {
      summary += heartVsA.elementalRelationship.description;
    } else {
      switch (heartVsA.alignmentType) {
        case 'unified':
          summary += `This path strongly aligns with your core values.`;
          break;
        case 'harmonious':
          summary += `This path supports your core values.`;
          break;
        default:
          summary += `This path creates complexity with your core values.`;
      }
    }

    relationships.push({
      type: 'axis',
      axis: 'Heart ↔ Path A',
      summary,
      positions: [0, 1],
      cards: [
        { card: heart.card, orientation: heart.orientation },
        { card: pathA.card, orientation: pathA.orientation }
      ],
      elementalRelationship: heartVsA.elementalRelationship,
      alignmentType: heartVsA.alignmentType
    });
  }

  if (heartVsB) {
    // Generate summary from structured data
    let summary = `${heartLabel} (${heart.card} ${heart.orientation}) and ${pathBLabel} (${pathB.card} ${pathB.orientation}): `;

    if (heartVsB.elementalRelationship?.description) {
      summary += heartVsB.elementalRelationship.description;
    } else {
      switch (heartVsB.alignmentType) {
        case 'unified':
          summary += `This path strongly aligns with your core values.`;
          break;
        case 'harmonious':
          summary += `This path supports your core values.`;
          break;
        default:
          summary += `This path creates complexity with your core values.`;
      }
    }

    relationships.push({
      type: 'axis',
      axis: 'Heart ↔ Path B',
      summary,
      positions: [0, 2],
      cards: [
        { card: heart.card, orientation: heart.orientation },
        { card: pathB.card, orientation: pathB.orientation }
      ],
      elementalRelationship: heartVsB.elementalRelationship,
      alignmentType: heartVsB.alignmentType
    });
  }

  if (pathAVsB) {
    // Generate summary from structured data
    let summary = `${pathALabel} (${pathA.card} ${pathA.orientation}) and ${pathBLabel} (${pathB.card} ${pathB.orientation}): `;

    if (pathAVsB.elementalRelationship?.description) {
      summary += pathAVsB.elementalRelationship.description;
    } else {
      if (pathAVsB.alignmentType === 'unified') {
        summary += `These paths share similar energies.`;
      } else if (pathAVsB.alignmentType === 'parallel-tension' || pathAVsB.alignmentType === 'dynamic-shift') {
        summary += `These paths contrast with each other.`;
      } else {
        summary += `These paths offer different approaches.`;
      }
    }

    relationships.push({
      type: 'axis',
      axis: 'Path A ↔ Path B',
      summary,
      positions: [1, 2],
      cards: [
        { card: pathA.card, orientation: pathA.orientation },
        { card: pathB.card, orientation: pathB.orientation }
      ],
      elementalRelationship: pathAVsB.elementalRelationship,
      alignmentType: pathAVsB.alignmentType
    });
  }

  const guidanceSummary = buildDecisionGuidanceSummary(clarifier, clarifierLabel, freeWill, freeWillLabel);
  if (guidanceSummary) {
    const guidanceCards = [clarifier, freeWill].filter(Boolean).map(card => ({
      card: card.card,
      orientation: card.orientation
    }));
    const guidancePositions = [];
    if (clarifier) guidancePositions.push(3);
    if (freeWill) guidancePositions.push(4);

    relationships.push({
      type: 'sequence',
      summary: guidanceSummary,
      positions: guidancePositions,
      cards: guidanceCards
    });
  }

  return {
    version: '1.0.0',
    spreadKey: 'decision',
    relationships,
    positionNotes: [
      { index: 0, label: 'Heart of the decision', notes: ['Core desire or non-negotiable value.'] },
      { index: 1, label: 'Path A — energy & likely outcome', notes: ['Trajectory if you commit to Path A.'] },
      { index: 2, label: 'Path B — energy & likely outcome', notes: ['Trajectory if you commit to Path B.'] },
      { index: 3, label: 'What clarifies the best path', notes: ['Insight that helps you evaluate the options.'] },
      { index: 4, label: 'What to remember about your free will', notes: ['Agency reminder; how you shape the outcome.'] }
    ],
    comparisons: {
      heartVsA,
      heartVsB,
      pathAVsB
    },
    guidance: {
      clarifier: clarifier ? { card: clarifier.card, orientation: clarifier.orientation } : null,
      freeWill: freeWill ? { card: freeWill.card, orientation: freeWill.orientation } : null
    }
  };
}

/**
 * Build guidance summary for decision spread
 *
 * @param {Object|null} clarifier - Clarifier card object
 * @param {string} clarifierLabel - Clarifier position label
 * @param {Object|null} freeWill - Free will card object
 * @param {string} freeWillLabel - Free will position label
 * @returns {string|null} Guidance summary prose or null
 */
function buildDecisionGuidanceSummary(clarifier, clarifierLabel, freeWill, freeWillLabel) {
  const parts = [];

  if (clarifier) {
    parts.push(
      `${clarifierLabel}: ${clarifier.card} ${clarifier.orientation} explains what data point or reflection helps you compare the routes.`
    );
  }

  if (freeWill) {
    parts.push(
      `${freeWillLabel}: ${freeWill.card} ${freeWill.orientation} reminds you that your agency ultimately shapes how this plays out.`
    );
  }

  if (parts.length === 0) return null;

  if (clarifier && freeWill) {
    parts.push('Together they ask you to pair clear-eyed assessment with empowered choice.');
  }

  return parts.join(' ');
}
</file>

<file path="functions/lib/symbolAnnotations.js">
export { SYMBOL_ANNOTATIONS } from '../../shared/symbols/symbolAnnotations.js';
</file>

<file path="functions/lib/timingMeta.js">
/**
 * Timing Meta (Soft Trajectory Heuristics)
 *
 * Provides non-deterministic timing hints derived from traditional suit/rank associations.
 * Used to gently describe pacing/arc (shorter-term vs longer arc), never fixed dates.
 *
 * Design:
 * - Wands: fast, initiating, catalytic
 * - Swords: quick but volatile; mental pivots
 * - Cups: emotional/relational tempo; moderate
 * - Pentacles: slow, steady, infrastructural
 *
 * - Early pip ranks (Aces–4): near-term shifts; opening moves
 * - Mid ranks (5–9): developing processes
 * - Tens + some Majors: longer arcs / completion cycles
 *
 * Majors:
 * - Many function as multi-chapter arcs. We bias them toward "developing" or "longer arc",
 *   but keep language soft and contextual.
 */

const FAST_SUITS = new Set(['Wands', 'Swords']);
const SLOW_SUITS = new Set(['Pentacles']);
const MID_SUITS = new Set(['Cups']);

function getSuitSpeedWeight(suit) {
  if (FAST_SUITS.has(suit)) return 1;          // leans sooner
  if (MID_SUITS.has(suit)) return 0;          // neutral
  if (SLOW_SUITS.has(suit)) return -1;        // leans longer
  return 0;
}

function getRankTempoWeight(rankValue) {
  if (typeof rankValue !== 'number') return 0;
  if (rankValue >= 1 && rankValue <= 4) return 1;   // earlier phase
  if (rankValue >= 5 && rankValue <= 9) return 0;   // mid-phase
  if (rankValue >= 10) return -1;              // culmination / slower arc
  return 0;
}

function getMajorTimingWeight(number) {
  if (typeof number !== 'number') return 0;
  // Light-touch heuristic: early majors slightly "sooner", late majors "longer arc"
  if (number >= 0 && number <= 6) return 0;     // The Fool–Lovers: can break quickly, but still arcs
  if (number >= 7 && number <= 14) return -0.5;  // Chariot–Temperance: process journeys
  if (number >= 15) return -1;                  // Devil–World: extended structural cycles
  return 0;
}

/**
 * getTimingHintForCard(card)
 *
 * Returns one of:
 * - 'sooner'       → feels nearer-term / quicker to move
 * - 'developing'   → unfolding across a chapter; medium arc
 * - 'longer-arc'   → slow-burn, structural or long-integration theme
 * - null           → no clear signal
 *
 * Always for internal meta; narrative must phrase these as non-guaranteed trajectories.
 */
export function getTimingHintForCard(card = {}) {
  if (!card) return null;

  // Major Arcana
  if (typeof card.number === 'number' && card.number >= 0 && card.number <= 21) {
    const w = getMajorTimingWeight(card.number);
    if (w <= -1) return 'longer-arc';
    if (w < 0) return 'developing';
    return 'developing';
  }

  // Minors and other cards
  const suit = card.suit || inferSuitFromName(card.card);
  const suitWeight = getSuitSpeedWeight(suit);
  const rankWeight = getRankTempoWeight(card.rankValue);

  const total = suitWeight + rankWeight;

  if (total >= 2) return 'sooner';
  if (total >= 1) return 'sooner';
  if (total <= -2) return 'longer-arc';
  if (total <= -1) return 'longer-arc';

  // Neutral / ambiguous => treat as "developing" only if we have any structure
  if (suit || typeof card.rankValue === 'number') return 'developing';

  return null;
}

/**
 * getSpreadTimingProfile({ cardsInfo, themes })
 *
 * Aggregates card-level hints with soft logic:
 * - Focus on future / outcome positions when present.
 * - If clear bias emerges, return a profile string:
 *   - 'near-term-tilt'
 *   - 'developing-arc'
 *   - 'longer-arc-tilt'
 * Otherwise null.
 */
export function getSpreadTimingProfile({ cardsInfo = [], themes: _themes = {} } = {}) {
  if (!Array.isArray(cardsInfo) || cardsInfo.length === 0) return null;

  // Prefer labeled positions commonly used as trajectory indicators
  const namedFuturePositions = new Set([
    'Future — trajectory if nothing shifts',
    'Near Future — what lies before (Card 4)',
    'Likely direction on current path',
    'Outcome — likely path if unchanged (Card 10)',
    'Outcome / what this can become'
  ]);

  const focusCards = cardsInfo.filter(c => {
    const pos = (c.position || '').trim();
    return namedFuturePositions.has(pos);
  });

  const sample = focusCards.length > 0 ? focusCards : cardsInfo;

  let sooner = 0;
  let developing = 0;
  let longer = 0;

  for (const card of sample) {
    const hint = getTimingHintForCard(card);
    if (hint === 'sooner') sooner++;
    else if (hint === 'developing') developing++;
    else if (hint === 'longer-arc') longer++;
  }

  const total = sooner + developing + longer;
  if (!total) return null;

  // Soft thresholds; we only speak when there's a clear lean
  if (sooner / total >= 0.55 && sooner >= 2) {
    return 'near-term-tilt';
  }
  if (longer / total >= 0.55 && longer >= 2) {
    return 'longer-arc-tilt';
  }

  // Default: treat as chapter-based unfolding
  return 'developing-arc';
}

function inferSuitFromName(name) {
  if (typeof name !== 'string') return null;
  if (name.includes('Wands')) return 'Wands';
  if (name.includes('Cups')) return 'Cups';
  if (name.includes('Swords')) return 'Swords';
  if (name.includes('Pentacles')) return 'Pentacles';
  return null;
}
</file>

<file path="functions/lib/utils.js">
/**
 * Shared HTTP helpers for Cloudflare Pages Functions.
 * Avoids duplicating boilerplate across tarot-reading and TTS endpoints.
 */

/**
 * Safely parse a JSON body from a Request. Returns an empty object when the
 * payload is empty and throws when the body cannot be parsed.
 *
 * @param {Request} request
 * @returns {Promise<Record<string, any>>}
 */
export async function readJsonBody(request) {
  if (!request) return {};

  const contentLength = request.headers?.get('content-length');
  if (contentLength === '0') {
    return {};
  }

  const text = await request.text();
  if (!text) {
    return {};
  }

  try {
    return JSON.parse(text);
  } catch {
    throw new Error('Invalid JSON payload.');
  }
}

/**
 * JSON convenience wrapper for Cloudflare Responses.
 *
 * @param {unknown} data
 * @param {ResponseInit} [init]
 */
export function jsonResponse(data, init = {}) {
  return new Response(JSON.stringify(data), {
    ...init,
    headers: {
      'content-type': 'application/json; charset=utf-8',
      ...(init.headers || {})
    }
  });
}
</file>

<file path="functions/lib/visionLabels.js">
const DEFAULT_LABEL = 'uploaded-image';
export const MAX_VISION_LABEL_LENGTH = 80;

const CONTROL_CHARS_REGEX = /\p{Cc}/gu;
const MARKDOWN_META_REGEX = /[#*_`>|]/g;
const BRACKETS_REGEX = /[[\]{}<>]/g;
const UNSAFE_CHAR_REGEX = /[^\p{L}\p{N}\s.,!?:;\-–—_'"/\\&()]/gu;

function collapseWhitespace(value) {
    return value.replace(/\s+/g, ' ').trim();
}

export function normalizeVisionLabel(label, options = {}) {
    const fallback = options.fallback || DEFAULT_LABEL;
    const maxLength = typeof options.maxLength === 'number' && options.maxLength > 0
        ? options.maxLength
        : MAX_VISION_LABEL_LENGTH;

    if (typeof label !== 'string') {
        return fallback;
    }

    let sanitized = label;
    sanitized = sanitized.replace(CONTROL_CHARS_REGEX, ' ');
    sanitized = sanitized.replace(MARKDOWN_META_REGEX, ' ');
    sanitized = sanitized.replace(BRACKETS_REGEX, ' ');
    sanitized = collapseWhitespace(sanitized);

    if (!sanitized) {
        return fallback;
    }

    sanitized = sanitized.replace(UNSAFE_CHAR_REGEX, '');
    sanitized = collapseWhitespace(sanitized);

    if (!sanitized) {
        return fallback;
    }

    if (sanitized.length > maxLength) {
        sanitized = sanitized.slice(0, maxLength).trim();
    }

    return sanitized || fallback;
}

export function formatVisionLabelForPrompt(label, options = {}) {
    const safe = normalizeVisionLabel(label, options);
    // Escape any lingering markdown characters (should be removed already, but double-escape for safety)
    return safe.replace(/([*_`])/g, '').trim();
}
</file>

<file path="functions/lib/visionProof.js">
import { canonicalizeCardName } from '../../shared/vision/cardNameMapping.js';

const encoder = new TextEncoder();
const _decoder = typeof TextDecoder === 'function' ? new TextDecoder() : null;
const DEFAULT_TTL_MS = 5 * 60 * 1000; // 5 minutes
const MAX_INSIGHTS = 10;

function getSubtle() {
  if (globalThis.crypto?.subtle) {
    return globalThis.crypto.subtle;
  }
  if (globalThis.crypto?.webcrypto?.subtle) {
    return globalThis.crypto.webcrypto.subtle;
  }
  throw new Error('WebCrypto subtle API is not available in this environment.');
}

function toArrayBufferFromBase64(base64) {
  if (typeof Buffer !== 'undefined') {
    return Uint8Array.from(Buffer.from(base64, 'base64')).buffer;
  }
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i += 1) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}

function fromArrayBufferToBase64(buffer) {
  if (typeof Buffer !== 'undefined') {
    return Buffer.from(buffer).toString('base64');
  }
  const bytes = new Uint8Array(buffer);
  let binary = '';
  bytes.forEach((b) => {
    binary += String.fromCharCode(b);
  });
  return btoa(binary);
}

async function importHmacKey(secret) {
  if (!secret) {
    throw new Error('VISION_PROOF_SECRET is not configured.');
  }
  const subtle = getSubtle();
  return subtle.importKey(
    'raw',
    encoder.encode(secret),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign', 'verify']
  );
}

function serializeProofPayload(payload) {
  return JSON.stringify(payload);
}

export function trimInsights(rawInsights = [], deckStyle = 'rws-1909') {
  if (!Array.isArray(rawInsights)) {
    return [];
  }
  return rawInsights
    .filter(Boolean)
    .slice(0, MAX_INSIGHTS)
    .map((insight) => ({
      label: typeof insight.label === 'string' ? insight.label : 'uploaded-image',
      predictedCard: canonicalizeCardName(insight.predictedCard || insight.card || null, deckStyle) || null,
      confidence: typeof insight.confidence === 'number' ? insight.confidence : null,
      basis: typeof insight.basis === 'string' ? insight.basis : null,
      matches: Array.isArray(insight.matches) ? insight.matches.slice(0, 3) : [],
      attention: insight.attention || null,
      symbolVerification: insight.symbolVerification || null,
      visualProfile: insight.visualProfile || null
    }));
}

export function buildVisionProofPayload({ id, deckStyle = 'rws-1909', insights, ttlMs = DEFAULT_TTL_MS }) {
  const now = Date.now();
  const payload = {
    id,
    deckStyle,
    createdAt: new Date(now).toISOString(),
    expiresAt: new Date(now + ttlMs).toISOString(),
    insights: trimInsights(insights, deckStyle)
  };
  return payload;
}

export async function signVisionProof(payload, secret) {
  const key = await importHmacKey(secret);
  const subtle = getSubtle();
  const data = encoder.encode(serializeProofPayload(payload));
  const signatureBuffer = await subtle.sign('HMAC', key, data);
  return fromArrayBufferToBase64(signatureBuffer);
}

export async function verifyVisionProof(proof, secret) {
  if (!proof || typeof proof !== 'object') {
    throw new Error('Vision proof payload is missing.');
  }
  const { signature, id, deckStyle = 'rws-1909', createdAt, expiresAt, insights } = proof;
  if (!signature || typeof signature !== 'string') {
    throw new Error('Vision proof signature missing.');
  }
  const payload = {
    id,
    deckStyle,
    createdAt,
    expiresAt,
    insights: trimInsights(insights, deckStyle)
  };
  if (!payload.id) {
    throw new Error('Vision proof id missing.');
  }
  if (!payload.createdAt || !payload.expiresAt) {
    throw new Error('Vision proof timestamps missing.');
  }
  const now = Date.now();
  const expiresAtMs = Date.parse(payload.expiresAt);
  if (Number.isNaN(expiresAtMs) || expiresAtMs < now) {
    throw new Error('Vision proof has expired.');
  }
  const key = await importHmacKey(secret);
  const subtle = getSubtle();
  const data = encoder.encode(serializeProofPayload(payload));
  const signatureBuffer = toArrayBufferFromBase64(signature);
  const verified = await subtle.verify('HMAC', key, signatureBuffer, data);
  if (!verified) {
    throw new Error('Vision proof signature invalid.');
  }
  return payload;
}
</file>

<file path="migrations/0001_initial_schema.sql">
-- ============================================================================
-- Mystic Tarot - Initial Database Schema
-- ============================================================================
-- Migration: 0001
-- Description: Initial schema for readings history and analytics
-- Created: 2025-11-15
--

-- ============================================================================
-- Readings Table
-- ============================================================================
-- Stores tarot readings for analytics and optional user history
-- Note: No personally identifiable information (PII) is stored
--
CREATE TABLE IF NOT EXISTS readings (
  id TEXT PRIMARY KEY,                     -- UUID generated client-side
  created_at INTEGER NOT NULL,             -- Unix timestamp (seconds)
  spread_key TEXT NOT NULL,                -- 'single', 'threeCard', 'celtic', etc.
  spread_name TEXT NOT NULL,               -- Human-readable spread name
  card_count INTEGER NOT NULL,             -- Number of cards in the reading
  has_reversals INTEGER NOT NULL DEFAULT 0,-- Boolean: 1 if any reversed cards
  reversal_count INTEGER NOT NULL DEFAULT 0,-- Number of reversed cards
  question_length INTEGER,                 -- Length of user's question (for analytics)
  provider TEXT,                           -- 'claude-sonnet-4.5' or 'local'
  reading_length INTEGER,                  -- Length of generated reading text

  -- Analytics fields
  session_seed TEXT,                       -- Ritual seed (for reproducibility)
  has_reflections INTEGER DEFAULT 0,       -- Boolean: 1 if user added reflections

  -- Optional tracking (privacy-preserving)
  user_agent TEXT,                         -- Browser/device info
  locale TEXT,                             -- User's locale (e.g., 'en-US')

  -- Metadata
  version INTEGER DEFAULT 1                -- Schema version for future migrations
);

-- Index for analytics queries
CREATE INDEX IF NOT EXISTS idx_readings_created_at
  ON readings(created_at);

CREATE INDEX IF NOT EXISTS idx_readings_spread_key
  ON readings(spread_key);

CREATE INDEX IF NOT EXISTS idx_readings_provider
  ON readings(provider);

-- ============================================================================
-- Cards Table
-- ============================================================================
-- Stores individual card draws within each reading
--
CREATE TABLE IF NOT EXISTS cards (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  reading_id TEXT NOT NULL,                -- Foreign key to readings.id
  position_index INTEGER NOT NULL,         -- 0-based position in spread
  position_label TEXT,                     -- 'Past', 'Present', 'Challenge', etc.
  card_name TEXT NOT NULL,                 -- 'The Fool', 'Ace of Wands', etc.
  card_number INTEGER,                     -- Major Arcana number (0-21), null for Minor
  suit TEXT,                               -- 'Wands', 'Cups', 'Swords', 'Pentacles', or null
  rank TEXT,                               -- 'Ace', '2', 'King', etc., or null
  is_reversed INTEGER NOT NULL DEFAULT 0,  -- Boolean: 1 if reversed

  FOREIGN KEY (reading_id) REFERENCES readings(id) ON DELETE CASCADE
);

-- Index for querying cards by reading
CREATE INDEX IF NOT EXISTS idx_cards_reading_id
  ON cards(reading_id);

CREATE INDEX IF NOT EXISTS idx_cards_card_name
  ON cards(card_name);

-- ============================================================================
-- Analytics Aggregates Table (Optional)
-- ============================================================================
-- Pre-computed daily/weekly/monthly stats for performance
-- Can be populated via scheduled Workers or manual scripts
--
CREATE TABLE IF NOT EXISTS reading_stats (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  period_start INTEGER NOT NULL,           -- Unix timestamp (start of period)
  period_end INTEGER NOT NULL,             -- Unix timestamp (end of period)
  period_type TEXT NOT NULL,               -- 'day', 'week', 'month'

  -- Aggregated metrics
  total_readings INTEGER DEFAULT 0,
  total_cards_drawn INTEGER DEFAULT 0,

  -- By spread
  single_count INTEGER DEFAULT 0,
  three_card_count INTEGER DEFAULT 0,
  five_card_count INTEGER DEFAULT 0,
  decision_count INTEGER DEFAULT 0,
  relationship_count INTEGER DEFAULT 0,
  celtic_count INTEGER DEFAULT 0,

  -- By provider
  claude_count INTEGER DEFAULT 0,
  local_count INTEGER DEFAULT 0,

  -- Card frequencies (JSON blob)
  card_frequency_json TEXT,                -- JSON: {"The Fool": 42, "Ace of Wands": 31, ...}

  updated_at INTEGER NOT NULL              -- Last updated timestamp
);

CREATE UNIQUE INDEX IF NOT EXISTS idx_reading_stats_period
  ON reading_stats(period_start, period_type);

-- ============================================================================
-- User Preferences Table (Future)
-- ============================================================================
-- Optional: Store user preferences keyed by anonymous session ID
-- Uncomment when implementing user preference persistence
--
-- CREATE TABLE IF NOT EXISTS user_preferences (
--   session_id TEXT PRIMARY KEY,            -- Anonymous session identifier
--   created_at INTEGER NOT NULL,
--   updated_at INTEGER NOT NULL,
--
--   -- Preferences
--   audio_enabled INTEGER DEFAULT 1,
--   voice_enabled INTEGER DEFAULT 0,
--   theme TEXT DEFAULT 'dark',
--
--   -- Privacy
--   analytics_consent INTEGER DEFAULT 0,
--
--   -- Metadata
--   last_seen_at INTEGER
-- );
--
-- CREATE INDEX IF NOT EXISTS idx_user_prefs_last_seen
--   ON user_preferences(last_seen_at);

-- ============================================================================
-- Migration Complete
-- ============================================================================
</file>

<file path="migrations/0002_add_auth_and_journals.sql">
-- ============================================================================
-- Mystic Tarot - Authentication and Journal Persistence
-- ============================================================================
-- Migration: 0002
-- Description: Add user authentication and journal entry persistence
-- Created: 2025-11-15
--

-- ============================================================================
-- Users Table
-- ============================================================================
-- Stores user accounts for authenticated journal access
--
CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,                     -- UUID
  email TEXT UNIQUE NOT NULL,              -- User email (for login)
  username TEXT UNIQUE NOT NULL,           -- Display name
  password_hash TEXT NOT NULL,             -- PBKDF2 derived hash
  password_salt TEXT NOT NULL,             -- Hex-encoded salt for PBKDF2
  created_at INTEGER NOT NULL,             -- Unix timestamp (seconds)
  updated_at INTEGER NOT NULL,             -- Unix timestamp (seconds)
  last_login_at INTEGER,                   -- Unix timestamp (seconds)

  -- Metadata
  is_active INTEGER NOT NULL DEFAULT 1,    -- Boolean: account active status
  email_verified INTEGER DEFAULT 0         -- Boolean: email verification status (future)
);

-- Indexes for auth queries
CREATE INDEX IF NOT EXISTS idx_users_email
  ON users(email);

CREATE INDEX IF NOT EXISTS idx_users_username
  ON users(username);

-- ============================================================================
-- Sessions Table
-- ============================================================================
-- Stores active user sessions with token-based authentication
--
CREATE TABLE IF NOT EXISTS sessions (
  id TEXT PRIMARY KEY,                     -- Session token (32-byte random)
  user_id TEXT NOT NULL,                   -- Foreign key to users.id
  created_at INTEGER NOT NULL,             -- Unix timestamp (seconds)
  expires_at INTEGER NOT NULL,             -- Unix timestamp (seconds) - 30 days from creation
  last_used_at INTEGER NOT NULL,           -- Unix timestamp (seconds)

  -- Session metadata
  user_agent TEXT,                         -- Browser/device info
  ip_address TEXT,                         -- Client IP (privacy-preserving)

  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Indexes for session lookups
CREATE INDEX IF NOT EXISTS idx_sessions_user_id
  ON sessions(user_id);

CREATE INDEX IF NOT EXISTS idx_sessions_expires_at
  ON sessions(expires_at);

-- ============================================================================
-- Journal Entries Table
-- ============================================================================
-- Stores tarot reading journal entries for authenticated users
-- Replaces localStorage for persistent, cross-device access
--
CREATE TABLE IF NOT EXISTS journal_entries (
  id TEXT PRIMARY KEY,                     -- UUID
  user_id TEXT NOT NULL,                   -- Foreign key to users.id
  created_at INTEGER NOT NULL,             -- Unix timestamp (seconds)
  updated_at INTEGER NOT NULL,             -- Unix timestamp (seconds)

  -- Reading metadata
  spread_key TEXT NOT NULL,                -- 'single', 'threeCard', 'celtic', etc.
  spread_name TEXT NOT NULL,               -- Human-readable spread name
  question TEXT,                           -- User's question

  -- Reading data (stored as JSON for flexibility)
  cards_json TEXT NOT NULL,                -- JSON array: [{ position, name, orientation, ... }]
  narrative TEXT,                          -- Generated reading text
  themes_json TEXT,                        -- JSON: { suitFocus, elementalBalance, timingProfile, etc. }
  reflections_json TEXT,                   -- JSON object: { "0": "my note", "1": "another note" }
  context TEXT,                            -- Reading context: 'love', 'career', 'self', 'spiritual'

  -- Metadata
  provider TEXT,                           -- 'azure-gpt5', 'local', etc.
  session_seed TEXT,                       -- Ritual seed (for reproducibility)

  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Indexes for journal queries
CREATE INDEX IF NOT EXISTS idx_journal_user_created
  ON journal_entries(user_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_journal_spread_key
  ON journal_entries(spread_key);

CREATE INDEX IF NOT EXISTS idx_journal_created_at
  ON journal_entries(created_at DESC);

-- ============================================================================
-- Migration Complete
-- ============================================================================
</file>

<file path="migrations/0003_add_share_tables.sql">
-- ============================================================================
-- Mystic Tarot - Collaborative Share Links
-- ============================================================================
-- Migration: 0003
-- Description: Share tokens, entry linkage, and collaborative notes
-- Created: 2025-11-18
--

CREATE TABLE IF NOT EXISTS share_tokens (
  token TEXT PRIMARY KEY,
  user_id TEXT NOT NULL,
  scope TEXT NOT NULL CHECK(scope IN ('entry', 'journal')),
  title TEXT,
  created_at INTEGER NOT NULL,
  expires_at INTEGER,
  view_count INTEGER NOT NULL DEFAULT 0,
  meta_json TEXT,
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_share_tokens_user
  ON share_tokens(user_id, created_at DESC);

CREATE TABLE IF NOT EXISTS share_token_entries (
  token TEXT NOT NULL,
  entry_id TEXT NOT NULL,
  sort_index INTEGER NOT NULL DEFAULT 0,
  PRIMARY KEY (token, entry_id),
  FOREIGN KEY (token) REFERENCES share_tokens(token) ON DELETE CASCADE,
  FOREIGN KEY (entry_id) REFERENCES journal_entries(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS share_notes (
  id TEXT PRIMARY KEY,
  token TEXT NOT NULL,
  author_name TEXT,
  body TEXT NOT NULL,
  card_position TEXT,
  created_at INTEGER NOT NULL,
  FOREIGN KEY (token) REFERENCES share_tokens(token) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_share_notes_token
  ON share_notes(token, created_at ASC);

-- ============================================================================
-- Migration Complete
-- ============================================================================
</file>

<file path="migrations/0004_add_api_keys.sql">
-- ============================================================================
-- API Keys and Rate Limiting
-- ============================================================================
-- Migration: 0004
-- Description: Add API keys for programmatic access
-- Created: 2025-11-19
--

-- ============================================================================
-- API Keys Table
-- ============================================================================
-- Stores API keys for programmatic access
--
CREATE TABLE IF NOT EXISTS api_keys (
  id TEXT PRIMARY KEY,                     -- UUID
  user_id TEXT NOT NULL,                   -- Foreign key to users.id
  key_hash TEXT NOT NULL UNIQUE,           -- Hashed API key (SHA-256)
  key_prefix TEXT NOT NULL,                -- First 8 chars for identification
  name TEXT NOT NULL,                      -- User-provided name for the key
  created_at INTEGER NOT NULL,             -- Unix timestamp (seconds)
  expires_at INTEGER,                      -- Optional expiration (seconds)
  last_used_at INTEGER,                    -- Unix timestamp (seconds)
  is_active INTEGER NOT NULL DEFAULT 1,    -- Boolean

  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Indexes for API key lookups
CREATE INDEX IF NOT EXISTS idx_api_keys_user_id
  ON api_keys(user_id);

CREATE INDEX IF NOT EXISTS idx_api_keys_key_hash
  ON api_keys(key_hash);
</file>

<file path="migrations/0005_add_archetype_journey.sql">
-- ============================================================================
-- Mystic Tarot - Archetype Journey Analytics
-- ============================================================================
-- Migration: 0005
-- Description: Add card appearance tracking for gamified analytics
-- Created: 2025-11-20
--

-- ============================================================================
-- Card Appearances Table
-- ============================================================================
-- Tracks card occurrences per user for archetype journey analytics
-- Enables "Top 5 cards this month", streaks, trends, and badge achievements
--
CREATE TABLE IF NOT EXISTS card_appearances (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,                   -- Foreign key to users.id
  card_name TEXT NOT NULL,                 -- 'The Fool', 'Ace of Wands', etc.
  card_number INTEGER,                     -- Major Arcana: 0-21, Minor: 22-77, null if unknown
  year_month TEXT NOT NULL,                -- YYYY-MM format (e.g., '2025-11')
  count INTEGER NOT NULL DEFAULT 1,        -- Number of appearances in this month
  last_seen INTEGER NOT NULL,              -- Unix timestamp (seconds) of most recent appearance
  first_seen INTEGER NOT NULL,             -- Unix timestamp (seconds) of first appearance in this period

  -- Constraint: one row per user+card+month
  UNIQUE(user_id, card_name, year_month),

  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Indexes for analytics queries
CREATE INDEX IF NOT EXISTS idx_card_appearances_user_month
  ON card_appearances(user_id, year_month DESC);

CREATE INDEX IF NOT EXISTS idx_card_appearances_card
  ON card_appearances(card_name);

-- ============================================================================
-- Archetype Badges Table
-- ============================================================================
-- Stores earned badges for streak achievements and milestones
--
CREATE TABLE IF NOT EXISTS archetype_badges (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id TEXT NOT NULL,                   -- Foreign key to users.id
  badge_type TEXT NOT NULL,                -- 'streak', 'frequency', 'completion', etc.
  badge_key TEXT NOT NULL,                 -- Unique badge identifier (e.g., 'tower_3x_nov')
  card_name TEXT,                          -- Card associated with badge (if applicable)
  earned_at INTEGER NOT NULL,              -- Unix timestamp (seconds)
  metadata_json TEXT,                      -- JSON: { count: 3, month: '2025-11', context: 'Tower appeared 3x' }

  -- Constraint: one badge per user+key
  UNIQUE(user_id, badge_key),

  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- Indexes for badge queries
CREATE INDEX IF NOT EXISTS idx_archetype_badges_user
  ON archetype_badges(user_id, earned_at DESC);

CREATE INDEX IF NOT EXISTS idx_archetype_badges_type
  ON archetype_badges(badge_type);

-- ============================================================================
-- User Analytics Preferences Table
-- ============================================================================
-- Stores user preferences for analytics features (opt-in/opt-out)
--
CREATE TABLE IF NOT EXISTS user_analytics_prefs (
  user_id TEXT PRIMARY KEY,                -- Foreign key to users.id
  archetype_journey_enabled INTEGER DEFAULT 1,  -- Boolean: opt-in for analytics
  show_badges INTEGER DEFAULT 1,           -- Boolean: show badge notifications
  updated_at INTEGER NOT NULL,             -- Unix timestamp (seconds)

  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- ============================================================================
-- Migration Complete
-- ============================================================================
</file>

<file path="migrations/0006_add_user_preferences.sql">
-- Migration: 0006_add_user_preferences
-- Purpose: Add user_preferences_json column to journal_entries for storing
--          personalization snapshot at time of reading (Phase 5.2)
--
-- Schema:
--   user_preferences_json TEXT - JSON object with:
--     - readingTone: 'gentle' | 'balanced' | 'blunt'
--     - spiritualFrame: 'psychological' | 'spiritual' | 'mixed' | 'playful'
--     - tarotExperience: 'newbie' | 'intermediate' | 'experienced'
--     - displayName: string (optional, only if set)
--
-- Backward compatible: NULL for entries created before this migration

-- ============================================================================
-- Add user_preferences_json column to journal_entries
-- ============================================================================

ALTER TABLE journal_entries ADD COLUMN user_preferences_json TEXT;

-- ============================================================================
-- Migration Complete
-- ============================================================================
</file>

<file path="migrations/0007_add_request_id_and_dedup_index.sql">
-- Migration: 0007_add_request_id_and_dedup_index
-- Purpose: Add request_id column for API tracing and unique index to prevent
--          duplicate journal entries from double-saves
--
-- Fixes:
--   1. Missing request_id column referenced by export scripts
--   2. Duplicate entries caused by double-click or network retry
--
-- Backward compatible: NULL for entries created before this migration

-- ============================================================================
-- Add request_id column to journal_entries
-- ============================================================================
-- Used for correlating readings with API logs, feedback, and metrics

ALTER TABLE journal_entries ADD COLUMN request_id TEXT;

-- Index for request_id lookups (used by feedback/metrics correlation)
CREATE INDEX IF NOT EXISTS idx_journal_request_id
  ON journal_entries(request_id)
  WHERE request_id IS NOT NULL;

-- ============================================================================
-- Add unique constraint on (user_id, session_seed) to prevent duplicates
-- ============================================================================
-- Only applies when session_seed is non-null (readings with ritual seed)
-- This is a partial unique index - allows multiple NULL session_seeds

CREATE UNIQUE INDEX IF NOT EXISTS idx_journal_user_session_seed_unique
  ON journal_entries(user_id, session_seed)
  WHERE session_seed IS NOT NULL;

-- ============================================================================
-- Migration Complete
-- ============================================================================
</file>

<file path="models/adapters/marseille/adapter_config.json">
{
  "alora_invocation_tokens": null,
  "alpha_pattern": {},
  "arrow_config": null,
  "auto_mapping": {
    "base_model_class": "CLIPModel",
    "parent_library": "transformers.models.clip.modeling_clip"
  },
  "base_model_name_or_path": "openai/clip-vit-base-patch32",
  "bias": "none",
  "corda_config": null,
  "ensure_weight_tying": false,
  "eva_config": null,
  "exclude_modules": null,
  "fan_in_fan_out": false,
  "inference_mode": true,
  "init_lora_weights": true,
  "layer_replication": null,
  "layers_pattern": null,
  "layers_to_transform": null,
  "loftq_config": {},
  "lora_alpha": 16,
  "lora_bias": false,
  "lora_dropout": 0.1,
  "megatron_config": null,
  "megatron_core": "megatron.core",
  "modules_to_save": [
    "classifier"
  ],
  "peft_type": "LORA",
  "peft_version": "0.18.0",
  "qalora_group_size": 16,
  "r": 16,
  "rank_pattern": {},
  "revision": null,
  "target_modules": [
    "q_proj",
    "v_proj"
  ],
  "target_parameters": null,
  "task_type": null,
  "trainable_token_indices": null,
  "use_dora": false,
  "use_qalora": false,
  "use_rslora": false
}
</file>

<file path="models/adapters/marseille/README.md">
---
base_model: openai/clip-vit-base-patch32
library_name: peft
tags:
- base_model:adapter:openai/clip-vit-base-patch32
- lora
- transformers
---

# Model Card for Model ID

<!-- Provide a quick summary of what the model is/does. -->



## Model Details

### Model Description

<!-- Provide a longer summary of what this model is. -->



- **Developed by:** [More Information Needed]
- **Funded by [optional]:** [More Information Needed]
- **Shared by [optional]:** [More Information Needed]
- **Model type:** [More Information Needed]
- **Language(s) (NLP):** [More Information Needed]
- **License:** [More Information Needed]
- **Finetuned from model [optional]:** [More Information Needed]

### Model Sources [optional]

<!-- Provide the basic links for the model. -->

- **Repository:** [More Information Needed]
- **Paper [optional]:** [More Information Needed]
- **Demo [optional]:** [More Information Needed]

## Uses

<!-- Address questions around how the model is intended to be used, including the foreseeable users of the model and those affected by the model. -->

### Direct Use

<!-- This section is for the model use without fine-tuning or plugging into a larger ecosystem/app. -->

[More Information Needed]

### Downstream Use [optional]

<!-- This section is for the model use when fine-tuned for a task, or when plugged into a larger ecosystem/app -->

[More Information Needed]

### Out-of-Scope Use

<!-- This section addresses misuse, malicious use, and uses that the model will not work well for. -->

[More Information Needed]

## Bias, Risks, and Limitations

<!-- This section is meant to convey both technical and sociotechnical limitations. -->

[More Information Needed]

### Recommendations

<!-- This section is meant to convey recommendations with respect to the bias, risk, and technical limitations. -->

Users (both direct and downstream) should be made aware of the risks, biases and limitations of the model. More information needed for further recommendations.

## How to Get Started with the Model

Use the code below to get started with the model.

[More Information Needed]

## Training Details

### Training Data

<!-- This should link to a Dataset Card, perhaps with a short stub of information on what the training data is all about as well as documentation related to data pre-processing or additional filtering. -->

[More Information Needed]

### Training Procedure

<!-- This relates heavily to the Technical Specifications. Content here should link to that section when it is relevant to the training procedure. -->

#### Preprocessing [optional]

[More Information Needed]


#### Training Hyperparameters

- **Training regime:** [More Information Needed] <!--fp32, fp16 mixed precision, bf16 mixed precision, bf16 non-mixed precision, fp16 non-mixed precision, fp8 mixed precision -->

#### Speeds, Sizes, Times [optional]

<!-- This section provides information about throughput, start/end time, checkpoint size if relevant, etc. -->

[More Information Needed]

## Evaluation

<!-- This section describes the evaluation protocols and provides the results. -->

### Testing Data, Factors & Metrics

#### Testing Data

<!-- This should link to a Dataset Card if possible. -->

[More Information Needed]

#### Factors

<!-- These are the things the evaluation is disaggregating by, e.g., subpopulations or domains. -->

[More Information Needed]

#### Metrics

<!-- These are the evaluation metrics being used, ideally with a description of why. -->

[More Information Needed]

### Results

[More Information Needed]

#### Summary



## Model Examination [optional]

<!-- Relevant interpretability work for the model goes here -->

[More Information Needed]

## Environmental Impact

<!-- Total emissions (in grams of CO2eq) and additional considerations, such as electricity usage, go here. Edit the suggested text below accordingly -->

Carbon emissions can be estimated using the [Machine Learning Impact calculator](https://mlco2.github.io/impact#compute) presented in [Lacoste et al. (2019)](https://arxiv.org/abs/1910.09700).

- **Hardware Type:** [More Information Needed]
- **Hours used:** [More Information Needed]
- **Cloud Provider:** [More Information Needed]
- **Compute Region:** [More Information Needed]
- **Carbon Emitted:** [More Information Needed]

## Technical Specifications [optional]

### Model Architecture and Objective

[More Information Needed]

### Compute Infrastructure

[More Information Needed]

#### Hardware

[More Information Needed]

#### Software

[More Information Needed]

## Citation [optional]

<!-- If there is a paper or blog post introducing the model, the APA and Bibtex information for that should go in this section. -->

**BibTeX:**

[More Information Needed]

**APA:**

[More Information Needed]

## Glossary [optional]

<!-- If relevant, include terms and calculations in this section that can help readers understand the model or model card. -->

[More Information Needed]

## More Information [optional]

[More Information Needed]

## Model Card Authors [optional]

[More Information Needed]

## Model Card Contact

[More Information Needed]
### Framework versions

- PEFT 0.18.0
</file>

<file path="models/adapters/rws/adapter_config.json">
{
  "alora_invocation_tokens": null,
  "alpha_pattern": {},
  "arrow_config": null,
  "auto_mapping": {
    "base_model_class": "CLIPModel",
    "parent_library": "transformers.models.clip.modeling_clip"
  },
  "base_model_name_or_path": "openai/clip-vit-base-patch32",
  "bias": "none",
  "corda_config": null,
  "ensure_weight_tying": false,
  "eva_config": null,
  "exclude_modules": null,
  "fan_in_fan_out": false,
  "inference_mode": true,
  "init_lora_weights": true,
  "layer_replication": null,
  "layers_pattern": null,
  "layers_to_transform": null,
  "loftq_config": {},
  "lora_alpha": 16,
  "lora_bias": false,
  "lora_dropout": 0.1,
  "megatron_config": null,
  "megatron_core": "megatron.core",
  "modules_to_save": [
    "classifier"
  ],
  "peft_type": "LORA",
  "peft_version": "0.18.0",
  "qalora_group_size": 16,
  "r": 16,
  "rank_pattern": {},
  "revision": null,
  "target_modules": [
    "v_proj",
    "q_proj"
  ],
  "target_parameters": null,
  "task_type": null,
  "trainable_token_indices": null,
  "use_dora": false,
  "use_qalora": false,
  "use_rslora": false
}
</file>

<file path="models/adapters/rws/README.md">
---
base_model: openai/clip-vit-base-patch32
library_name: peft
tags:
- base_model:adapter:openai/clip-vit-base-patch32
- lora
- transformers
---

# Model Card for Model ID

<!-- Provide a quick summary of what the model is/does. -->



## Model Details

### Model Description

<!-- Provide a longer summary of what this model is. -->



- **Developed by:** [More Information Needed]
- **Funded by [optional]:** [More Information Needed]
- **Shared by [optional]:** [More Information Needed]
- **Model type:** [More Information Needed]
- **Language(s) (NLP):** [More Information Needed]
- **License:** [More Information Needed]
- **Finetuned from model [optional]:** [More Information Needed]

### Model Sources [optional]

<!-- Provide the basic links for the model. -->

- **Repository:** [More Information Needed]
- **Paper [optional]:** [More Information Needed]
- **Demo [optional]:** [More Information Needed]

## Uses

<!-- Address questions around how the model is intended to be used, including the foreseeable users of the model and those affected by the model. -->

### Direct Use

<!-- This section is for the model use without fine-tuning or plugging into a larger ecosystem/app. -->

[More Information Needed]

### Downstream Use [optional]

<!-- This section is for the model use when fine-tuned for a task, or when plugged into a larger ecosystem/app -->

[More Information Needed]

### Out-of-Scope Use

<!-- This section addresses misuse, malicious use, and uses that the model will not work well for. -->

[More Information Needed]

## Bias, Risks, and Limitations

<!-- This section is meant to convey both technical and sociotechnical limitations. -->

[More Information Needed]

### Recommendations

<!-- This section is meant to convey recommendations with respect to the bias, risk, and technical limitations. -->

Users (both direct and downstream) should be made aware of the risks, biases and limitations of the model. More information needed for further recommendations.

## How to Get Started with the Model

Use the code below to get started with the model.

[More Information Needed]

## Training Details

### Training Data

<!-- This should link to a Dataset Card, perhaps with a short stub of information on what the training data is all about as well as documentation related to data pre-processing or additional filtering. -->

[More Information Needed]

### Training Procedure

<!-- This relates heavily to the Technical Specifications. Content here should link to that section when it is relevant to the training procedure. -->

#### Preprocessing [optional]

[More Information Needed]


#### Training Hyperparameters

- **Training regime:** [More Information Needed] <!--fp32, fp16 mixed precision, bf16 mixed precision, bf16 non-mixed precision, fp16 non-mixed precision, fp8 mixed precision -->

#### Speeds, Sizes, Times [optional]

<!-- This section provides information about throughput, start/end time, checkpoint size if relevant, etc. -->

[More Information Needed]

## Evaluation

<!-- This section describes the evaluation protocols and provides the results. -->

### Testing Data, Factors & Metrics

#### Testing Data

<!-- This should link to a Dataset Card if possible. -->

[More Information Needed]

#### Factors

<!-- These are the things the evaluation is disaggregating by, e.g., subpopulations or domains. -->

[More Information Needed]

#### Metrics

<!-- These are the evaluation metrics being used, ideally with a description of why. -->

[More Information Needed]

### Results

[More Information Needed]

#### Summary



## Model Examination [optional]

<!-- Relevant interpretability work for the model goes here -->

[More Information Needed]

## Environmental Impact

<!-- Total emissions (in grams of CO2eq) and additional considerations, such as electricity usage, go here. Edit the suggested text below accordingly -->

Carbon emissions can be estimated using the [Machine Learning Impact calculator](https://mlco2.github.io/impact#compute) presented in [Lacoste et al. (2019)](https://arxiv.org/abs/1910.09700).

- **Hardware Type:** [More Information Needed]
- **Hours used:** [More Information Needed]
- **Cloud Provider:** [More Information Needed]
- **Compute Region:** [More Information Needed]
- **Carbon Emitted:** [More Information Needed]

## Technical Specifications [optional]

### Model Architecture and Objective

[More Information Needed]

### Compute Infrastructure

[More Information Needed]

#### Hardware

[More Information Needed]

#### Software

[More Information Needed]

## Citation [optional]

<!-- If there is a paper or blog post introducing the model, the APA and Bibtex information for that should go in this section. -->

**BibTeX:**

[More Information Needed]

**APA:**

[More Information Needed]

## Glossary [optional]

<!-- If relevant, include terms and calculations in this section that can help readers understand the model or model card. -->

[More Information Needed]

## More Information [optional]

[More Information Needed]

## Model Card Authors [optional]

[More Information Needed]

## Model Card Contact

[More Information Needed]
### Framework versions

- PEFT 0.18.0
</file>

<file path="models/adapters/thoth/adapter_config.json">
{
  "alora_invocation_tokens": null,
  "alpha_pattern": {},
  "arrow_config": null,
  "auto_mapping": {
    "base_model_class": "CLIPModel",
    "parent_library": "transformers.models.clip.modeling_clip"
  },
  "base_model_name_or_path": "openai/clip-vit-base-patch32",
  "bias": "none",
  "corda_config": null,
  "ensure_weight_tying": false,
  "eva_config": null,
  "exclude_modules": null,
  "fan_in_fan_out": false,
  "inference_mode": true,
  "init_lora_weights": true,
  "layer_replication": null,
  "layers_pattern": null,
  "layers_to_transform": null,
  "loftq_config": {},
  "lora_alpha": 16,
  "lora_bias": false,
  "lora_dropout": 0.1,
  "megatron_config": null,
  "megatron_core": "megatron.core",
  "modules_to_save": [
    "classifier"
  ],
  "peft_type": "LORA",
  "peft_version": "0.18.0",
  "qalora_group_size": 16,
  "r": 16,
  "rank_pattern": {},
  "revision": null,
  "target_modules": [
    "q_proj",
    "v_proj"
  ],
  "target_parameters": null,
  "task_type": null,
  "trainable_token_indices": null,
  "use_dora": false,
  "use_qalora": false,
  "use_rslora": false
}
</file>

<file path="models/adapters/thoth/README.md">
---
base_model: openai/clip-vit-base-patch32
library_name: peft
tags:
- base_model:adapter:openai/clip-vit-base-patch32
- lora
- transformers
---

# Model Card for Model ID

<!-- Provide a quick summary of what the model is/does. -->



## Model Details

### Model Description

<!-- Provide a longer summary of what this model is. -->



- **Developed by:** [More Information Needed]
- **Funded by [optional]:** [More Information Needed]
- **Shared by [optional]:** [More Information Needed]
- **Model type:** [More Information Needed]
- **Language(s) (NLP):** [More Information Needed]
- **License:** [More Information Needed]
- **Finetuned from model [optional]:** [More Information Needed]

### Model Sources [optional]

<!-- Provide the basic links for the model. -->

- **Repository:** [More Information Needed]
- **Paper [optional]:** [More Information Needed]
- **Demo [optional]:** [More Information Needed]

## Uses

<!-- Address questions around how the model is intended to be used, including the foreseeable users of the model and those affected by the model. -->

### Direct Use

<!-- This section is for the model use without fine-tuning or plugging into a larger ecosystem/app. -->

[More Information Needed]

### Downstream Use [optional]

<!-- This section is for the model use when fine-tuned for a task, or when plugged into a larger ecosystem/app -->

[More Information Needed]

### Out-of-Scope Use

<!-- This section addresses misuse, malicious use, and uses that the model will not work well for. -->

[More Information Needed]

## Bias, Risks, and Limitations

<!-- This section is meant to convey both technical and sociotechnical limitations. -->

[More Information Needed]

### Recommendations

<!-- This section is meant to convey recommendations with respect to the bias, risk, and technical limitations. -->

Users (both direct and downstream) should be made aware of the risks, biases and limitations of the model. More information needed for further recommendations.

## How to Get Started with the Model

Use the code below to get started with the model.

[More Information Needed]

## Training Details

### Training Data

<!-- This should link to a Dataset Card, perhaps with a short stub of information on what the training data is all about as well as documentation related to data pre-processing or additional filtering. -->

[More Information Needed]

### Training Procedure

<!-- This relates heavily to the Technical Specifications. Content here should link to that section when it is relevant to the training procedure. -->

#### Preprocessing [optional]

[More Information Needed]


#### Training Hyperparameters

- **Training regime:** [More Information Needed] <!--fp32, fp16 mixed precision, bf16 mixed precision, bf16 non-mixed precision, fp16 non-mixed precision, fp8 mixed precision -->

#### Speeds, Sizes, Times [optional]

<!-- This section provides information about throughput, start/end time, checkpoint size if relevant, etc. -->

[More Information Needed]

## Evaluation

<!-- This section describes the evaluation protocols and provides the results. -->

### Testing Data, Factors & Metrics

#### Testing Data

<!-- This should link to a Dataset Card if possible. -->

[More Information Needed]

#### Factors

<!-- These are the things the evaluation is disaggregating by, e.g., subpopulations or domains. -->

[More Information Needed]

#### Metrics

<!-- These are the evaluation metrics being used, ideally with a description of why. -->

[More Information Needed]

### Results

[More Information Needed]

#### Summary



## Model Examination [optional]

<!-- Relevant interpretability work for the model goes here -->

[More Information Needed]

## Environmental Impact

<!-- Total emissions (in grams of CO2eq) and additional considerations, such as electricity usage, go here. Edit the suggested text below accordingly -->

Carbon emissions can be estimated using the [Machine Learning Impact calculator](https://mlco2.github.io/impact#compute) presented in [Lacoste et al. (2019)](https://arxiv.org/abs/1910.09700).

- **Hardware Type:** [More Information Needed]
- **Hours used:** [More Information Needed]
- **Cloud Provider:** [More Information Needed]
- **Compute Region:** [More Information Needed]
- **Carbon Emitted:** [More Information Needed]

## Technical Specifications [optional]

### Model Architecture and Objective

[More Information Needed]

### Compute Infrastructure

[More Information Needed]

#### Hardware

[More Information Needed]

#### Software

[More Information Needed]

## Citation [optional]

<!-- If there is a paper or blog post introducing the model, the APA and Bibtex information for that should go in this section. -->

**BibTeX:**

[More Information Needed]

**APA:**

[More Information Needed]

## Glossary [optional]

<!-- If relevant, include terms and calculations in this section that can help readers understand the model or model card. -->

[More Information Needed]

## More Information [optional]

[More Information Needed]

## Model Card Authors [optional]

[More Information Needed]

## Model Card Contact

[More Information Needed]
### Framework versions

- PEFT 0.18.0
</file>

<file path="plugins/tarot-astro-plugins/.claude-plugin/marketplace.json">
{
  "name": "tarot-astro-plugins",
  "description": "Astrological context and symbolism reference tools for tarot readings",
  "owner": {
    "name": "Mystic Tarot",
    "email": "dev@mystictarot.app"
  },
  "plugins": [
    {
      "name": "ephemeris-server",
      "source": "./ephemeris-server",
      "description": "Real-time planetary positions and astrological context for readings"
    },
    {
      "name": "symbolism-server",
      "source": "./symbolism-server",
      "description": "Comprehensive symbolism reference database for card interpretation"
    }
  ]
}
</file>

<file path="plugins/tarot-astro-plugins/ephemeris-server/.claude-plugin/plugin.json">
{
  "name": "ephemeris-server",
  "version": "1.0.0",
  "description": "Real-time planetary positions and astrological context for tarot readings",
  "author": {
    "name": "Mystic Tarot",
    "email": "dev@mystictarot.app"
  },
  "license": "MIT",
  "keywords": ["astrology", "ephemeris", "planets", "moon", "aspects"],
  "mcpServers": "./.mcp.json"
}
</file>

<file path="plugins/tarot-astro-plugins/ephemeris-server/commands/astro-reading.md">
---
description: Add comprehensive astrological context to a tarot reading
---

# Astrological Reading Context

When invoked, gather comprehensive astrological context for the current or specified reading.

## Instructions

1. **Get current ephemeris data** using `get_current_positions` and `get_daily_astrological_weather`

2. **Identify key cosmic themes:**
   - Current moon phase and its meaning for the reading
   - Active planetary aspects and their influence
   - Any retrograde planets and what they suggest for reflection
   - The overall "astrological weather" of the day

3. **Present context to the user in this format:**

```
🌙 Astrological Context for Your Reading

**Moon Phase:** [Phase Name] in [Sign]
[Moon phase interpretation]

**Planetary Highlights:**
- [Key aspect or transit 1]
- [Key aspect or transit 2]
- [Key aspect or transit 3]

**Retrograde Activity:**
[List any retrograde planets and their significance for the reading]

**Daily Cosmic Theme:**
[Overall astrological weather and what it suggests for the reading]

**Integration with Your Cards:**
Consider how these cosmic currents might be reflected in or amplified by the cards drawn. The celestial energies don't determine the reading, but they can provide valuable context for the timing and themes emerging in your spread.
```

4. **Be ready to:**
   - Explain any astrological terms in accessible language
   - Draw connections between planetary energies and card meanings
   - Avoid deterministic language - frame as context, not cause

## Example

User: "/astro-reading"

Response:
```
🌙 Astrological Context for Your Reading

**Moon Phase:** Waxing Gibbous in Pisces (87% illuminated)
The moon is building toward fullness while moving through intuitive Pisces, suggesting a time of refinement and emotional deepening. Trust what's emerging from your inner world as you approach the culmination of this lunar cycle.

**Planetary Highlights:**
- Sun square Mars (orb: 0.8°) - Dynamic tension between will and action, catalyzing breakthroughs
- Venus trine Jupiter (orb: 2.3°) - Expansive love energy, optimism in relationships
- Mercury in Capricorn - Practical, grounded communication and planning

**Retrograde Activity:**
No planets currently retrograde - forward momentum available in all areas.

**Daily Cosmic Theme:**
Growth, building, expansion; Tension requiring resolution, growth through challenge; Flow, ease, natural talents emerging

**Integration with Your Cards:**
With Mars and the Sun in dynamic square, themes of action, courage, or constructive conflict in your cards may be especially relevant. The waxing moon in Pisces invites you to trust your intuition as you interpret the imagery and symbols before you.
```

## Important Notes

- Always use the MCP tools to get real, current data - never make up astrological positions
- Keep language accessible and avoid overwhelming jargon
- Frame astrology as context and timing, not deterministic prediction
- Connect cosmic energies to card meanings where natural, but don't force connections
- Remember: the cards respond to the question and querent, astrology provides backdrop
</file>

<file path="plugins/tarot-astro-plugins/ephemeris-server/scripts/check-ephemeris-files.js">
#!/usr/bin/env node

/**
 * Post-install script to check for Swiss Ephemeris data files
 * and provide guidance if they're missing
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const EPHE_DIRS = [
  path.join(__dirname, '..', 'ephe'),
  path.join(__dirname, '..', '..', 'ephe'),
  '/usr/share/swisseph',
];

const REQUIRED_FILES = ['sepl_18.se1', 'semo_18.se1'];

function checkEphemerisFiles() {
  console.log('\n📡 Checking for Swiss Ephemeris data files...\n');

  // Check environment variable
  const envPath = process.env.SE_EPHE_PATH;
  if (envPath) {
    EPHE_DIRS.unshift(envPath);
  }

  let foundDir = null;
  let foundFiles = [];

  for (const dir of EPHE_DIRS) {
    if (!fs.existsSync(dir)) continue;

    const files = fs.readdirSync(dir);
    const foundRequired = REQUIRED_FILES.filter(f => files.includes(f));

    if (foundRequired.length > 0) {
      foundDir = dir;
      foundFiles = foundRequired;
      break;
    }
  }

  if (foundDir && foundFiles.length === REQUIRED_FILES.length) {
    console.log('✅ Swiss Ephemeris data files found!');
    console.log(`   Location: ${foundDir}`);
    console.log(`   Files: ${foundFiles.join(', ')}\n`);
    return;
  }

  // Files not found or incomplete
  console.log('⚠️  Swiss Ephemeris data files not found or incomplete\n');
  console.log('This server requires ephemeris data files to calculate planetary positions.\n');
  console.log('Quick setup:\n');
  console.log('  1. Create the ephe directory:');
  console.log('     mkdir -p ephe\n');
  console.log('  2. Download essential files:');
  console.log('     cd ephe');
  console.log('     curl -O https://www.astro.com/ftp/swisseph/ephe/sepl_18.se1');
  console.log('     curl -O https://www.astro.com/ftp/swisseph/ephe/semo_18.se1\n');
  console.log('     Or use wget:');
  console.log('     wget https://www.astro.com/ftp/swisseph/ephe/sepl_18.se1');
  console.log('     wget https://www.astro.com/ftp/swisseph/ephe/semo_18.se1\n');
  console.log('For detailed instructions, see: EPHEMERIS_DATA_README.md\n');

  if (foundDir && foundFiles.length < REQUIRED_FILES.length) {
    console.log(`Found partial installation at ${foundDir}`);
    console.log(`Missing files: ${REQUIRED_FILES.filter(f => !foundFiles.includes(f)).join(', ')}\n`);
  }
}

checkEphemerisFiles();
</file>

<file path="plugins/tarot-astro-plugins/ephemeris-server/server/ephemeris.js">
/**
 * Ephemeris calculations using Swiss Ephemeris (via sweph)
 * Provides planetary positions, aspects, and lunar data with high precision
 */

import sweph from 'sweph';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Import constants from sweph
const {
  SE_SUN,
  SE_MOON,
  SE_MERCURY,
  SE_VENUS,
  SE_MARS,
  SE_JUPITER,
  SE_SATURN,
  SE_URANUS,
  SE_NEPTUNE,
  SE_PLUTO,
  SE_GREG_CAL,
  SEFLG_SWIEPH,
  SEFLG_SPEED
} = sweph.constants;

const PLANETS = [
  { name: 'Sun', id: SE_SUN },
  { name: 'Moon', id: SE_MOON },
  { name: 'Mercury', id: SE_MERCURY },
  { name: 'Venus', id: SE_VENUS },
  { name: 'Mars', id: SE_MARS },
  { name: 'Jupiter', id: SE_JUPITER },
  { name: 'Saturn', id: SE_SATURN },
  { name: 'Uranus', id: SE_URANUS },
  { name: 'Neptune', id: SE_NEPTUNE },
  { name: 'Pluto', id: SE_PLUTO }
];

const ZODIAC_SIGNS = [
  'Aries', 'Taurus', 'Gemini', 'Cancer',
  'Leo', 'Virgo', 'Libra', 'Scorpio',
  'Sagittarius', 'Capricorn', 'Aquarius', 'Pisces'
];

// Initialize Swiss Ephemeris with data file path
function initSwissEph() {
  const possiblePaths = [
    path.join(__dirname, '..', 'ephe'),
    path.join(__dirname, '..', '..', 'ephe'),
    '/usr/share/swisseph',
    process.env.SE_EPHE_PATH
  ].filter(Boolean);

  for (const ephePath of possiblePaths) {
    try {
      sweph.set_ephe_path(ephePath);
      // Test if path works by trying to calculate Sun position
      const jd = sweph.julday(2024, 1, 1, 12.0, SE_GREG_CAL);
      const result = sweph.calc_ut(jd, SE_SUN, SEFLG_SWIEPH);
      if (!result.error) {
        console.error(`✅ Swiss Ephemeris initialized with path: ${ephePath}`);
        return ephePath;
      }
    } catch {
      continue;
    }
  }

  console.error('⚠️  Warning: Swiss Ephemeris data files not found. Please run: npm run postinstall');
  return null;
}

// Initialize on module load
const EPHE_PATH = initSwissEph();

/**
 * Convert JavaScript Date to Julian Day (UT)
 */
function dateToJulianDay(date) {
  const year = date.getUTCFullYear();
  const month = date.getUTCMonth() + 1; // JS months are 0-indexed
  const day = date.getUTCDate();
  const hour = date.getUTCHours() + (date.getUTCMinutes() / 60.0) + (date.getUTCSeconds() / 3600.0);

  return sweph.julday(year, month, day, hour, SE_GREG_CAL);
}

/**
 * Get zodiac sign and degree from ecliptic longitude
 */
function getLongitudeInfo(longitude) {
  // Normalize to 0-360
  const normalizedLon = ((longitude % 360) + 360) % 360;
  const signIndex = Math.floor(normalizedLon / 30);
  const degree = normalizedLon % 30;

  return {
    sign: ZODIAC_SIGNS[signIndex],
    degree: parseFloat(degree.toFixed(2)),
    longitude: parseFloat(normalizedLon.toFixed(2))
  };
}

/**
 * Get current planetary positions
 */
export function getCurrentPositions(dateString = null) {
  const date = dateString ? new Date(dateString) : new Date();
  const jd = dateToJulianDay(date);
  const positions = {};

  PLANETS.forEach(planet => {
    try {
      const result = sweph.calc_ut(jd, planet.id, SEFLG_SWIEPH | SEFLG_SPEED);

      if (result.error) {
        console.error(`Error calculating ${planet.name}: ${result.error}`);
        return;
      }

      const longitude = result.data[0]; // Ecliptic longitude
      const latitude = result.data[1];  // Ecliptic latitude
      const speed = result.data[3];     // Daily motion in longitude

      const lonInfo = getLongitudeInfo(longitude);

      positions[planet.name] = {
        sign: lonInfo.sign,
        degree: lonInfo.degree,
        longitude: lonInfo.longitude,
        latitude: parseFloat(latitude.toFixed(2)),
        speed: parseFloat(speed.toFixed(4)),
        isDirect: speed >= 0
      };
    } catch (error) {
      console.error(`Exception calculating ${planet.name}:`, error);
    }
  });

  return {
    timestamp: date.toISOString(),
    julianDay: jd,
    positions
  };
}

/**
 * Get moon phase information
 */
export function getMoonPhase(dateString = null) {
  const date = dateString ? new Date(dateString) : new Date();
  const jd = dateToJulianDay(date);

  try {
    // Get Sun and Moon positions
    const sunResult = sweph.calc_ut(jd, SE_SUN, SEFLG_SWIEPH);
    const moonResult = sweph.calc_ut(jd, SE_MOON, SEFLG_SWIEPH);

    if (sunResult.error || moonResult.error) {
      throw new Error(sunResult.error || moonResult.error);
    }

    const sunLon = sunResult.data[0];
    const moonLon = moonResult.data[0];

    // Calculate phase angle (0-360)
    let phaseAngle = moonLon - sunLon;
    if (phaseAngle < 0) phaseAngle += 360;

    // Calculate illumination (0-100%)
    const illumination = (1 - Math.cos((phaseAngle * Math.PI) / 180)) / 2 * 100;

    // Determine phase name
    let phaseName;
    if (phaseAngle < 22.5 || phaseAngle >= 337.5) phaseName = 'New Moon';
    else if (phaseAngle < 67.5) phaseName = 'Waxing Crescent';
    else if (phaseAngle < 112.5) phaseName = 'First Quarter';
    else if (phaseAngle < 157.5) phaseName = 'Waxing Gibbous';
    else if (phaseAngle < 202.5) phaseName = 'Full Moon';
    else if (phaseAngle < 247.5) phaseName = 'Waning Gibbous';
    else if (phaseAngle < 292.5) phaseName = 'Last Quarter';
    else phaseName = 'Waning Crescent';

    const moonLonInfo = getLongitudeInfo(moonLon);

    return {
      timestamp: date.toISOString(),
      phaseName,
      phaseAngle: parseFloat(phaseAngle.toFixed(2)),
      illumination: parseFloat(illumination.toFixed(1)),
      sign: moonLonInfo.sign,
      degree: moonLonInfo.degree,
      isWaxing: phaseAngle < 180,
      interpretation: getMoonPhaseInterpretation(phaseName, moonLonInfo.sign)
    };
  } catch (error) {
    console.error('Error calculating moon phase:', error);
    throw error;
  }
}

/**
 * Get planetary aspects
 */
export function getPlanetaryAspects(dateString = null, orb = 8) {
  const _date = dateString ? new Date(dateString) : new Date();
  const positions = getCurrentPositions(dateString).positions;
  const aspects = [];

  const planetNames = Object.keys(positions);

  // Check all planet pairs
  for (let i = 0; i < planetNames.length; i++) {
    for (let j = i + 1; j < planetNames.length; j++) {
      const planet1 = planetNames[i];
      const planet2 = planetNames[j];

      const lon1 = positions[planet1].longitude;
      const lon2 = positions[planet2].longitude;

      let angle = Math.abs(lon1 - lon2);
      if (angle > 180) angle = 360 - angle;

      // Check for major aspects
      const aspectTypes = [
        { name: 'conjunction', angle: 0, orb },
        { name: 'opposition', angle: 180, orb },
        { name: 'trine', angle: 120, orb },
        { name: 'square', angle: 90, orb },
        { name: 'sextile', angle: 60, orb: 6 }
      ];

      aspectTypes.forEach(aspectType => {
        const diff = Math.abs(angle - aspectType.angle);
        if (diff <= aspectType.orb) {
          aspects.push({
            planet1,
            planet2,
            type: aspectType.name,
            angle: parseFloat(angle.toFixed(2)),
            orb: parseFloat(diff.toFixed(2)),
            applying: isAspectApplying(positions[planet1], positions[planet2], aspectType.angle),
            interpretation: getAspectInterpretation(planet1, planet2, aspectType.name)
          });
        }
      });
    }
  }

  return aspects.sort((a, b) => a.orb - b.orb);
}

/**
 * Check if aspect is applying (planets moving together) or separating
 */
function isAspectApplying(planet1Pos, planet2Pos, _targetAngle) {
  // If planet1 is faster and behind, or planet2 is faster and behind, aspect is applying
  const speedDiff = planet1Pos.speed - planet2Pos.speed;
  let lonDiff = planet1Pos.longitude - planet2Pos.longitude;
  if (lonDiff < 0) lonDiff += 360;

  // Simplified check - more complex logic needed for exact determination
  return Math.abs(speedDiff) > 0.01;
}

/**
 * Get planets in retrograde
 */
export function getRetrogradePlanets(dateString = null) {
  const _date = dateString ? new Date(dateString) : new Date();
  const positions = getCurrentPositions(dateString).positions;
  const retrogrades = [];

  // Check Mercury through Pluto (not Sun/Moon)
  const retroPlanets = ['Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune', 'Pluto'];

  retroPlanets.forEach(planetName => {
    const planetPos = positions[planetName];
    if (planetPos && planetPos.speed < 0) {
      retrogrades.push({
        planet: planetName,
        sign: planetPos.sign,
        degree: planetPos.degree,
        speed: planetPos.speed,
        interpretation: getRetrogradeInterpretation(planetName)
      });
    }
  });

  return retrogrades;
}

/**
 * Get complete ephemeris snapshot for a reading
 */
export function getEphemerisForReading(timestamp) {
  const date = new Date(timestamp);

  return {
    timestamp: date.toISOString(),
    positions: getCurrentPositions(timestamp).positions,
    moon: getMoonPhase(timestamp),
    aspects: getPlanetaryAspects(timestamp),
    retrogrades: getRetrogradePlanets(timestamp),
    readingContext: generateReadingContext(date),
    ephemerisPath: EPHE_PATH
  };
}

/**
 * Generate astrological context for a reading
 */
function generateReadingContext(date) {
  const positions = getCurrentPositions(date.toISOString()).positions;
  const moon = getMoonPhase(date.toISOString());
  const aspects = getPlanetaryAspects(date.toISOString());
  const retrogrades = getRetrogradePlanets(date.toISOString());

  const context = [];

  // Moon phase context
  context.push(`Moon in ${moon.sign} (${moon.phaseName})`);

  // Sun sign
  context.push(`Sun in ${positions.Sun.sign}`);

  // Key aspects
  const majorAspects = aspects.filter(a => a.orb < 3);
  if (majorAspects.length > 0) {
    context.push(`Active aspects: ${majorAspects.slice(0, 3).map(a =>
      `${a.planet1}-${a.planet2} ${a.type}`
    ).join(', ')}`);
  }

  // Retrogrades
  if (retrogrades.length > 0) {
    context.push(`Retrograde: ${retrogrades.map(r => r.planet).join(', ')}`);
  }

  return context.join(' | ');
}

/**
 * Interpretation helpers
 */
function getMoonPhaseInterpretation(phaseName, sign) {
  const phaseInterpretations = {
    'New Moon': 'Beginnings, seeds, intentions',
    'Waxing Crescent': 'Initial growth, faith required',
    'First Quarter': 'Action, decision, commitment',
    'Waxing Gibbous': 'Refinement, adjustment, development',
    'Full Moon': 'Culmination, revelation, illumination',
    'Waning Gibbous': 'Gratitude, sharing, dissemination',
    'Last Quarter': 'Re-orientation, crisis of consciousness',
    'Waning Crescent': 'Release, surrender, transition'
  };

  return `${phaseInterpretations[phaseName]} in ${sign}`;
}

function getAspectInterpretation(planet1, planet2, aspectType) {
  const interpretations = {
    conjunction: 'Fusion, blending, new cycle',
    opposition: 'Awareness, balance, integration',
    trine: 'Flow, ease, natural expression',
    square: 'Tension, growth, breakthrough',
    sextile: 'Opportunity, connection, skill'
  };

  return `${planet1}-${planet2}: ${interpretations[aspectType]}`;
}

function getRetrogradeInterpretation(planet) {
  const interpretations = {
    Mercury: 'Review communication, rethink plans, revisit details',
    Venus: 'Reevaluate relationships, reassess values, rediscover pleasure',
    Mars: 'Redirect energy, reconsider actions, internal drive',
    Jupiter: 'Internal expansion, philosophical review, reassess beliefs',
    Saturn: 'Structural review, karmic rework, authority reassessment',
    Uranus: 'Internal revolution, personal liberation, authentic change',
    Neptune: 'Spiritual deepening, dissolving illusions, inner mysticism',
    Pluto: 'Deep transformation, power reclamation, shadow integration'
  };

  return interpretations[planet] || 'Retrograde energy';
}

// Cleanup function (call when shutting down)
export function closeEphemeris() {
  sweph.close();
}
</file>

<file path="plugins/tarot-astro-plugins/ephemeris-server/server/index.js">
#!/usr/bin/env node

/**
 * Ephemeris MCP Server
 * Provides real-time astronomical data for tarot readings
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';

import {
  getCurrentPositions,
  getMoonPhase,
  getPlanetaryAspects,
  getRetrogradePlanets,
  getEphemerisForReading
} from './ephemeris.js';

const server = new Server(
  {
    name: 'ephemeris-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'get_current_positions',
        description: 'Get current planetary positions (sign, degree, house)',
        inputSchema: {
          type: 'object',
          properties: {},
        },
      },
      {
        name: 'get_moon_phase',
        description: 'Get current moon phase, illumination percentage, and sign placement',
        inputSchema: {
          type: 'object',
          properties: {
            date: {
              type: 'string',
              description: 'Optional ISO date string. Defaults to now.',
            },
          },
        },
      },
      {
        name: 'get_planetary_aspects',
        description: 'Get active planetary aspects (conjunctions, squares, trines, etc.)',
        inputSchema: {
          type: 'object',
          properties: {
            date: {
              type: 'string',
              description: 'Optional ISO date string. Defaults to now.',
            },
            orb: {
              type: 'number',
              description: 'Orb in degrees (default: 8)',
              default: 8,
            },
          },
        },
      },
      {
        name: 'get_retrograde_planets',
        description: 'Get list of planets currently in retrograde motion',
        inputSchema: {
          type: 'object',
          properties: {
            date: {
              type: 'string',
              description: 'Optional ISO date string. Defaults to now.',
            },
          },
        },
      },
      {
        name: 'get_ephemeris_for_reading',
        description: 'Get complete astrological snapshot for a tarot reading timestamp',
        inputSchema: {
          type: 'object',
          properties: {
            timestamp: {
              type: 'string',
              description: 'ISO timestamp of the reading',
              required: true,
            },
          },
          required: ['timestamp'],
        },
      },
      {
        name: 'get_daily_astrological_weather',
        description: 'Get overall astrological "weather" - key transits and themes for the day',
        inputSchema: {
          type: 'object',
          properties: {
            date: {
              type: 'string',
              description: 'Optional ISO date string. Defaults to today.',
            },
          },
        },
      },
    ],
  };
});

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case 'get_current_positions':
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(getCurrentPositions(), null, 2),
            },
          ],
        };

      case 'get_moon_phase':
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(getMoonPhase(args?.date), null, 2),
            },
          ],
        };

      case 'get_planetary_aspects':
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(
                getPlanetaryAspects(args?.date, args?.orb),
                null,
                2
              ),
            },
          ],
        };

      case 'get_retrograde_planets':
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(getRetrogradePlanets(args?.date), null, 2),
            },
          ],
        };

      case 'get_ephemeris_for_reading':
        if (!args?.timestamp) {
          throw new Error('timestamp is required');
        }
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(
                getEphemerisForReading(args.timestamp),
                null,
                2
              ),
            },
          ],
        };

      case 'get_daily_astrological_weather': {
        const positions = getCurrentPositions(args?.date);
        const aspects = getPlanetaryAspects(args?.date);
        const moon = getMoonPhase(args?.date);
        const retrogrades = getRetrogradePlanets(args?.date);

        const weather = {
          date: args?.date || new Date().toISOString(),
          moon,
          retrogrades,
          majorAspects: aspects.filter((a) => a.orb < 3),
          keyTransits: identifyKeyTransits(positions, aspects),
          dailyTheme: generateDailyTheme(positions, aspects, moon, retrogrades),
        };

        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(weather, null, 2),
            },
          ],
        };
      }

      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({ error: error.message }, null, 2),
        },
      ],
      isError: true,
    };
  }
});

// Helper functions
function identifyKeyTransits(positions, aspects) {
  const keyTransits = [];

  // Look for significant aspects
  aspects.forEach((aspect) => {
    if (aspect.orb < 2 && aspect.type !== 'sextile') {
      keyTransits.push({
        type: 'aspect',
        description: `${aspect.planet1} ${aspect.type} ${aspect.planet2}`,
        significance: aspect.type === 'conjunction' ? 'high' : 'medium',
      });
    }
  });

  // Check for sign changes (planets at 0-2 degrees)
  Object.entries(positions).forEach(([planet, data]) => {
    if (data.degree < 2) {
      keyTransits.push({
        type: 'ingress',
        description: `${planet} entering ${data.sign}`,
        significance: 'medium',
      });
    }
  });

  return keyTransits;
}

function generateDailyTheme(positions, aspects, moon, retrogrades) {
  const themes = [];

  // Moon phase influence
  if (moon.phase === 'New Moon') {
    themes.push('Beginnings, intention-setting, new cycles');
  } else if (moon.phase === 'Full Moon') {
    themes.push('Culmination, revelation, release');
  } else if (moon.phaseName.includes('Waxing')) {
    themes.push('Growth, building, expansion');
  } else {
    themes.push('Release, reflection, integration');
  }

  // Retrograde influence
  if (retrogrades.length > 0) {
    themes.push(`Reflection and review (${retrogrades.length} retrograde${retrogrades.length > 1 ? 's' : ''})`);
  }

  // Major aspects
  const squares = aspects.filter((a) => a.type === 'square' && a.orb < 3);
  const trines = aspects.filter((a) => a.type === 'trine' && a.orb < 3);

  if (squares.length > 0) {
    themes.push('Tension requiring resolution, growth through challenge');
  }
  if (trines.length > 0) {
    themes.push('Flow, ease, natural talents emerging');
  }

  return themes.join('; ');
}

// Start the server
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('Ephemeris MCP server running on stdio');
}

main().catch((error) => {
  console.error('Server error:', error);
  process.exit(1);
});
</file>

<file path="plugins/tarot-astro-plugins/ephemeris-server/server/test.js">
#!/usr/bin/env node

/**
 * Simple test script for Swiss Ephemeris calculations
 */

import {
  getCurrentPositions,
  getMoonPhase,
  getPlanetaryAspects,
  getRetrogradePlanets,
  getEphemerisForReading
} from './ephemeris.js';

console.log('🧪 Testing Swiss Ephemeris Calculations\n');
console.log('=' .repeat(60));

try {
  console.log('\n1️⃣  Current Planetary Positions:');
  console.log('-'.repeat(60));
  const positions = getCurrentPositions();
  console.log(`Timestamp: ${positions.timestamp}`);
  console.log(`Julian Day: ${positions.julianDay}\n`);

  Object.entries(positions.positions).forEach(([planet, data]) => {
    const direction = data.isDirect ? '→' : '℞';
    console.log(`${planet.padEnd(10)} ${data.sign.padEnd(12)} ${data.degree.toFixed(2)}° ${direction} (speed: ${data.speed.toFixed(4)})`);
  });

  console.log('\n2️⃣  Moon Phase:');
  console.log('-'.repeat(60));
  const moon = getMoonPhase();
  console.log(`Phase: ${moon.phaseName}`);
  console.log(`Illumination: ${moon.illumination}%`);
  console.log(`Sign: ${moon.sign} ${moon.degree.toFixed(2)}°`);
  console.log(`Waxing: ${moon.isWaxing ? 'Yes' : 'No'}`);
  console.log(`Interpretation: ${moon.interpretation}`);

  console.log('\n3️⃣  Planetary Aspects (orb < 5°):');
  console.log('-'.repeat(60));
  const aspects = getPlanetaryAspects(null, 8);
  const tightAspects = aspects.filter(a => a.orb < 5);

  if (tightAspects.length === 0) {
    console.log('No tight aspects found.');
  } else {
    tightAspects.slice(0, 10).forEach(aspect => {
      const applying = aspect.applying ? '→' : '←';
      console.log(`${aspect.planet1} ${aspect.type} ${aspect.planet2} (orb: ${aspect.orb.toFixed(2)}°) ${applying}`);
      console.log(`  ${aspect.interpretation}`);
    });
  }

  console.log('\n4️⃣  Retrograde Planets:');
  console.log('-'.repeat(60));
  const retrogrades = getRetrogradePlanets();

  if (retrogrades.length === 0) {
    console.log('No planets currently retrograde.');
  } else {
    retrogrades.forEach(retro => {
      console.log(`${retro.planet} ℞ in ${retro.sign} ${retro.degree.toFixed(2)}°`);
      console.log(`  ${retro.interpretation}`);
    });
  }

  console.log('\n5️⃣  Complete Reading Context:');
  console.log('-'.repeat(60));
  const reading = getEphemerisForReading(new Date().toISOString());
  console.log(reading.readingContext);
  console.log(`\nEphemeris data path: ${reading.ephemerisPath || 'NOT FOUND'}`);

  console.log('\n' + '='.repeat(60));
  console.log('✅ All tests completed successfully!\n');

} catch (error) {
  console.error('\n❌ Test failed:', error.message);
  console.error('\nMake sure you have:');
  console.error('1. Installed dependencies: npm install');
  console.error('2. Downloaded ephemeris files: see EPHEMERIS_DATA_README.md');
  console.error('3. Native build tools installed (node-gyp requirements)\n');
  process.exit(1);
}
</file>

<file path="plugins/tarot-astro-plugins/ephemeris-server/EPHEMERIS_DATA_README.md">
# Swiss Ephemeris Data Files

This server requires Swiss Ephemeris data files for astronomical calculations.

## Quick Setup

### Option 1: Download Essential Files (Recommended)

Download the minimal required files for planetary calculations:

```bash
# Create data directory
mkdir -p /home/azureuser/tarot/plugins/tarot-astro-plugins/ephemeris-server/ephe

# Download essential planetary files (planets 1800-2400)
cd /home/azureuser/tarot/plugins/tarot-astro-plugins/ephemeris-server/ephe
curl -O https://www.astro.com/ftp/swisseph/ephe/sepl_18.se1
curl -O https://www.astro.com/ftp/swisseph/ephe/semo_18.se1

# Or use wget
wget https://www.astro.com/ftp/swisseph/ephe/sepl_18.se1
wget https://www.astro.com/ftp/swisseph/ephe/semo_18.se1
```

### Option 2: Download Complete Dataset

For extended date ranges and asteroid support:

```bash
# Download all files (warning: ~200MB)
cd /home/azureuser/tarot/plugins/tarot-astro-plugins/ephemeris-server/ephe
wget -r -np -nH --cut-dirs=3 -R "index.html*" https://www.astro.com/ftp/swisseph/ephe/
```

## File Types

### Essential Files (Required)

- **sepl_18.se1** - Planets 1800-2400 AD (main planets, ~3MB)
- **semo_18.se1** - Moon 1800-2400 AD (~8MB)

### Extended Files (Optional)

- **sepl_*.se1** - Planets for different date ranges:
  - sepl_00.se1: 0-600 AD
  - sepl_06.se1: 600-1200 AD
  - sepl_12.se1: 1200-1800 AD
  - sepl_24.se1: 2400-3000 AD

- **seas_18.se1** - Asteroids 1800-2400 AD (for asteroid calculations)

## Configuration

The server automatically looks for data files in:

1. `./ephe` (relative to server directory)
2. `./ephemeris-server/ephe` (plugin root)
3. `/usr/share/swisseph` (system-wide)
4. Environment variable: `SE_EPHE_PATH`

You can override the path by setting the environment variable:

```bash
export SE_EPHE_PATH=/path/to/your/ephe/files
```

Or in the `.mcp.json` configuration:

```json
{
  "mcpServers": {
    "ephemeris": {
      "type": "stdio",
      "command": "node",
      "args": ["${CLAUDE_PLUGIN_ROOT}/server/index.js"],
      "env": {
        "SE_EPHE_PATH": "${CLAUDE_PLUGIN_ROOT}/ephe"
      }
    }
  }
}
```

## Verifying Installation

After downloading the files, test the server:

```bash
# Navigate to plugin directory
cd /home/azureuser/tarot/plugins/tarot-astro-plugins/ephemeris-server

# Run the server test
npm test
```

You should see planetary positions calculated successfully.

## Date Ranges

Each file covers a specific date range:

| File Range | Dates Covered | File Prefix |
|------------|---------------|-------------|
| _00 | 0 - 600 AD | sepl_00, semo_00 |
| _06 | 600 - 1200 AD | sepl_06, semo_06 |
| _12 | 1200 - 1800 AD | sepl_12, semo_12 |
| _18 | 1800 - 2400 AD | sepl_18, semo_18 |
| _24 | 2400 - 3000 AD | sepl_24, semo_24 |

For tarot readings, **sepl_18.se1 and semo_18.se1** cover all modern dates (1800-2400).

## Troubleshooting

### "Ephemeris file not found" error

1. Check that files are downloaded:
   ```bash
   ls -lh ephe/
   ```

2. Verify file permissions:
   ```bash
   chmod 644 ephe/*.se1
   ```

3. Set explicit path:
   ```bash
   export SE_EPHE_PATH=/home/azureuser/tarot/plugins/tarot-astro-plugins/ephemeris-server/ephe
   ```

### Wrong date range

Download the appropriate file for your date range (see table above).

### Asteroid calculations failing

Download the asteroid ephemeris files (seas_*.se1).

## Sources

- **Swiss Ephemeris Data**: https://www.astro.com/ftp/swisseph/ephe/
- **Documentation**: https://www.astro.com/swisseph/
- **GitHub Repository**: https://github.com/aloistr/swisseph

## License

Swiss Ephemeris data files are based on JPL planetary ephemeris data (public domain)
and are distributed under the same license as the Swiss Ephemeris library (AGPL-3.0
or Professional License).

See the main LICENSE file for complete licensing information.
</file>

<file path="plugins/tarot-astro-plugins/ephemeris-server/LICENSE">
EPHEMERIS SERVER LICENSE

This MCP server uses the Swiss Ephemeris library via the 'sweph' Node.js package.

================================================================================
PLUGIN LICENSE (Except Swiss Ephemeris components)
================================================================================

MIT License

Copyright (c) 2024 Mystic Tarot

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================================================================================
SWISS EPHEMERIS LICENSE (sweph package)
================================================================================

This server depends on the Swiss Ephemeris library (via the 'sweph' npm package),
which is dual-licensed:

1. **AGPL-3.0 License** (Open Source)
   - Free for use in open-source projects
   - Requires derivative works to also be open-source under AGPL
   - Full license: https://www.gnu.org/licenses/agpl-3.0.html

2. **Professional License** (Commercial)
   - Required for proprietary/commercial software
   - Contact: https://www.astro.com/swisseph/

Since this plugin is distributed as open-source, it uses the AGPL-3.0 license
for the Swiss Ephemeris components.

IMPORTANT NOTES:

- If you use this plugin in a **closed-source or commercial application**, you
  must either:
  a) Make your entire application AGPL-3.0 compatible, OR
  b) Purchase a Professional License from Astrodienst AG

- If you distribute this plugin or derivative works, you must:
  a) Include this license file
  b) Provide source code access per AGPL-3.0 requirements
  c) Clearly indicate any modifications made

For more information about Swiss Ephemeris licensing:
https://www.astro.com/swisseph/

================================================================================
EPHEMERIS DATA FILES
================================================================================

This server requires Swiss Ephemeris data files, which are available from:
- https://github.com/aloistr/swisseph
- https://www.astro.com/ftp/swisseph/

These data files are based on JPL planetary ephemeris data (public domain)
and are distributed under the same license as the Swiss Ephemeris library.

================================================================================
USAGE GUIDANCE
================================================================================

This plugin is provided as an open-source tool for the Mystic Tarot application
and the broader tarot reading community.

✅ Permitted Use (Under AGPL-3.0):
- Personal tarot readings
- Open-source tarot applications
- Educational and research purposes
- Non-commercial astrological software
- Redistribution with source code (must remain AGPL)

⚠️ Restricted Use (Requires Professional License):
- Closed-source commercial applications
- Proprietary tarot reading services
- Mobile apps without source disclosure
- SaaS platforms without AGPL compliance

If you have questions about licensing compliance, please consult:
- AGPL-3.0 FAQ: https://www.gnu.org/licenses/gpl-faq.html
- Swiss Ephemeris Professional License: https://www.astro.com/swisseph/

================================================================================
</file>

<file path="plugins/tarot-astro-plugins/ephemeris-server/package.json">
{
  "name": "ephemeris-mcp-server",
  "version": "2.0.0",
  "description": "MCP server providing real-time astronomical data for tarot readings using Swiss Ephemeris",
  "type": "module",
  "main": "server/index.js",
  "scripts": {
    "start": "node server/index.js",
    "dev": "node --watch server/index.js",
    "test": "node server/test.js",
    "postinstall": "node scripts/check-ephemeris-files.js"
  },
  "keywords": ["mcp", "astrology", "ephemeris", "tarot", "astronomy", "swiss-ephemeris"],
  "author": "Mystic Tarot",
  "license": "SEE LICENSE IN LICENSE",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^0.5.0",
    "sweph": "2.10.3-b-1"
  },
  "engines": {
    "node": ">=16.0.0"
  }
}
</file>

<file path="plugins/tarot-astro-plugins/ephemeris-server/README.md">
# Ephemeris MCP Server

Real-time astronomical data for tarot readings. Provides planetary positions, moon phases, aspects, and astrological context.

## Features

- **Planetary Positions**: Current position of all planets by sign and degree
- **Moon Phases**: Detailed lunar data including phase, illumination, and interpretation
- **Planetary Aspects**: Detection of conjunctions, oppositions, squares, trines, and sextiles
- **Retrograde Detection**: Identifies planets in retrograde motion
- **Reading Snapshots**: Complete astrological context for any timestamp
- **Daily Weather**: Overview of key astrological themes and transits

## Installation

```bash
cd ephemeris-server
npm install
```

## Usage

This MCP server is automatically configured when the plugin is installed. Claude Code will have access to these tools:

### Available Tools

#### `get_current_positions()`
Returns current planetary positions for all planets.

**Example response:**
```json
{
  "timestamp": "2025-01-23T10:30:00.000Z",
  "positions": {
    "Sun": {
      "sign": "Aquarius",
      "degree": 3.45,
      "longitude": 303.45,
      "latitude": 0.0
    },
    "Moon": {
      "sign": "Pisces",
      "degree": 12.78,
      "longitude": 342.78,
      "latitude": 5.13
    }
    // ... all planets
  }
}
```

#### `get_moon_phase(date?)`
Get moon phase information for a specific date.

**Parameters:**
- `date` (optional): ISO date string

**Example response:**
```json
{
  "timestamp": "2025-01-23T10:30:00.000Z",
  "phaseName": "Waxing Gibbous",
  "phaseAngle": 142.5,
  "illumination": 87.3,
  "sign": "Pisces",
  "degree": 12.78,
  "isWaxing": true,
  "interpretation": "Refinement, adjustment, development in Pisces"
}
```

#### `get_planetary_aspects(date?, orb?)`
Get active planetary aspects.

**Parameters:**
- `date` (optional): ISO date string
- `orb` (optional): Orb in degrees (default: 8)

**Example response:**
```json
[
  {
    "planet1": "Sun",
    "planet2": "Mars",
    "type": "square",
    "angle": 89.2,
    "orb": 0.8,
    "interpretation": "Sun-Mars: Tension, growth, breakthrough"
  }
]
```

#### `get_retrograde_planets(date?)`
Get planets currently in retrograde.

**Example response:**
```json
[
  {
    "planet": "Mercury",
    "sign": "Capricorn",
    "degree": 15.23,
    "interpretation": "Review communication, rethink plans, revisit details"
  }
]
```

#### `get_ephemeris_for_reading(timestamp)`
Complete astrological snapshot for a reading.

**Parameters:**
- `timestamp` (required): ISO timestamp of the reading

**Example response:**
```json
{
  "timestamp": "2025-01-23T10:30:00.000Z",
  "positions": { /* all planetary positions */ },
  "moon": { /* moon phase data */ },
  "aspects": [ /* all aspects */ ],
  "retrogrades": [ /* retrograde planets */ ],
  "readingContext": "Moon in Pisces (Waxing Gibbous) | Sun in Aquarius | Active aspects: Sun-Mars square | Retrograde: Mercury"
}
```

#### `get_daily_astrological_weather(date?)`
Overview of daily astrological themes.

**Example response:**
```json
{
  "date": "2025-01-23T00:00:00.000Z",
  "moon": { /* moon data */ },
  "retrogrades": [ /* retrograde planets */ ],
  "majorAspects": [ /* tight aspects */ ],
  "keyTransits": [
    {
      "type": "aspect",
      "description": "Sun square Mars",
      "significance": "medium"
    }
  ],
  "dailyTheme": "Growth, building, expansion; Reflection and review (1 retrograde); Tension requiring resolution, growth through challenge"
}
```

## Integration with Tarot Readings

### Automatic Context
When enabled, this plugin adds astrological context to every reading:

```javascript
// In your reading function
const astroContext = await getEphemerisForReading(readingTimestamp);

// Include in narrative generation
const prompt = `
Reading performed at: ${astroContext.readingContext}

Moon phase: ${astroContext.moon.phaseName} in ${astroContext.moon.sign}
- ${astroContext.moon.interpretation}

Active planetary energies:
${astroContext.aspects.slice(0, 3).map(a => `- ${a.interpretation}`).join('\n')}

Consider these cosmic influences when interpreting the cards...
`;
```

### Example Reading Enhancement

**Without astrological context:**
> "The Tower suggests sudden change and breakthrough."

**With astrological context:**
> "The Tower suggests sudden change and breakthrough. With Mars square Uranus active today (exact within 1°), this energy of sudden shifts and liberation is amplified in the collective field. The Waning Moon in Scorpio supports the release of what no longer serves."

## Astrological Interpretation Guide

### Moon Phases
- **New Moon**: Planting seeds, setting intentions, new beginnings
- **Waxing Crescent**: Faith, initial growth, following impulses
- **First Quarter**: Action, decisions, overcoming obstacles
- **Waxing Gibbous**: Refinement, development, trust the process
- **Full Moon**: Culmination, revelation, maximum illumination
- **Waning Gibbous**: Sharing, gratitude, teaching
- **Last Quarter**: Re-evaluation, release, letting go
- **Waning Crescent**: Surrender, rest, preparation for renewal

### Major Aspects
- **Conjunction (0°)**: Fusion, new cycles, concentrated energy
- **Opposition (180°)**: Awareness, balance, integration of opposites
- **Trine (120°)**: Flow, ease, natural talents, harmony
- **Square (90°)**: Tension, growth, necessary challenges
- **Sextile (60°)**: Opportunities, connections, skillful expression

### Retrograde Themes
Retrograde periods invite internal processing and review in the planet's domain:
- **Mercury Rx**: Communication, technology, plans, details
- **Venus Rx**: Relationships, values, aesthetics, self-worth
- **Mars Rx**: Action, desire, energy, assertion
- **Jupiter Rx**: Beliefs, growth, philosophy, meaning
- **Saturn Rx**: Structure, responsibility, authority, karma
- **Uranus Rx**: Change, freedom, authenticity, revolution
- **Neptune Rx**: Spirituality, illusions, dreams, boundaries
- **Pluto Rx**: Power, transformation, shadow work, control

## Technical Details

### Dependencies
- `astronomy-engine`: High-precision astronomical calculations
- `@modelcontextprotocol/sdk`: MCP server framework

### Accuracy
Uses Swiss Ephemeris algorithms via astronomy-engine for accurate planetary positions (precision: ±0.1°).

### Performance
All calculations are performed in real-time with minimal latency (<10ms per query).

## License

MIT
</file>

<file path="plugins/tarot-astro-plugins/symbolism-server/.claude-plugin/plugin.json">
{
  "name": "symbolism-server",
  "version": "1.0.0",
  "description": "Comprehensive symbolism reference database for tarot card interpretation",
  "author": {
    "name": "Mystic Tarot",
    "email": "dev@mystictarot.app"
  },
  "license": "MIT",
  "keywords": ["symbolism", "tarot", "interpretation", "imagery", "archetypes"],
  "mcpServers": "./.mcp.json"
}
</file>

<file path="plugins/tarot-astro-plugins/symbolism-server/commands/symbol-analysis.md">
---
description: Deep symbolic analysis of tarot card imagery
---

# Symbol Analysis for Tarot Cards

Provide comprehensive symbolic interpretation of imagery in tarot cards.

## Instructions

When the user requests symbol analysis for a card (or cards), follow this process:

1. **Identify the symbols present** in the card(s)
   - Ask the user which card(s) they want analyzed if not specified
   - If analyzing Rider-Waite cards, recall the common symbols in each card

2. **Use the symbolism MCP tools** to gather meanings:
   - Use `interpret_card_symbols` for multi-symbol synthesis
   - Use `get_symbol` for detailed individual symbol meanings
   - Use `get_color_meanings` to analyze the color palette
   - Use `get_numerological_insight` for number symbolism
   - Use `get_related_symbols` to explore thematic connections

3. **Present findings in this layered format:**

```
🔮 Symbolic Analysis: [Card Name]

**Primary Symbols:**

[Symbol 1 - Name]
• Keywords: [list keywords]
• General meaning: [general interpretation]
• In this card: [specific to this card's context]
• Archetypal resonance: [deeper archetypal meaning]

[Symbol 2 - Name]
• Keywords: [list keywords]
• General meaning: [general interpretation]
• In this card: [specific to this card's context]
• Archetypal resonance: [deeper archetypal meaning]

**Color Symbolism:**
The card's palette of [colors] creates an energetic signature of [interpretation].

**Numerological Insight:**
[Card number/position meaning and significance]

**Symbolic Synthesis:**
[Weave the symbols together into a coherent interpretation, identifying dominant themes and how symbols interact/reinforce each other]

**Interpretive Guidance:**
When reading this card, pay special attention to [key symbols] as they hold the core message. The interplay between [symbol A] and [symbol B] suggests [synthesis].
```

4. **Make it interactive:**
   - Invite deeper exploration: "Would you like me to explore any specific symbol further?"
   - Offer thematic connections: "I can find other symbols related to [theme] if you'd like"
   - Connect to reading context: "How does this symbolic language speak to your question?"

## Example

User: "/symbol-analysis The High Priestess"

Response:
```
🔮 Symbolic Analysis: The High Priestess

**Primary Symbols:**

Pomegranate
• Keywords: underworld, knowledge, abundance, fertility, Persephone
• General meaning: Underworld mysteries, sacred knowledge, abundant fertility
• In this card: The veil decorated with pomegranates represents the threshold between conscious and unconscious, the abundance of wisdom hidden behind the veil
• Archetypal resonance: Seeds of wisdom, descent into the underworld, hidden abundance

Moon at Her Feet
• Keywords: unconscious, intuition, cycles, feminine, mystery
• General meaning: The unconscious, intuition, cycles, dreams, the feminine
• In this card: The crescent moon represents her dominion over the unconscious realms and the cyclical nature of hidden wisdom
• Archetypal resonance: The divine feminine, lunar mysteries, cyclical wisdom

Pillars (Black & White)
• Keywords: duality, balance, threshold, opposites, gateway
• General meaning: The balance of opposites, the gateway between worlds
• In this card: Boaz and Jachin - the pillars of Solomon's temple, representing duality that must be balanced to access wisdom
• Archetypal resonance: The pillars of manifestation, positive and negative forces in balance

**Color Symbolism:**
The card's palette of blue, white, and black creates an energetic signature of deep intuition (blue), pure spiritual wisdom (white), and the mysterious void of infinite potential (black). This combination suggests accessing pure wisdom through the depths of the unconscious.

**Numerological Insight:**
As card II (2), The High Priestess embodies duality, relationship, balance of opposites, and the reflective nature of wisdom. The number 2 represents the first division from unity - awareness through reflection.

**Symbolic Synthesis:**
The High Priestess sits at the threshold between opposites (black/white pillars), veiled by pomegranates (hidden wisdom), with the moon at her feet (unconscious mastery). She holds the Torah (divine law/wisdom) partially hidden, suggesting that true wisdom must be accessed through intuition and inner knowing, not just intellectual study. The water behind her represents the unconscious realm she guards and mediates.

The dominant themes are: threshold consciousness, hidden wisdom, intuitive knowing, balance of opposites, and the feminine principle of receptive understanding.

**Interpretive Guidance:**
When reading this card, pay special attention to the veil and pomegranates - they indicate that the wisdom sought is available but requires you to look beyond the obvious, to trust intuition over pure logic. The interplay between the pillars and the veil suggests that accessing this wisdom requires balancing opposites and being willing to sit in the space between.
```

## Important Notes

- Use actual MCP tool data - don't fabricate symbol meanings
- Synthesize multiple symbols into coherent interpretation
- Connect symbols to the specific card's context
- Layer meanings: keyword → general → card-specific → archetypal
- Always tie analysis back to practical reading guidance
- Respect that symbols can have multiple valid interpretations
- Acknowledge cultural and traditional sources of symbolism
</file>

<file path="plugins/tarot-astro-plugins/symbolism-server/data/symbols.json">
{
  "animals": {
    "dog": {
      "keywords": ["loyalty", "instinct", "companionship", "guidance", "protection"],
      "meanings": {
        "general": "Faithful companion, instinctual wisdom, guardian of the threshold",
        "tarot": "Appears in The Fool and The Moon - represents instinct, loyalty, and the animal nature that guides us",
        "archetypal": "Cerberus, Anubis - guardian between worlds, psychopomp, trusted guide"
      },
      "cultural_context": "Cross-culturally associated with fidelity, protection, and the bridge between human and natural realms"
    },
    "wolf": {
      "keywords": ["wildness", "shadow", "instinct", "lunar", "pack consciousness"],
      "meanings": {
        "general": "Untamed nature, lunar mysteries, pack wisdom, shadow integration",
        "tarot": "The Moon - the wild, untamed aspects of consciousness that emerge in darkness",
        "archetypal": "Fenrir, Romulus and Remus - wild nature that can destroy or nurture"
      },
      "cultural_context": "Symbol of the wild, the untamed, and the mysterious lunar forces"
    },
    "crayfish": {
      "keywords": ["emergence", "primordial", "unconscious", "vulnerable", "evolution"],
      "meanings": {
        "general": "Emergence from the depths, primordial consciousness, evolutionary impulse",
        "tarot": "The Moon - the primitive, instinctual self emerging from the unconscious waters",
        "archetypal": "The primordial creature, the evolutionary impulse from water to land"
      },
      "cultural_context": "Ancient symbol of evolution, emergence, and the journey from unconscious to conscious"
    },
    "lion": {
      "keywords": ["courage", "strength", "solar", "mastery", "heart"],
      "meanings": {
        "general": "Courage, raw power tamed through love, solar majesty, heart-centered strength",
        "tarot": "Strength - the union of gentleness and power, taming through love not force",
        "archetypal": "The Solar Lion, Sekhmet, Heart of the King"
      },
      "cultural_context": "Universal symbol of courage, nobility, and the power of the heart"
    },
    "serpent": {
      "keywords": ["transformation", "kundalini", "wisdom", "healing", "renewal"],
      "meanings": {
        "general": "Transformation, shedding old skins, primal energy, healing wisdom",
        "tarot": "The Magician, The Lovers - life force, temptation, transformation",
        "archetypal": "Ouroboros, Kundalini, Caduceus - eternal renewal, primordial wisdom"
      },
      "cultural_context": "Ancient symbol of transformation, healing, and the cycle of death and rebirth"
    },
    "eagle": {
      "keywords": ["vision", "spiritual", "ascension", "clarity", "sovereignty"],
      "meanings": {
        "general": "Higher perspective, spiritual vision, ascension, seeing the whole",
        "tarot": "The Empress, The Wheel - divine perspective, spiritual sovereignty",
        "archetypal": "Zeus's eagle, Solar bird, Messenger of the gods"
      },
      "cultural_context": "Symbol of spiritual vision, divine authority, and the ability to see from above"
    },
    "dove": {
      "keywords": ["peace", "spirit", "purity", "love", "messenger"],
      "meanings": {
        "general": "Peace, Holy Spirit, pure love, divine messenger",
        "tarot": "The Lovers, The Star - spiritual love, divine grace, purity",
        "archetypal": "Holy Spirit, Aphrodite's bird, Messenger of peace"
      },
      "cultural_context": "Universal symbol of peace, divine spirit, and pure love"
    },
    "ram": {
      "keywords": ["initiative", "yang", "fire", "leadership", "Aries"],
      "meanings": {
        "general": "Initiative, primal masculine force, breaking new ground, leadership",
        "tarot": "The Emperor - masculine authority, initiative, primal force",
        "archetypal": "Aries, The Golden Fleece, Sacrifice and renewal"
      },
      "cultural_context": "Symbol of initiative, masculine force, and the courage to lead"
    },
    "bull": {
      "keywords": ["earthly", "fertility", "Taurus", "strength", "stability"],
      "meanings": {
        "general": "Earthly power, fertility, stability, material strength",
        "tarot": "The Hierophant - earthly authority, traditional power, stability",
        "archetypal": "Apis Bull, Minotaur, Earth strength"
      },
      "cultural_context": "Ancient symbol of earthly fertility, power, and the sacredness of the material"
    },
    "crab": {
      "keywords": ["home", "protection", "Cancer", "emotional", "shell"],
      "meanings": {
        "general": "Protection, emotional boundaries, home, the shell we carry",
        "tarot": "The Chariot - protective shell, emotional armor, carrying home with you",
        "archetypal": "The Sacred Shell, Cancer, Emotional protection"
      },
      "cultural_context": "Symbol of emotional protection, home, and the boundaries we create"
    },
    "horse": {
      "keywords": ["power", "freedom", "journey", "nobility", "spirit"],
      "meanings": {
        "general": "Spiritual power, freedom, the journey, noble spirit",
        "tarot": "Death, The Sun - transformation vehicle, solar vitality, spiritual journey",
        "archetypal": "Pegasus, Sleipnir, Vehicles of the gods"
      },
      "cultural_context": "Symbol of spiritual power, freedom, and the vehicle of transformation"
    },
    "sphinx": {
      "keywords": ["riddle", "mystery", "guardian", "wisdom", "four-fold"],
      "meanings": {
        "general": "Keeper of mysteries, riddle of existence, guardian of wisdom",
        "tarot": "The Wheel of Fortune - the mystery of fate, the riddle of existence",
        "archetypal": "Guardian of thresholds, Keeper of mysteries, Four elements united"
      },
      "cultural_context": "Ancient guardian of sacred knowledge and the mysteries of existence"
    }
  },
  "colors": {
    "red": {
      "keywords": ["passion", "fire", "energy", "life-force", "action"],
      "meanings": {
        "general": "Vital energy, passion, blood, life force, action, desire",
        "psychological": "Stimulating, energizing, can signify anger or passion",
        "spiritual": "Root chakra, grounding, survival, physical vitality",
        "elemental": "Fire - transformation, will, creative power"
      },
      "associations": ["Mars", "Aries", "Wands suit", "Strength", "Magician"]
    },
    "blue": {
      "keywords": ["water", "emotion", "intuition", "depth", "spirit"],
      "meanings": {
        "general": "Depth, emotion, intuition, spiritual waters, inner truth",
        "psychological": "Calming, introspective, emotional depth",
        "spiritual": "Throat chakra, truth, communication, the divine feminine",
        "elemental": "Water - emotion, flow, intuition, the unconscious"
      },
      "associations": ["Moon", "Cancer", "Cups suit", "High Priestess", "Hanged Man"]
    },
    "yellow": {
      "keywords": ["intellect", "clarity", "air", "joy", "consciousness"],
      "meanings": {
        "general": "Mental clarity, consciousness, joy, illumination, intellect",
        "psychological": "Optimistic, stimulating to the mind, clear thinking",
        "spiritual": "Solar plexus chakra, personal power, mental clarity",
        "elemental": "Air - thought, communication, clarity, mental realm"
      },
      "associations": ["Sun", "Mercury", "Swords suit", "The Sun", "The Magician"]
    },
    "green": {
      "keywords": ["growth", "nature", "heart", "healing", "fertility"],
      "meanings": {
        "general": "Growth, fertility, nature, healing, abundance, balance",
        "psychological": "Balancing, nurturing, restful, harmonious",
        "spiritual": "Heart chakra, love, compassion, healing, nature connection",
        "elemental": "Earth - growth, manifestation, material abundance"
      },
      "associations": ["Venus", "Taurus", "Pentacles suit", "Empress", "World"]
    },
    "purple": {
      "keywords": ["spiritual", "crown", "wisdom", "mystery", "transformation"],
      "meanings": {
        "general": "Spiritual wisdom, mystery, transformation, royalty, higher consciousness",
        "psychological": "Contemplative, mysterious, transformative",
        "spiritual": "Crown chakra, spiritual connection, divine wisdom",
        "elemental": "Spirit - transcendence, unity, divine connection"
      },
      "associations": ["Jupiter", "Neptune", "Hermit", "High Priestess", "Temperance"]
    },
    "white": {
      "keywords": ["purity", "light", "wholeness", "clarity", "spirit"],
      "meanings": {
        "general": "Purity, divine light, wholeness, clarity, spiritual essence",
        "psychological": "Clear, pure, innocent, complete",
        "spiritual": "All chakras unified, divine light, pure consciousness",
        "elemental": "All elements in balance, unity, pure essence"
      },
      "associations": ["The Fool", "The Magician", "Death", "Temperance"]
    },
    "black": {
      "keywords": ["mystery", "void", "potential", "shadow", "unknown"],
      "meanings": {
        "general": "The void, mystery, potential, shadow, the unknown, absorption",
        "psychological": "Mystery, depth, the unconscious, hidden aspects",
        "spiritual": "The void, infinite potential, the dark mother, shadow work",
        "elemental": "The primordial darkness from which all emerges"
      },
      "associations": ["Saturn", "Pluto", "Death", "The Moon", "Devil"]
    },
    "gold": {
      "keywords": ["solar", "divine", "enlightenment", "perfection", "spiritual wealth"],
      "meanings": {
        "general": "Solar consciousness, enlightenment, divine perfection, spiritual gold",
        "psychological": "Valuable, precious, refined, perfected",
        "spiritual": "Spiritual gold, enlightenment, the philosopher's stone",
        "elemental": "Solar - divine consciousness, perfected will"
      },
      "associations": ["Sun", "Leo", "The Sun", "Wheel of Fortune", "World"]
    },
    "silver": {
      "keywords": ["lunar", "receptive", "intuition", "reflection", "feminine"],
      "meanings": {
        "general": "Lunar consciousness, receptivity, reflection, intuitive wisdom",
        "psychological": "Reflective, intuitive, receptive, flowing",
        "spiritual": "Lunar mysteries, divine feminine, intuitive wisdom",
        "elemental": "Lunar - receptivity, cycles, reflection"
      },
      "associations": ["Moon", "Cancer", "High Priestess", "The Moon", "Star"]
    }
  },
  "numbers": {
    "0": {
      "keywords": ["potential", "void", "infinite", "beginning", "chaos"],
      "meanings": {
        "general": "Infinite potential, the void, chaos before creation, the beginning and end",
        "tarot": "The Fool - zero point, pure potential, the journey before it begins",
        "spiritual": "The Ain Soph, the void from which all emerges",
        "psychological": "Unlimited possibility, freedom from structure"
      },
      "archetypal": "The Void, The Womb, Infinite Possibility"
    },
    "1": {
      "keywords": ["unity", "beginning", "individuation", "will", "source"],
      "meanings": {
        "general": "Unity, the source, new beginnings, individual will, initiative",
        "tarot": "The Magician, Aces - pure beginning, concentrated power, I AM",
        "spiritual": "The Monad, Divine Unity, The One Source",
        "psychological": "Individuation, self-awareness, independence"
      },
      "archetypal": "The Creator, The Self, The Source"
    },
    "2": {
      "keywords": ["duality", "relationship", "balance", "choice", "polarity"],
      "meanings": {
        "general": "Duality, relationship, balance of opposites, choice, reflection",
        "tarot": "High Priestess, Twos - balance, relationship, choice between paths",
        "spiritual": "Polarity, the divine dyad, masculine/feminine",
        "psychological": "Relationship, mirror, the other, choice"
      },
      "archetypal": "The Lovers, The Twin, The Mirror"
    },
    "3": {
      "keywords": ["creation", "synthesis", "expression", "growth", "trinity"],
      "meanings": {
        "general": "Creation, synthesis of opposites, expression, growth, the trinity",
        "tarot": "Empress, Threes - creative expression, growth, manifestation beginning",
        "spiritual": "Holy Trinity, Maiden-Mother-Crone, Mind-Body-Spirit",
        "psychological": "Creative expression, synthesis, offspring of union"
      },
      "archetypal": "The Creator, The Trinity, The Child"
    },
    "4": {
      "keywords": ["structure", "stability", "foundation", "earth", "manifestation"],
      "meanings": {
        "general": "Structure, stability, foundation, material manifestation, the square",
        "tarot": "Emperor, Fours - stability, structure, foundation, earthly power",
        "spiritual": "Four elements, four directions, the material world",
        "psychological": "Security, structure, boundaries, foundation"
      },
      "archetypal": "The Builder, The Foundation, The Square"
    },
    "5": {
      "keywords": ["change", "challenge", "instability", "human", "pentagram"],
      "meanings": {
        "general": "Change, challenge, instability, the human number, dynamic tension",
        "tarot": "Hierophant, Fives - challenge, change, disruption, growth through conflict",
        "spiritual": "The pentagram, human with spirit, five senses",
        "psychological": "Crisis, change, growth through challenge"
      },
      "archetypal": "The Challenger, The Human, The Rebel"
    },
    "6": {
      "keywords": ["harmony", "balance", "beauty", "love", "hexagram"],
      "meanings": {
        "general": "Harmony, balance, beauty, love, the union of opposites",
        "tarot": "Lovers, Sixes - harmony, choice aligned with love, balance achieved",
        "spiritual": "As above so below, hexagram, perfect balance",
        "psychological": "Harmony, aesthetic sense, balanced relationships"
      },
      "archetypal": "The Lover, The Artist, Perfect Balance"
    },
    "7": {
      "keywords": ["spiritual", "mystical", "inner", "contemplation", "mastery"],
      "meanings": {
        "general": "Spiritual wisdom, inner journey, mystical number, contemplation",
        "tarot": "Chariot, Sevens - spiritual mastery, inner journey, contemplation",
        "spiritual": "Seven chakras, seven days, seven planets, mystical perfection",
        "psychological": "Contemplation, inner wisdom, solitary journey"
      },
      "archetypal": "The Mystic, The Seeker, The Hermit"
    },
    "8": {
      "keywords": ["power", "infinity", "manifestation", "karma", "balance"],
      "meanings": {
        "general": "Power, infinity, karmic balance, material mastery, regeneration",
        "tarot": "Strength, Eights - power, manifestation, karmic balance",
        "spiritual": "Infinity symbol, karma, the octave, regeneration",
        "psychological": "Personal power, mastery, cause and effect"
      },
      "archetypal": "The Manifestor, Infinity, The Master"
    },
    "9": {
      "keywords": ["completion", "wisdom", "attainment", "integration", "three times three"],
      "meanings": {
        "general": "Completion, wisdom, attainment, the end before the beginning",
        "tarot": "Hermit, Nines - completion, wisdom, solitary attainment",
        "spiritual": "Triple trinity, completion before renewal, integration",
        "psychological": "Wisdom, completion, integration of lessons"
      },
      "archetypal": "The Sage, The Complete, The Wise Elder"
    },
    "10": {
      "keywords": ["completion", "wholeness", "return", "new cycle", "perfection"],
      "meanings": {
        "general": "Completion, return to unity, perfection, end of cycle",
        "tarot": "Wheel of Fortune, Tens - completion, new cycle beginning",
        "spiritual": "Return to unity with wisdom, completion of cycle",
        "psychological": "Completion, wholeness, readiness for new beginning"
      },
      "archetypal": "The Cycle Complete, The Omega, The Return"
    }
  },
  "elements": {
    "fire": {
      "keywords": ["will", "passion", "energy", "transformation", "spirit"],
      "meanings": {
        "general": "Will, creative force, passion, transformation, spirit, action",
        "tarot": "Wands suit - inspiration, willpower, creative energy, spiritual fire",
        "directional": "South - midday, summer, full power, manifestation",
        "alchemical": "Sulfur - the active principle, the masculine force, transformation"
      },
      "qualities": "Hot and dry, expansive, ascending, yang, active",
      "associations": ["Salamander", "Lion", "Red/Orange", "Triangle pointing up"]
    },
    "water": {
      "keywords": ["emotion", "intuition", "flow", "unconscious", "receptivity"],
      "meanings": {
        "general": "Emotion, intuition, flow, the unconscious, love, dreams",
        "tarot": "Cups suit - emotion, relationships, intuition, love, inner life",
        "directional": "West - sunset, autumn, inward turning, reflection",
        "alchemical": "Mercury - the receptive principle, the feminine force, dissolution"
      },
      "qualities": "Cold and moist, contracting, descending, yin, receptive",
      "associations": ["Undines", "Dolphins", "Blue/Silver", "Triangle pointing down"]
    },
    "air": {
      "keywords": ["thought", "communication", "clarity", "logic", "breath"],
      "meanings": {
        "general": "Thought, communication, clarity, ideas, logic, breath of life",
        "tarot": "Swords suit - thought, conflict, truth, mental clarity, challenges",
        "directional": "East - dawn, spring, new beginnings, fresh start",
        "alchemical": "Salt - the neutral principle, crystallization, manifestation"
      },
      "qualities": "Hot and moist, expansive, ascending, yang, active",
      "associations": ["Sylphs", "Eagles", "Yellow/White", "Triangle with horizontal line"]
    },
    "earth": {
      "keywords": ["manifestation", "stability", "body", "material", "grounding"],
      "meanings": {
        "general": "Material manifestation, stability, body, physical realm, grounding",
        "tarot": "Pentacles suit - material world, money, body, practical matters",
        "directional": "North - midnight, winter, darkness, gestation, depth",
        "alchemical": "Prima materia - the base substance, the foundation, the body"
      },
      "qualities": "Cold and dry, contracting, descending, yin, receptive",
      "associations": ["Gnomes", "Bulls", "Green/Brown", "Triangle with inverted line"]
    },
    "spirit": {
      "keywords": ["unity", "transcendence", "quintessence", "divine", "center"],
      "meanings": {
        "general": "The fifth element, unity of all, transcendence, divine spark",
        "tarot": "Major Arcana - spiritual journey, transcendent experiences",
        "directional": "Center - the axis mundi, the point of connection, the heart",
        "alchemical": "Quintessence - the fifth essence, spiritual gold, perfection"
      },
      "qualities": "Beyond qualities, unifying principle, the center point",
      "associations": ["Purple/Gold", "Circle", "Infinite spiral", "The void and fullness"]
    }
  },
  "plants": {
    "rose": {
      "keywords": ["love", "beauty", "unfolding", "heart", "divine feminine"],
      "meanings": {
        "general": "Divine love, beauty, the unfolding soul, heart wisdom",
        "tarot": "The Magician, Death, Fool - the soul's flowering, beauty through transformation",
        "spiritual": "The mystic rose, divine love, the soul's unfoldment"
      }
    },
    "lily": {
      "keywords": ["purity", "resurrection", "divine", "annunciation", "light"],
      "meanings": {
        "general": "Purity, resurrection, divine light, spiritual awakening",
        "tarot": "The Magician, Death - purity, spiritual transformation, rebirth",
        "spiritual": "The white lily of resurrection, divine purity, virgin birth"
      }
    },
    "pomegranate": {
      "keywords": ["underworld", "Persephone", "abundance", "fertility", "knowledge"],
      "meanings": {
        "general": "Underworld mysteries, sacred knowledge, abundant fertility",
        "tarot": "High Priestess - secret knowledge, underworld wisdom, initiation",
        "spiritual": "Seeds of wisdom, descent into the underworld, hidden abundance"
      }
    },
    "wheat": {
      "keywords": ["harvest", "abundance", "Demeter", "nourishment", "cycles"],
      "meanings": {
        "general": "Harvest, abundance, nourishment, natural cycles",
        "tarot": "Empress - abundant fertility, the harvest, nourishment",
        "spiritual": "Grain mysteries, death and rebirth, seasonal cycles"
      }
    },
    "grape": {
      "keywords": ["Dionysus", "ecstasy", "transformation", "spiritual intoxication"],
      "meanings": {
        "general": "Transformation, spiritual ecstasy, divine intoxication",
        "tarot": "Temperance, The Sun - transformation, joy, spiritual fermentation",
        "spiritual": "Wine mysteries, transubstantiation, sacred transformation"
      }
    },
    "sunflower": {
      "keywords": ["solar", "devotion", "enlightenment", "following the light"],
      "meanings": {
        "general": "Solar devotion, following the light, spiritual orientation",
        "tarot": "The Sun - solar consciousness, enlightenment, joy",
        "spiritual": "Devotion to the divine, spiritual orientation, heliotropism"
      }
    },
    "lotus": {
      "keywords": ["enlightenment", "purity", "arising", "transcendence", "chakras"],
      "meanings": {
        "general": "Enlightenment, purity arising from mud, spiritual unfoldment",
        "tarot": "Magician, Star - spiritual arising, enlightenment, chakra opening",
        "spiritual": "The thousand-petaled lotus, enlightenment, purity in the world"
      }
    },
    "oak": {
      "keywords": ["strength", "endurance", "wisdom", "Druidic", "axis mundi"],
      "meanings": {
        "general": "Ancient strength, wisdom, endurance, sacred tree",
        "tarot": "Emperor, Hierophant - lasting strength, traditional wisdom",
        "spiritual": "World tree, axis mundi, Druidic wisdom"
      }
    },
    "willow": {
      "keywords": ["flexibility", "lunar", "emotion", "water", "intuition"],
      "meanings": {
        "general": "Flexibility, lunar wisdom, emotional depth, water connection",
        "tarot": "High Priestess, Moon - lunar wisdom, emotional flexibility",
        "spiritual": "Tree of enchantment, lunar mysteries, emotional wisdom"
      }
    },
    "ivy": {
      "keywords": ["Dionysus", "persistence", "immortality", "spiraling growth"],
      "meanings": {
        "general": "Persistent growth, immortality, spiraling ascent",
        "tarot": "Death, World - persistent life force, immortality through transformation",
        "spiritual": "Eternal life, spiraling growth, Dionysian mysteries"
      }
    }
  },
  "celestial": {
    "sun": {
      "keywords": ["consciousness", "life", "vitality", "enlightenment", "masculine"],
      "meanings": {
        "general": "Consciousness, vitality, life force, enlightenment, the self",
        "tarot": "The Sun, Strength, Wheel - life force, consciousness, vitality",
        "spiritual": "The divine masculine, solar consciousness, enlightenment",
        "psychological": "The conscious ego, identity, vitality, the hero"
      },
      "associations": ["Gold", "Lion", "Apollo", "Sunday"]
    },
    "moon": {
      "keywords": ["unconscious", "intuition", "cycles", "feminine", "mystery"],
      "meanings": {
        "general": "The unconscious, intuition, cycles, dreams, the feminine",
        "tarot": "The Moon, High Priestess - unconscious, mystery, intuition",
        "spiritual": "The divine feminine, lunar mysteries, cyclical wisdom",
        "psychological": "The unconscious, emotions, instinct, the inner world"
      },
      "associations": ["Silver", "Crab", "Artemis", "Monday"]
    },
    "stars": {
      "keywords": ["hope", "guidance", "destiny", "higher self", "inspiration"],
      "meanings": {
        "general": "Hope, guidance, destiny, divine light, inspiration",
        "tarot": "The Star - hope, guidance, divine inspiration, higher self",
        "spiritual": "Divine guidance, our higher nature, celestial light",
        "psychological": "Hope, aspiration, the idealized self, guidance"
      },
      "associations": ["The Star card", "Aquarius", "Divine hope"]
    },
    "lightning": {
      "keywords": ["revelation", "sudden", "divine", "Tower", "awakening"],
      "meanings": {
        "general": "Sudden revelation, divine intervention, breakthrough, awakening",
        "tarot": "The Tower - sudden awakening, divine revelation, breakthrough",
        "spiritual": "Divine fire, sudden enlightenment, Zeus's thunderbolt",
        "psychological": "Sudden insight, breakthrough, destruction of false structures"
      },
      "associations": ["The Tower", "Sudden change", "Revelation"]
    }
  }
}
</file>

<file path="plugins/tarot-astro-plugins/symbolism-server/server/database.js">
/**
 * Symbolism Database
 * Handles symbol lookups, searches, and relationships
 */

import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Load symbol database
const symbolsPath = join(__dirname, '../data/symbols.json');
const symbolDatabase = JSON.parse(readFileSync(symbolsPath, 'utf-8'));

/**
 * Search for symbols by query string
 */
export function searchSymbols(query, categoryFilter = null, limit = 10) {
  const queryLower = query.toLowerCase();
  const results = [];

  const categories = categoryFilter
    ? [categoryFilter]
    : Object.keys(symbolDatabase);

  categories.forEach((category) => {
    const categoryData = symbolDatabase[category];

    Object.entries(categoryData).forEach(([name, data]) => {
      // Check name match
      if (name.toLowerCase().includes(queryLower)) {
        results.push({
          name,
          category,
          relevance: 1.0,
          ...data,
        });
        return;
      }

      // Check keyword match
      if (data.keywords) {
        const keywordMatch = data.keywords.some((keyword) =>
          keyword.toLowerCase().includes(queryLower)
        );
        if (keywordMatch) {
          results.push({
            name,
            category,
            relevance: 0.8,
            ...data,
          });
          return;
        }
      }

      // Check meaning text match
      if (data.meanings) {
        const meaningText = JSON.stringify(data.meanings).toLowerCase();
        if (meaningText.includes(queryLower)) {
          results.push({
            name,
            category,
            relevance: 0.6,
            ...data,
          });
        }
      }
    });
  });

  // Sort by relevance and limit
  return results
    .sort((a, b) => b.relevance - a.relevance)
    .slice(0, limit);
}

/**
 * Get a specific symbol by category and name
 */
export function getSymbol(category, name) {
  const categoryData = symbolDatabase[category];
  if (!categoryData) {
    throw new Error(`Unknown category: ${category}`);
  }

  const nameLower = name.toLowerCase();
  const symbolData = categoryData[nameLower];

  if (!symbolData) {
    throw new Error(`Symbol '${name}' not found in category '${category}'`);
  }

  return {
    name: nameLower,
    category,
    ...symbolData,
  };
}

/**
 * Get all symbols in a category
 */
export function getCategory(category) {
  const categoryData = symbolDatabase[category];
  if (!categoryData) {
    throw new Error(`Unknown category: ${category}`);
  }

  return {
    category,
    symbols: Object.entries(categoryData).map(([name, data]) => ({
      name,
      keywords: data.keywords,
      summary: data.meanings?.general || data.meanings?.tarot || 'No summary available',
    })),
  };
}

/**
 * Fuzzy match a symbol name across all categories
 */
export function fuzzyMatch(query) {
  const queryLower = query.toLowerCase();

  for (const [category, categoryData] of Object.entries(symbolDatabase)) {
    for (const [name, data] of Object.entries(categoryData)) {
      if (name.toLowerCase() === queryLower) {
        return {
          category,
          name,
          data,
        };
      }
    }
  }

  // Try partial match
  for (const [category, categoryData] of Object.entries(symbolDatabase)) {
    for (const [name, data] of Object.entries(categoryData)) {
      if (name.toLowerCase().includes(queryLower) || queryLower.includes(name.toLowerCase())) {
        return {
          category,
          name,
          data,
        };
      }
    }
  }

  return null;
}

/**
 * Get symbols related to a theme
 */
export function getRelatedSymbols(theme, limit = 10) {
  const themeLower = theme.toLowerCase();
  const results = [];

  Object.entries(symbolDatabase).forEach(([category, categoryData]) => {
    Object.entries(categoryData).forEach(([name, data]) => {
      let relevance = 0;

      // Check keywords
      if (data.keywords) {
        const keywordMatch = data.keywords.some((keyword) =>
          keyword.toLowerCase().includes(themeLower) || themeLower.includes(keyword.toLowerCase())
        );
        if (keywordMatch) {
          relevance += 0.5;
        }
      }

      // Check meanings
      if (data.meanings) {
        const meaningText = JSON.stringify(data.meanings).toLowerCase();
        if (meaningText.includes(themeLower)) {
          relevance += 0.3;
        }
      }

      // Check archetypal field
      if (data.archetypal && typeof data.archetypal === 'string') {
        if (data.archetypal.toLowerCase().includes(themeLower)) {
          relevance += 0.2;
        }
      }

      if (relevance > 0) {
        results.push({
          name,
          category,
          relevance,
          keywords: data.keywords,
          summary: data.meanings?.general || data.meanings?.tarot || '',
        });
      }
    });
  });

  return results
    .sort((a, b) => b.relevance - a.relevance)
    .slice(0, limit);
}

/**
 * Get symbol combinations (useful for multi-symbol interpretation)
 */
export function getSymbolCombination(symbols) {
  const symbolData = symbols.map((symbol) => {
    const match = fuzzyMatch(symbol);
    return match ? { name: symbol, ...match } : null;
  }).filter(Boolean);

  // Analyze thematic connections
  const allKeywords = symbolData.flatMap((s) => s.data.keywords || []);
  const keywordCounts = {};

  allKeywords.forEach((keyword) => {
    keywordCounts[keyword] = (keywordCounts[keyword] || 0) + 1;
  });

  const sharedThemes = Object.entries(keywordCounts)
    .filter(([_, count]) => count > 1)
    .sort((a, b) => b[1] - a[1])
    .map(([keyword, _]) => keyword);

  return {
    symbols: symbolData,
    sharedThemes,
    interpretation: generateCombinationInterpretation(symbolData, sharedThemes),
  };
}

/**
 * Generate interpretation for symbol combination
 */
function generateCombinationInterpretation(symbolData, sharedThemes) {
  if (symbolData.length === 0) {
    return 'No symbols to interpret.';
  }

  if (symbolData.length === 1) {
    const symbol = symbolData[0];
    return symbol.data.meanings?.general || symbol.data.meanings?.tarot || 'Single symbol present.';
  }

  const symbolNames = symbolData.map((s) => s.name).join(', ');

  if (sharedThemes.length > 0) {
    return `The combination of ${symbolNames} creates a resonance around themes of ${sharedThemes.slice(0, 3).join(', ')}, suggesting a unified message about ${sharedThemes[0]}.`;
  }

  return `The symbols ${symbolNames} create a diverse tapestry, each contributing unique energy to the overall interpretation.`;
}
</file>

<file path="plugins/tarot-astro-plugins/symbolism-server/server/index.js">
#!/usr/bin/env node

/**
 * Symbolism Reference MCP Server
 * Provides comprehensive symbolism database for tarot interpretation
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';

import { searchSymbols, getSymbol, getCategory, fuzzyMatch, getRelatedSymbols } from './database.js';

const server = new Server(
  {
    name: 'symbolism-server',
    version: '1.0.0',
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// Define available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: 'search_symbols',
        description: 'Search for symbols by keyword or name. Returns matching symbols with meanings and interpretations.',
        inputSchema: {
          type: 'object',
          properties: {
            query: {
              type: 'string',
              description: 'Search query (symbol name or keyword)',
              required: true,
            },
            category: {
              type: 'string',
              description: 'Optional category filter: animals, colors, numbers, elements, plants, celestial',
              enum: ['animals', 'colors', 'numbers', 'elements', 'plants', 'celestial'],
            },
            limit: {
              type: 'number',
              description: 'Maximum number of results (default: 10)',
              default: 10,
            },
          },
          required: ['query'],
        },
      },
      {
        name: 'get_symbol',
        description: 'Get detailed information about a specific symbol',
        inputSchema: {
          type: 'object',
          properties: {
            category: {
              type: 'string',
              description: 'Symbol category',
              enum: ['animals', 'colors', 'numbers', 'elements', 'plants', 'celestial'],
              required: true,
            },
            name: {
              type: 'string',
              description: 'Symbol name (e.g., "rose", "red", "7")',
              required: true,
            },
          },
          required: ['category', 'name'],
        },
      },
      {
        name: 'get_category',
        description: 'Get all symbols in a specific category',
        inputSchema: {
          type: 'object',
          properties: {
            category: {
              type: 'string',
              description: 'Category to retrieve',
              enum: ['animals', 'colors', 'numbers', 'elements', 'plants', 'celestial'],
              required: true,
            },
          },
          required: ['category'],
        },
      },
      {
        name: 'get_related_symbols',
        description: 'Get symbols related to a specific theme or archetype',
        inputSchema: {
          type: 'object',
          properties: {
            theme: {
              type: 'string',
              description: 'Theme to explore (e.g., "transformation", "love", "wisdom")',
              required: true,
            },
            limit: {
              type: 'number',
              description: 'Maximum number of results (default: 10)',
              default: 10,
            },
          },
          required: ['theme'],
        },
      },
      {
        name: 'interpret_card_symbols',
        description: 'Get interpretation framework for common symbols appearing in a tarot card',
        inputSchema: {
          type: 'object',
          properties: {
            cardName: {
              type: 'string',
              description: 'Name of the tarot card',
              required: true,
            },
            symbols: {
              type: 'array',
              description: 'List of symbols visible in the card',
              items: {
                type: 'string',
              },
              required: true,
            },
          },
          required: ['cardName', 'symbols'],
        },
      },
      {
        name: 'get_color_meanings',
        description: 'Get comprehensive color symbolism and meanings',
        inputSchema: {
          type: 'object',
          properties: {
            colors: {
              type: 'array',
              description: 'List of colors to interpret',
              items: {
                type: 'string',
              },
              required: true,
            },
          },
          required: ['colors'],
        },
      },
      {
        name: 'get_numerological_insight',
        description: 'Get numerological meaning for a number or card position',
        inputSchema: {
          type: 'object',
          properties: {
            number: {
              type: 'string',
              description: 'Number to interpret (0-10)',
              required: true,
            },
          },
          required: ['number'],
        },
      },
    ],
  };
});

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    switch (name) {
      case 'search_symbols': {
        if (!args?.query) {
          throw new Error('query is required');
        }
        const results = searchSymbols(args.query, args.category, args.limit);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(results, null, 2),
            },
          ],
        };
      }

      case 'get_symbol': {
        if (!args?.category || !args?.name) {
          throw new Error('category and name are required');
        }
        const symbol = getSymbol(args.category, args.name);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(symbol, null, 2),
            },
          ],
        };
      }

      case 'get_category': {
        if (!args?.category) {
          throw new Error('category is required');
        }
        const category = getCategory(args.category);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(category, null, 2),
            },
          ],
        };
      }

      case 'get_related_symbols': {
        if (!args?.theme) {
          throw new Error('theme is required');
        }
        const related = getRelatedSymbols(args.theme, args.limit);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(related, null, 2),
            },
          ],
        };
      }

      case 'interpret_card_symbols': {
        if (!args?.cardName || !args?.symbols) {
          throw new Error('cardName and symbols are required');
        }
        const interpretation = interpretCardSymbols(args.cardName, args.symbols);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(interpretation, null, 2),
            },
          ],
        };
      }

      case 'get_color_meanings': {
        if (!args?.colors) {
          throw new Error('colors is required');
        }
        const colorMeanings = args.colors.map((color) => {
          const colorData = getSymbol('colors', color.toLowerCase());
          return {
            color,
            ...colorData,
          };
        });
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(colorMeanings, null, 2),
            },
          ],
        };
      }

      case 'get_numerological_insight': {
        if (!args?.number) {
          throw new Error('number is required');
        }
        const numData = getSymbol('numbers', args.number);
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(numData, null, 2),
            },
          ],
        };
      }

      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  } catch (error) {
    return {
      content: [
        {
          type: 'text',
          text: JSON.stringify({ error: error.message }, null, 2),
        },
      ],
      isError: true,
    };
  }
});

/**
 * Interpret symbols in context of a specific card
 */
function interpretCardSymbols(cardName, symbols) {
  const symbolData = symbols.map((symbolName) => {
    // Try fuzzy matching to find the symbol
    const match = fuzzyMatch(symbolName);
    if (match) {
      return {
        symbol: symbolName,
        category: match.category,
        data: match.data,
      };
    }
    return {
      symbol: symbolName,
      found: false,
    };
  });

  // Generate contextual interpretation
  const interpretation = {
    card: cardName,
    symbols: symbolData,
    synthesis: synthesizeSymbols(cardName, symbolData),
  };

  return interpretation;
}

/**
 * Synthesize multiple symbols into coherent interpretation
 */
function synthesizeSymbols(cardName, symbolData) {
  const _themes = [];
  const keywords = [];

  symbolData.forEach((item) => {
    if (item.data && item.data.keywords) {
      keywords.push(...item.data.keywords);
    }
  });

  // Identify common themes
  const themeMap = {};
  keywords.forEach((keyword) => {
    themeMap[keyword] = (themeMap[keyword] || 0) + 1;
  });

  const commonThemes = Object.entries(themeMap)
    .filter(([_, count]) => count > 1)
    .map(([theme, _]) => theme)
    .slice(0, 5);

  return {
    dominantThemes: commonThemes,
    symbolCount: symbolData.length,
    interpretation: `The ${cardName} combines ${symbolData.length} symbolic elements creating a rich tapestry of meaning around themes of: ${commonThemes.join(', ')}.`,
  };
}

// Start the server
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error('Symbolism MCP server running on stdio');
}

main().catch((error) => {
  console.error('Server error:', error);
  process.exit(1);
});
</file>

<file path="plugins/tarot-astro-plugins/symbolism-server/server/test.js">
#!/usr/bin/env node

/**
 * Simple test script for Symbolism Database
 */

import { searchSymbols, getSymbol, getCategory, getRelatedSymbols, fuzzyMatch } from './database.js';

console.log('🧪 Testing Symbolism Database\n');
console.log('='.repeat(60));

try {
  console.log('\n1️⃣  Search Symbols (keyword: "transformation"):');
  console.log('-'.repeat(60));
  const searchResults = searchSymbols('transformation', null, 5);
  searchResults.forEach(result => {
    console.log(`${result.category.toUpperCase()}: ${result.name}`);
    console.log(`  Keywords: ${result.keywords.join(', ')}`);
    console.log(`  General: ${result.meanings.general.substring(0, 80)}...`);
  });

  console.log('\n2️⃣  Get Specific Symbol (serpent):');
  console.log('-'.repeat(60));
  const serpent = getSymbol('animals', 'serpent');
  if (serpent) {
    console.log(`Name: serpent`);
    console.log(`Keywords: ${serpent.keywords.join(', ')}`);
    console.log(`General: ${serpent.meanings.general}`);
    console.log(`Tarot: ${serpent.meanings.tarot}`);
    console.log(`Archetypal: ${serpent.meanings.archetypal}`);
  }

  console.log('\n3️⃣  Get Category (colors):');
  console.log('-'.repeat(60));
  const colorsResult = getCategory('colors');
  console.log(`Found ${colorsResult.symbols.length} colors:`);
  colorsResult.symbols.slice(0, 5).forEach(symbol => {
    console.log(`  ${symbol.name}: ${symbol.keywords.join(', ')}`);
  });

  console.log('\n4️⃣  Get Related Symbols (theme: "wisdom"):');
  console.log('-'.repeat(60));
  const wisdomSymbols = getRelatedSymbols('wisdom', 5);
  wisdomSymbols.forEach(symbol => {
    console.log(`${symbol.category}/${symbol.name} - ${symbol.summary.substring(0, 60)}...`);
  });

  console.log('\n5️⃣  Fuzzy Match Test (query: "snak"):');
  console.log('-'.repeat(60));
  const fuzzyResult = fuzzyMatch('snak'); // Should find "serpent" or similar
  if (fuzzyResult) {
    console.log(`Match found: ${fuzzyResult.category}/${fuzzyResult.name}`);
    console.log(`Keywords: ${fuzzyResult.data.keywords.join(', ')}`);
  } else {
    console.log('No fuzzy match found');
  }

  console.log('\n6️⃣  Numerology Test (number: 7):');
  console.log('-'.repeat(60));
  const seven = getSymbol('numbers', '7');
  if (seven) {
    console.log(`Number: 7`);
    console.log(`Keywords: ${seven.keywords.join(', ')}`);
    console.log(`Tarot: ${seven.meanings.tarot}`);
  }

  console.log('\n' + '='.repeat(60));
  console.log('✅ All tests completed successfully!\n');

} catch (error) {
  console.error('\n❌ Test failed:', error.message);
  console.error(error.stack);
  process.exit(1);
}
</file>

<file path="plugins/tarot-astro-plugins/symbolism-server/package.json">
{
  "name": "symbolism-mcp-server",
  "version": "1.0.0",
  "description": "MCP server providing comprehensive symbolism reference database for tarot interpretation",
  "type": "module",
  "main": "server/index.js",
  "scripts": {
    "start": "node server/index.js",
    "dev": "node --watch server/index.js",
    "test": "node server/test.js"
  },
  "keywords": ["mcp", "symbolism", "tarot", "interpretation", "imagery"],
  "author": "Mystic Tarot",
  "license": "MIT",
  "dependencies": {
    "@modelcontextprotocol/sdk": "^0.5.0"
  }
}
</file>

<file path="plugins/tarot-astro-plugins/symbolism-server/README.md">
# Symbolism Reference MCP Server

Comprehensive symbolism database for tarot card interpretation. Provides meanings for animals, colors, numbers, elements, plants, and celestial symbols.

## Features

- **6 Symbol Categories**: Animals, colors, numbers, elements, plants, celestial bodies
- **Rich Meanings**: General, tarot-specific, spiritual, and psychological interpretations
- **Keyword Search**: Find symbols by name or associated keywords
- **Theme Exploration**: Discover symbols related to specific themes or archetypes
- **Contextual Interpretation**: Synthesize multiple symbols for coherent readings
- **Cross-References**: Discover relationships between symbols

## Installation

```bash
cd symbolism-server
npm install
```

## Usage

This MCP server is automatically configured when the plugin is installed. Claude Code will have access to these tools:

### Available Tools

#### `search_symbols(query, category?, limit?)`
Search for symbols by keyword or name.

**Parameters:**
- `query` (required): Search term
- `category` (optional): Filter by category (animals, colors, numbers, elements, plants, celestial)
- `limit` (optional): Max results (default: 10)

**Example:**
```javascript
search_symbols("transformation")
// Returns symbols related to transformation across all categories
```

**Response:**
```json
[
  {
    "name": "serpent",
    "category": "animals",
    "relevance": 0.8,
    "keywords": ["transformation", "kundalini", "wisdom", "healing", "renewal"],
    "meanings": {
      "general": "Transformation, shedding old skins, primal energy, healing wisdom",
      "tarot": "The Magician, The Lovers - life force, temptation, transformation"
    }
  }
]
```

#### `get_symbol(category, name)`
Get detailed information about a specific symbol.

**Example:**
```javascript
get_symbol("animals", "lion")
```

**Response:**
```json
{
  "name": "lion",
  "category": "animals",
  "keywords": ["courage", "strength", "solar", "mastery", "heart"],
  "meanings": {
    "general": "Courage, raw power tamed through love, solar majesty",
    "tarot": "Strength - the union of gentleness and power",
    "archetypal": "The Solar Lion, Sekhmet, Heart of the King"
  },
  "cultural_context": "Universal symbol of courage, nobility, and power of the heart"
}
```

#### `get_category(category)`
Get all symbols in a specific category.

**Example:**
```javascript
get_category("elements")
```

**Response:**
```json
{
  "category": "elements",
  "symbols": [
    {
      "name": "fire",
      "keywords": ["will", "passion", "energy", "transformation", "spirit"],
      "summary": "Will, creative force, passion, transformation, spirit, action"
    }
    // ... all elements
  ]
}
```

#### `get_related_symbols(theme, limit?)`
Find symbols related to a specific theme.

**Example:**
```javascript
get_related_symbols("love", 10)
```

**Response:**
```json
[
  {
    "name": "rose",
    "category": "plants",
    "relevance": 0.8,
    "keywords": ["love", "beauty", "unfolding", "heart"],
    "summary": "Divine love, beauty, the unfolding soul, heart wisdom"
  },
  {
    "name": "dove",
    "category": "animals",
    "relevance": 0.7,
    "keywords": ["peace", "spirit", "purity", "love"],
    "summary": "Peace, Holy Spirit, pure love, divine messenger"
  }
]
```

#### `interpret_card_symbols(cardName, symbols)`
Get interpretation framework for symbols in a tarot card.

**Example:**
```javascript
interpret_card_symbols("The Magician", ["serpent", "rose", "lily", "red", "white"])
```

**Response:**
```json
{
  "card": "The Magician",
  "symbols": [
    {
      "symbol": "serpent",
      "category": "animals",
      "data": { /* full symbol data */ }
    }
    // ... all symbols
  ],
  "synthesis": {
    "dominantThemes": ["transformation", "purity", "passion"],
    "symbolCount": 5,
    "interpretation": "The Magician combines 5 symbolic elements creating a rich tapestry of meaning around themes of: transformation, purity, passion."
  }
}
```

#### `get_color_meanings(colors)`
Get comprehensive color symbolism.

**Example:**
```javascript
get_color_meanings(["red", "blue", "gold"])
```

**Response:**
```json
[
  {
    "color": "red",
    "keywords": ["passion", "fire", "energy", "life-force", "action"],
    "meanings": {
      "general": "Vital energy, passion, blood, life force",
      "spiritual": "Root chakra, grounding, survival, physical vitality",
      "elemental": "Fire - transformation, will, creative power"
    },
    "associations": ["Mars", "Aries", "Wands suit"]
  }
  // ... other colors
]
```

#### `get_numerological_insight(number)`
Get numerological meaning for a number.

**Example:**
```javascript
get_numerological_insight("7")
```

**Response:**
```json
{
  "name": "7",
  "category": "numbers",
  "keywords": ["spiritual", "mystical", "inner", "contemplation", "mastery"],
  "meanings": {
    "general": "Spiritual wisdom, inner journey, mystical number",
    "tarot": "Chariot, Sevens - spiritual mastery, inner journey",
    "spiritual": "Seven chakras, seven days, mystical perfection"
  },
  "archetypal": "The Mystic, The Seeker, The Hermit"
}
```

## Symbol Categories

### Animals
Represents instinctual energies, archetypal forces, and animal wisdom:
- **Dog**: Loyalty, instinct, companionship, guidance
- **Wolf**: Wildness, shadow, lunar consciousness
- **Lion**: Courage, solar strength, heart mastery
- **Serpent**: Transformation, kundalini, healing
- **Eagle**: Spiritual vision, sovereignty, higher perspective
- **Dove**: Peace, spirit, pure love
- **Horse**: Power, freedom, spiritual journey
- **Sphinx**: Mystery, guardian, four-fold wisdom

### Colors
Psychological, spiritual, and elemental meanings:
- **Red**: Passion, fire, life force, action
- **Blue**: Emotion, intuition, depth, spirit
- **Yellow**: Intellect, clarity, consciousness
- **Green**: Growth, heart, healing, nature
- **Purple**: Spiritual wisdom, transformation
- **White**: Purity, light, wholeness
- **Black**: Mystery, void, potential, shadow
- **Gold**: Solar consciousness, enlightenment
- **Silver**: Lunar wisdom, receptivity

### Numbers (0-10)
Numerological and archetypal significance:
- **0**: Infinite potential, the void
- **1**: Unity, beginning, individuation
- **2**: Duality, relationship, balance
- **3**: Creation, synthesis, trinity
- **4**: Structure, stability, manifestation
- **5**: Change, challenge, human number
- **6**: Harmony, balance, beauty
- **7**: Spiritual wisdom, inner journey
- **8**: Power, infinity, karma
- **9**: Completion, wisdom, attainment
- **10**: Wholeness, return, new cycle

### Elements
Classical and alchemical element symbolism:
- **Fire**: Will, passion, transformation
- **Water**: Emotion, intuition, flow
- **Air**: Thought, communication, clarity
- **Earth**: Manifestation, stability, body
- **Spirit**: Unity, transcendence, quintessence

### Plants
Botanical symbolism and sacred plants:
- **Rose**: Divine love, beauty, unfolding
- **Lily**: Purity, resurrection, light
- **Pomegranate**: Underworld wisdom, abundance
- **Wheat**: Harvest, nourishment, cycles
- **Lotus**: Enlightenment, purity arising
- **Oak**: Strength, wisdom, axis mundi
- **Willow**: Flexibility, lunar wisdom

### Celestial
Heavenly bodies and cosmic forces:
- **Sun**: Consciousness, vitality, enlightenment
- **Moon**: Unconscious, intuition, cycles
- **Stars**: Hope, guidance, higher self
- **Lightning**: Revelation, breakthrough, divine fire

## Integration with Tarot Readings

### Enhance Card Interpretation

```javascript
// When interpreting The Moon card
const moonSymbols = await interpret_card_symbols("The Moon", [
  "moon", "wolf", "dog", "crayfish", "silver", "blue"
]);

// Get deeper context
const lunarThemes = await get_related_symbols("lunar mysteries");

// Combine for rich interpretation
const reading = `
The Moon card presents a landscape of lunar symbolism:

${moonSymbols.synthesis.interpretation}

The ${moonSymbols.symbols.find(s => s.symbol === 'wolf').data.meanings.tarot}
The ${moonSymbols.symbols.find(s => s.symbol === 'dog').data.meanings.tarot}

The crayfish emerging from the water represents ${moonSymbols.symbols.find(s => s.symbol === 'crayfish').data.meanings.general}
`;
```

### Color Analysis in Readings

```javascript
// Analyze dominant colors in a reading
const colors = await get_color_meanings(["blue", "red", "gold"]);

// Understanding the energetic mix
const interpretation = `
The color palette of this reading combines:
- Blue: ${colors[0].meanings.spiritual}
- Red: ${colors[1].meanings.spiritual}
- Gold: ${colors[2].meanings.spiritual}

This suggests a journey from emotional depth (blue) through passionate action (red) to spiritual enlightenment (gold).
`;
```

### Numerological Context

```javascript
// For a 7-card spread in position 3
const numberMeaning = await get_numerological_insight("7");
const positionMeaning = await get_numerological_insight("3");

// Rich numerological context
const context = `
Seven-card spread: ${numberMeaning.meanings.spiritual}
Third position: ${positionMeaning.meanings.tarot}
`;
```

## Extending the Database

To add new symbols, edit `/data/symbols.json`:

```json
{
  "animals": {
    "new-animal": {
      "keywords": ["keyword1", "keyword2"],
      "meanings": {
        "general": "General meaning",
        "tarot": "Tarot-specific meaning",
        "archetypal": "Archetypal associations"
      },
      "cultural_context": "Cultural and historical context"
    }
  }
}
```

## Best Practices

1. **Layered Interpretation**: Use multiple symbol lookups to build rich, contextual meanings
2. **Cross-Reference**: Explore related symbols to discover thematic connections
3. **Cultural Sensitivity**: Remember that symbols have different meanings in different traditions
4. **Synthesis**: Combine multiple symbols for coherent interpretation rather than listing meanings
5. **Context Matters**: Same symbol can mean different things in different card positions

## Technical Details

### Database Structure
- JSON-based symbol database
- Hierarchical category organization
- Multiple meaning contexts per symbol
- Keyword indexing for fast search
- Fuzzy matching for flexible queries

### Performance
- In-memory database for fast lookups
- Efficient keyword indexing
- Sub-millisecond response times

## License

MIT
</file>

<file path="plugins/tarot-astro-plugins/ARCHITECTURE.md">
# Tarot Astro Plugins - Architecture Overview

## System Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     Claude Code (Main)                           │
│                                                                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐          │
│  │ /astro-      │  │ /symbol-     │  │ Tarot        │          │
│  │  reading     │  │  analysis    │  │ Reading UI   │          │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘          │
│         │                  │                  │                   │
│         └──────────┬───────┴──────────────────┘                  │
│                    │                                              │
│         ┌──────────▼──────────────────────┐                     │
│         │   MCP Protocol Layer             │                     │
│         └──────────┬──────────────────────┘                     │
└────────────────────┼────────────────────────────────────────────┘
                     │
        ┌────────────┴────────────┐
        │                         │
┌───────▼──────────┐    ┌────────▼─────────┐
│ Ephemeris Server │    │ Symbolism Server │
│  (MCP Server)    │    │  (MCP Server)    │
├──────────────────┤    ├──────────────────┤
│                  │    │                  │
│ • Planetary      │    │ • Symbol Search  │
│   Positions      │    │ • Category       │
│ • Moon Phases    │    │   Browser        │
│ • Aspects        │    │ • Multi-symbol   │
│ • Retrogrades    │    │   Synthesis      │
│ • Daily Weather  │    │ • Color/Number   │
│                  │    │   Analysis       │
├──────────────────┤    ├──────────────────┤
│ astronomy-engine │    │ symbols.json     │
│ (Swiss Ephemeris)│    │ (Database)       │
└──────────────────┘    └──────────────────┘
```

## Plugin Structure

```
tarot-astro-plugins/
│
├── .claude-plugin/
│   └── marketplace.json           ← Marketplace definition
│
├── ephemeris-server/              ← Plugin 1: Astronomical Data
│   ├── .claude-plugin/
│   │   └── plugin.json           ← Plugin manifest
│   ├── .mcp.json                 ← MCP server config
│   ├── commands/
│   │   └── astro-reading.md      ← Custom slash command
│   ├── server/
│   │   ├── index.js              ← MCP server (stdio)
│   │   ├── ephemeris.js          ← Astronomical calculations
│   │   └── aspects.js            ← Aspect detection
│   ├── package.json
│   └── README.md
│
├── symbolism-server/              ← Plugin 2: Symbol Database
│   ├── .claude-plugin/
│   │   └── plugin.json
│   ├── .mcp.json
│   ├── commands/
│   │   └── symbol-analysis.md
│   ├── server/
│   │   ├── index.js              ← MCP server (stdio)
│   │   ├── database.js           ← Symbol search engine
│   │   └── search.js
│   ├── data/
│   │   └── symbols.json          ← Comprehensive symbol DB
│   ├── package.json
│   └── README.md
│
├── README.md                      ← Main documentation
├── INSTALL.md                     ← Installation guide
└── ARCHITECTURE.md                ← This file
```

## Data Flow: Astrological Reading

```
User Request
     │
     ▼
┌─────────────────────────┐
│ /astro-reading command  │
└────────┬────────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│ Claude receives command prompt:          │
│ "Get astrological context for reading"   │
└────────┬────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│ Claude invokes MCP tools:                │
│ • get_current_positions()                │
│ • get_daily_astrological_weather()       │
│ • get_moon_phase()                       │
│ • get_planetary_aspects()                │
└────────┬────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│ Ephemeris Server calculates:             │
│ 1. Query astronomy-engine                │
│ 2. Compute ecliptic positions            │
│ 3. Detect aspects between planets        │
│ 4. Identify retrograde motion            │
│ 5. Generate interpretations              │
└────────┬────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│ Return JSON data to Claude:               │
│ {                                         │
│   "moon": { phase, sign, illumination }  │
│   "aspects": [ Sun-Mars square, ... ]    │
│   "retrogrades": [ Mercury, ... ]        │
│   "theme": "Growth through challenge"    │
│ }                                         │
└────────┬────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│ Claude synthesizes and presents:          │
│                                           │
│ 🌙 Astrological Context                  │
│ Moon Phase: Waxing Gibbous in Pisces     │
│ [formatted, human-readable output]       │
└───────────────────────────────────────────┘
```

## Data Flow: Symbol Analysis

```
User Request: "/symbol-analysis The Fool"
     │
     ▼
┌─────────────────────────────────────────┐
│ Claude receives command with card name   │
└────────┬────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│ Claude identifies symbols in The Fool:   │
│ • Dog, cliff, sun, white rose, etc.      │
└────────┬────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│ Claude invokes MCP tools:                │
│ • interpret_card_symbols(                │
│     "The Fool",                          │
│     ["dog", "sun", "rose", "white"]      │
│   )                                      │
│ • get_color_meanings(["white"])         │
│ • get_numerological_insight("0")        │
└────────┬────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│ Symbolism Server processes:              │
│ 1. Search symbols.json for each symbol  │
│ 2. Extract meanings (general, tarot,    │
│    archetypal, cultural)                 │
│ 3. Identify shared themes/keywords      │
│ 4. Generate symbolic synthesis          │
└────────┬────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│ Return structured symbol data:           │
│ {                                        │
│   "symbols": [                           │
│     {                                    │
│       "name": "dog",                     │
│       "keywords": ["loyalty", ...],     │
│       "meanings": { ... }                │
│     }                                    │
│   ],                                     │
│   "synthesis": {                         │
│     "dominantThemes": [...],            │
│     "interpretation": "..."             │
│   }                                      │
│ }                                        │
└────────┬────────────────────────────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│ Claude presents layered analysis:        │
│                                          │
│ 🔮 Symbolic Analysis: The Fool          │
│                                          │
│ **Primary Symbols:**                    │
│ Dog - Loyalty, instinct, guidance...    │
│ [formatted, comprehensive output]       │
└──────────────────────────────────────────┘
```

## MCP Tool Catalog

### Ephemeris Server Tools (6 total)

| Tool | Input | Output | Latency |
|------|-------|--------|---------|
| `get_current_positions` | none | All planetary positions | <10ms |
| `get_moon_phase` | date? | Moon phase, sign, illumination | <5ms |
| `get_planetary_aspects` | date?, orb? | Array of aspects | <15ms |
| `get_retrograde_planets` | date? | Array of retrograde planets | <10ms |
| `get_ephemeris_for_reading` | timestamp | Complete snapshot | <20ms |
| `get_daily_astrological_weather` | date? | Daily overview + theme | <25ms |

### Symbolism Server Tools (7 total)

| Tool | Input | Output | Latency |
|------|-------|--------|---------|
| `search_symbols` | query, category?, limit? | Matching symbols | <5ms |
| `get_symbol` | category, name | Single symbol details | <2ms |
| `get_category` | category | All symbols in category | <5ms |
| `get_related_symbols` | theme, limit? | Related symbols | <10ms |
| `interpret_card_symbols` | cardName, symbols[] | Multi-symbol synthesis | <15ms |
| `get_color_meanings` | colors[] | Color symbolism | <5ms |
| `get_numerological_insight` | number | Number meanings | <2ms |

## Symbol Database Schema

```json
{
  "category": {
    "symbol-name": {
      "keywords": ["keyword1", "keyword2"],
      "meanings": {
        "general": "Universal meaning",
        "tarot": "Tarot-specific meaning",
        "spiritual": "Esoteric meaning",
        "psychological": "Psychological interpretation"
      },
      "associations": ["related", "concepts"],
      "cultural_context": "Historical/cultural background"
    }
  }
}
```

**Categories:**
- `animals` (13 symbols): dog, wolf, lion, serpent, eagle, etc.
- `colors` (9 symbols): red, blue, yellow, green, purple, white, black, gold, silver
- `numbers` (11 symbols): 0-10, each with tarot + archetypal meanings
- `elements` (5 symbols): fire, water, air, earth, spirit
- `plants` (10 symbols): rose, lily, pomegranate, wheat, lotus, etc.
- `celestial` (4 symbols): sun, moon, stars, lightning

**Total:** 52 curated symbols with rich, multi-layered meanings

## Technical Stack

### Ephemeris Server
- **Runtime**: Node.js
- **Framework**: MCP SDK (`@modelcontextprotocol/sdk`)
- **Astronomy**: `astronomy-engine` (Swiss Ephemeris algorithms)
- **Transport**: stdio (local process)
- **Data Format**: JSON responses
- **Accuracy**: ±0.1° for planetary positions

### Symbolism Server
- **Runtime**: Node.js
- **Framework**: MCP SDK
- **Database**: JSON file-based (in-memory during runtime)
- **Search**: Keyword indexing + fuzzy matching
- **Transport**: stdio (local process)
- **Data Format**: Structured JSON

## Integration Points

### With Tarot Reading App

```javascript
// In functions/api/tarot-reading.js

// 1. Fetch astrological context
const astroContext = await ephemerisTools.get_ephemeris_for_reading(timestamp);

// 2. Analyze card symbols
const symbolAnalysis = await symbolismTools.interpret_card_symbols(
  cardName,
  identifiedSymbols
);

// 3. Enhance narrative
const enrichedNarrative = `
  ${baseReading}

  **Cosmic Context:**
  ${astroContext.readingContext}

  **Symbol Insights:**
  ${symbolAnalysis.synthesis.interpretation}
`;
```

### With Claude Code Workflows

```
User Workflow:
1. Ask for reading
2. Claude automatically checks /astro-reading
3. Claude draws cards (existing logic)
4. Claude analyzes symbols via /symbol-analysis
5. Claude synthesizes everything into narrative
6. User receives enriched reading
```

## Performance Characteristics

### Ephemeris Server
- **Startup Time**: ~500ms (load astronomy-engine)
- **Query Response**: <25ms per tool call
- **Memory Usage**: ~50MB (astronomy data tables)
- **CPU Usage**: Minimal (mathematical calculations)

### Symbolism Server
- **Startup Time**: ~100ms (load symbols.json)
- **Query Response**: <15ms per tool call
- **Memory Usage**: ~5MB (symbol database)
- **CPU Usage**: Minimal (JSON search)

### Combined Impact
- **Total Startup**: ~600ms
- **Reading Enhancement**: +50-100ms
- **Memory Footprint**: ~55MB total
- **Negligible** impact on tarot app performance

## Security Considerations

### Data Privacy
- ✅ No external API calls (fully local)
- ✅ No data transmission outside localhost
- ✅ No personal data storage
- ✅ Astronomical data is public domain

### MCP Security
- ✅ stdio transport (local process only)
- ✅ No network exposure
- ✅ Sandboxed execution
- ✅ No file system access beyond plugin directory

## Extensibility

### Adding New Symbols

```javascript
// Edit symbolism-server/data/symbols.json
{
  "animals": {
    "new-symbol": {
      "keywords": [...],
      "meanings": { ... }
    }
  }
}
```

### Adding New Astrological Features

```javascript
// Add to ephemeris-server/server/ephemeris.js
export function getChironPosition(date) {
  // Implement Chiron ephemeris
}

// Expose via MCP in server/index.js
{
  name: 'get_chiron_position',
  description: 'Get Chiron position for healing themes',
  inputSchema: { ... }
}
```

### Custom Slash Commands

```markdown
<!-- Add to either plugin's commands/ directory -->
---
description: Your custom command
---

# Custom Command

Instructions for Claude to execute...
```

## Future Architecture Enhancements

### Planned Features

1. **Birth Chart Integration**
   - Store user birth data
   - Calculate natal chart
   - Compare transits to natal positions

2. **Historical Ephemeris**
   - Query past dates
   - Track planetary patterns over time
   - Correlate with reading history

3. **Vision Integration**
   - Connect to card image analyzer
   - Automatic symbol detection from card photos
   - Physical deck support

4. **Export & Analytics**
   - Export readings with cosmic context
   - Pattern analysis over time
   - Journal integration

---

**Architecture designed for:** Performance, extensibility, and seamless integration with Mystic Tarot application.
</file>

<file path="plugins/tarot-astro-plugins/INSTALL.md">
# Installation Guide

Quick installation guide for the Tarot Astro Plugins marketplace.

## Prerequisites

- Claude Code installed and running
- Node.js and npm installed on your system
- Basic command-line familiarity

## Step-by-Step Installation

### 1. Add the Marketplace

From your tarot project directory:

```bash
# Navigate to your project root
cd /home/azureuser/tarot

# Start Claude Code
claude

# In Claude Code, add the marketplace
/plugin marketplace add ./plugins/tarot-astro-plugins
```

### 2. Install the Plugins

```bash
# Install both plugins
/plugin install ephemeris-server@tarot-astro-plugins
/plugin install symbolism-server@tarot-astro-plugins
```

Select "Install now" when prompted for each plugin.

### 3. Install Dependencies and Download Ephemeris Files

Open a new terminal and run:

```bash
# Install ephemeris server dependencies
cd /home/azureuser/tarot/plugins/tarot-astro-plugins/ephemeris-server
npm install

# Download Swiss Ephemeris data files (required for calculations)
cd ephe
wget https://github.com/aloistr/swisseph/raw/master/ephe/sepl_18.se1
wget https://github.com/aloistr/swisseph/raw/master/ephe/semo_18.se1
cd ..

# Install symbolism server dependencies
cd ../symbolism-server
npm install
```

Expected output:
```
✅ Swiss Ephemeris data files found!
   Location: /home/azureuser/tarot/plugins/tarot-astro-plugins/ephemeris-server/ephe
   Files: sepl_18.se1, semo_18.se1

added 2 packages in 12s
```

**Note:** The ephemeris server uses Swiss Ephemeris, which requires data files for calculations. The `npm install` postinstall script will check for these files and provide guidance if they're missing.

### 4. Restart Claude Code

Exit and restart Claude Code to activate the MCP servers:

```bash
# Exit Claude Code
/exit

# Start again
claude
```

### 5. Verify Installation

Check that everything is working:

```bash
# Check plugins are installed
/plugin

# Check MCP servers are running
/mcp

# Try the custom commands
/astro-reading
/symbol-analysis The Fool
```

## Verification Checklist

✅ Marketplace appears in `/plugin marketplace list`
✅ Both plugins show as "Enabled" in `/plugin`
✅ Both MCP servers show as "Connected" in `/mcp`
✅ `/astro-reading` command is available
✅ `/symbol-analysis` command is available
✅ MCP tools are accessible (try asking "What's the current moon phase?")

## Troubleshooting

### Issue: Plugins not appearing

**Solution:**
```bash
# Verify marketplace was added correctly
/plugin marketplace list

# If not listed, re-add the marketplace
/plugin marketplace add ./plugins/tarot-astro-plugins
```

### Issue: MCP servers not connecting

**Solution:**
```bash
# Check that dependencies are installed
cd /home/azureuser/tarot/plugins/tarot-astro-plugins/ephemeris-server
ls node_modules

# If empty, run:
npm install

# Do the same for symbolism-server
cd ../symbolism-server
npm install

# Restart Claude Code
```

### Issue: "astronomy-engine not found"

**Solution:**
```bash
# Reinstall dependencies
cd /home/azureuser/tarot/plugins/tarot-astro-plugins/ephemeris-server
rm -rf node_modules
npm install
```

### Issue: Commands not working

**Solution:**
```bash
# Verify plugins are enabled
/plugin

# If disabled, enable them:
/plugin enable ephemeris-server@tarot-astro-plugins
/plugin enable symbolism-server@tarot-astro-plugins

# Restart Claude Code
```

## Testing the Installation

Try these commands to ensure everything works:

### Test Ephemeris Server

```bash
# Ask for current planetary positions
> "What are the current planetary positions?"

# Use the astro-reading command
/astro-reading

# Ask about moon phase
> "What's today's moon phase and what does it mean?"
```

Expected: Claude should use the ephemeris MCP tools to provide real astronomical data.

### Test Symbolism Server

```bash
# Use the symbol-analysis command
/symbol-analysis The Magician

# Ask about a specific symbol
> "What does the serpent symbolize in tarot?"

# Search for related symbols
> "Find all symbols related to transformation"
```

Expected: Claude should use the symbolism MCP tools to provide detailed symbol meanings.

### Test Integration

```bash
# Ask for a reading with both contexts
> "I'd like a one-card reading. Please include current astrological
   context and analyze the symbols in the card that comes up."
```

Expected: Claude should use both servers together to provide a rich, contextual reading.

## Next Steps

Once installed successfully:

1. **Explore the documentation**: See README.md for full feature documentation
2. **Try the slash commands**: `/astro-reading` and `/symbol-analysis`
3. **Integrate with readings**: Ask Claude to include cosmic context in your spreads
4. **Customize**: Add your own symbols or modify interpretations as needed

## Uninstallation

To remove the plugins:

```bash
# Uninstall both plugins
/plugin uninstall ephemeris-server@tarot-astro-plugins
/plugin uninstall symbolism-server@tarot-astro-plugins

# Remove the marketplace (optional)
/plugin marketplace remove tarot-astro-plugins
```

## Getting Help

If you encounter issues not covered here:

1. Check the main README.md for detailed documentation
2. Run `claude --debug` to see detailed error logs
3. Verify Node.js and npm are properly installed: `node --version && npm --version`
4. Check file permissions on the plugin directories

---

**Installation complete!** You're now ready to enhance your tarot readings with cosmic wisdom. ✨
</file>

<file path="plugins/tarot-astro-plugins/README.md">
# Tarot Astro Plugins

Enhance your tarot readings with real-time astrological context and comprehensive symbolism analysis.

## Overview

This marketplace provides two powerful MCP server plugins that bring depth and cosmic context to your tarot practice:

### 📡 Ephemeris Server
Real-time astronomical data including planetary positions, moon phases, aspects, and retrograde tracking. Adds astrological context to readings with accurate celestial information.

### 🔮 Symbolism Reference Database
Comprehensive symbolism database covering animals, colors, numbers, elements, plants, and celestial bodies. Provides multi-layered interpretations for tarot card imagery.

## Quick Start

### Installation

1. **Add the marketplace** to Claude Code:
   ```bash
   cd /home/azureuser/tarot
   /plugin marketplace add ./plugins/tarot-astro-plugins
   ```

2. **Install both plugins:**
   ```bash
   /plugin install ephemeris-server@tarot-astro-plugins
   /plugin install symbolism-server@tarot-astro-plugins
   ```

3. **Install dependencies** for each plugin:
   ```bash
   cd plugins/tarot-astro-plugins/ephemeris-server
   npm install

   cd ../symbolism-server
   npm install
   ```

4. **Restart Claude Code** to activate the MCP servers

### Verify Installation

Once installed, you should see:

```bash
# Check that both plugins are loaded
/plugin

# Check that MCP servers are running
/mcp

# Try the custom slash commands
/astro-reading
/symbol-analysis The Fool
```

## Features

### Ephemeris Server Features

✨ **Current Planetary Positions**
- All planets by sign and degree
- Longitudinal and latitudinal coordinates
- Real-time astronomical accuracy

🌙 **Moon Phase Tracking**
- Current phase name and angle
- Illumination percentage
- Sign placement and interpretation
- Waxing/waning status

⚡ **Planetary Aspects**
- Conjunctions, oppositions, squares, trines, sextiles
- Configurable orb tolerance
- Interpretive meanings for each aspect

♒ **Retrograde Detection**
- Identifies all retrograde planets
- Sign and degree placement
- Interpretation guidance

📅 **Daily Astrological Weather**
- Overview of key transits and themes
- Major aspects within tight orbs
- Recommended focus areas

### Symbolism Server Features

🦁 **Animal Symbolism**
- 12+ animals with rich meanings
- Tarot-specific interpretations
- Archetypal associations

🎨 **Color Analysis**
- 9 primary colors
- Psychological, spiritual, and elemental meanings
- Chakra and suit associations

🔢 **Numerological Insights**
- Numbers 0-10
- Tarot and spiritual significance
- Archetypal meanings

🌊 **Elemental Wisdom**
- Five elements (Fire, Water, Air, Earth, Spirit)
- Alchemical correspondences
- Directional and quality associations

🌸 **Plant & Botanical Symbols**
- Sacred plants and their meanings
- Mythological connections
- Spiritual significance

⭐ **Celestial Bodies**
- Sun, Moon, Stars, Lightning
- Astrological and spiritual interpretations

## Usage Examples

### Adding Astrological Context to a Reading

```bash
# Get current cosmic context
/astro-reading

# Then proceed with your reading
# Claude will have access to current planetary positions,
# moon phase, aspects, and retrograde information
```

**Example output:**
```
🌙 Astrological Context for Your Reading

**Moon Phase:** Waxing Gibbous in Pisces (87% illuminated)
The moon is building toward fullness while moving through intuitive
Pisces, suggesting a time of refinement and emotional deepening.

**Planetary Highlights:**
- Sun square Mars (orb: 0.8°) - Dynamic tension catalyzing breakthroughs
- Venus trine Jupiter (orb: 2.3°) - Expansive love energy, optimism
- Mercury in Capricorn - Practical, grounded communication

**Integration with Your Cards:**
With Mars and the Sun in dynamic square, themes of action, courage,
or constructive conflict in your cards may be especially relevant.
```

### Deep Symbol Analysis

```bash
# Analyze symbols in a specific card
/symbol-analysis The High Priestess

# Or ask Claude to interpret symbols
> "What does the pomegranate symbolize in The High Priestess?"
```

**Example output:**
```
🔮 Symbolic Analysis: The High Priestess

**Primary Symbols:**

Pomegranate
• Keywords: underworld, knowledge, abundance, fertility, Persephone
• General meaning: Underworld mysteries, sacred knowledge
• In this card: The veil decorated with pomegranates represents
  the threshold between conscious and unconscious
• Archetypal resonance: Seeds of wisdom, descent into the
  underworld, hidden abundance

[Additional symbols analyzed...]

**Symbolic Synthesis:**
The High Priestess sits at the threshold between opposites, veiled
by pomegranates (hidden wisdom), with the moon at her feet
(unconscious mastery). She holds wisdom that must be accessed
through intuition and inner knowing.
```

### Integration During Readings

The plugins work automatically during readings. Claude can:

```bash
# Reference current planetary energies
> "Consider the current Mars square Uranus when interpreting The Tower"

# Look up symbol meanings
> "What does the color blue represent in The Star card?"

# Check numerological significance
> "What's the significance of position 7 in this spread?"

# Get moon phase context
> "How does today's new moon affect this reading?"
```

## MCP Tools Reference

### Ephemeris Server Tools

| Tool | Description | Example Use |
|------|-------------|-------------|
| `get_current_positions` | All planetary positions | Current cosmic snapshot |
| `get_moon_phase` | Moon phase data | Lunar timing context |
| `get_planetary_aspects` | Active aspects | Understanding tensions/harmonies |
| `get_retrograde_planets` | Retrograde list | Reflection periods |
| `get_ephemeris_for_reading` | Complete snapshot for timestamp | Record cosmic context of reading |
| `get_daily_astrological_weather` | Daily overview | Morning cosmic check-in |

### Symbolism Server Tools

| Tool | Description | Example Use |
|------|-------------|-------------|
| `search_symbols` | Search by keyword | Find all "transformation" symbols |
| `get_symbol` | Get specific symbol | Detailed lion symbolism |
| `get_category` | All symbols in category | All animal symbols |
| `get_related_symbols` | Theme-based search | All love-related symbols |
| `interpret_card_symbols` | Multi-symbol synthesis | Analyze The Fool's symbols |
| `get_color_meanings` | Color analysis | Red, white, blue in reading |
| `get_numerological_insight` | Number meanings | Significance of 3 |

## Custom Slash Commands

### `/astro-reading`
Provides comprehensive astrological context for the current moment:
- Current moon phase and interpretation
- Active planetary aspects
- Retrograde activity
- Daily cosmic theme
- Integration guidance for readings

### `/symbol-analysis [Card Name]`
Deep symbolic analysis of tarot card imagery:
- Primary symbol meanings
- Color symbolism
- Numerological insights
- Symbolic synthesis
- Interpretive guidance

## Integration with Tarot Readings

### Automatic Context Enhancement

The plugins seamlessly integrate with your tarot reading workflow:

**Before the plugins:**
> "The Tower suggests sudden change and breakthrough."

**With astrological context:**
> "The Tower suggests sudden change and breakthrough. With Mars square
> Uranus active today (exact within 1°), this energy of sudden shifts
> and liberation is amplified in the collective field. The Waning Moon
> in Scorpio supports the release of what no longer serves."

**With symbol analysis:**
> "The lightning striking the crown represents divine intervention
> (sudden revelation, breakthrough, awakening). The falling figures
> symbolize the destruction of false structures and ego constructs.
> The cosmic background suggests this is a fated event aligned with
> higher purpose."

### Example Reading Workflow

1. **Set intention** for the reading
2. **Check astrological context**: `/astro-reading`
3. **Draw cards** using your chosen spread
4. **Analyze symbols** as needed: `/symbol-analysis [Card Name]`
5. **Synthesize** card meanings with cosmic context
6. **Record** the reading with timestamp for future reference

## Technical Details

### Requirements
- Claude Code installed
- Node.js (for running MCP servers)
- npm (for dependency installation)

### Dependencies
- **Ephemeris Server**: `astronomy-engine`, `@modelcontextprotocol/sdk`
- **Symbolism Server**: `@modelcontextprotocol/sdk`

### MCP Server Configuration

Both plugins are configured to run as stdio MCP servers:

```json
{
  "mcpServers": {
    "ephemeris": {
      "command": "node",
      "args": ["server/index.js"]
    },
    "symbolism": {
      "command": "node",
      "args": ["server/index.js"]
    }
  }
}
```

### Data Sources

**Ephemeris Server:**
- **Uses genuine Swiss Ephemeris library** (via `sweph` Node.js bindings)
- **Accuracy:** Research-grade precision matching NASA JPL data
- **Precision:** 0.001 arcsecond accuracy for major planets
- Based on JPL DE431 planetary ephemeris data
- Real-time calculations with minimal latency
- Requires ephemeris data files (see EPHEMERIS_DATA_README.md)

**Symbolism Server:**
- Curated database of traditional tarot symbolism
- Cross-referenced with multiple esoteric traditions
- Extensible JSON format for custom additions

## Extending the Plugins

### Adding Custom Symbols

Edit `symbolism-server/data/symbols.json`:

```json
{
  "animals": {
    "phoenix": {
      "keywords": ["rebirth", "transformation", "immortality"],
      "meanings": {
        "general": "Death and rebirth, rising from ashes",
        "tarot": "Judgment, Death - transformation and renewal",
        "archetypal": "Eternal return, alchemical transformation"
      },
      "cultural_context": "Universal symbol of resurrection"
    }
  }
}
```

### Custom Commands

Add new slash commands in the `commands/` directory of either plugin:

```markdown
---
description: Your custom command description
---

# Command Name

Instructions for Claude on how to execute this command...
```

## Troubleshooting

### Plugins Not Loading

```bash
# Check plugin installation
/plugin

# Verify marketplace is added
/plugin marketplace list

# Check for errors in debug mode
claude --debug
```

### MCP Servers Not Running

```bash
# Check MCP server status
/mcp

# Verify dependencies are installed
cd plugins/tarot-astro-plugins/ephemeris-server
npm install

cd ../symbolism-server
npm install

# Restart Claude Code
```

### Ephemeris Calculations Incorrect

The ephemeris server uses well-tested astronomical algorithms. If you encounter discrepancies:

1. Check that `astronomy-engine` is properly installed
2. Verify your system time is correct
3. Compare with https://www.astro.com/swisseph/ for validation

### Symbol Not Found

If a symbol search returns no results:

1. Try alternate spellings or related keywords
2. Check the category (animals, colors, numbers, etc.)
3. Use `get_category` to browse available symbols
4. Consider adding custom symbols to the database

## Future Enhancements

Planned features for future releases:

- [ ] Birth chart integration (enter birth data for personalized context)
- [ ] Astrological transits to natal planets
- [ ] Expanded symbol database with more traditions
- [ ] Integration with card image analysis (vision AI)
- [ ] Historical ephemeris lookups for past readings
- [ ] Customizable symbol interpretation frameworks
- [ ] Export readings with astrological data

## Contributing

To contribute to these plugins:

1. Fork the repository
2. Create your feature branch
3. Add new symbols, improve algorithms, or enhance functionality
4. Test thoroughly with actual readings
5. Submit a pull request

## License

MIT License - See LICENSE file for details

## Credits

**Astronomical Calculations:**
- Swiss Ephemeris via `astronomy-engine`
- JPL Planetary Ephemeris data

**Symbolism Database:**
- Curated from traditional tarot sources
- Rider-Waite-Smith symbolism
- Hermetic and Kabbalistic traditions
- Cross-cultural archetypal research

**Developed for:**
Mystic Tarot - Authentic tarot reading web application

## Support

For issues, questions, or feature requests:
- Open an issue on GitHub
- Consult the documentation
- Test with `claude --debug` for detailed logs

---

**May your readings be illuminated by the stars above and the symbols within.** ✨🌙🔮
</file>

<file path="plugins/tarot-astro-plugins/test-servers.sh">
#!/bin/bash

# Test script for Tarot Astro Plugins MCP servers

echo "🧪 Testing Tarot Astro Plugins MCP Servers"
echo "=========================================="
echo ""

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Test counter
TESTS_PASSED=0
TESTS_FAILED=0

# Function to test if a command succeeds
test_command() {
    local description=$1
    local command=$2

    echo -n "Testing: $description... "

    if eval $command > /dev/null 2>&1; then
        echo -e "${GREEN}✓ PASS${NC}"
        ((TESTS_PASSED++))
        return 0
    else
        echo -e "${RED}✗ FAIL${NC}"
        ((TESTS_FAILED++))
        return 1
    fi
}

# Check Node.js is installed
echo "Prerequisites:"
test_command "Node.js is installed" "command -v node"
test_command "npm is installed" "command -v npm"
echo ""

# Check dependencies are installed
echo "Dependencies:"
test_command "Ephemeris server has node_modules" "test -d ephemeris-server/node_modules"
test_command "Symbolism server has node_modules" "test -d symbolism-server/node_modules"
test_command "astronomy-engine is installed" "test -d ephemeris-server/node_modules/astronomy-engine"
test_command "MCP SDK is installed (ephemeris)" "test -d ephemeris-server/node_modules/@modelcontextprotocol"
test_command "MCP SDK is installed (symbolism)" "test -d symbolism-server/node_modules/@modelcontextprotocol"
echo ""

# Check file structure
echo "File Structure:"
test_command "Marketplace manifest exists" "test -f .claude-plugin/marketplace.json"
test_command "Ephemeris plugin manifest exists" "test -f ephemeris-server/.claude-plugin/plugin.json"
test_command "Ephemeris MCP config exists" "test -f ephemeris-server/.mcp.json"
test_command "Ephemeris server code exists" "test -f ephemeris-server/server/index.js"
test_command "Ephemeris calculations exist" "test -f ephemeris-server/server/ephemeris.js"
test_command "Symbolism plugin manifest exists" "test -f symbolism-server/.claude-plugin/plugin.json"
test_command "Symbolism MCP config exists" "test -f symbolism-server/.mcp.json"
test_command "Symbolism server code exists" "test -f symbolism-server/server/index.js"
test_command "Symbolism database exists" "test -f symbolism-server/server/database.js"
test_command "Symbol data file exists" "test -f symbolism-server/data/symbols.json"
echo ""

# Check custom commands
echo "Custom Commands:"
test_command "Astro-reading command exists" "test -f ephemeris-server/commands/astro-reading.md"
test_command "Symbol-analysis command exists" "test -f symbolism-server/commands/symbol-analysis.md"
echo ""

# Check JSON files are valid
echo "JSON Validation:"
test_command "Marketplace JSON is valid" "node -e 'require(\"./.claude-plugin/marketplace.json\")'"
test_command "Ephemeris plugin JSON is valid" "node -e 'require(\"./ephemeris-server/.claude-plugin/plugin.json\")'"
test_command "Ephemeris MCP JSON is valid" "node -e 'require(\"./ephemeris-server/.mcp.json\")'"
test_command "Symbolism plugin JSON is valid" "node -e 'require(\"./symbolism-server/.claude-plugin/plugin.json\")'"
test_command "Symbolism MCP JSON is valid" "node -e 'require(\"./symbolism-server/.mcp.json\")'"
test_command "Symbol database JSON is valid" "node -e 'require(\"./symbolism-server/data/symbols.json\")'"
echo ""

# Test symbol database content
echo "Symbol Database Content:"
test_command "Animals category exists" "node -e 'const db = require(\"./symbolism-server/data/symbols.json\"); if (!db.animals) process.exit(1)'"
test_command "Colors category exists" "node -e 'const db = require(\"./symbolism-server/data/symbols.json\"); if (!db.colors) process.exit(1)'"
test_command "Numbers category exists" "node -e 'const db = require(\"./symbolism-server/data/symbols.json\"); if (!db.numbers) process.exit(1)'"
test_command "Elements category exists" "node -e 'const db = require(\"./symbolism-server/data/symbols.json\"); if (!db.elements) process.exit(1)'"
test_command "Plants category exists" "node -e 'const db = require(\"./symbolism-server/data/symbols.json\"); if (!db.plants) process.exit(1)'"
test_command "Celestial category exists" "node -e 'const db = require(\"./symbolism-server/data/symbols.json\"); if (!db.celestial) process.exit(1)'"
echo ""

# Summary
echo "=========================================="
echo "Test Summary:"
echo -e "  ${GREEN}Passed: $TESTS_PASSED${NC}"
if [ $TESTS_FAILED -gt 0 ]; then
    echo -e "  ${RED}Failed: $TESTS_FAILED${NC}"
else
    echo -e "  ${GREEN}Failed: $TESTS_FAILED${NC}"
fi
echo ""

if [ $TESTS_FAILED -eq 0 ]; then
    echo -e "${GREEN}✓ All tests passed! Plugins are ready to use.${NC}"
    echo ""
    echo "Next steps:"
    echo "1. Start Claude Code: claude"
    echo "2. Add marketplace: /plugin marketplace add ./plugins/tarot-astro-plugins"
    echo "3. Install plugins: /plugin install ephemeris-server@tarot-astro-plugins"
    echo "                    /plugin install symbolism-server@tarot-astro-plugins"
    echo "4. Restart Claude Code"
    echo "5. Test with: /astro-reading and /symbol-analysis"
    exit 0
else
    echo -e "${RED}✗ Some tests failed. Please review the errors above.${NC}"
    exit 1
fi
</file>

<file path="public/images/tableu-sprite.svg">
<svg xmlns="http://www.w3.org/2000/svg" style="display:none">
  <defs>
    <style>
      .tableu-fill {
        fill: var(--fill, currentColor);
      }
      .tableu-stroke {
        fill: none;
        stroke: var(--fill, currentColor);
        stroke-width: 6;
        stroke-linecap: round;
        stroke-linejoin: round;
      }
      .theme-primary {
        --fill: #C9B36E;
      }
      .theme-mono {
        --fill: #000000;
      }
      .theme-dark {
        --fill: #FFFFFF;
      }
    </style>

    <!-- Tableu Logo Art: Octopus in tarot card frame with celestial elements -->
    <g id="tableu-art-shape">
      <!-- Card Frame (rounded rectangle with divider) -->
      <rect class="tableu-stroke" x="100" y="40" width="232" height="340" rx="20" ry="20"/>
      <!-- Top divider line -->
      <line class="tableu-stroke" x1="216" y1="40" x2="216" y2="120"/>

      <!-- Crescent Moon (upper left) -->
      <path class="tableu-fill" d="M145 90
        a 28 28 0 1 1 0 50
        a 22 22 0 1 0 0 -50 Z"/>

      <!-- Star upper right (4-pointed) -->
      <path class="tableu-fill" d="M275 75
        l 4 12 l 12 4 l -12 4 l -4 12
        l -4 -12 l -12 -4 l 12 -4 Z"/>

      <!-- Line from octopus arm to star -->
      <path class="tableu-stroke" stroke-width="4" d="M255 140 Q 270 110 275 95"/>

      <!-- Octopus Head -->
      <ellipse class="tableu-fill" cx="216" cy="190" rx="55" ry="50"/>

      <!-- Octopus closed eyes (curved lines) -->
      <path class="tableu-stroke" stroke-width="5" fill="none" stroke="#1a1a2e" d="M190 200 Q 200 210 210 200"/>
      <path class="tableu-stroke" stroke-width="5" fill="none" stroke="#1a1a2e" d="M222 200 Q 232 210 242 200"/>

      <!-- Octopus smile -->
      <path class="tableu-stroke" stroke-width="4" fill="none" stroke="#1a1a2e" d="M200 220 Q 216 235 232 220"/>

      <!-- Octopus Tentacles (8 total) -->
      <!-- Upper left tentacle (reaching up) -->
      <path class="tableu-fill" d="M175 175 Q 150 150 145 170 Q 155 175 165 180 Q 170 185 175 190 Z"/>
      <!-- Upper right tentacle (reaching to star) -->
      <path class="tableu-fill" d="M257 175 Q 270 145 260 140 Q 252 150 250 165 Q 253 175 257 185 Z"/>

      <!-- Mid-upper left -->
      <path class="tableu-fill" d="M165 200 Q 130 190 125 210 Q 140 215 155 215 Q 160 210 165 205 Z"/>
      <!-- Mid-upper right -->
      <path class="tableu-fill" d="M267 200 Q 290 195 290 215 Q 275 218 265 215 Q 265 210 267 205 Z"/>

      <!-- Lower tentacles (4 hanging down) -->
      <path class="tableu-fill" d="M180 235 Q 165 280 155 320 Q 160 325 170 315 Q 178 275 185 240 Z"/>
      <path class="tableu-fill" d="M200 240 Q 190 290 185 340 Q 195 345 200 335 Q 205 290 208 245 Z"/>
      <path class="tableu-fill" d="M232 240 Q 242 290 247 340 Q 237 345 232 335 Q 227 290 224 245 Z"/>
      <path class="tableu-fill" d="M252 235 Q 267 280 277 320 Q 272 325 262 315 Q 254 275 247 240 Z"/>

      <!-- Stars on left side -->
      <!-- Lower left star (outside frame) -->
      <path class="tableu-fill" d="M70 270
        l 3 9 l 9 3 l -9 3 l -3 9
        l -3 -9 l -9 -3 l 9 -3 Z"/>
      <!-- Second star (inside frame area) -->
      <path class="tableu-fill" d="M95 310
        l 2 6 l 6 2 l -6 2 l -2 6
        l -2 -6 l -6 -2 l 6 -2 Z"/>

      <!-- Line connecting to stars -->
      <path class="tableu-stroke" stroke-width="3" d="M145 260 L 80 275"/>

      <!-- Eye symbol (right side, outside frame) -->
      <g transform="translate(350, 230)">
        <!-- Eye outline -->
        <ellipse class="tableu-stroke" stroke-width="5" cx="0" cy="0" rx="28" ry="18"/>
        <!-- Iris -->
        <circle class="tableu-stroke" stroke-width="4" cx="0" cy="0" r="8"/>
        <!-- Pupil -->
        <circle class="tableu-fill" cx="0" cy="0" r="3"/>
      </g>

      <!-- Line from tentacle to eye -->
      <path class="tableu-stroke" stroke-width="3" d="M290 215 L 320 225"/>

      <!-- Curved base/horizon line inside card -->
      <path class="tableu-stroke" stroke-width="5" d="M110 355 Q 216 380 322 355"/>
    </g>
  </defs>

  <symbol id="tableu-mark" viewBox="0 0 432 400">
    <g class="theme-primary">
      <use href="#tableu-art-shape" />
    </g>
  </symbol>

  <symbol id="tableu-primary" viewBox="0 0 432 400">
    <use href="#tableu-mark" />
  </symbol>

  <symbol id="tableu-icon" viewBox="0 0 432 400">
    <use href="#tableu-mark" />
  </symbol>

  <symbol id="tableu-mono" viewBox="0 0 432 400">
    <g class="theme-mono">
      <use href="#tableu-art-shape" />
    </g>
  </symbol>

  <symbol id="tableu-dark" viewBox="0 0 432 400">
    <g class="theme-dark">
      <use href="#tableu-art-shape" />
    </g>
  </symbol>

  <symbol id="tableu-favicon" viewBox="60 20 320 400">
    <g class="theme-primary">
      <use href="#tableu-art-shape" />
    </g>
  </symbol>

  <symbol id="tableu-full" viewBox="0 0 432 500">
    <g class="theme-primary">
      <use href="#tableu-art-shape" />
      <text
        x="216"
        y="470"
        text-anchor="middle"
        font-family="'Cormorant Garamond', 'Times New Roman', serif"
        font-size="56"
        font-weight="400"
        letter-spacing="14"
        class="tableu-fill"
      >TABLEU</text>
    </g>
  </symbol>
</svg>
</file>

<file path="public/manifest.webmanifest">
{
  "name": "Tableu",
  "short_name": "Tableu",
  "description": "Tableu blends AI insights, journaling, and ritual tooling. Authentic tarot, thoughtfully interpreted.",
  "start_url": "/",
  "scope": "/",
  "display": "standalone",
  "background_color": "#020617",
  "theme_color": "#022c22",
  "icons": [
    {
      "src": "/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
</file>

<file path="public/offline.html">
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mystic Tarot · Offline</title>
    <style>
      body {
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        background: radial-gradient(circle at top, #0f172a 0%, #020617 70%);
        color: #fef9c3;
        margin: 0;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 2rem;
        text-align: center;
      }
      .card {
        border: 1px solid rgba(16, 185, 129, 0.4);
        border-radius: 1.5rem;
        padding: 2rem 2.5rem;
        max-width: 28rem;
        background: rgba(2, 6, 23, 0.85);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
      }
      h1 {
        font-family: "Playfair Display", "Times New Roman", serif;
        margin-bottom: 0.25rem;
        font-size: 1.75rem;
      }
      p {
        font-size: 0.95rem;
        line-height: 1.5;
        color: rgba(248, 250, 252, 0.85);
      }
      button {
        margin-top: 1.5rem;
        padding: 0.85rem 1.5rem;
        border-radius: 999px;
        border: 1px solid rgba(248, 250, 252, 0.4);
        background: transparent;
        color: inherit;
        font-weight: 600;
      }
    </style>
  </head>
  <body>
    <main class="card">
      <h1>Offline for now</h1>
      <p>
        Mystic Tarot can run offline once your spreads and journal load at least once.
        Please reconnect to sync the latest decks, AI insights, and audio features.
      </p>
      <button type="button" onclick="window.location.reload()">Try again</button>
    </main>
  </body>
</html>
</file>

<file path="public/sw.js">
const CACHE_NAME = 'mystic-tarot-shell-v1';
const OFFLINE_URL = '/offline.html';
const PLACEHOLDER_IMAGE = '/images/cards/RWS1909_-_00_Fool.jpeg';
const PRECACHE_URLS = [
  '/',
  '/journal',
  OFFLINE_URL,
  '/manifest.webmanifest',
  '/icons/icon-192.svg',
  '/icons/icon-512.svg',
  PLACEHOLDER_IMAGE
];

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(PRECACHE_URLS)).then(() => self.skipWaiting())
  );
});

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches
      .keys()
      .then((keys) =>
        Promise.all(
          keys.filter((key) => key !== CACHE_NAME).map((key) => caches.delete(key))
        )
      )
      .then(() => self.clients.claim())
  );
});

function isApiRequest(url) {
  return url.includes('/api/');
}

function isSameOrigin(request) {
  return request.url.startsWith(self.location.origin);
}

async function cacheResponse(request, response) {
  if (!response || response.status !== 200) {
    return response;
  }
  const cache = await caches.open(CACHE_NAME);
  cache.put(request, response.clone());
  return response;
}

self.addEventListener('fetch', (event) => {
  const { request } = event;
  if (request.method !== 'GET' || !isSameOrigin(request) || isApiRequest(request.url)) {
    return;
  }

  if (request.mode === 'navigate') {
    event.respondWith(
      fetch(request)
        .then((response) => cacheResponse(request, response))
        .catch(async () => {
          const cached = await caches.match(request);
          return cached || caches.match('/') || caches.match(OFFLINE_URL);
        })
    );
    return;
  }

  event.respondWith(
    caches.match(request).then((cachedResponse) => {
      if (cachedResponse) {
        fetch(request)
          .then((response) => cacheResponse(request, response))
          .catch(() => {});
        return cachedResponse;
      }
      return fetch(request)
        .then((response) => cacheResponse(request, response))
        .catch(async () => {
          if (request.destination === 'image') {
            const fallback = await caches.match(PLACEHOLDER_IMAGE);
            if (fallback) return fallback;
          }
          return caches.match(OFFLINE_URL);
        });
    })
  );
});
</file>

<file path="scripts/assets/generate_thoth_placeholders_enhanced.py">
#!/usr/bin/env python3
"""
Generate enhanced stylised placeholder images for the Thoth (Crowley/Harris) deck.

The real artwork is still under copyright in many jurisdictions, so this script
creates abstract cards with Thoth-specific titles, suit colours, and keywords,
enhanced with astrological symbols, Hebrew letters, and Art Deco gradients to
improve CLIP vision recognition accuracy.
"""

from __future__ import annotations

import math
import textwrap
from pathlib import Path

from PIL import Image, ImageDraw, ImageFont, ImageFilter

# Canvas configuration
WIDTH = 480
HEIGHT = 800
MARGIN = 32
TITLE_BAND = 90
KEYWORD_ZONE = 160

OUT_DIR = Path("public/images/cards/thoth")
OUT_DIR.mkdir(parents=True, exist_ok=True)


def load_font(name: str, size: int) -> ImageFont.FreeTypeFont:
    """
    Attempt to load the requested font family. Fall back to DejaVuSans which is
    available on the GitHub runners and Codespaces base images.
    """
    search_paths = [
        f"/usr/share/fonts/truetype/dejavu/{name}.ttf",
        f"/usr/share/fonts/truetype/{name}.ttf",
        f"/System/Library/Fonts/{name}.ttc",
    ]
    for path in search_paths:
        if Path(path).exists():
            return ImageFont.truetype(path, size)
    return ImageFont.load_default()


TITLE_FONT = load_font("DejaVuSans-Bold", 42)
SUBTITLE_FONT = load_font("DejaVuSans", 26)
KEYWORD_FONT = load_font("DejaVuSans", 22)
SYMBOL_FONT = load_font("DejaVuSans", 64)


# Hebrew letters for Major Arcana (Unicode)
HEBREW_LETTERS = {
    0: "א",   # Aleph
    1: "ב",   # Beth
    2: "ג",   # Gimel
    3: "ד",   # Daleth
    4: "צ",   # Tzaddi
    5: "ו",   # Vav
    6: "ז",   # Zain
    7: "ח",   # Cheth
    8: "ל",   # Lamed
    9: "י",   # Yod
    10: "כ",  # Kaph
    11: "ט",  # Teth
    12: "מ",  # Mem
    13: "נ",  # Nun
    14: "ס",  # Samekh
    15: "ע",  # Ayin
    16: "פ",  # Pe
    17: "ה",  # He (Star uses Tzaddi in some systems)
    18: "ק",  # Qoph
    19: "ר",  # Resh
    20: "ש",  # Shin
    21: "ת",  # Tau
}

# Astrological/Elemental symbols (Unicode)
ASTRO_SYMBOLS = {
    "Aries": "♈", "Taurus": "♉", "Gemini": "♊", "Cancer": "♋",
    "Leo": "♌", "Virgo": "♍", "Libra": "♎", "Scorpio": "♏",
    "Sagittarius": "♐", "Capricorn": "♑", "Aquarius": "♒", "Pisces": "♓",
    "Sun": "☉", "Moon": "☽", "Mercury": "☿", "Venus": "♀",
    "Mars": "♂", "Jupiter": "♃", "Saturn": "♄",
    "Air": "🜁", "Water": "🜄", "Fire": "🜂", "Earth": "🜃",
}

THOTH_MAJOR_TITLES = {
    0: ("The Fool", "Aleph • Air", "Air"),
    1: ("The Magus", "Beth • Mercury", "Mercury"),
    2: ("The Priestess", "Gimel • Moon", "Moon"),
    3: ("The Empress", "Daleth • Venus", "Venus"),
    4: ("The Emperor", "Tzaddi • Aries", "Aries"),
    5: ("The Hierophant", "Vav • Taurus", "Taurus"),
    6: ("The Lovers", "Zain • Gemini", "Gemini"),
    7: ("The Chariot", "Cheth • Cancer", "Cancer"),
    8: ("Adjustment", "Lamed • Libra", "Libra"),
    9: ("The Hermit", "Yod • Virgo", "Virgo"),
    10: ("Fortune", "Kaph • Jupiter", "Jupiter"),
    11: ("Lust", "Teth • Leo", "Leo"),
    12: ("The Hanged Man", "Mem • Water", "Water"),
    13: ("Death", "Nun • Scorpio", "Scorpio"),
    14: ("Art", "Samekh • Sagittarius", "Sagittarius"),
    15: ("The Devil", "Ayin • Capricorn", "Capricorn"),
    16: ("The Tower", "Pe • Mars", "Mars"),
    17: ("The Star", "Tzaddi • Aquarius", "Aquarius"),
    18: ("The Moon", "Qoph • Pisces", "Pisces"),
    19: ("The Sun", "Resh • Sun", "Sun"),
    20: ("The Aeon", "Shin • Fire/Spirit", "Fire"),
    21: ("The Universe", "Tau • Saturn/Earth", "Saturn"),
}

THOTH_MINOR_TITLES = {
    "Wands": {
        1: "Root of Fire", 2: "Dominion", 3: "Virtue", 4: "Completion", 5: "Strife",
        6: "Victory", 7: "Valour", 8: "Swiftness", 9: "Strength", 10: "Oppression",
    },
    "Cups": {
        1: "Root of Water", 2: "Love", 3: "Abundance", 4: "Luxury", 5: "Disappointment",
        6: "Pleasure", 7: "Debauch", 8: "Indolence", 9: "Happiness", 10: "Satiety",
    },
    "Swords": {
        1: "Root of Air", 2: "Peace", 3: "Sorrow", 4: "Truce", 5: "Defeat",
        6: "Science", 7: "Futility", 8: "Interference", 9: "Cruelty", 10: "Ruin",
    },
    "Pentacles": {
        1: "Root of Earth", 2: "Change", 3: "Works", 4: "Power", 5: "Worry",
        6: "Success", 7: "Failure", 8: "Prudence", 9: "Gain", 10: "Wealth",
    },
}

# Enhanced Art Deco color palettes per suit
SUIT_COLOURS = {
    "major": {
        "base": [(29, 27, 42), (73, 60, 123), (94, 80, 150)],  # Deep indigo gradient
        "accent": [(233, 213, 255), (186, 148, 255), (147, 112, 219)],  # Violet-lavender
        "glow": (233, 213, 255),
    },
    "Wands": {
        "base": [(52, 19, 8), (115, 46, 16), (217, 119, 6)],  # Fire ombre
        "accent": [(251, 191, 36), (252, 211, 77), (254, 243, 199)],  # Gold gradient
        "glow": (251, 191, 36),
    },
    "Cups": {
        "base": [(4, 47, 46), (13, 148, 136), (45, 212, 191)],  # Teal depths
        "accent": [(153, 246, 228), (94, 234, 212), (20, 184, 166)],  # Aqua shimmer
        "glow": (153, 246, 228),
    },
    "Swords": {
        "base": [(15, 23, 42), (30, 58, 138), (59, 130, 246)],  # Blue steel
        "accent": [(191, 219, 254), (147, 197, 253), (96, 165, 250)],  # Sky blue
        "glow": (191, 219, 254),
    },
    "Pentacles": {
        "base": [(26, 31, 22), (63, 98, 18), (132, 204, 22)],  # Earth green
        "accent": [(217, 249, 157), (190, 242, 100), (163, 230, 53)],  # Lime radiance
        "glow": (217, 249, 157),
    },
}

SUIT_ALIASES = {
    "Pentacles": "Disks",
    "Wands": "Wands",
    "Cups": "Cups",
    "Swords": "Swords",
}

COURT_ALIASES = {
    "Page": "Princess",
    "Knight": "Prince",
    "Queen": "Queen",
    "King": "Knight",
}

RANK_LABELS = {
    1: "Ace", 2: "Two", 3: "Three", 4: "Four", 5: "Five",
    6: "Six", 7: "Seven", 8: "Eight", 9: "Nine", 10: "Ten",
}

# Element symbols for Minor Arcana
SUIT_ELEMENTS = {
    "Wands": "Fire",
    "Cups": "Water",
    "Swords": "Air",
    "Pentacles": "Earth",
}


def slugify(value: str) -> str:
    return (
        value.lower()
        .replace(" ", "-")
        .replace("/", "-")
        .replace("'", "")
        .replace(".", "")
    )


def draw_gradient_background(draw: ImageDraw.ImageDraw, width: int, height: int, colors: list):
    """Draw a vertical gradient using the color list."""
    num_colors = len(colors)
    if num_colors < 2:
        return

    segment_height = height // (num_colors - 1)

    for i in range(num_colors - 1):
        r1, g1, b1 = colors[i]
        r2, g2, b2 = colors[i + 1]

        for y in range(segment_height):
            progress = y / segment_height
            r = int(r1 + (r2 - r1) * progress)
            g = int(g1 + (g2 - g1) * progress)
            b = int(b1 + (b2 - b1) * progress)

            y_pos = i * segment_height + y
            if y_pos < height:
                draw.line([(0, y_pos), (width, y_pos)], fill=(r, g, b))


def draw_geometric_motifs(draw: ImageDraw.ImageDraw, width: int, height: int, accent_colors: list, suit: str):
    """Draw Art Deco geometric patterns inspired by Thoth deck."""
    accent = accent_colors[1] if len(accent_colors) > 1 else accent_colors[0]

    # Central mandala-like circles
    center_x, center_y = width // 2, height // 2

    # Outer circle
    draw.ellipse(
        [center_x - 140, center_y - 140, center_x + 140, center_y + 140],
        outline=accent,
        width=3,
    )

    # Middle circle
    draw.ellipse(
        [center_x - 100, center_y - 100, center_x + 100, center_y + 100],
        outline=accent,
        width=2,
    )

    # Inner circle
    draw.ellipse(
        [center_x - 60, center_y - 60, center_x + 60, center_y + 60],
        outline=accent,
        width=2,
    )

    # Radiating lines (8 directions)
    for angle in range(0, 360, 45):
        rad = math.radians(angle)
        x1 = center_x + 70 * math.cos(rad)
        y1 = center_y + 70 * math.sin(rad)
        x2 = center_x + 130 * math.cos(rad)
        y2 = center_y + 130 * math.sin(rad)
        draw.line([(x1, y1), (x2, y2)], fill=accent, width=2)

    # Corner triangles (Art Deco style)
    triangle_size = 40
    for corner in [(0, 0), (width - triangle_size, 0), (0, height - triangle_size), (width - triangle_size, height - triangle_size)]:
        x, y = corner
        if x == 0 and y == 0:  # Top-left
            draw.polygon([(x, y), (x + triangle_size, y), (x, y + triangle_size)], outline=accent, width=2)
        elif x > 0 and y == 0:  # Top-right
            draw.polygon([(x + triangle_size, y), (x + triangle_size, y + triangle_size), (x, y)], outline=accent, width=2)
        elif x == 0 and y > 0:  # Bottom-left
            draw.polygon([(x, y + triangle_size), (x + triangle_size, y + triangle_size), (x, y)], outline=accent, width=2)
        else:  # Bottom-right
            draw.polygon([(x + triangle_size, y + triangle_size), (x, y + triangle_size), (x + triangle_size, y)], outline=accent, width=2)


def draw_text_block(draw: ImageDraw.ImageDraw, text: str, box, font, fill):
    """Render wrapped text inside the bounding box."""
    x0, y0, x1, y1 = box
    width = x1 - x0
    lines = []
    if not text:
        return
    for paragraph in text.splitlines():
        wrapped = textwrap.wrap(paragraph, width=max(1, width // (font.size // 2)))
        lines.extend(wrapped if wrapped else [""])
    total_height = sum(font.getbbox(line)[3] for line in lines) + (len(lines) - 1) * 4
    current_y = y0 + max(0, (y1 - y0 - total_height) // 2)
    for line in lines:
        bbox = font.getbbox(line)
        text_width = bbox[2]
        draw.text(
            (x0 + (width - text_width) / 2, current_y),
            line,
            font=font,
            fill=fill,
        )
        current_y += bbox[3] + 4


def render_card(
    filename: Path,
    title: str,
    subtitle: str,
    keyword: str,
    suit: str,
    hebrew_letter: str = None,
    astro_symbol: str = None,
):
    """Render enhanced Thoth-style card with gradients and symbols."""
    colors = SUIT_COLOURS[suit]
    base_gradient = colors["base"]
    accent_gradient = colors["accent"]
    glow_color = colors["glow"]

    # Create base image with gradient
    image = Image.new("RGB", (WIDTH, HEIGHT), base_gradient[0])
    draw = ImageDraw.Draw(image)

    # Draw gradient background
    draw_gradient_background(draw, WIDTH, HEIGHT, base_gradient)

    # Draw geometric Art Deco motifs
    draw_geometric_motifs(draw, WIDTH, HEIGHT, accent_gradient, suit)

    # Title band with gradient
    title_gradient = Image.new("RGB", (WIDTH, TITLE_BAND), accent_gradient[0])
    title_draw = ImageDraw.Draw(title_gradient)
    draw_gradient_background(title_draw, WIDTH, TITLE_BAND, accent_gradient)
    image.paste(title_gradient, (0, 0))

    # Draw title
    draw_text_block(
        draw,
        title.upper(),
        (MARGIN, 12, WIDTH - MARGIN, TITLE_BAND - 6),
        TITLE_FONT,
        "#1a1a2e",
    )

    # Hebrew letter (top-left corner) for Major Arcana
    if hebrew_letter:
        draw.text(
            (MARGIN - 8, TITLE_BAND + 20),
            hebrew_letter,
            font=SYMBOL_FONT,
            fill=glow_color,
        )

    # Astrological symbol (top-right corner)
    if astro_symbol:
        symbol_bbox = SYMBOL_FONT.getbbox(astro_symbol)
        symbol_width = symbol_bbox[2] - symbol_bbox[0]
        draw.text(
            (WIDTH - MARGIN - symbol_width + 8, TITLE_BAND + 20),
            astro_symbol,
            font=SYMBOL_FONT,
            fill=glow_color,
        )

    # Subtitle
    draw_text_block(
        draw,
        subtitle,
        (MARGIN, TITLE_BAND + 95, WIDTH - MARGIN, TITLE_BAND + 150),
        SUBTITLE_FONT,
        glow_color,
    )

    # Keywords zone with border
    keyword_y = HEIGHT - KEYWORD_ZONE - MARGIN
    draw.rectangle(
        [MARGIN, keyword_y, WIDTH - MARGIN, HEIGHT - MARGIN],
        outline=accent_gradient[1],
        width=4,
    )

    # Inner glow effect
    draw.rectangle(
        [MARGIN + 4, keyword_y + 4, WIDTH - MARGIN - 4, HEIGHT - MARGIN - 4],
        outline=accent_gradient[0],
        width=2,
    )

    draw_text_block(
        draw,
        keyword,
        (
            MARGIN + 15,
            keyword_y + 15,
            WIDTH - MARGIN - 15,
            HEIGHT - MARGIN - 15,
        ),
        KEYWORD_FONT,
        "#e0f2fe",
    )

    # Add subtle texture overlay for Art Deco feel
    # (optional: could add noise or pattern here)

    image.save(filename, format="PNG", optimize=True)
    print(f"Generated: {filename.name}")


def build_major_cards():
    """Generate all 22 Major Arcana cards."""
    for number, (title, subtitle, astro_key) in THOTH_MAJOR_TITLES.items():
        slug = slugify(title)
        path = OUT_DIR / f"thoth_major_{number:02d}_{slug}.png"

        hebrew = HEBREW_LETTERS.get(number, "")
        astro = ASTRO_SYMBOLS.get(astro_key, "")

        render_card(
            path,
            title,
            subtitle,
            "Major Arcana • Path of Initiation",
            "major",
            hebrew_letter=hebrew,
            astro_symbol=astro,
        )


def build_minor_cards():
    """Generate all 56 Minor Arcana cards."""
    for suit, titles in THOTH_MINOR_TITLES.items():
        suit_alias = SUIT_ALIASES[suit]
        element = SUIT_ELEMENTS[suit]
        element_symbol = ASTRO_SYMBOLS.get(element, "")

        # Numbered cards (1-10)
        for rank_value in range(1, 11):
            title = titles[rank_value]
            rank_label = RANK_LABELS[rank_value]
            subtitle = f"{rank_label} of {suit_alias}"
            slug = slugify(f"{rank_label}-{suit_alias}-{title}")
            path = OUT_DIR / f"thoth_{suit_alias.lower()}_{rank_value:02d}_{slug}.png"

            render_card(
                path,
                title,
                subtitle,
                f"{title} • {suit_alias} • {element}",
                suit,
                astro_symbol=element_symbol,
            )

        # Court cards (11-14)
        for rank_value, base_rank in zip(range(11, 15), ["Page", "Knight", "Queen", "King"]):
            alias = COURT_ALIASES[base_rank]
            subtitle = f"{alias} of {suit_alias}"
            slug = slugify(f"{alias}-{suit_alias}")
            path = OUT_DIR / f"thoth_{suit_alias.lower()}_{rank_value:02d}_{slug}.png"

            render_card(
                path,
                alias,
                subtitle,
                f"Court of {suit_alias} • {element}",
                suit,
                astro_symbol=element_symbol,
            )


def main():
    """Generate all 78 enhanced Thoth placeholder cards."""
    print("Generating enhanced Thoth placeholder cards...")
    print("=" * 60)

    build_major_cards()
    build_minor_cards()

    total = len(list(OUT_DIR.glob("*.png")))
    print("=" * 60)
    print(f"✓ Generated {total} enhanced Thoth placeholder cards")
    print(f"✓ Output directory: {OUT_DIR}")
    print("\nEnhancements:")
    print("  • Art Deco gradients (3-color per suit)")
    print("  • Hebrew letters (Major Arcana)")
    print("  • Astrological symbols (all cards)")
    print("  • Geometric mandalas and radiating patterns")
    print("  • Corner triangle motifs")
    print("  • Enhanced color palettes matching Thoth aesthetic")


if __name__ == "__main__":
    main()
</file>

<file path="scripts/assets/generate_thoth_placeholders.py">
#!/usr/bin/env python3
"""
Generate stylised placeholder images for the Thoth (Crowley/Harris) deck.

The real artwork is still under copyright in many jurisdictions, so this script
creates abstract cards with Thoth-specific titles, suit colours, and keywords.
The images live under public/images/cards/thoth and give the CLIP prototype
library distinct visual cues for the thoth-a1 deck profile.
"""

from __future__ import annotations

import math
import textwrap
from pathlib import Path

from PIL import Image, ImageDraw, ImageFont

# Canvas configuration
WIDTH = 384
HEIGHT = 640
MARGIN = 28
TITLE_BAND = 78
KEYWORD_ZONE = 140

OUT_DIR = Path("public/images/cards/thoth")
OUT_DIR.mkdir(parents=True, exist_ok=True)


def load_font(name: str, size: int) -> ImageFont.FreeTypeFont:
    """
    Attempt to load the requested font family. Fall back to DejaVuSans which is
    available on the GitHub runners and Codespaces base images.
    """

    search_paths = [
        f"/usr/share/fonts/truetype/dejavu/{name}.ttf",
        f"/usr/share/fonts/truetype/{name}.ttf",
    ]
    for path in search_paths:
        if Path(path).exists():
            return ImageFont.truetype(path, size)
    # Fallback to default PIL font if nothing else is available.
    return ImageFont.load_default()


TITLE_FONT = load_font("DejaVuSans-Bold", 38)
SUBTITLE_FONT = load_font("DejaVuSans", 24)
KEYWORD_FONT = load_font("DejaVuSans", 20)


THOTH_MAJOR_TITLES = {
    0: ("The Fool", "Aleph • Air"),
    1: ("The Magus", "Beth • Mercury"),
    2: ("The Priestess", "Gimel • Moon"),
    3: ("The Empress", "Daleth • Venus"),
    4: ("The Emperor", "Tzaddi • Aries"),
    5: ("The Hierophant", "Vav • Taurus"),
    6: ("The Lovers", "Zain • Gemini"),
    7: ("The Chariot", "Cheth • Cancer"),
    8: ("Adjustment", "Lamed • Libra"),
    9: ("The Hermit", "Yod • Virgo"),
    10: ("Fortune", "Kaph • Jupiter"),
    11: ("Lust", "Teth • Leo"),
    12: ("The Hanged Man", "Mem • Water"),
    13: ("Death", "Nun • Scorpio"),
    14: ("Art", "Samekh • Sagittarius"),
    15: ("The Devil", "Ayin • Capricorn"),
    16: ("The Tower", "Pe • Mars"),
    17: ("The Star", "Tzaddi • Aquarius"),
    18: ("The Moon", "Qoph • Pisces"),
    19: ("The Sun", "Resh • Sun"),
    20: ("The Aeon", "Shin • Fire/Spirit"),
    21: ("The Universe", "Tau • Saturn/Earth"),
}

THOTH_MINOR_TITLES = {
    "Wands": {
        1: "Root of Fire",
        2: "Dominion",
        3: "Virtue",
        4: "Completion",
        5: "Strife",
        6: "Victory",
        7: "Valour",
        8: "Swiftness",
        9: "Strength",
        10: "Oppression",
    },
    "Cups": {
        1: "Root of Water",
        2: "Love",
        3: "Abundance",
        4: "Luxury",
        5: "Disappointment",
        6: "Pleasure",
        7: "Debauch",
        8: "Indolence",
        9: "Happiness",
        10: "Satiety",
    },
    "Swords": {
        1: "Root of Air",
        2: "Peace",
        3: "Sorrow",
        4: "Truce",
        5: "Defeat",
        6: "Science",
        7: "Futility",
        8: "Interference",
        9: "Cruelty",
        10: "Ruin",
    },
    "Pentacles": {
        1: "Root of Earth",
        2: "Change",
        3: "Works",
        4: "Power",
        5: "Worry",
        6: "Success",
        7: "Failure",
        8: "Prudence",
        9: "Gain",
        10: "Wealth",
    },
}

SUIT_COLOURS = {
    "major": ("#1d1b2a", "#493c7b"),
    "Wands": ("#341308", "#d97706"),
    "Cups": ("#042f2e", "#0d9488"),
    "Swords": ("#0f172a", "#3b82f6"),
    "Pentacles": ("#1a1f16", "#84cc16"),
}

SUIT_ALIASES = {
    "Pentacles": "Disks",
    "Wands": "Wands",
    "Cups": "Cups",
    "Swords": "Swords",
}

COURT_ALIASES = {
    "Page": "Princess",
    "Knight": "Prince",
    "Queen": "Queen",
    "King": "Knight",
}

RANK_LABELS = {
    1: "Ace",
    2: "Two",
    3: "Three",
    4: "Four",
    5: "Five",
    6: "Six",
    7: "Seven",
    8: "Eight",
    9: "Nine",
    10: "Ten",
}


def slugify(value: str) -> str:
    return (
        value.lower()
        .replace(" ", "-")
        .replace("/", "-")
        .replace("'", "")
        .replace(".", "")
    )


def draw_text_block(draw: ImageDraw.ImageDraw, text: str, box, font, fill):
    """
    Render wrapped text inside the bounding box.
    """

    x0, y0, x1, y1 = box
    width = x1 - x0
    lines = []
    if not text:
        return
    for paragraph in text.splitlines():
        wrapped = textwrap.wrap(paragraph, width=max(1, width // (font.size // 2)))
        lines.extend(wrapped if wrapped else [""])
    total_height = sum(font.getbbox(line)[3] for line in lines) + (len(lines) - 1) * 4
    current_y = y0 + max(0, (y1 - y0 - total_height) // 2)
    for line in lines:
        bbox = font.getbbox(line)
        text_width = bbox[2]
        draw.text(
            (x0 + (width - text_width) / 2, current_y),
            line,
            font=font,
            fill=fill,
        )
        current_y += bbox[3] + 4


def render_card(filename: Path, title: str, subtitle: str, keyword: str, suit: str):
    base_colour, accent = SUIT_COLOURS[suit]
    image = Image.new("RGB", (WIDTH, HEIGHT), base_colour)
    draw = ImageDraw.Draw(image)

    # Decorative arcs give each suit a recognisable motif.
    arc_radius = WIDTH * 0.8
    draw.arc(
        [
            (WIDTH - arc_radius) / 2,
            HEIGHT * 0.25 - arc_radius / 2,
            (WIDTH + arc_radius) / 2,
            HEIGHT * 0.25 + arc_radius / 2,
        ],
        start=195,
        end=-15,
        width=6,
        fill=accent,
    )
    draw.arc(
        [
            (WIDTH - arc_radius) / 2,
            HEIGHT * 0.7 - arc_radius / 2,
            (WIDTH + arc_radius) / 2,
            HEIGHT * 0.7 + arc_radius / 2,
        ],
        start=15,
        end=195,
        width=6,
        fill=accent,
    )

    # Title band
    draw.rectangle([0, 0, WIDTH, TITLE_BAND], fill=accent)
    draw_text_block(
        draw,
        title.upper(),
        (MARGIN, 12, WIDTH - MARGIN, TITLE_BAND - 6),
        TITLE_FONT,
        "#fef9c3",
    )

    # Subtitle
    draw_text_block(
        draw,
        subtitle,
        (MARGIN, TITLE_BAND + 10, WIDTH - MARGIN, TITLE_BAND + 80),
        SUBTITLE_FONT,
        "#fef9c3",
    )

    # Keywords / epithets zone
    draw.rectangle(
        [MARGIN, HEIGHT - KEYWORD_ZONE - MARGIN, WIDTH - MARGIN, HEIGHT - MARGIN],
        outline=accent,
        width=3,
    )
    draw_text_block(
        draw,
        keyword,
        (
            MARGIN + 10,
            HEIGHT - KEYWORD_ZONE - MARGIN + 12,
            WIDTH - MARGIN - 10,
            HEIGHT - MARGIN - 12,
        ),
        KEYWORD_FONT,
        "#e0f2fe",
    )

    image.save(filename, format="PNG", optimize=True)


def build_major_cards():
    for number, (title, subtitle) in THOTH_MAJOR_TITLES.items():
        slug = slugify(title)
        path = OUT_DIR / f"thoth_major_{number:02d}_{slug}.png"
        render_card(path, title, subtitle, "Major Arcana • Macrocosm", "major")


def build_minor_cards():
    for suit, titles in THOTH_MINOR_TITLES.items():
        suit_alias = SUIT_ALIASES[suit]
        for rank_value in range(1, 11):
            title = titles[rank_value]
            rank_label = RANK_LABELS[rank_value]
            subtitle = f"{rank_label} of {suit_alias}"
            slug = slugify(f"{rank_label}-{suit_alias}-{title}")
            path = OUT_DIR / f"thoth_{suit_alias.lower()}_{rank_value:02d}_{slug}.png"
            render_card(path, title, subtitle, f"{title} • {suit_alias}", suit)
        # Courts
        for rank_value, base_rank in zip(range(11, 15), ["Page", "Knight", "Queen", "King"]):
            alias = COURT_ALIASES[base_rank]
            subtitle = f"{alias} of {suit_alias}"
            slug = slugify(f"{alias}-{suit_alias}")
            path = OUT_DIR / f"thoth_{suit_alias.lower()}_{rank_value:02d}_{slug}.png"
            render_card(path, alias, subtitle, f"Court of {suit_alias}", suit)


def main():
    build_major_cards()
    build_minor_cards()
    total = len(list(OUT_DIR.glob("*.png")))
    print(f"Generated {total} Thoth placeholder cards in {OUT_DIR}")


if __name__ == "__main__":
    main()
</file>

<file path="scripts/assets/install_thoth_scans.sh">
#!/bin/bash
# Install confirmed Thoth card scans to replace placeholders

set -e

SOURCE_DIR="public/images/thoth-scans"
TARGET_DIR="public/images/cards/thoth"
BACKUP_DIR="public/images/cards/thoth-placeholders-backup"

echo "Installing authentic Thoth card scans..."
echo "========================================"

# Create backup of placeholders
echo ""
echo "1. Backing up current placeholders..."
mkdir -p "$BACKUP_DIR"
cp -r "$TARGET_DIR"/*.png "$BACKUP_DIR/" 2>/dev/null || true
echo "   ✓ Placeholders backed up to $BACKUP_DIR"

# Copy and convert confirmed Thoth scans
echo ""
echo "2. Installing 15 confirmed Thoth scans..."

# Function to copy and convert JPG to PNG
install_card() {
    local source=$1
    local target=$2
    local name=$3

    if [ -f "$SOURCE_DIR/$source" ]; then
        # Convert JPG to PNG using ImageMagick or fall back to direct copy
        if command -v convert &> /dev/null; then
            convert "$SOURCE_DIR/$source" "$TARGET_DIR/$target"
        else
            # If ImageMagick not available, use Python PIL
            python3 -c "
from PIL import Image
img = Image.open('$SOURCE_DIR/$source')
img.save('$TARGET_DIR/$target', 'PNG')
"
        fi
        echo "   ✓ $name"
    else
        echo "   ✗ Missing: $source"
    fi
}

# Install confirmed cards
install_card "thoth_0436_card_01.jpg" "thoth_major_01_the-magus.png" "The Magus (I)"
install_card "thoth_0436_card_02.jpg" "thoth_major_07_the-chariot.png" "The Chariot (VII)"
install_card "thoth_0436_card_03.jpg" "thoth_major_11_lust.png" "Lust (XI)"
install_card "thoth_0436_card_04.jpg" "thoth_major_12_the-hanged-man.png" "The Hanged Man (XII)"
install_card "thoth_0436_card_05.jpg" "thoth_major_16_the-tower.png" "The Tower (XVI)"

install_card "thoth_0437_card_01.jpg" "thoth_major_04_the-emperor.png" "The Emperor (IV)"
install_card "thoth_0437_card_02.jpg" "thoth_major_03_the-empress.png" "The Empress (III)"
install_card "thoth_0437_card_03.jpg" "thoth_major_05_the-hierophant.png" "The Hierophant (V)"
install_card "thoth_0437_card_04.jpg" "thoth_major_06_the-lovers.png" "The Lovers (VI)"
install_card "thoth_0437_card_05.jpg" "thoth_major_10_fortune.png" "Fortune (X)"

install_card "thoth_0438_card_01.jpg" "thoth_major_17_the-star.png" "The Star (XVII)"
install_card "thoth_0438_card_02.jpg" "thoth_major_19_the-sun.png" "The Sun (XIX)"
install_card "thoth_0438_card_03.jpg" "thoth_major_21_the-universe.png" "The Universe (XXI)"
install_card "thoth_0438_card_04.jpg" "thoth_major_20_the-aeon.png" "The Aeon (XX)"
install_card "thoth_0438_card_05.jpg" "thoth_major_14_art.png" "Art (XIV)"

echo ""
echo "========================================"
echo "✓ Installed 15 authentic Thoth Major Arcana scans"
echo ""
echo "Remaining cards still using placeholders:"
echo "  Major Arcana: 7 cards (0, 2, 8, 9, 13, 15, 18)"
echo "    - The Fool (0)"
echo "    - The Priestess (2)"
echo "    - Adjustment (8)"
echo "    - The Hermit (9)"
echo "    - Death (13)"
echo "    - The Devil (15)"
echo "    - The Moon (18)"
echo ""
echo "  Minor Arcana: All 56 cards still use placeholders"
echo ""
echo "Note: IMG_0440 cards not installed due to labeling discrepancies"
echo "      (says 'THE HIGH PRIESTESS' and 'TEMPERANCE' instead of"
echo "       Thoth names 'THE PRIESTESS' and 'ART')"
</file>

<file path="scripts/assets/map_thoth_scans.json">
{
  "confirmed_thoth_cards": [
    {
      "source": "thoth_0436_card_01.jpg",
      "card_name": "The Magus",
      "card_number": 1,
      "target": "thoth_major_01_the-magus.png"
    },
    {
      "source": "thoth_0436_card_02.jpg",
      "card_name": "The Chariot",
      "card_number": 7,
      "target": "thoth_major_07_the-chariot.png"
    },
    {
      "source": "thoth_0436_card_03.jpg",
      "card_name": "Lust",
      "card_number": 11,
      "target": "thoth_major_11_lust.png"
    },
    {
      "source": "thoth_0436_card_04.jpg",
      "card_name": "The Hanged Man",
      "card_number": 12,
      "target": "thoth_major_12_the-hanged-man.png",
      "note": "Partially cut off in photo but identifiable"
    },
    {
      "source": "thoth_0436_card_05.jpg",
      "card_name": "The Tower",
      "card_number": 16,
      "target": "thoth_major_16_the-tower.png"
    },
    {
      "source": "thoth_0437_card_01.jpg",
      "card_name": "The Emperor",
      "card_number": 4,
      "target": "thoth_major_04_the-emperor.png"
    },
    {
      "source": "thoth_0437_card_02.jpg",
      "card_name": "The Empress",
      "card_number": 3,
      "target": "thoth_major_03_the-empress.png"
    },
    {
      "source": "thoth_0437_card_03.jpg",
      "card_name": "The Hierophant",
      "card_number": 5,
      "target": "thoth_major_05_the-hierophant.png"
    },
    {
      "source": "thoth_0437_card_04.jpg",
      "card_name": "Lovers",
      "card_number": 6,
      "target": "thoth_major_06_the-lovers.png",
      "note": "Card says 'LOVERS' not 'THE LOVERS'"
    },
    {
      "source": "thoth_0437_card_05.jpg",
      "card_name": "Fortune",
      "card_number": 10,
      "target": "thoth_major_10_fortune.png"
    },
    {
      "source": "thoth_0438_card_01.jpg",
      "card_name": "The Star",
      "card_number": 17,
      "target": "thoth_major_17_the-star.png"
    },
    {
      "source": "thoth_0438_card_02.jpg",
      "card_name": "The Sun",
      "card_number": 19,
      "target": "thoth_major_19_the-sun.png"
    },
    {
      "source": "thoth_0438_card_03.jpg",
      "card_name": "The Universe",
      "card_number": 21,
      "target": "thoth_major_21_the-universe.png"
    },
    {
      "source": "thoth_0438_card_04.jpg",
      "card_name": "The Aeon",
      "card_number": 20,
      "target": "thoth_major_20_the-aeon.png"
    },
    {
      "source": "thoth_0438_card_05.jpg",
      "card_name": "Art",
      "card_number": 14,
      "target": "thoth_major_14_art.png"
    }
  ],
  "questionable_cards": [
    {
      "source": "thoth_0440_card_01.jpg",
      "card_label": "THE FOOL",
      "card_number": 0,
      "issue": "Artwork style looks Thoth but could be from different deck",
      "possible_target": "thoth_major_00_the-fool.png"
    },
    {
      "source": "thoth_0440_card_02.jpg",
      "card_label": "THE HIGH PRIESTESS",
      "card_number": 2,
      "issue": "Thoth deck calls this 'THE PRIESTESS' not 'THE HIGH PRIESTESS' - may be RWS or hybrid deck",
      "possible_target": "thoth_major_02_the-priestess.png"
    },
    {
      "source": "thoth_0440_card_03.jpg",
      "card_label": "DEATH",
      "card_number": 13,
      "issue": "Artwork style questionable - may not be authentic Thoth",
      "possible_target": "thoth_major_13_death.png"
    },
    {
      "source": "thoth_0440_card_04.jpg",
      "card_label": "TEMPERANCE",
      "card_number": 14,
      "issue": "Thoth deck calls this 'ART' not 'TEMPERANCE' - likely RWS or hybrid deck",
      "possible_target": null,
      "conflict": "Conflicts with confirmed Art card from thoth_0438_card_05.jpg"
    }
  ],
  "summary": {
    "total_scans": 19,
    "confirmed_thoth": 15,
    "questionable": 4,
    "unique_major_arcana": 15
  }
}
</file>

<file path="scripts/assets/splice_card_photos_simple.py">
#!/usr/bin/env python3
"""
Split multi-card photos into individual card images using PIL only.

Since cards are laid out horizontally in a row, we can split by dividing
the width evenly based on the number of cards visible.
"""

from pathlib import Path
from PIL import Image, ImageOps

INPUT_DIR = Path("public/images")
OUTPUT_DIR = Path("public/images/thoth-scans")
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

# Manual card counts per photo (based on visual inspection)
PHOTO_CONFIG = {
    "IMG_0436.JPG": 5,  # The Magus, The Chariot, Lust, Hanged Man(?), The Tower
    "IMG_0437.JPG": 5,  # The Emperor, The Empress, The Hierophant, Lovers, Fortune
    "IMG_0438.JPG": 5,  # The Star, The Sun, The Universe, Aeon, Art
    "IMG_0440.JPG": 4,  # The Fool, The High Priestess, Death, Temperance (might be RWS not Thoth)
}


def extract_cards_simple(image_path, num_cards):
    """
    Extract cards by dividing image into equal vertical slices.
    Assumes cards are arranged horizontally in a row with minimal spacing.
    """
    img = Image.open(image_path)
    width, height = img.size

    # Calculate card width (with small overlap tolerance)
    card_width = width // num_cards
    extracted = []

    prefix = f"thoth_{image_path.stem.replace('IMG_', '')}"

    print(f"\n📷 {image_path.name} → {num_cards} cards")

    for i in range(num_cards):
        # Calculate crop box for this card
        # Add small margins to avoid edges
        left = i * card_width + 5
        right = (i + 1) * card_width - 5
        top = 5
        bottom = height - 5

        # Ensure we don't go outside image bounds
        left = max(0, left)
        right = min(width, right)
        top = max(0, top)
        bottom = min(height, bottom)

        # Crop card
        card_img = img.crop((left, top, right, bottom))

        # Auto-crop to remove black borders
        card_img = ImageOps.crop(card_img, border=10)

        # Save
        output_path = OUTPUT_DIR / f"{prefix}_card_{i+1:02d}.jpg"
        card_img.save(output_path, quality=95)

        extracted.append(output_path)
        print(f"  ✓ Card {i+1} → {output_path.name} ({card_img.width}×{card_img.height}px)")

    return extracted


def main():
    """Process all uploaded card photos."""
    print("Splicing multi-card photos into individual cards...")
    print("=" * 70)

    total_cards = 0

    for filename, num_cards in PHOTO_CONFIG.items():
        photo_path = INPUT_DIR / filename

        if not photo_path.exists():
            print(f"⚠️  {filename} not found, skipping")
            continue

        extracted = extract_cards_simple(photo_path, num_cards)
        total_cards += len(extracted)

    print("\n" + "=" * 70)
    print(f"✓ Extracted {total_cards} individual card images")
    print(f"✓ Saved to: {OUTPUT_DIR}/")
    print("\nNext: Validate with vision pipeline:")
    print(f"  node scripts/vision/runVisionPrototype.js {OUTPUT_DIR}/*.jpg \\")
    print(f"    --deck-style thoth-a1 --all-cards --max-results 3")


if __name__ == "__main__":
    main()
# Add IMG_0441 config
PHOTO_CONFIG["IMG_0441.JPG"] = 5  # 5 cards
</file>

<file path="scripts/assets/splice_card_photos.py">
#!/usr/bin/env python3
"""
Split multi-card photos into individual card images.

Detects card boundaries automatically and extracts each card as a separate file.
"""

from pathlib import Path
import cv2
import numpy as np
from PIL import Image

INPUT_DIR = Path("public/images")
OUTPUT_DIR = Path("public/images/thoth-scans")
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

def find_cards_in_image(image_path):
    """
    Detect individual cards in a multi-card photo using contour detection.
    Returns list of bounding boxes (x, y, w, h) for each card.
    """
    # Read image
    img = cv2.imread(str(image_path))
    if img is None:
        print(f"❌ Could not read {image_path}")
        return []

    # Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Apply threshold to get binary image
    _, binary = cv2.threshold(gray, 60, 255, cv2.THRESH_BINARY)

    # Find contours
    contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Filter contours by area and aspect ratio (cards should be rectangular)
    card_boxes = []
    img_area = img.shape[0] * img.shape[1]

    for contour in contours:
        x, y, w, h = cv2.boundingRect(contour)
        area = w * h
        aspect_ratio = h / w if w > 0 else 0

        # Cards should be:
        # - Reasonably large (at least 5% of image)
        # - Vertical rectangles (aspect ratio ~1.5-2.0)
        # - Not too small or too large
        if (area > img_area * 0.05 and
            area < img_area * 0.95 and
            1.3 < aspect_ratio < 2.2):
            card_boxes.append((x, y, w, h))

    # Sort by x-coordinate (left to right)
    card_boxes.sort(key=lambda box: box[0])

    return img, card_boxes


def extract_cards(image_path, output_prefix):
    """Extract individual cards from a multi-card photo."""
    img, card_boxes = find_cards_in_image(image_path)

    if not card_boxes:
        print(f"⚠️  No cards detected in {image_path.name}")
        return []

    extracted = []

    for i, (x, y, w, h) in enumerate(card_boxes):
        # Add small padding
        padding = 5
        x1 = max(0, x - padding)
        y1 = max(0, y - padding)
        x2 = min(img.shape[1], x + w + padding)
        y2 = min(img.shape[0], y + h + padding)

        # Extract card region
        card_img = img[y1:y2, x1:x2]

        # Convert BGR to RGB for PIL
        card_rgb = cv2.cvtColor(card_img, cv2.COLOR_BGR2RGB)
        pil_img = Image.fromarray(card_rgb)

        # Save with indexed name
        output_path = OUTPUT_DIR / f"{output_prefix}_card_{i+1:02d}.jpg"
        pil_img.save(output_path, quality=95)

        extracted.append(output_path)
        print(f"  ✓ Extracted card {i+1} → {output_path.name}")

    return extracted


def main():
    """Process all uploaded card photos."""
    print("Splicing multi-card photos into individual cards...")
    print("=" * 60)

    # Find all JPG files in public/images (excluding cards/ subdirectory)
    photo_files = sorted(INPUT_DIR.glob("IMG_*.JPG"))

    if not photo_files:
        print("❌ No IMG_*.JPG files found in public/images/")
        return

    total_cards = 0

    for photo_path in photo_files:
        print(f"\n📷 Processing: {photo_path.name}")

        # Use filename as prefix (e.g., IMG_0436 → thoth_0436)
        prefix = f"thoth_{photo_path.stem.replace('IMG_', '')}"

        extracted = extract_cards(photo_path, prefix)
        total_cards += len(extracted)

    print("\n" + "=" * 60)
    print(f"✓ Extracted {total_cards} individual cards")
    print(f"✓ Saved to: {OUTPUT_DIR}")
    print("\nNext step: Run vision validation on extracted cards:")
    print(f"  node scripts/vision/runVisionPrototype.js {OUTPUT_DIR}/*.jpg --deck-style thoth-a1 --all-cards")


if __name__ == "__main__":
    main()
</file>

<file path="scripts/evaluation/lib/csv.js">
export function parseCsv(content = '') {
  const lines = content
    .split(/\r?\n/)
    .map((line) => line.trimEnd())
    .filter((line) => line.length > 0);

  if (!lines.length) {
    return { header: [], rows: [] };
  }

  const header = parseLine(lines[0]);
  const rows = lines.slice(1).map(parseLine);
  return { header, rows };
}

export function stringifyRow(values = []) {
  return values
    .map((value) => {
      if (value === null || value === undefined) return '';
      const str = String(value);
      if (/[,"\n]/.test(str)) {
        return `"${str.replace(/"/g, '""')}"`;
      }
      return str;
    })
    .join(',');
}

function parseLine(line = '') {
  const result = [];
  let current = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];

    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i += 1;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }

    if (char === ',' && !inQuotes) {
      result.push(current);
      current = '';
    } else {
      current += char;
    }
  }

  result.push(current);
  return result;
}
</file>

<file path="scripts/evaluation/computeNarrativeMetrics.js">
#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';

import { validateReadingNarrative } from '../../functions/lib/narrativeSpine.js';
import { MAJOR_ARCANA } from '../../src/data/majorArcana.js';
import { MINOR_ARCANA } from '../../src/data/minorArcana.js';
import { parseCsv, stringifyRow } from './lib/csv.js';

const DEFAULT_INPUT = 'data/evaluations/narrative-samples.json';
const DEFAULT_METRICS_OUT = 'data/evaluations/narrative-metrics.json';
const DEFAULT_REVIEW_OUT = 'data/evaluations/narrative-review-queue.csv';

const DETERMINISTIC_PATTERNS = [
  /\bguaranteed\b/i,
  /\bwill definitely\b/i,
  /\bfated to\b/i,
  /\bdestined to\b/i,
  /\bno choice\b/i,
  /\bset in stone\b/i,
  /\binescapable\b/i,
  /\bcannot fail\b/i,
  /\binevitable outcome\b/i
];

const AGENCY_PATTERNS = [
  /\bfree will\b/i,
  /\bchoice\b/i,
  /\bchoose\b/i,
  /\bagency\b/i,
  /\byou decide\b/i,
  /\byou direct\b/i,
  /\bco-creating\b/i,
  /\byou can shape\b/i
];

const SUPPORTIVE_TONE_PATTERNS = [
  /\bgentle\b/i,
  /\bcompassion\b/i,
  /\bself-compassion\b/i,
  /\bkindness\b/i,
  /\bground(?:ing)?\b/i,
  /\bcuriosity\b/i,
  /\boffer yourself\b/i,
  /\bpermission\b/i,
  /\bsoften\b/i,
  /\bbreath\b/i,
  /\binvite\b/i,
  /\bconsider\b/i,
  /\bchoice\b/i,
  /\bagency\b/i
];

const HARSH_TONE_PATTERNS = [
  /\byou must\b/i,
  /\byou should\b/i,
  /\bno choice\b/i,
  /\bnever\b/i,
  /\balways\b/i,
  /\bonly way\b/i,
  /\bcannot avoid\b/i,
  /\bmust not\b/i
];

const ALL_CARD_NAME_PATTERNS = [...MAJOR_ARCANA, ...MINOR_ARCANA].map((card) => card.name).map((name) => ({
  name,
  normalized: normalizeCardName(name),
  pattern: new RegExp(`\\b${escapeRegex(name)}\\b`, 'i')
}));

function usage() {
  console.log('Usage: node scripts/evaluation/computeNarrativeMetrics.js [--in file] [--metrics-out file] [--review-out file]');
}

function parseArgs(rawArgs) {
  const options = {
    input: DEFAULT_INPUT,
    metricsOut: DEFAULT_METRICS_OUT,
    reviewOut: DEFAULT_REVIEW_OUT
  };

  for (let i = 0; i < rawArgs.length; i += 1) {
    const arg = rawArgs[i];
    if (arg === '--in') {
      options.input = rawArgs[i + 1] || options.input;
      i += 1;
    } else if (arg === '--metrics-out') {
      options.metricsOut = rawArgs[i + 1] || options.metricsOut;
      i += 1;
    } else if (arg === '--review-out') {
      options.reviewOut = rawArgs[i + 1] || options.reviewOut;
      i += 1;
    } else if (arg === '--help' || arg === '-h') {
      usage();
      process.exit(0);
    }
  }

  return options;
}

function containsPattern(text, patterns) {
  if (!text) return false;
  return patterns.some((pattern) => pattern.test(text));
}

function escapeRegex(text) {
  return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function normalizeCardName(value = '') {
  return value.trim().toLowerCase();
}

function analyzeCardCoverage(reading, cardsInfo = []) {
  if (!Array.isArray(cardsInfo) || cardsInfo.length === 0) {
    return { coverage: 1, missingCards: [] };
  }

  const missingCards = [];
  cardsInfo.forEach((card) => {
    const pattern = new RegExp(escapeRegex(card.card), 'i');
    if (!pattern.test(reading)) {
      missingCards.push(card.card);
    }
  });

  const presentCount = cardsInfo.length - missingCards.length;
  return {
    coverage: cardsInfo.length ? presentCount / cardsInfo.length : 1,
    missingCards
  };
}

function detectHallucinatedCards(reading, cardsInfo = []) {
  if (!reading) return [];
  const drawn = new Set((cardsInfo || []).map((card) => normalizeCardName(card.card)));
  const hallucinated = [];

  ALL_CARD_NAME_PATTERNS.forEach(({ name, normalized, pattern }) => {
    if (!pattern.test(reading)) return;
    if (!drawn.has(normalized)) {
      hallucinated.push(name);
    }
  });

  return [...new Set(hallucinated)];
}

function analyzeToneSignals(reading = '') {
  return {
    supportive: containsPattern(reading, SUPPORTIVE_TONE_PATTERNS),
    harsh: containsPattern(reading, HARSH_TONE_PATTERNS)
  };
}

function buildIssueNotes(result) {
  const notes = [];
  if (!result.spine.isValid) {
    notes.push(`Story spine complete ${result.spine.completeSections}/${result.spine.totalSections}`);
  }
  if (result.missingCards.length) {
    notes.push(`Missing cards: ${result.missingCards.join(', ')}`);
  }
  if (result.deterministicLanguage) {
    notes.push('Deterministic language detected');
  }
  if (!result.hasAgencyLanguage) {
    notes.push('Agency/choice language missing');
  }
  if (result.hallucinatedCards.length) {
    notes.push(`Hallucinated cards referenced: ${result.hallucinatedCards.join(', ')}`);
  }
  if (result.hasHarshTone) {
    notes.push('Harsh/imperative tone detected');
  }
  if (!result.hasSupportiveTone) {
    notes.push('Supportive/trauma-informed tone missing');
  }
  return notes.join('; ');
}

function buildIssueFlags(result) {
  const flags = [];
  if (!result.spine.isValid) {
    flags.push('spine-incomplete');
  }
  if (result.missingCards.length) {
    flags.push(`missing-cards(${result.missingCards.length})`);
  }
  if (result.deterministicLanguage) {
    flags.push('deterministic-language');
  }
  if (!result.hasAgencyLanguage) {
    flags.push('missing-agency-language');
  }
  if (result.hallucinatedCards.length) {
    flags.push(`hallucinated-cards(${result.hallucinatedCards.length})`);
  }
  if (result.hasHarshTone) {
    flags.push('harsh-tone');
  }
  if (!result.hasSupportiveTone) {
    flags.push('missing-supportive-tone');
  }
  return flags;
}

function getIssuesForQueue(result) {
  return buildIssueFlags(result).join('; ');
}

function summarizeSample(sample) {
  const reading = sample.reading || '';
  const spine = validateReadingNarrative(reading);
  const cardCoverage = analyzeCardCoverage(reading, sample.cardsInfo || []);
  const deterministicLanguage = containsPattern(reading, DETERMINISTIC_PATTERNS);
  const hasAgencyLanguage = containsPattern(reading, AGENCY_PATTERNS);
  const hallucinatedCards = detectHallucinatedCards(reading, sample.cardsInfo || []);
  const tone = analyzeToneSignals(reading);
  const issueFlags = buildIssueFlags({
    spine,
    missingCards: cardCoverage.missingCards,
    deterministicLanguage,
    hasAgencyLanguage,
    hallucinatedCards,
    hasHarshTone: tone.harsh,
    hasSupportiveTone: tone.supportive
  });
  const coherenceScore = spine.totalSections
    ? spine.completeSections / spine.totalSections
    : spine.isValid
      ? 1
      : 0;

  return {
    id: sample.id,
    spreadKey: sample.spreadKey,
    spreadName: sample.spreadName,
    question: sample.userQuestion,
    spine: {
      isValid: spine.isValid,
      totalSections: spine.totalSections || 0,
      completeSections: spine.completeSections || 0,
      incompleteSections: spine.incompleteSections || 0
    },
    cardCoverage: cardCoverage.coverage,
    missingCards: cardCoverage.missingCards,
    deterministicLanguage,
    hasAgencyLanguage,
    hallucinatedCards,
    hasSupportiveTone: tone.supportive,
    hasHarshTone: tone.harsh,
    issueFlags,
    issuesPresent: issueFlags.length > 0,
    rubric: {
      accuracy: cardCoverage.coverage,
      coherence: coherenceScore,
      agency: hasAgencyLanguage ? 1 : 0,
      compassion: tone.supportive ? 1 : 0
    }
  };
}

async function readExistingAnnotations(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    const { header, rows } = parseCsv(content);
    const idIdx = header.indexOf('sample_id');
    const verdictIdx = header.indexOf('human_verdict');
    const notesIdx = header.indexOf('human_notes');
    if (idIdx === -1 || verdictIdx === -1) {
      return new Map();
    }
    const map = new Map();
    rows.forEach((cols) => {
      const key = cols[idIdx];
      map.set(key, {
        human_verdict: verdictIdx >= 0 ? cols[verdictIdx] : '',
        human_notes: notesIdx >= 0 ? cols[notesIdx] : ''
      });
    });
    return map;
  } catch (err) {
    if (err.code === 'ENOENT') {
      return new Map();
    }
    throw err;
  }
}

async function writeReviewQueue(rows, filePath, existingAnnotations) {
  const header = ['sample_id', 'spread', 'question', 'issues', 'automated_notes', 'human_verdict', 'human_notes'];
  const lines = [stringifyRow(header)];
  rows.forEach((row) => {
    const annotation = existingAnnotations.get(row.sample_id) || {};
    lines.push(
      stringifyRow([
        row.sample_id,
        row.spread,
        row.question,
        row.issues,
        row.notes,
        annotation.human_verdict || '',
        annotation.human_notes || ''
      ])
    );
  });
  await fs.mkdir(path.dirname(filePath), { recursive: true });
  await fs.writeFile(filePath, lines.join('\n'));
}

async function main() {
  const options = parseArgs(process.argv.slice(2));
  const inputPath = path.resolve(process.cwd(), options.input);
  let payload;
  try {
    payload = JSON.parse(await fs.readFile(inputPath, 'utf-8'));
  } catch (err) {
    console.error(`Unable to read ${options.input}. Run 'npm run eval:narrative' first.`);
    throw err;
  }

  const samples = Array.isArray(payload?.samples) ? payload.samples : [];
  if (!samples.length) {
    console.error('No narrative samples found.');
    process.exit(1);
  }

  const analyses = samples.map(summarizeSample);
  const totalSamples = analyses.length;
  const spinePass = analyses.filter((result) => result.spine.isValid).length;
  const deterministicCount = analyses.filter((result) => result.deterministicLanguage).length;
  const missingAgencyCount = analyses.filter((result) => !result.hasAgencyLanguage).length;
  const hallucinationCount = analyses.filter((result) => result.hallucinatedCards.length > 0).length;
  const harshToneCount = analyses.filter((result) => result.hasHarshTone).length;
  const missingSupportiveToneCount = analyses.filter((result) => !result.hasSupportiveTone).length;
  const flaggedSamples = analyses.filter((result) => result.issueFlags.length > 0);
  const avgCardCoverage = analyses.reduce((sum, result) => sum + result.cardCoverage, 0) / totalSamples;
  const rubricTotals = analyses.reduce(
    (acc, result) => {
      acc.accuracy += result.rubric.accuracy;
      acc.coherence += result.rubric.coherence;
      acc.agency += result.rubric.agency;
      acc.compassion += result.rubric.compassion;
      return acc;
    },
    { accuracy: 0, coherence: 0, agency: 0, compassion: 0 }
  );
  const avgRubricScores = totalSamples
    ? {
        accuracy: rubricTotals.accuracy / totalSamples,
        coherence: rubricTotals.coherence / totalSamples,
        agency: rubricTotals.agency / totalSamples,
        compassion: rubricTotals.compassion / totalSamples
      }
    : { accuracy: 0, coherence: 0, agency: 0, compassion: 0 };

  const metrics = {
    generatedAt: new Date().toISOString(),
    sourceFile: path.relative(process.cwd(), inputPath),
    totalSamples,
    spinePassRate: spinePass / totalSamples,
    avgCardCoverage,
    deterministicLanguageCount: deterministicCount,
    missingAgencyCount,
    hallucinationCount,
    harshToneCount,
    missingSupportiveToneCount,
    flaggedSampleCount: flaggedSamples.length,
    avgRubricScores,
    perSample: analyses
  };

  const metricsPath = path.resolve(process.cwd(), options.metricsOut);
  await fs.mkdir(path.dirname(metricsPath), { recursive: true });
  await fs.writeFile(metricsPath, JSON.stringify(metrics, null, 2));
  console.log(`Narrative metrics written to ${path.relative(process.cwd(), metricsPath)}.`);

  const queueRows = flaggedSamples.map((result) => ({
    sample_id: result.id,
    spread: result.spreadName,
    question: result.question,
    issues: getIssuesForQueue(result),
    notes: buildIssueNotes(result)
  }));

  const reviewPath = path.resolve(process.cwd(), options.reviewOut);
  const existingAnnotations = await readExistingAnnotations(reviewPath);
  await writeReviewQueue(queueRows, reviewPath, existingAnnotations);
  console.log(
    queueRows.length > 0
      ? `Narrative review queue updated with ${queueRows.length} flagged sample(s).`
      : 'Narrative review queue refreshed (no flagged samples; header only).'
  );
}

main().catch((err) => {
  console.error('Failed to compute narrative metrics:', err.message);
  process.exit(1);
});
</file>

<file path="scripts/evaluation/computeVisionMetrics.js">
#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';

import { MAJOR_ARCANA } from '../../src/data/majorArcana.js';
import { MINOR_ARCANA } from '../../src/data/minorArcana.js';
import { getDeckImagePath } from '../../shared/vision/deckAssets.js';
import { canonicalizeCardName } from '../../shared/vision/cardNameMapping.js';
import { parseCsv, stringifyRow } from './lib/csv.js';

function usage() {
  console.log('Usage: node scripts/evaluation/computeVisionMetrics.js [--in data/evaluations/vision-confidence.json]');
}

function parseArgs(rawArgs) {
const options = {
  input: 'data/evaluations/vision-confidence.json',
  reviewOut: 'data/evaluations/vision-review-queue.csv',
  metricsOut: 'data/evaluations/vision-metrics.json',
  deckStyle: null
  };

  for (let i = 0; i < rawArgs.length; i++) {
    const arg = rawArgs[i];
    if (arg === '--in') {
      options.input = rawArgs[i + 1] || options.input;
      i += 1;
    } else if (arg === '--review-out') {
      options.reviewOut = rawArgs[i + 1] || options.reviewOut;
      i += 1;
    } else if (arg === '--metrics-out') {
      options.metricsOut = rawArgs[i + 1] || options.metricsOut;
      i += 1;
    } else if (arg === '--deck-style') {
      options.deckStyle = rawArgs[i + 1] || null;
      i += 1;
    } else if (arg === '--help' || arg === '-h') {
      usage();
      process.exit(0);
    }
  }

  return options;
}

function buildDeckLookups(deckStyle) {
  const imageMap = new Map();
  const register = (card) => {
    const potential = [];
    if (card?.image) potential.push(card.image);
    const deckSpecific = getDeckImagePath(card, deckStyle);
    if (deckSpecific && deckSpecific !== card?.image) {
      potential.push(deckSpecific);
    }
    const canonical = card?.name || 'Unknown card';

    potential.forEach((location) => {
      const basename = path.basename(location);
      if (basename && !imageMap.has(basename)) {
        imageMap.set(basename, canonical);
      }
    });
  };
  MAJOR_ARCANA.forEach(register);
  MINOR_ARCANA.forEach(register);
  return { imageMap };
}

function normalizeName(name) {
  return (name || '').trim().toLowerCase();
}

function buildReviewKey(row) {
  return `${row.image}||${row.expected}||${row.predicted}`;
}

async function readExistingAnnotations(filePath) {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    const { header, rows } = parseCsv(content);
    const imageIdx = header.indexOf('image');
    const expectedIdx = header.indexOf('expected');
    const predictedIdx = header.indexOf('predicted');
    const verdictIdx = header.indexOf('human_verdict');
    const notesIdx = header.indexOf('human_notes');
    if (imageIdx === -1 || expectedIdx === -1 || predictedIdx === -1 || verdictIdx === -1) {
      return new Map();
    }

    const map = new Map();
    rows.forEach((cols) => {
      const key = `${cols[imageIdx]}||${cols[expectedIdx]}||${cols[predictedIdx]}`;
      map.set(key, {
        human_verdict: verdictIdx >= 0 ? cols[verdictIdx] : '',
        human_notes: notesIdx >= 0 ? cols[notesIdx] : ''
      });
    });
    return map;
  } catch (err) {
    if (err.code === 'ENOENT') {
      return new Map();
    }
    throw err;
  }
}

async function writeReviewCsv(rows, filePath, existingAnnotations) {
  const header = ['image', 'expected', 'predicted', 'confidence', 'basis', 'human_verdict', 'human_notes'];
  const lines = [stringifyRow(header)];

  rows.forEach((row) => {
    const key = buildReviewKey(row);
    const annotation = existingAnnotations.get(key) || {};
    lines.push(
      stringifyRow([
        row.image,
        row.expected,
        row.predicted,
        row.confidence?.toFixed(4) ?? '',
        row.basis || '',
        annotation.human_verdict || '',
        annotation.human_notes || ''
      ])
    );
  });

  await fs.writeFile(filePath, lines.join('\n'));
}

async function main() {
  const options = parseArgs(process.argv.slice(2));
  const inputPath = path.resolve(process.cwd(), options.input);
  let payload;
  try {
    payload = JSON.parse(await fs.readFile(inputPath, 'utf-8'));
  } catch (err) {
    console.error(`Unable to read ${inputPath}:`, err.message);
    process.exit(1);
  }

  const samples = Array.isArray(payload?.results) ? payload.results : [];
  if (samples.length === 0) {
    console.error('No results found in vision confidence file.');
    process.exit(1);
  }

  const deckStyle = options.deckStyle || payload?.deckStyle || 'rws-1909';
  const { imageMap: imageNameMap } = buildDeckLookups(deckStyle);
  let total = 0;
  let correct = 0;
  let highConfidenceCorrect = 0;
  let highConfidenceTotal = 0;
  const mismatches = [];
  const perLabelCounts = new Map();
  let symbolTotal = 0;
  let symbolFocused = 0;
  const symbolStats = new Map();
  const symbolMatchRates = [];
  let symbolExpectedTotal = 0;
  let symbolDetectedTotal = 0;
  const missingSymbolTally = new Map();

  for (const entry of samples) {
    const image = entry.image || entry.label || entry.imagePath;
    const basename = path.basename(image);
    const expected = imageNameMap.get(basename);
    if (!expected) {
      console.warn(`No expected mapping for ${basename}; skipping.`);
      continue;
    }
    total += 1;
    const predicted = entry.topMatch?.cardName;
    const confidence = entry.topMatch?.score ?? 0;
    // Expected is already in RWS canonical form (from imageNameMap)
    // Only canonicalize predicted value (which may be in Thoth/Marseille form)
    const normalizedExpected = normalizeName(expected);
    const normalizedPredicted = normalizeName(canonicalizeCardName(predicted, deckStyle) || predicted);
    const isCorrect = normalizedPredicted === normalizedExpected;
    if (isCorrect) {
      correct += 1;
      if (confidence >= 0.9) highConfidenceCorrect += 1;
    } else {
      mismatches.push({ image: basename, expected, predicted: predicted || 'n/a', confidence, basis: entry.topMatch?.basis });
    }
    if (confidence >= 0.9) highConfidenceTotal += 1;

    const labelStats = perLabelCounts.get(expected) || { total: 0, correct: 0 };
    labelStats.total += 1;
    if (isCorrect) labelStats.correct += 1;
    perLabelCounts.set(expected, labelStats);

    const symbolVerification = entry.symbolVerification;
    if (symbolVerification && typeof symbolVerification.matchRate === 'number') {
      symbolMatchRates.push(symbolVerification.matchRate);
      if (typeof symbolVerification.expectedCount === 'number') {
        symbolExpectedTotal += symbolVerification.expectedCount;
      }
      if (typeof symbolVerification.detectedCount === 'number') {
        symbolDetectedTotal += symbolVerification.detectedCount;
      }
      if (Array.isArray(symbolVerification.missingSymbols)) {
        symbolVerification.missingSymbols.forEach((symbol) => {
          if (!symbol) return;
          const current = missingSymbolTally.get(symbol) || 0;
          missingSymbolTally.set(symbol, current + 1);
        });
      }
    }

    const symbolAlignment = entry.attention?.symbolAlignment;
    if (Array.isArray(symbolAlignment)) {
      symbolAlignment.forEach((symbol) => {
        if (typeof symbol.attentionScore !== 'number') {
          return;
        }
        symbolTotal += 1;
        const isFocused = symbol.isModelFocused || symbol.attentionScore >= 0.65;
        if (isFocused) {
          symbolFocused += 1;
        }
        const key = symbol.object || 'symbol';
        const stats = symbolStats.get(key) || { total: 0, focused: 0 };
        stats.total += 1;
        if (isFocused) {
          stats.focused += 1;
        }
        symbolStats.set(key, stats);
      });
    }
  }

  const accuracy = total ? correct / total : 0;
  const highConfidenceAccuracy = highConfidenceTotal ? highConfidenceCorrect / highConfidenceTotal : 0;
  let symbolCoverageRate = null;

  if (symbolMatchRates.length > 0) {
    symbolCoverageRate = symbolMatchRates.reduce((sum, value) => sum + value, 0) / symbolMatchRates.length;
  } else if (symbolTotal) {
    symbolCoverageRate = symbolFocused / symbolTotal;
  }

  const symbolDetectionRate = symbolExpectedTotal
    ? symbolDetectedTotal / symbolExpectedTotal
    : null;

  // Micro precision/recall/f1 collapses to accuracy for single-label classification.
  const precisionMicro = accuracy;
  const recallMicro = accuracy;
  const f1Micro = accuracy;

  const perLabelAccuracy = Array.from(perLabelCounts.entries()).map(([label, stats]) => ({
    label,
    accuracy: stats.total ? stats.correct / stats.total : 0,
    total: stats.total
  })).sort((a, b) => a.label.localeCompare(b.label));

  const metricsEntry = {
    deckStyle,
    generatedAt: new Date().toISOString(),
    sourceFile: path.relative(process.cwd(), inputPath),
    sampleSize: total,
    accuracy,
    microPrecision: precisionMicro,
    microRecall: recallMicro,
    microF1: f1Micro,
    highConfidenceCoverage: highConfidenceTotal / (total || 1),
    highConfidenceAccuracy,
    symbolCoverageRate,
    symbolDetectionRate,
    symbolMissingLeaders: Array.from(missingSymbolTally.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([symbol, count]) => ({ symbol, count })),
    symbolBreakdown: Array.from(symbolStats.entries()).map(([object, stats]) => ({
      object,
      coverage: stats.total ? stats.focused / stats.total : 0,
      total: stats.total
    })).sort((a, b) => b.coverage - a.coverage),
    perLabelAccuracy
  };

  const metricsPath = path.resolve(process.cwd(), options.metricsOut);
  await fs.mkdir(path.dirname(metricsPath), { recursive: true });
  let existing = {};
  try {
    existing = JSON.parse(await fs.readFile(metricsPath, 'utf-8'));
  } catch (err) {
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }
  const metricsByDeck = existing.metricsByDeck || {};
  metricsByDeck[deckStyle] = metricsEntry;
  const finalPayload = {
    updatedAt: new Date().toISOString(),
    metricsByDeck
  };
  await fs.writeFile(metricsPath, JSON.stringify(finalPayload, null, 2));

  const reviewPath = path.resolve(process.cwd(), options.reviewOut);
  const existingAnnotations = await readExistingAnnotations(reviewPath);
  await writeReviewCsv(mismatches, reviewPath, existingAnnotations);

  console.log('Vision metrics written to', metricsPath);
  console.log('Review queue written to', reviewPath);
  console.log(`Overall accuracy: ${(accuracy * 100).toFixed(2)}% (${correct}/${total})`);
  if (highConfidenceTotal) {
    console.log(`High-confidence accuracy (>=0.9): ${(highConfidenceAccuracy * 100).toFixed(2)}% (${highConfidenceCorrect}/${highConfidenceTotal})`);
  }
}

main().catch((err) => {
  console.error('Vision metrics computation failed:', err);
  process.exit(1);
});
</file>

<file path="scripts/evaluation/processNarrativeReviews.js">
#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';

import { parseCsv } from './lib/csv.js';

const DEFAULT_QUEUE = 'data/evaluations/narrative-review-queue.csv';
const DEFAULT_SUMMARY = 'data/evaluations/narrative-review-summary.json';

function _usage() {
  console.log('Usage: node scripts/evaluation/processNarrativeReviews.js [queueFile] [summaryFile]');
}

function normalizeVerdict(value = '') {
  const trimmed = value.trim();
  return trimmed ? trimmed.toLowerCase() : '';
}

function extractColumns(header) {
  return {
    sampleId: header.indexOf('sample_id'),
    spread: header.indexOf('spread'),
    issues: header.indexOf('issues'),
    notes: header.indexOf('automated_notes'),
    verdict: header.indexOf('human_verdict'),
    humanNotes: header.indexOf('human_notes')
  };
}

async function main() {
  const queuePath = path.resolve(process.cwd(), process.argv[2] || DEFAULT_QUEUE);
  const summaryPath = path.resolve(process.cwd(), process.argv[3] || DEFAULT_SUMMARY);

  let csvContent;
  try {
    csvContent = await fs.readFile(queuePath, 'utf-8');
  } catch (err) {
    if (err.code === 'ENOENT') {
      console.error(`Review queue not found at ${queuePath}. Run 'npm run eval:narrative' first.`);
      process.exit(1);
    }
    throw err;
  }

  const { header, rows } = parseCsv(csvContent);
  if (header.length === 0) {
    console.error('Narrative review queue is empty.');
    process.exit(1);
  }

  const columns = extractColumns(header);
  if (columns.sampleId === -1 || columns.verdict === -1) {
    console.error('Narrative review queue is missing required columns.');
    process.exit(1);
  }

  const annotatedRows = rows
    .map((cols) => ({
      sampleId: cols[columns.sampleId] || '',
      spread: columns.spread >= 0 ? cols[columns.spread] : '',
      issues: columns.issues >= 0 ? cols[columns.issues] : '',
      notes: columns.notes >= 0 ? cols[columns.notes] : '',
      verdict: columns.verdict >= 0 ? cols[columns.verdict] : '',
      humanNotes: columns.humanNotes >= 0 ? cols[columns.humanNotes] : ''
    }))
    .filter((entry) => entry.sampleId);

  const responded = annotatedRows.filter((entry) => normalizeVerdict(entry.verdict));
  const verdictCounts = responded.reduce((acc, entry) => {
    const key = normalizeVerdict(entry.verdict) || 'unspecified';
    acc[key] = (acc[key] || 0) + 1;
    return acc;
  }, {});

  const summary = {
    generatedAt: new Date().toISOString(),
    sourceFile: path.relative(process.cwd(), queuePath),
    totalRows: annotatedRows.length,
    respondedRows: responded.length,
    verdictCounts,
    samples: responded.slice(0, 5).map((entry) => ({
      sampleId: entry.sampleId,
      spread: entry.spread,
      issues: entry.issues,
      verdict: entry.verdict,
      reviewerNotes: entry.humanNotes
    }))
  };

  await fs.mkdir(path.dirname(summaryPath), { recursive: true });
  await fs.writeFile(summaryPath, JSON.stringify(summary, null, 2));
  console.log(`Narrative review summary written to ${path.relative(process.cwd(), summaryPath)}.`);
}

main().catch((err) => {
  console.error('Failed to process narrative reviews:', err.message);
  process.exit(1);
});
</file>

<file path="scripts/evaluation/processVisionReviews.js">
#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';

import { parseCsv } from './lib/csv.js';

const DEFAULT_QUEUE = 'data/evaluations/vision-review-queue.csv';
const DEFAULT_OUTPUT = 'data/evaluations/vision-review-summary.json';

const POSITIVE_VERDICTS = new Set(['correct', 'match', 'accept', 'accepted', 'ok', 'true']);
const NEGATIVE_VERDICTS = new Set(['incorrect', 'reject', 'mismatch', 'fail', 'false']);
const NEUTRAL_VERDICTS = new Set(['needs_review', 'uncertain', 'pending', 'skip']);

function normalizeVerdict(value = '') {
  const normalized = value.trim().toLowerCase();
  if (!normalized) return '';
  if (POSITIVE_VERDICTS.has(normalized)) return 'accepted';
  if (NEGATIVE_VERDICTS.has(normalized)) return 'rejected';
  if (NEUTRAL_VERDICTS.has(normalized)) return 'needs_review';
  return normalized;
}

function parseArgs(args) {
  const options = {
    queue: DEFAULT_QUEUE,
    output: DEFAULT_OUTPUT
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--queue') {
      options.queue = args[i + 1] || options.queue;
      i += 1;
    } else if (arg === '--out') {
      options.output = args[i + 1] || options.output;
      i += 1;
    }
  }

  return options;
}

function extractIndex(header, key) {
  const idx = header.indexOf(key);
  if (idx === -1) {
    throw new Error(`Missing "${key}" column in review queue.`);
  }
  return idx;
}

async function main() {
  const options = parseArgs(process.argv.slice(2));
  const queuePath = path.resolve(process.cwd(), options.queue);
  let csvContent;
  try {
    csvContent = await fs.readFile(queuePath, 'utf-8');
  } catch (err) {
    console.error(`Unable to read ${queuePath}:`, err.message);
    process.exit(1);
    return;
  }

  const { header, rows } = parseCsv(csvContent);
  if (!header.length) {
    console.error('Review queue is empty.');
    process.exit(1);
    return;
  }

  const verdictIdx = extractIndex(header, 'human_verdict');
  const notesIdx = header.indexOf('human_notes');
  const imageIdx = extractIndex(header, 'image');
  const expectedIdx = extractIndex(header, 'expected');
  const predictedIdx = extractIndex(header, 'predicted');

  const verdictCounts = {};
  const reviewedRows = [];

  rows.forEach((cols) => {
    const verdictRaw = cols[verdictIdx] || '';
    const normalizedVerdict = normalizeVerdict(verdictRaw);
    if (!normalizedVerdict) {
      return;
    }
    verdictCounts[normalizedVerdict] = (verdictCounts[normalizedVerdict] || 0) + 1;
    reviewedRows.push({
      image: cols[imageIdx],
      expected: cols[expectedIdx],
      predicted: cols[predictedIdx],
      verdict: normalizedVerdict,
      notes: notesIdx >= 0 ? cols[notesIdx] : ''
    });
  });

  const reviewedCount = reviewedRows.length;
  if (!reviewedCount) {
    console.log('No human verdicts recorded yet.');
    process.exit(0);
    return;
  }

  const acceptedCount = verdictCounts.accepted ?? 0;
  const rejectedCount = verdictCounts.rejected ?? 0;
  const needsReviewCount = verdictCounts['needs_review'] ?? 0;

  const summary = {
    generatedAt: new Date().toISOString(),
    queueFile: path.relative(process.cwd(), queuePath),
    reviewedCount,
    verdictCounts,
    acceptanceRate: acceptedCount / reviewedCount,
    rejectionRate: rejectedCount / reviewedCount,
    needsReviewRate: needsReviewCount / reviewedCount,
    acceptedSamples: reviewedRows.filter((row) => row.verdict === 'accepted').slice(0, 10),
    rejectedSamples: reviewedRows.filter((row) => row.verdict === 'rejected').slice(0, 10)
  };

  const outputPath = path.resolve(process.cwd(), options.output);
  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, JSON.stringify(summary, null, 2));
  console.log('Review summary written to', outputPath);
  console.log(`Reviewed ${reviewedCount} rows. Acceptance rate: ${(summary.acceptanceRate * 100).toFixed(2)}%`);
}

main().catch((err) => {
  console.error('Processing vision reviews failed:', err.message);
  process.exit(1);
});
</file>

<file path="scripts/evaluation/runNarrativeSamples.js">
#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';

import { MAJOR_ARCANA } from '../../src/data/majorArcana.js';
import { MINOR_ARCANA } from '../../src/data/minorArcana.js';
import { SPREADS } from '../../src/data/spreads.js';
import {
  analyzeSpreadThemes,
  analyzeCelticCross,
  analyzeThreeCard,
  analyzeFiveCard,
  analyzeRelationship,
  analyzeDecision
} from '../../functions/lib/spreadAnalysis.js';
import {
  buildCelticCrossReading,
  buildThreeCardReading,
  buildFiveCardReading,
  buildRelationshipReading,
  buildDecisionReading,
  buildSingleCardReading
} from '../../functions/lib/narrativeBuilder.js';
import { inferContext } from '../../functions/lib/contextDetection.js';

const CARD_LOOKUP = new Map([
  ...MAJOR_ARCANA.map((card) => [card.name, card]),
  ...MINOR_ARCANA.map((card) => [card.name, card])
]);

const DEFAULT_OUTPUT = 'data/evaluations/narrative-samples.json';

const SAMPLE_DEFINITIONS = [
  {
    id: 'single-new-role',
    spreadKey: 'single',
    userQuestion: 'What guiding energy should I bring into this new leadership role?',
    reflectionsText: 'I want to stay curious yet grounded even when the stakes feel high.',
    cards: [
      { name: 'The Fool', orientation: 'Upright' }
    ]
  },
  {
    id: 'three-card-transition',
    spreadKey: 'threeCard',
    userQuestion: 'How can I navigate the transition after leaving my hometown?',
    reflectionsText: 'Part of me is nostalgic while another part is ready for reinvention.',
    cards: [
      { name: 'Six of Cups', orientation: 'Reversed' },
      { name: 'The Tower', orientation: 'Upright' },
      { name: 'The Star', orientation: 'Upright' }
    ]
  },
  {
    id: 'five-card-creative-project',
    spreadKey: 'fiveCard',
    userQuestion: 'What should I know about launching my creative project this quarter?',
    reflectionsText: 'I feel momentum but keep second-guessing the tone and timing.',
    cards: [
      { name: 'Ace of Wands', orientation: 'Upright' },
      { name: 'Seven of Swords', orientation: 'Reversed' },
      { name: 'Queen of Cups', orientation: 'Upright' },
      { name: 'Three of Pentacles', orientation: 'Upright' },
      { name: 'Wheel of Fortune', orientation: 'Reversed' }
    ]
  },
  {
    id: 'relationship-checkin',
    spreadKey: 'relationship',
    userQuestion: 'What should I understand about the energetic exchange between me and Alex?',
    reflectionsText: 'Communication feels uneven lately and I want to ground before reacting.',
    cards: [
      { name: 'Queen of Cups', orientation: 'Reversed' },
      { name: 'Knight of Swords', orientation: 'Upright' },
      { name: 'Two of Cups', orientation: 'Upright' }
    ]
  },
  {
    id: 'celtic-deep-shift',
    spreadKey: 'celtic',
    userQuestion: 'How can I stay centered while everything at home and work restructures at once?',
    reflectionsText: 'It feels like multiple towers at the same time; I want to stay compassionate without losing momentum.',
    cards: [
      { name: 'The Hermit', orientation: 'Upright' },
      { name: 'Five of Wands', orientation: 'Reversed' },
      { name: 'Death', orientation: 'Upright' },
      { name: 'Temperance', orientation: 'Upright' },
      { name: 'The Emperor', orientation: 'Upright' },
      { name: 'The Moon', orientation: 'Reversed' },
      { name: 'Strength', orientation: 'Upright' },
      { name: 'Eight of Pentacles', orientation: 'Upright' },
      { name: 'Nine of Swords', orientation: 'Reversed' },
      { name: 'The Sun', orientation: 'Upright' }
    ]
  }
];

function usage() {
  console.log(`Usage: node scripts/evaluation/runNarrativeSamples.js [--out ${DEFAULT_OUTPUT}] [--sample sample-id]`);
}

function parseArgs(rawArgs) {
  const options = { output: DEFAULT_OUTPUT, sampleIds: null };
  for (let i = 0; i < rawArgs.length; i += 1) {
    const arg = rawArgs[i];
    if (arg === '--out') {
      options.output = rawArgs[i + 1] || DEFAULT_OUTPUT;
      i += 1;
    } else if (arg === '--sample') {
      const id = rawArgs[i + 1];
      if (!id) {
        throw new Error('Missing value for --sample');
      }
      options.sampleIds = options.sampleIds || new Set();
      options.sampleIds.add(id);
      i += 1;
    } else if (arg === '--help' || arg === '-h') {
      usage();
      process.exit(0);
    }
  }
  return options;
}

function normalizeOrientation(value) {
  return String(value || 'Upright').toLowerCase() === 'reversed' ? 'Reversed' : 'Upright';
}

function getCardByName(name) {
  const card = CARD_LOOKUP.get(name);
  if (!card) {
    throw new Error(`Unknown card name: ${name}`);
  }
  return card;
}

function buildCardEntry(baseCard, position, orientation) {
  const isReversed = orientation === 'Reversed';
  return {
    position,
    card: baseCard.name,
    orientation,
    meaning: isReversed ? baseCard.reversed : baseCard.upright,
    number: typeof baseCard.number === 'number' ? baseCard.number : undefined,
    suit: baseCard.suit || null,
    rank: baseCard.rank || null,
    rankValue: typeof baseCard.rankValue === 'number' ? baseCard.rankValue : null
  };
}

async function buildSpreadAnalysis(spreadKey, cardsInfo) {
  switch (spreadKey) {
    case 'celtic':
      return analyzeCelticCross(cardsInfo);
    case 'threeCard':
      return analyzeThreeCard(cardsInfo);
    case 'fiveCard':
      return analyzeFiveCard(cardsInfo);
    case 'relationship':
      return analyzeRelationship(cardsInfo);
    case 'decision':
      return analyzeDecision(cardsInfo);
    default:
      return null;
  }
}

async function buildReadingFromAnalysis(spreadKey, { spreadAnalysis, cardsInfo, userQuestion, reflectionsText, themes, spreadInfo, context }) {
  switch (spreadKey) {
    case 'celtic':
      return buildCelticCrossReading({ cardsInfo, userQuestion, reflectionsText, celticAnalysis: spreadAnalysis, themes, spreadInfo, context });
    case 'threeCard':
      return buildThreeCardReading({ cardsInfo, userQuestion, reflectionsText, threeCardAnalysis: spreadAnalysis, themes, spreadInfo, context });
    case 'fiveCard':
      return buildFiveCardReading({ cardsInfo, userQuestion, reflectionsText, fiveCardAnalysis: spreadAnalysis, themes, spreadInfo, context });
    case 'relationship':
      return buildRelationshipReading({ cardsInfo, userQuestion, reflectionsText, themes, spreadInfo, context });
    case 'decision':
      return buildDecisionReading({ cardsInfo, userQuestion, reflectionsText, decisionAnalysis: spreadAnalysis, themes, spreadInfo, context });
    case 'single':
    default:
      return buildSingleCardReading({ cardsInfo, userQuestion, reflectionsText, themes, spreadInfo, context });
  }
}

async function generateSample(sample) {
  const spreadInfo = SPREADS[sample.spreadKey];
  if (!spreadInfo) {
    throw new Error(`Unknown spread key: ${sample.spreadKey}`);
  }

  if (sample.cards.length !== spreadInfo.count) {
    throw new Error(`Sample ${sample.id} cards (${sample.cards.length}) do not match spread count (${spreadInfo.count}).`);
  }

  const cardsInfo = sample.cards.map((cardDef, index) => {
    const position = spreadInfo.positions[index] || `Position ${index + 1}`;
    const orientation = normalizeOrientation(cardDef.orientation);
    const baseCard = getCardByName(cardDef.name);
    return buildCardEntry(baseCard, position, orientation);
  });

  const themes = await analyzeSpreadThemes(cardsInfo);
  const spreadAnalysis = await buildSpreadAnalysis(sample.spreadKey, cardsInfo);
  const context = sample.context || inferContext(sample.userQuestion, sample.spreadKey);
  const reading = await buildReadingFromAnalysis(sample.spreadKey, {
    spreadAnalysis,
    cardsInfo,
    userQuestion: sample.userQuestion,
    reflectionsText: sample.reflectionsText || '',
    themes,
    spreadInfo,
    context
  });

  if (!reading || !reading.trim()) {
    throw new Error(`Reading generation failed for sample ${sample.id}`);
  }

  return {
    id: sample.id,
    spreadKey: sample.spreadKey,
    spreadName: spreadInfo.name,
    userQuestion: sample.userQuestion,
    reflectionsText: sample.reflectionsText || '',
    context,
    cardsInfo,
    reading,
    themesSummary: {
      reversalFramework: themes.reversalFramework,
      suitFocus: themes.suitFocus || null,
      archetypeDescription: themes.archetypeDescription || null
    }
  };
}

async function main() {
  const options = parseArgs(process.argv.slice(2));
  const selectedSamples = SAMPLE_DEFINITIONS.filter((sample) => {
    if (!options.sampleIds) return true;
    return options.sampleIds.has(sample.id);
  });

  if (selectedSamples.length === 0) {
    console.error('No samples matched the provided filters.');
    process.exit(1);
  }

  const generated = [];
  for (const sample of selectedSamples) {
    generated.push(await generateSample(sample));
  }

  const payload = {
    generatedAt: new Date().toISOString(),
    model: 'local-composer',
    sampleCount: generated.length,
    samples: generated
  };

  const outPath = path.resolve(process.cwd(), options.output);
  await fs.mkdir(path.dirname(outPath), { recursive: true });
  await fs.writeFile(outPath, JSON.stringify(payload, null, 2));
  console.log(`Narrative samples written to ${path.relative(process.cwd(), outPath)} (${generated.length} samples).`);
}

main().catch((err) => {
  console.error('Failed to generate narrative samples:', err.message);
  process.exit(1);
});
</file>

<file path="scripts/evaluation/runVisionConfidence.js">
#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';

import { createVisionBackend } from '../../shared/vision/visionBackends.js';
import { getDeckProfile } from '../../shared/vision/deckProfiles.js';

function parseArgs(rawArgs) {
  const options = {
    scope: 'all',
    deckStyle: 'rws-1909',
    out: 'data/evaluations/vision-confidence.json',
    limit: null,
    outProvided: false
  };

  for (let i = 0; i < rawArgs.length; i++) {
    const arg = rawArgs[i];
    if (arg === '--scope') {
      options.scope = rawArgs[i + 1] || options.scope;
      i += 1;
    } else if (arg === '--deck-style') {
      options.deckStyle = rawArgs[i + 1] || options.deckStyle;
      i += 1;
    } else if (arg === '--out') {
      options.out = rawArgs[i + 1] || options.out;
      options.outProvided = true;
      i += 1;
    } else if (arg === '--limit') {
      const value = Number(rawArgs[i + 1]);
      if (!Number.isNaN(value)) {
        options.limit = value;
      }
      i += 1;
    }
  }
  if (!options.outProvided && options.deckStyle && options.deckStyle !== 'rws-1909') {
    options.out = `data/evaluations/vision-confidence.${options.deckStyle}.json`;
  }
  delete options.outProvided;

  return options;
}

async function collectImagePaths(deckProfile, limit) {
  const cardsDir = path.resolve(process.cwd(), 'public/images/cards');
  const deckDir =
    deckProfile?.assetScanDir && deckProfile.assetScanDir !== '.'
      ? path.join(cardsDir, deckProfile.assetScanDir)
      : cardsDir;

  let searchDir = deckDir;
  try {
    await fs.access(deckDir);
  } catch {
    searchDir = cardsDir;
  }

  const entries = await fs.readdir(searchDir, { withFileTypes: true });
  const files = entries
    .filter((entry) => entry.isFile() && /\.(png|jpe?g)$/i.test(entry.name))
    .map((entry) => ({
      source: path.join(searchDir, entry.name).replace(/\\/g, '/'),
      label: entry.name
    }));

  const targets = typeof limit === 'number' ? files.slice(0, limit) : files;
  return targets;
}

async function main() {
  const options = parseArgs(process.argv.slice(2));
  const deckProfile = getDeckProfile(options.deckStyle);
  const imageInputs = await collectImagePaths(deckProfile, options.limit);
  if (imageInputs.length === 0) {
    console.error('No card images found in public/images/cards');
    process.exitCode = 1;
    return;
  }

  const backend = await createVisionBackend({
    backendId: 'clip-default',
    cardScope: options.scope,
    deckStyle: options.deckStyle,
    maxResults: 5
  });

  console.log(`Evaluating ${imageInputs.length} images with deck style ${options.deckStyle}...`);
  await backend.warmup();
  const analyses = await backend.analyzeImages(imageInputs, {
    includeAttention: true,
    includeSymbols: true
  });

  const report = {
    generatedAt: new Date().toISOString(),
    deckStyle: options.deckStyle,
    scope: options.scope,
    sampleSize: analyses.length,
    results: analyses.map((entry) => ({
      image: entry.label || entry.imagePath,
      topMatch: entry.topMatch,
      confidence: entry.confidence,
      matches: entry.matches,
      attention: entry.attention || null,
      symbolVerification: entry.symbolVerification || null
    }))
  };

  const outputPath = path.resolve(process.cwd(), options.out);
  await fs.mkdir(path.dirname(outputPath), { recursive: true });
  await fs.writeFile(outputPath, JSON.stringify(report, null, 2));
  console.log(`Vision confidence report written to ${outputPath}`);
}

main().catch((err) => {
  console.error('Vision confidence evaluation failed:', err);
  process.exitCode = 1;
});
</file>

<file path="scripts/evaluation/verifyNarrativeGate.js">
#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';

const DEFAULT_FILE = 'data/evaluations/narrative-metrics.json';
const MIN_SPINE_RATE = parseFloat(process.env.NARRATIVE_MIN_SPINE_PASS_RATE || '0.9');
const MIN_CARD_COVERAGE = parseFloat(process.env.NARRATIVE_MIN_CARD_COVERAGE || '0.9');
const MAX_DETERMINISTIC = parseInt(process.env.NARRATIVE_MAX_DETERMINISTIC_ISSUES || '0', 10);
const MAX_MISSING_AGENCY = parseInt(process.env.NARRATIVE_MAX_MISSING_AGENCY || '0', 10);
const MAX_FLAGGED = parseInt(process.env.NARRATIVE_MAX_FLAGGED_SAMPLES || '0', 10);
const MAX_HALLUCINATIONS = parseInt(process.env.NARRATIVE_MAX_HALLUCINATIONS || '0', 10);
const MAX_HARSH_TONE = parseInt(process.env.NARRATIVE_MAX_HARSH_TONE || '0', 10);
const MAX_MISSING_SUPPORTIVE = parseInt(process.env.NARRATIVE_MAX_MISSING_SUPPORTIVE || '0', 10);
const MIN_RUBRIC_ACCURACY = parseFloat(process.env.NARRATIVE_MIN_RUBRIC_ACCURACY || '0.85');
const MIN_RUBRIC_COHERENCE = parseFloat(process.env.NARRATIVE_MIN_RUBRIC_COHERENCE || '0.85');
const MIN_RUBRIC_AGENCY = parseFloat(process.env.NARRATIVE_MIN_RUBRIC_AGENCY || '0.8');
const MIN_RUBRIC_COMPASSION = parseFloat(process.env.NARRATIVE_MIN_RUBRIC_COMPASSION || '0.85');

function pct(value) {
  return `${(value * 100).toFixed(1)}%`;
}

async function main() {
  const metricsPath = path.resolve(process.cwd(), process.argv[2] || DEFAULT_FILE);
  let metrics;
  try {
    metrics = JSON.parse(await fs.readFile(metricsPath, 'utf-8'));
  } catch (err) {
    console.error(`Unable to read ${metricsPath}. Run 'npm run eval:narrative' first.`);
    throw err;
  }

  const failures = [];
  const spineRate = metrics?.spinePassRate ?? 0;
  const coverage = metrics?.avgCardCoverage ?? 0;
  const deterministicIssues = metrics?.deterministicLanguageCount ?? 0;
  const agencyIssues = metrics?.missingAgencyCount ?? 0;
  const flagged = metrics?.flaggedSampleCount ?? 0;
  const hallucinations = metrics?.hallucinationCount ?? 0;
  const harshTone = metrics?.harshToneCount ?? 0;
  const missingSupportive = metrics?.missingSupportiveToneCount ?? 0;
  const rubric = metrics?.avgRubricScores || {};

  if (spineRate < MIN_SPINE_RATE) {
    failures.push(`Story spine pass rate ${pct(spineRate)} < minimum ${pct(MIN_SPINE_RATE)}`);
  }
  if (coverage < MIN_CARD_COVERAGE) {
    failures.push(`Average card coverage ${pct(coverage)} < minimum ${pct(MIN_CARD_COVERAGE)}`);
  }
  if (deterministicIssues > MAX_DETERMINISTIC) {
    failures.push(`Deterministic language issues ${deterministicIssues} > limit ${MAX_DETERMINISTIC}`);
  }
  if (agencyIssues > MAX_MISSING_AGENCY) {
    failures.push(`Missing agency language issues ${agencyIssues} > limit ${MAX_MISSING_AGENCY}`);
  }
  if (flagged > MAX_FLAGGED) {
    failures.push(`Flagged samples ${flagged} > limit ${MAX_FLAGGED}`);
  }
  if (hallucinations > MAX_HALLUCINATIONS) {
    failures.push(`Hallucinated card issues ${hallucinations} > limit ${MAX_HALLUCINATIONS}`);
  }
  if (harshTone > MAX_HARSH_TONE) {
    failures.push(`Harsh-tone issues ${harshTone} > limit ${MAX_HARSH_TONE}`);
  }
  if (missingSupportive > MAX_MISSING_SUPPORTIVE) {
    failures.push(`Missing supportive tone issues ${missingSupportive} > limit ${MAX_MISSING_SUPPORTIVE}`);
  }
  if ((rubric.accuracy ?? 0) < MIN_RUBRIC_ACCURACY) {
    failures.push(`Rubric accuracy ${(rubric.accuracy * 100).toFixed(1)}% < minimum ${(MIN_RUBRIC_ACCURACY * 100).toFixed(1)}%`);
  }
  if ((rubric.coherence ?? 0) < MIN_RUBRIC_COHERENCE) {
    failures.push(`Rubric coherence ${(rubric.coherence * 100).toFixed(1)}% < minimum ${(MIN_RUBRIC_COHERENCE * 100).toFixed(1)}%`);
  }
  if ((rubric.agency ?? 0) < MIN_RUBRIC_AGENCY) {
    failures.push(`Rubric agency ${(rubric.agency * 100).toFixed(1)}% < minimum ${(MIN_RUBRIC_AGENCY * 100).toFixed(1)}%`);
  }
  if ((rubric.compassion ?? 0) < MIN_RUBRIC_COMPASSION) {
    failures.push(`Rubric compassion ${(rubric.compassion * 100).toFixed(1)}% < minimum ${(MIN_RUBRIC_COMPASSION * 100).toFixed(1)}%`);
  }

  if (failures.length) {
    console.error('Narrative gate failed:', failures.join('; '));
    process.exitCode = 1;
    return;
  }

  console.log('Narrative metrics meet thresholds:', {
    spinePassRate: pct(spineRate),
    avgCardCoverage: pct(coverage),
    deterministicLanguageCount: deterministicIssues,
    missingAgencyCount: agencyIssues,
    hallucinationCount: hallucinations,
    harshToneCount: harshTone,
    missingSupportiveToneCount: missingSupportive,
    flaggedSamples: flagged,
    avgRubric: {
      accuracy: pct(rubric.accuracy ?? 0),
      coherence: pct(rubric.coherence ?? 0),
      agency: pct(rubric.agency ?? 0),
      compassion: pct(rubric.compassion ?? 0)
    }
  });
}

main().catch((err) => {
  console.error('Narrative gate check failed:', err.message);
  process.exit(1);
});
</file>

<file path="scripts/evaluation/verifyVisionGate.js">
#!/usr/bin/env node
import fs from 'node:fs/promises';
import path from 'node:path';

const DEFAULT_FILE = 'data/evaluations/vision-metrics.json';
const ACC_THRESHOLD = parseFloat(process.env.VISION_MIN_ACCURACY || '0.9');
const COVERAGE_THRESHOLD = parseFloat(process.env.VISION_MIN_HIGH_CONFIDENCE_COVERAGE || '0.75');
const COVERAGE_ACC_THRESHOLD = parseFloat(process.env.VISION_MIN_HIGH_CONFIDENCE_ACCURACY || '0.9');
const SYMBOL_COVERAGE_THRESHOLD = parseFloat(process.env.VISION_MIN_SYMBOL_COVERAGE || '0.6');

function formatPct(value) {
  return `${(value * 100).toFixed(2)}%`;
}

function parseCli(rawArgs) {
  const options = {
    file: DEFAULT_FILE,
    deckStyle: 'rws-1909'
  };

  for (let i = 0; i < rawArgs.length; i += 1) {
    const arg = rawArgs[i];
    if (arg === '--deck-style') {
      options.deckStyle = rawArgs[i + 1] || options.deckStyle;
      i += 1;
    } else if (!arg.startsWith('--')) {
      options.file = arg;
    }
  }

  return options;
}

async function main() {
  const args = parseCli(process.argv.slice(2));
  const metricsPath = path.resolve(process.cwd(), args.file || DEFAULT_FILE);
  let payload;
  try {
    payload = JSON.parse(await fs.readFile(metricsPath, 'utf-8'));
  } catch (err) {
    console.error(`Unable to read ${metricsPath}. Run 'npm run eval:vision' first.`);
    throw err;
  }

  const metrics =
    payload?.metricsByDeck?.[args.deckStyle] ||
    payload?.metricsByDeck?.[Object.keys(payload?.metricsByDeck || {})[0]] ||
    payload;

  if (!metrics) {
    console.error(`No metrics found for deck style ${args.deckStyle}.`);
    process.exitCode = 1;
    return;
  }

  const accuracy = metrics?.accuracy ?? 0;
  const coverage = metrics?.highConfidenceCoverage ?? 0;
  const coverageAccuracy = metrics?.highConfidenceAccuracy ?? 0;
  const symbolCoverage = metrics?.symbolCoverageRate ?? 0;

  const failures = [];
  if (accuracy < ACC_THRESHOLD) {
    failures.push(`accuracy ${formatPct(accuracy)} < threshold ${formatPct(ACC_THRESHOLD)}`);
  }
  if (coverage < COVERAGE_THRESHOLD) {
    failures.push(`high-confidence coverage ${formatPct(coverage)} < threshold ${formatPct(COVERAGE_THRESHOLD)}`);
  }
  if (coverageAccuracy < COVERAGE_ACC_THRESHOLD) {
    failures.push(`high-confidence accuracy ${formatPct(coverageAccuracy)} < threshold ${formatPct(COVERAGE_ACC_THRESHOLD)}`);
  }
  if (symbolCoverage < SYMBOL_COVERAGE_THRESHOLD) {
    failures.push(`symbol coverage ${formatPct(symbolCoverage)} < threshold ${formatPct(SYMBOL_COVERAGE_THRESHOLD)}`);
  }

  if (failures.length) {
    console.error('Vision gate failed:', failures.join('; '));
    process.exitCode = 1;
    return;
  }

  console.log(`Vision metrics meet thresholds for ${args.deckStyle}:`, {
    accuracy: formatPct(accuracy),
    highConfidenceCoverage: formatPct(coverage),
    highConfidenceAccuracy: formatPct(coverageAccuracy),
    symbolCoverage: formatPct(symbolCoverage)
  });
}

main().catch((err) => {
  console.error('Vision gate check failed:', err.message);
  process.exit(1);
});
</file>

<file path="scripts/training/buildMultimodalDataset.js">
#!/usr/bin/env node

import fs from 'node:fs/promises';
import path from 'node:path';

import { MAJOR_ARCANA } from '../../src/data/majorArcana.js';
import { MINOR_ARCANA } from '../../src/data/minorArcana.js';
import { SPREADS } from '../../src/data/spreads.js';
import { getDeckImagePath } from '../../shared/vision/deckAssets.js';
import { buildGraphContext } from '../../functions/lib/graphContext.js';
import { canonicalizeCardName } from '../../shared/vision/cardNameMapping.js';

const DEFAULT_INPUT = 'training/readings.jsonl';
const DEFAULT_OUTPUT = 'training/multimodal-dataset.jsonl';
const DEFAULT_VISION_METRICS = 'data/evaluations/vision-metrics.json';
const DEFAULT_DECK_STYLE = 'rws-1909';

const CARD_INDEX = buildCardIndex();

function buildCardIndex() {
  const map = new Map();
  [...MAJOR_ARCANA, ...MINOR_ARCANA].forEach((card) => {
    if (card && card.name) {
      map.set(card.name, card);
    }
  });
  return map;
}

function getDeckLineage(deckStyle) {
  if (!deckStyle) return null;
  if (deckStyle.startsWith('thoth')) return 'thoth';
  if (deckStyle.startsWith('marseille')) return 'marseille';
  if (deckStyle.startsWith('rws')) return 'rws-like';
  return 'indie';
}

function parseArgs(argv) {
  const options = {
    input: DEFAULT_INPUT,
    output: DEFAULT_OUTPUT,
    visionMetricsFile: DEFAULT_VISION_METRICS,
    defaultDeckStyle: DEFAULT_DECK_STYLE,
    verbose: false
  };

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    switch (arg) {
      case '--in':
      case '--input':
        options.input = argv[++i] || options.input;
        break;
      case '--out':
      case '--output':
        options.output = argv[++i] || options.output;
        break;
      case '--vision-metrics':
        options.visionMetricsFile = argv[++i] || options.visionMetricsFile;
        break;
      case '--default-deck-style':
        options.defaultDeckStyle = argv[++i] || options.defaultDeckStyle;
        break;
      case '--verbose':
        options.verbose = true;
        break;
      case '--help':
      case '-h':
        printUsage();
        process.exit(0);
        break;
      default:
        // Ignore unknown args to keep script flexible.
        break;
    }
  }

  return options;
}

function printUsage() {
  console.log(`Usage: node scripts/training/buildMultimodalDataset.js [options]

Options:
  --in | --input <file>            Input readings JSONL (default: ${DEFAULT_INPUT})
  --out | --output <file>          Output multimodal JSONL (default: ${DEFAULT_OUTPUT})
  --vision-metrics <file>          Vision metrics JSON file (default: ${DEFAULT_VISION_METRICS})
  --default-deck-style <deckId>    Fallback deck style when missing (default: ${DEFAULT_DECK_STYLE})
  --verbose                        Enable debug logging
`);
}

async function loadJsonl(filePath) {
  const absPath = path.resolve(process.cwd(), filePath);
  let content;
  try {
    content = await fs.readFile(absPath, 'utf-8');
  } catch (err) {
    if (err.code === 'ENOENT') {
      throw new Error(`Input file not found: ${filePath}`);
    }
    throw err;
  }

  return content
    .split('\n')
    .map((line) => line.trim())
    .filter((line) => line.length > 0)
    .map((line, index) => {
      try {
        return JSON.parse(line);
      } catch (err) {
        console.warn(`[buildMultimodalDataset] Skipping invalid JSON on line ${index + 1}:`, err.message);
        return null;
      }
    })
    .filter(Boolean);
}

async function loadVisionMetrics(filePath, { verbose } = {}) {
  if (!filePath) return null;
  const absPath = path.resolve(process.cwd(), filePath);
  try {
    const content = await fs.readFile(absPath, 'utf-8');
    const parsed = JSON.parse(content);
    if (verbose) {
      console.log('[buildMultimodalDataset] Loaded vision metrics from', filePath);
    }
    return parsed;
  } catch (err) {
    if (err.code === 'ENOENT') {
      console.warn('[buildMultimodalDataset] Vision metrics file not found; deckVisionMetrics will be omitted.');
      return null;
    }
    console.warn('[buildMultimodalDataset] Failed to read vision metrics:', err.message);
    return null;
  }
}

function pickDeckVisionMetrics(allMetrics, deckStyle) {
  if (!allMetrics || !deckStyle) return null;
  const metricsByDeck = allMetrics.metricsByDeck || {};
  const entry = metricsByDeck[deckStyle];
  return entry || null;
}

function enrichCard(baseCard, deckStyle) {
  if (!baseCard || typeof baseCard !== 'object') {
    return null;
  }

  const rawName = baseCard.card || baseCard.name || null;
  const canonicalName = rawName ? canonicalizeCardName(rawName, deckStyle) : null;
  const key = canonicalName || rawName || null;
  const canonical = key ? CARD_INDEX.get(key) || {} : {};
  const name = canonicalName || canonical.name || rawName || null;

  const merged = {
    position: baseCard.position || null,
    name,
    card: name,
    orientation: baseCard.orientation || 'Upright',
    number: baseCard.number ?? canonical.number ?? null,
    suit: baseCard.suit || canonical.suit || null,
    rank: baseCard.rank || canonical.rank || null,
    rankValue: baseCard.rankValue ?? canonical.rankValue ?? null
  };

  const imageCard = { ...canonical, ...merged };
  const imagePath = getDeckImagePath(imageCard, deckStyle);

  return {
    ...merged,
    imagePath: imagePath || null,
    isReversed: String(merged.orientation || '').toLowerCase() === 'reversed'
  };
}

function toMultimodalExample(reading, deckMetrics, options) {
  const deckStyle = reading.deckStyle || options.defaultDeckStyle || DEFAULT_DECK_STYLE;
  const deckLineage = getDeckLineage(deckStyle);
  const cards = Array.isArray(reading.cards) ? reading.cards : [];
  const spreadDef = reading.spreadKey ? SPREADS[reading.spreadKey] : null;
  const roleKeys = Array.isArray(spreadDef?.roleKeys) ? spreadDef.roleKeys : [];

  const enrichedCards = cards
    .map((card, index) => {
      const enriched = enrichCard(card, deckStyle);
      if (!enriched) return null;
      const slotIndex = index;
      const slot = index + 1;
      const positionRole = roleKeys[index] || null;
      return {
        ...enriched,
        slotIndex,
        slot,
        positionRole
      };
    })
    .filter(Boolean);

  const imagePaths = enrichedCards
    .map((card) => card.imagePath)
    .filter((p) => typeof p === 'string' && p.length > 0);

  const visionDeckMetrics = reading.deckVisionMetrics || pickDeckVisionMetrics(deckMetrics, deckStyle);

  let graphContext = null;
  try {
    graphContext = buildGraphContext(enrichedCards, { deckStyle });
  } catch (err) {
    if (options.verbose) {
      console.warn('[buildMultimodalDataset] Graph context detection failed:', err.message);
    }
    graphContext = null;
  }

  const knowledgeGraph = graphContext
    ? {
        patterns: graphContext.patterns || null,
        narrativeHighlights: graphContext.narrativeHighlights || [],
        graphKeys: graphContext.graphKeys || null
      }
    : {
        patterns: null,
        narrativeHighlights: [],
        graphKeys: null
      };

  const spreadSchema = spreadDef
    ? {
        key: reading.spreadKey || null,
        name: spreadDef.name || reading.spreadName || null,
        count: spreadDef.count || (Array.isArray(cards) ? cards.length : null),
        positions: Array.isArray(spreadDef.positions) ? spreadDef.positions : null,
        roleKeys: Array.isArray(spreadDef.roleKeys) ? spreadDef.roleKeys : null
      }
    : null;

  return {
    id: reading.requestId || reading.journalId || null,
    requestId: reading.requestId || null,
    journalId: reading.journalId || null,
    timestamp: reading.timestamp || null,
    deckStyle,
    deckLineage,
    spreadKey: reading.spreadKey || null,
    spreadName: reading.spreadName || spreadDef?.name || null,
    spreadSchema,
    question: reading.question || '',
    context: reading.context || null,
    provider: reading.provider || null,
    cards: enrichedCards,
    imagePaths,
    readingText: reading.readingText || '',
    spreadAnalysis: reading.spreadAnalysis || null,
    themes: reading.themes || null,
    reflections: reading.reflections || {},
    feedback: reading.feedback || null,
    metrics: reading.metrics || null,
    visionSummary: reading.visionSummary || reading.feedback?.visionSummary || null,
    feedbackLabel: reading.feedbackLabel || reading.feedback?.label || null,
    feedbackAverage: reading.feedbackAverage ?? reading.feedback?.averageScore ?? null,
    deckVisionMetrics: visionDeckMetrics || null,
    knowledgeGraph
  };
}

async function writeJsonl(records, outputPath) {
  const absPath = path.resolve(process.cwd(), outputPath);
  await fs.mkdir(path.dirname(absPath), { recursive: true });
  const lines = records.map((record) => JSON.stringify(record));
  await fs.writeFile(absPath, `${lines.join('\n')}\n`);
}

async function main() {
  const options = parseArgs(process.argv.slice(2));

  try {
    const readings = await loadJsonl(options.input);
    if (!readings.length) {
      console.error('[buildMultimodalDataset] No readings found in input file.');
      process.exit(1);
    }

    const deckMetrics = await loadVisionMetrics(options.visionMetricsFile, options);

    const dataset = readings.map((reading) => toMultimodalExample(reading, deckMetrics, options));
    await writeJsonl(dataset, options.output);

    console.log(`[buildMultimodalDataset] Wrote ${dataset.length} example(s) to ${options.output}`);
  } catch (err) {
    console.error('[buildMultimodalDataset] Failed to build multimodal dataset:', err.message);
    process.exit(1);
  }
}

main();
</file>

<file path="scripts/training/buildVectorIndex.py">
import os
import argparse
import json
import torch
import faiss
import numpy as np
from PIL import Image
from tqdm import tqdm
from transformers import CLIPProcessor, CLIPModel
from peft import PeftModel

"""
Tarot Vision - Vector Index Builder
-----------------------------------
This script generates a FAISS vector index from card images using the CLIP model
(optionally with a trained LoRA adapter). This index replaces the static JSON
centroids for faster and more accurate card recognition.

Usage:
    python buildVectorIndex.py --deck rws --adapter_path models/adapters/rws
"""

def build_index(args):
    device = "cuda" if torch.cuda.is_available() else "cpu"
    print(f"Building vector index for deck: {args.deck} on {device}")

    # 1. Load Model
    model_id = "openai/clip-vit-base-patch32"
    model = CLIPModel.from_pretrained(model_id)
    processor = CLIPProcessor.from_pretrained(model_id)

    if args.adapter_path and os.path.exists(args.adapter_path):
        print(f"Loading LoRA adapter from {args.adapter_path}")
        model = PeftModel.from_pretrained(model, args.adapter_path)
        model = model.merge_and_unload() # Merge for faster inference
    else:
        print("Using base CLIP model (no adapter loaded)")

    model.to(device)
    model.eval()

    # 2. Prepare Data
    image_dir = os.path.join("data", "raw_images", args.deck)
    if not os.path.exists(image_dir):
        print(f"Error: Image directory {image_dir} not found.")
        return

    image_files = [f for f in os.listdir(image_dir) if f.endswith(('.jpg', '.jpeg', '.png'))]
    if not image_files:
        print("No images found.")
        return

    print(f"Found {len(image_files)} images. Generating embeddings...")

    embeddings = []
    metadata = []

    # 3. Generate Embeddings
    with torch.no_grad():
        for idx, img_file in enumerate(tqdm(image_files)):
            img_path = os.path.join(image_dir, img_file)
            try:
                image = Image.open(img_path).convert("RGB")
                inputs = processor(images=image, return_tensors="pt").to(device)

                # Get image features
                image_features = model.get_image_features(**inputs)

                # Normalize features (important for cosine similarity)
                image_features = image_features / image_features.norm(p=2, dim=-1, keepdim=True)

                embeddings.append(image_features.cpu().numpy())

                # Store metadata
                card_name = img_file.split('.')[0].replace('_', ' ').replace('-', ' ')
                metadata.append({
                    "id": idx,
                    "filename": img_file,
                    "card_name": card_name
                })
            except Exception as e:
                print(f"Error processing {img_file}: {e}")

    if not embeddings:
        print("No embeddings generated.")
        return

    # 4. Build FAISS Index
    d = embeddings[0].shape[1] # Dimension of embeddings (512 for CLIP-ViT-B/32)
    embeddings_np = np.vstack(embeddings).astype('float32')

    # Use Inner Product (IP) index because vectors are normalized -> equivalent to Cosine Similarity
    index = faiss.IndexFlatIP(d)
    index.add(embeddings_np)

    print(f"Index built with {index.ntotal} vectors.")

    # 5. Save Artifacts
    output_dir = os.path.join("data", "indices", args.deck)
    os.makedirs(output_dir, exist_ok=True)

    index_path = os.path.join(output_dir, "index.faiss")
    metadata_path = os.path.join(output_dir, "metadata.json")

    faiss.write_index(index, index_path)
    with open(metadata_path, 'w') as f:
        json.dump(metadata, f, indent=2)

    print(f"Saved index to {index_path}")
    print(f"Saved metadata to {metadata_path}")

    # 6. Export to JSON (for Web App Integration)
    if args.export_json:
        export_path = args.export_json
        print(f"Exporting embeddings to JSON for web app: {export_path}")

        # Load existing if present to merge
        full_export = {}
        if os.path.exists(export_path):
            try:
                with open(export_path, 'r') as f:
                    full_export = json.load(f)
            except:
                pass

        if "deckStyles" not in full_export:
            full_export["deckStyles"] = {}

        # Map deck name to ID used in app (e.g., rws -> rws-1909)
        deck_id_map = {
            "rws": "rws-1909",
            "thoth": "thoth",
            "marseille": "marseille"
        }
        app_deck_id = deck_id_map.get(args.deck, args.deck)

        cards_data = {}
        for i, meta in enumerate(metadata):
            # Convert numpy float32 to standard float for JSON
            vec = embeddings[i].tolist()
            # Use canonical name as key
            cards_data[meta["card_name"]] = {
                "embedding": vec,
                "count": 1 # Single prototype for now
            }

        full_export["deckStyles"][app_deck_id] = {
            "cards": cards_data
        }

        os.makedirs(os.path.dirname(export_path), exist_ok=True)
        with open(export_path, 'w') as f:
            json.dump(full_export, f)
        print(f"Updated {export_path} with {len(cards_data)} cards for {app_deck_id}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Build FAISS vector index for Tarot cards")
    parser.add_argument("--deck", type=str, required=True, help="Deck name (e.g., rws, thoth)")
    parser.add_argument("--adapter_path", type=str, help="Path to trained LoRA adapter")
    parser.add_argument("--export_json", type=str, help="Path to export JSON for web app (e.g., data/vision/fine-tuned/prototypes.json)")

    args = parser.parse_args()
    build_index(args)
</file>

<file path="scripts/training/buildVisionPrototypes.js">
#!/usr/bin/env node
import fs from 'node:fs';
import fsPromises from 'node:fs/promises';
import path from 'node:path';
import readline from 'node:readline';

import { AutoProcessor, CLIPVisionModelWithProjection, RawImage } from '@xenova/transformers';

const DEFAULT_DATASET = 'training/multimodal-dataset.jsonl';
const DEFAULT_OUTPUT = 'data/vision/fine-tuned/prototypes.json';
const DEFAULT_MODEL = 'Xenova/clip-vit-base-patch32';

function parseArgs(argv = []) {
  const options = {
    dataset: DEFAULT_DATASET,
    output: DEFAULT_OUTPUT,
    model: DEFAULT_MODEL,
    deckStyle: null,
    limit: null,
    perCardLimit: 50,
    quantized: false,
    verbose: false
  };

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    switch (arg) {
      case '--dataset':
        options.dataset = argv[i + 1] || options.dataset;
        i += 1;
        break;
      case '--output':
        options.output = argv[i + 1] || options.output;
        i += 1;
        break;
      case '--model':
        options.model = argv[i + 1] || options.model;
        i += 1;
        break;
      case '--deck-style':
        options.deckStyle = argv[i + 1] || null;
        i += 1;
        break;
      case '--limit':
        options.limit = Number.parseInt(argv[i + 1] || '0', 10) || null;
        i += 1;
        break;
      case '--per-card-limit':
        options.perCardLimit = Number.parseInt(argv[i + 1] || '0', 10) || options.perCardLimit;
        i += 1;
        break;
      case '--quantized':
        options.quantized = true;
        break;
      case '--verbose':
        options.verbose = true;
        break;
      default:
        break;
    }
  }

  return options;
}

function normalizeVector(values = []) {
  const norm = Math.sqrt(values.reduce((sum, value) => sum + value * value, 0));
  if (!norm || Number.isNaN(norm)) {
    return values.slice();
  }
  return values.map((value) => value / norm);
}

async function embedImage(imagePath, processor, model) {
  const rawImage = await RawImage.read(imagePath);
  const processed = await processor(rawImage);
  const { image_embeds } = await model(processed);
  return normalizeVector(Array.from(image_embeds.data));
}

function resolveImagePath(imagePath) {
  if (!imagePath || typeof imagePath !== 'string') {
    return null;
  }
  if (/^https?:/i.test(imagePath) || imagePath.startsWith('data:')) {
    return imagePath;
  }
  const trimmed = imagePath.replace(/^\/+/, '');
  if (trimmed.startsWith('public/')) {
    return path.resolve(process.cwd(), trimmed);
  }
  return path.resolve(process.cwd(), 'public', trimmed);
}

function accumulate(stats, deckStyle, cardName, vector, perCardLimit = null) {
  if (!deckStyle || !cardName || !Array.isArray(vector)) {
    return false;
  }
  if (!stats.has(deckStyle)) {
    stats.set(deckStyle, new Map());
  }
  const deckMap = stats.get(deckStyle);
  if (!deckMap.has(cardName)) {
    deckMap.set(cardName, {
      count: 0,
      sum: new Array(vector.length).fill(0)
    });
  }
  const entry = deckMap.get(cardName);
  if (perCardLimit && entry.count >= perCardLimit) {
    return false;
  }
  entry.count += 1;
  for (let i = 0; i < vector.length; i += 1) {
    entry.sum[i] += vector[i];
  }
  return true;
}

async function ingestRecord(record, context) {
  const deckStyle = record.deckStyle || context.defaultDeck || 'rws-1909';
  const cards = Array.isArray(record.cards) ? record.cards : [];
  for (const card of cards) {
    const cardName = card.card || card.name || card.position || 'Unknown';
    const resolved = resolveImagePath(card.imagePath);
    if (!resolved) {
      continue;
    }
    try {
      const vector = await embedImage(resolved, context.processor, context.model);
      accumulate(context.stats, deckStyle, cardName, vector, context.perCardLimit);
    } catch (err) {
      if (context.verbose) {
        console.warn(`[fineTuneVision] Skipping ${cardName}:`, err.message || err);
      }
    }
  }
}

async function writeOutput(stats, outputPath, modelName) {
  const payload = {
    model: modelName,
    generatedAt: new Date().toISOString(),
    deckStyles: {}
  };

  stats.forEach((cardMap, deckStyle) => {
    const cards = {};
    cardMap.forEach((entry, cardName) => {
      if (!entry.count || !entry.sum) {
        return;
      }
      const averaged = entry.sum.map((value) => value / entry.count);
      cards[cardName] = {
        count: entry.count,
        embedding: normalizeVector(averaged)
      };
    });
    payload.deckStyles[deckStyle] = {
      cardCount: Object.keys(cards).length,
      cards
    };
  });

  await fsPromises.mkdir(path.dirname(outputPath), { recursive: true });
  await fsPromises.writeFile(outputPath, JSON.stringify(payload, null, 2));
  console.log('[fineTuneVision] Saved fine-tuned embeddings to', outputPath);
}

async function loadVisionModel(modelName, quantized) {
  const processor = await AutoProcessor.from_pretrained(modelName);
  const model = await CLIPVisionModelWithProjection.from_pretrained(modelName, {
    quantized: Boolean(quantized),
    progress_callback: null
  });
  return { processor, model };
}

async function main() {
  const options = parseArgs(process.argv.slice(2));
  const datasetPath = path.resolve(process.cwd(), options.dataset);
  if (!fs.existsSync(datasetPath)) {
    console.error('[fineTuneVision] Dataset not found at', datasetPath);
    process.exit(1);
  }

  const stats = new Map();
  const { processor, model } = await loadVisionModel(options.model, options.quantized);
  const input = fs.createReadStream(datasetPath, { encoding: 'utf-8' });
  const rl = readline.createInterface({ input, crlfDelay: Infinity });

  let processed = 0;
  for await (const line of rl) {
    if (!line || !line.trim()) {
      continue;
    }
    let record;
    try {
      record = JSON.parse(line);
    } catch (err) {
      console.warn('[fineTuneVision] Skipping malformed line:', err.message);
      continue;
    }
    if (options.deckStyle && record.deckStyle !== options.deckStyle) {
      continue;
    }
    await ingestRecord(record, {
      stats,
      processor,
      model,
      perCardLimit: options.perCardLimit,
      defaultDeck: options.deckStyle,
      verbose: options.verbose
    });
    processed += 1;
    if (options.limit && processed >= options.limit) {
      break;
    }
    if (processed % 25 === 0) {
      console.log(`[fineTuneVision] Processed ${processed} examples...`);
    }
  }

  if (!processed) {
    console.warn('[fineTuneVision] No records were processed. Output will be empty.');
  }

  const outputPath = path.resolve(process.cwd(), options.output);
  await writeOutput(stats, outputPath, options.model);
}

main().catch((err) => {
  console.error('[fineTuneVision] Training failed:', err);
  process.exit(1);
});
</file>

<file path="scripts/training/exportReadings.js">
#!/usr/bin/env node
/**
 * Export structured tarot readings for training/evaluation.
 *
 * Aggregates data from:
 * - journal_entries (D1 or JSON backup)
 * - feedback (Workers KV or JSON backup)
 * - reading metrics (KV or JSONL backup)
 *
 * Usage examples:
 *   node scripts/training/exportReadings.js
 *   node scripts/training/exportReadings.js --out tmp/readings.jsonl --limit 200
 *   node scripts/training/exportReadings.js --journal-source file --journal-file data/journal/export.json
 *
 * Requires Wrangler for live D1/KV exports. Configure bindings in wrangler.jsonc (or legacy
 * wrangler.toml) or use --feedback-namespace / --metrics-namespace flags to override.
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import { spawn } from 'node:child_process';

const DEFAULT_OUTPUT = 'training/readings.jsonl';
const DEFAULT_JOURNAL_FILE = 'data/journal/export.json';
const DEFAULT_FEEDBACK_FILE = 'data/feedback/export.json';
const DEFAULT_METRICS_FILE = 'data/evaluations/reading-metrics.jsonl';

async function main() {
  const wranglerConfig = await loadWranglerConfig();
  const options = parseArgs(process.argv.slice(2), wranglerConfig);

  if (options.verbose) {
    console.log('[export] options:', options);
  }

  const journalEntries = await loadJournalEntries(options);
  if (!journalEntries.length) {
    console.warn('[export] No journal entries found; output will be empty unless other sources add records.');
  }

  const feedbackRecords = options.feedbackSource === 'none'
    ? []
    : await loadFeedbackRecords(options);

  const metricsRecords = options.metricsSource === 'none'
    ? []
    : await loadMetricsRecords(options);

  const dataset = mergeReadings(journalEntries, feedbackRecords, metricsRecords);
  await writeJsonl(dataset, options.output);

  console.log(`[export] Wrote ${dataset.length} reading(s) to ${options.output}`);
}

function parseArgs(argv, wranglerConfig) {
  const defaults = {
    output: DEFAULT_OUTPUT,
    journalSource: 'd1',
    journalFile: DEFAULT_JOURNAL_FILE,
    feedbackSource: 'kv',
    feedbackFile: DEFAULT_FEEDBACK_FILE,
    metricsSource: 'kv',
    metricsFile: DEFAULT_METRICS_FILE,
    limit: null,
    wranglerTarget: 'remote',
    verbose: false,
    d1Name: wranglerConfig?.d1?.[0]?.database_name || 'mystic-tarot-db',
    feedbackNamespace: getNamespaceId(wranglerConfig, 'FEEDBACK_KV') || null,
    metricsNamespace: getNamespaceId(wranglerConfig, 'METRICS_DB') || null
  };

  const options = { ...defaults };

  for (let i = 0; i < argv.length; i += 1) {
    const arg = argv[i];
    switch (arg) {
      case '--out':
      case '--output':
        options.output = argv[++i] || defaults.output;
        break;
      case '--journal-source':
        options.journalSource = (argv[++i] || defaults.journalSource).toLowerCase();
        break;
      case '--journal-file':
        options.journalFile = argv[++i] || defaults.journalFile;
        break;
      case '--feedback-source':
        options.feedbackSource = (argv[++i] || defaults.feedbackSource).toLowerCase();
        break;
      case '--feedback-file':
        options.feedbackFile = argv[++i] || defaults.feedbackFile;
        break;
      case '--metrics-source':
        options.metricsSource = (argv[++i] || defaults.metricsSource).toLowerCase();
        break;
      case '--metrics-file':
        options.metricsFile = argv[++i] || defaults.metricsFile;
        break;
      case '--limit':
        options.limit = Number(argv[++i]);
        break;
      case '--wrangler-target':
        options.wranglerTarget = (argv[++i] || defaults.wranglerTarget).toLowerCase();
        break;
      case '--d1-name':
        options.d1Name = argv[++i] || defaults.d1Name;
        break;
      case '--feedback-namespace':
        options.feedbackNamespace = argv[++i] || null;
        break;
      case '--metrics-namespace':
        options.metricsNamespace = argv[++i] || null;
        break;
      case '--verbose':
        options.verbose = true;
        break;
      case '--help':
      case '-h':
        printUsage();
        process.exit(0);
        break;
      default:
        console.warn(`[export] Unknown argument ignored: ${arg}`);
        break;
    }
  }

  return options;
}

function printUsage() {
  console.log(`Usage: node scripts/training/exportReadings.js [options]

Options:
  --out <file>                 Output JSONL path (default: ${DEFAULT_OUTPUT})
  --limit <number>             Limit journal rows when using D1 source
  --journal-source <d1|file>   Source for journal entries (default: d1)
  --journal-file <path>        JSON file to read journal entries when using file source
  --feedback-source <kv|file|none>  Source for feedback records (default: kv)
  --feedback-file <path>       JSON file for feedback when using file source
  --metrics-source <kv|file|none>   Source for metrics (default: kv)
  --metrics-file <path>        JSONL/JSON file for metrics when using file source
  --wrangler-target <local|remote>  Use local or remote Wrangler bindings (default: remote)
  --d1-name <name>             D1 database binding name (default: from wrangler.jsonc/wrangler.toml)
  --feedback-namespace <id>    Override FEEDBACK_KV namespace id
  --metrics-namespace <id>     Override METRICS_DB namespace id
  --verbose                    Enable debug logging
`);
}

async function loadJournalEntries(options) {
  if (options.journalSource === 'file') {
    return readJournalFromFile(options.journalFile);
  }
  return fetchJournalFromD1(options);
}

async function loadFeedbackRecords(options) {
  if (options.feedbackSource === 'file') {
    return readFeedbackFromFile(options.feedbackFile);
  }

  if (!options.feedbackNamespace) {
    console.warn('[export] FEEDBACK_KV namespace id missing; pass --feedback-namespace or add FEEDBACK_KV binding to wrangler.jsonc/wrangler.toml. Falling back to file source.');
    return readFeedbackFromFile(options.feedbackFile, { optional: true });
  }

  return fetchFeedbackFromKv({
    namespaceId: options.feedbackNamespace,
    target: options.wranglerTarget
  });
}

async function loadMetricsRecords(options) {
  if (options.metricsSource === 'file') {
    return readMetricsFromFile(options.metricsFile);
  }

  if (!options.metricsNamespace) {
    console.warn('[export] METRICS_DB namespace id missing; pass --metrics-namespace or set METRICS_DB in wrangler.jsonc/wrangler.toml. Metrics will be skipped.');
    return [];
  }

  return fetchMetricsFromKv({
    namespaceId: options.metricsNamespace,
    target: options.wranglerTarget
  });
}

async function readJournalFromFile(filePath, { optional = false } = {}) {
  try {
    const absPath = path.resolve(process.cwd(), filePath);
    const content = await fs.readFile(absPath, 'utf-8');
    const data = JSON.parse(content);
    if (Array.isArray(data)) return data;
    if (Array.isArray(data?.entries)) return data.entries;
    return [];
  } catch (err) {
    if (optional && err.code === 'ENOENT') {
      return [];
    }
    throw err;
  }
}

async function readFeedbackFromFile(filePath, { optional = false } = {}) {
  try {
    const absPath = path.resolve(process.cwd(), filePath);
    const content = await fs.readFile(absPath, 'utf-8');
    const data = JSON.parse(content);
    if (Array.isArray(data)) return data;
    if (Array.isArray(data?.records)) return data.records;
    return [];
  } catch (err) {
    if (optional && err.code === 'ENOENT') {
      return [];
    }
    throw err;
  }
}

async function readMetricsFromFile(filePath, { optional = true } = {}) {
  try {
    const absPath = path.resolve(process.cwd(), filePath);
    const content = await fs.readFile(absPath, 'utf-8');
    // Accept JSON Lines or plain JSON array
    if (content.trim().startsWith('{') || content.trim().startsWith('[')) {
      const data = JSON.parse(content);
      if (Array.isArray(data)) return data;
      if (Array.isArray(data?.records)) return data.records;
      return data?.perSample || [];
    }
    const lines = content.split('\n').map((line) => line.trim()).filter(Boolean);
    return lines.map((line) => JSON.parse(line));
  } catch (err) {
    if (optional && err.code === 'ENOENT') {
      return [];
    }
    throw err;
  }
}

async function fetchJournalFromD1(options) {
  const limitClause = Number.isFinite(options.limit) ? ` LIMIT ${options.limit}` : '';

  // Check if request_id column exists (added in migration 0007)
  // We must detect this dynamically because referencing a non-existent column
  // in SQLite throws "no such column" even inside COALESCE.
  const pragmaArgs = [
    'wrangler',
    'd1',
    'execute',
    options.d1Name,
    '--command',
    'PRAGMA table_info(journal_entries);',
    '--json'
  ];
  if (options.wranglerTarget === 'local') {
    pragmaArgs.push('--local');
  } else if (options.wranglerTarget === 'remote') {
    pragmaArgs.push('--remote');
  }

  let hasRequestIdColumn = false;
  try {
    const pragmaResult = await runCommand('npx', pragmaArgs);
    const pragmaParsed = JSON.parse(pragmaResult);
    const columns = Array.isArray(pragmaParsed)
      ? pragmaParsed.flatMap((entry) => entry?.results || [])
      : pragmaParsed?.results || [];
    hasRequestIdColumn = columns.some((col) => col.name === 'request_id');
  } catch {
    // If PRAGMA fails, assume column doesn't exist
    hasRequestIdColumn = false;
  }

  const requestIdSelect = hasRequestIdColumn ? ',\n      request_id' : '';
  const sql = `
    SELECT
      id,
      created_at,
      spread_key,
      spread_name,
      question,
      cards_json,
      narrative,
      themes_json,
      reflections_json,
      context,
      provider,
      session_seed${requestIdSelect}
    FROM journal_entries
    ORDER BY created_at DESC${limitClause};
  `.trim();

  const args = [
    'wrangler',
    'd1',
    'execute',
    options.d1Name,
    '--command',
    sql,
    '--json'
  ];

  if (options.wranglerTarget === 'local') {
    args.push('--local');
  } else if (options.wranglerTarget === 'remote') {
    args.push('--remote');
  }

  const result = await runCommand('npx', args);
  let parsed;
  try {
    parsed = JSON.parse(result);
  } catch (err) {
    throw new Error(`Failed to parse D1 response: ${err.message}`);
  }

  const rows = Array.isArray(parsed)
    ? parsed.flatMap((entry) => entry?.results || [])
    : parsed?.results || [];

  return rows.map((row) => ({
    id: row.id,
    timestamp: row.created_at ? new Date(row.created_at * 1000).toISOString() : null,
    spreadKey: row.spread_key,
    spreadName: row.spread_name,
    question: row.question || '',
    cards: safeParseJson(row.cards_json, []),
    readingText: row.narrative || '',
    themes: safeParseJson(row.themes_json, null),
    reflections: safeParseJson(row.reflections_json, {}),
    context: row.context || null,
    provider: row.provider || null,
    sessionSeed: row.session_seed || null,
    requestId: row.request_id || null
  }));
}

async function fetchFeedbackFromKv({ namespaceId, target }) {
  const args = [
    'wrangler',
    'kv',
    'key',
    'list',
    '--namespace-id',
    namespaceId,
    '--prefix',
    'feedback:'
  ];

  if (target === 'remote') {
    args.push('--remote');
  } else if (target === 'local') {
    args.push('--local');
  }

  const listOutput = await runCommand('npx', args);
  let keys;
  try {
    keys = JSON.parse(listOutput);
  } catch (err) {
    throw new Error(`Failed to parse feedback key list: ${err.message}`);
  }

  const records = [];
  for (const entry of keys) {
    if (!entry?.name) continue;
    const record = await readKvJson(namespaceId, entry.name, target);
    if (record) records.push(record);
  }
  return records;
}

async function fetchMetricsFromKv({ namespaceId, target }) {
  const args = [
    'wrangler',
    'kv',
    'key',
    'list',
    '--namespace-id',
    namespaceId,
    '--prefix',
    'reading:'
  ];

  if (target === 'remote') {
    args.push('--remote');
  } else if (target === 'local') {
    args.push('--local');
  }

  const listOutput = await runCommand('npx', args);
  let keys;
  try {
    keys = JSON.parse(listOutput);
  } catch (err) {
    throw new Error(`Failed to parse metrics key list: ${err.message}`);
  }

  const records = [];
  for (const entry of keys) {
    if (!entry?.name) continue;
    const record = await readKvJson(namespaceId, entry.name, target);
    if (record) records.push(record);
  }
  return records;
}

async function readKvJson(namespaceId, key, target) {
  const args = [
    'wrangler',
    'kv',
    'key',
    'get',
    key,
    '--namespace-id',
    namespaceId
  ];

  if (target === 'remote') {
    args.push('--remote');
  } else if (target === 'local') {
    args.push('--local');
  }

  const value = await runCommand('npx', args);
  try {
    return JSON.parse(value);
  } catch (err) {
    console.warn(`[export] Failed to parse KV value for ${key}: ${err.message}`);
    return null;
  }
}

function mergeReadings(journalEntries, feedbackRecords, metricsRecords) {
  const feedbackByRequest = new Map();
  const feedbackBySignature = new Map();
  feedbackRecords.forEach((record) => {
    if (record?.requestId) {
      feedbackByRequest.set(record.requestId, record);
    }
    const sig = buildSignature(record?.spreadKey, record?.userQuestion, record?.cards);
    if (sig) {
      feedbackBySignature.set(sig, record);
    }
  });

  const metricsByRequest = new Map();
  metricsRecords.forEach((record) => {
    if (record?.requestId) {
      metricsByRequest.set(record.requestId, record);
    }
  });

  return journalEntries.map((entry) => {
    const signature = buildSignature(entry.spreadKey, entry.question, entry.cards);
    const primaryFeedback = entry.requestId
      ? feedbackByRequest.get(entry.requestId)
      : null;
    const fallbackFeedback = !primaryFeedback && signature
      ? feedbackBySignature.get(signature)
      : null;
    const feedback = primaryFeedback || fallbackFeedback || null;

    const requestId = entry.requestId || feedback?.requestId || null;
    const metrics = requestId ? metricsByRequest.get(requestId) || null : null;

    const feedbackStats = feedback ? deriveFeedbackStats(feedback.ratings) : null;

    return {
      requestId,
      journalId: entry.id,
      timestamp: entry.timestamp,
      spreadKey: entry.spreadKey,
      spreadName: entry.spreadName,
      deckStyle: feedback?.deckStyle || metrics?.deckStyle || null,
      context: entry.context,
      question: entry.question,
      cards: normalizeCards(entry.cards),
      readingText: entry.readingText,
      spreadAnalysis: entry.spreadAnalysis || null,
      themes: entry.themes,
      reflections: entry.reflections,
      provider: entry.provider,
      sessionSeed: entry.sessionSeed,
      visionSummary: feedback?.visionSummary || metrics?.vision?.summary || null,
      deckVisionMetrics: metrics?.vision || null,
      feedbackLabel: feedbackStats?.label || null,
      feedbackAverage: feedbackStats?.average || null,
      feedback: feedback
        ? {
            ratings: feedback.ratings,
            notes: feedback.notes || null,
            submittedAt: feedback.submittedAt,
            visionSummary: feedback.visionSummary || null,
            label: feedbackStats?.label || null,
            averageScore: feedbackStats?.average || null
          }
        : null,
      metrics: metrics
        ? {
            vision: metrics.vision || null,
            narrative: metrics.narrative || null,
            spreadKey: metrics.spreadKey,
            provider: metrics.provider,
            timestamp: metrics.timestamp
          }
        : null
    };
  });
}

function normalizeCards(cards = []) {
  if (!Array.isArray(cards)) return [];
  return cards.map((card, index) => {
    // Infer rankValue from rank name if missing (for legacy data)
    let rankValue = card.rankValue ?? null;
    if (rankValue === null && card.rank) {
      const RANK_VALUES = {
        Ace: 1, Two: 2, Three: 3, Four: 4, Five: 5, Six: 6, Seven: 7,
        Eight: 8, Nine: 9, Ten: 10, Page: 11, Knight: 12, Queen: 13, King: 14
      };
      rankValue = RANK_VALUES[card.rank] ?? null;
    }

    return {
      position: card.position || `Position ${index + 1}`,
      name: card.name || card.card || card.title || null,
      card: card.card || card.name || null,
      orientation: card.orientation || card.status || 'Upright',
      // Major Arcana: number (0-21), Minor Arcana: null
      number: card.number ?? card.value ?? null,
      suit: card.suit || null,
      rank: card.rank || null,
      // Minor Arcana: rankValue (1-14), Major Arcana: null
      rankValue
    };
  });
}

function deriveFeedbackStats(ratings) {
  if (!ratings || typeof ratings !== 'object') {
    return null;
  }
  const values = Object.values(ratings)
    .map((value) => Number(value))
    .filter((value) => Number.isFinite(value));
  if (!values.length) {
    return null;
  }
  const average = values.reduce((sum, value) => sum + value, 0) / values.length;
  let label = 'neutral';
  if (average >= 4.5) {
    label = 'strong-positive';
  } else if (average >= 3.5) {
    label = 'positive';
  } else if (average <= 2) {
    label = 'negative';
  } else if (average <= 3) {
    label = 'mixed';
  }
  return { average, label };
}

function buildSignature(spreadKey, question, cards = []) {
  if (!Array.isArray(cards) || cards.length === 0) {
    return null;
  }
  const normalizedCards = cards
    .map((card) => `${card.position || ''}|${card.card || card.name || ''}|${card.orientation || ''}`)
    .join('||');
  return `${spreadKey || 'general'}::${question || ''}::${normalizedCards}`;
}

async function writeJsonl(records, outputPath) {
  const absPath = path.resolve(process.cwd(), outputPath);
  await fs.mkdir(path.dirname(absPath), { recursive: true });
  const lines = records.map((record) => JSON.stringify(record));
  await fs.writeFile(absPath, `${lines.join('\n')}\n`);
}

function safeParseJson(value, fallback = null) {
  if (!value || typeof value !== 'string') return fallback;
  try {
    return JSON.parse(value);
  } catch {
    return fallback;
  }
}

async function runCommand(command, args) {
  return new Promise((resolve, reject) => {
    const child = spawn(command, args, { stdio: ['ignore', 'pipe', 'pipe'] });
    let stdout = '';
    let stderr = '';
    child.stdout.on('data', (chunk) => {
      stdout += chunk.toString();
    });
    child.stderr.on('data', (chunk) => {
      stderr += chunk.toString();
    });
    child.on('close', (code) => {
      if (code !== 0) {
        reject(new Error(`${command} ${args.join(' ')} failed: ${stderr || stdout}`));
      } else {
        resolve(stdout.trim());
      }
    });
  });
}

/**
 * Load wrangler config from wrangler.jsonc (preferred) or wrangler.toml (legacy).
 * Supports optional configPath override for either format.
 */
async function loadWranglerConfig(configPath = null) {
  // If explicit path provided, use that
  if (configPath) {
    return loadWranglerConfigFromPath(configPath);
  }

  // Try wrangler.jsonc first (new Workers format), then fall back to wrangler.toml
  const jsoncResult = await loadWranglerConfigFromPath('wrangler.jsonc');
  if (jsoncResult) return jsoncResult;

  return loadWranglerConfigFromPath('wrangler.toml');
}

async function loadWranglerConfigFromPath(configPath) {
  try {
    const absPath = path.resolve(process.cwd(), configPath);
    const content = await fs.readFile(absPath, 'utf-8');

    // Detect format based on extension
    if (configPath.endsWith('.jsonc') || configPath.endsWith('.json')) {
      return parseJsoncConfig(content);
    }

    // Legacy TOML format
    return {
      d1: parseTomlBlocks(content, 'd1_databases'),
      kv: parseTomlBlocks(content, 'kv_namespaces')
    };
  } catch {
    return null;
  }
}

/**
 * Parse JSONC (JSON with comments) wrangler config.
 * Strips comments while preserving URLs and other strings containing "//".
 */
function parseJsoncConfig(content) {
  // Strip comments while respecting string literals.
  // Process character-by-character to avoid stripping "//" inside strings.
  let stripped = '';
  let inString = false;
  let escapeNext = false;

  for (let i = 0; i < content.length; i++) {
    const char = content[i];
    const next = content[i + 1];

    if (escapeNext) {
      stripped += char;
      escapeNext = false;
      continue;
    }

    if (char === '\\' && inString) {
      stripped += char;
      escapeNext = true;
      continue;
    }

    if (char === '"' && !escapeNext) {
      inString = !inString;
      stripped += char;
      continue;
    }

    if (!inString) {
      // Check for single-line comment
      if (char === '/' && next === '/') {
        // Skip to end of line
        while (i < content.length && content[i] !== '\n') {
          i++;
        }
        // Include the newline to preserve line structure
        if (content[i] === '\n') {
          stripped += '\n';
        }
        continue;
      }
      // Check for multi-line comment
      if (char === '/' && next === '*') {
        i += 2; // Skip /*
        while (i < content.length && !(content[i] === '*' && content[i + 1] === '/')) {
          i++;
        }
        i++; // Skip closing */
        continue;
      }
    }

    stripped += char;
  }

  try {
    const config = JSON.parse(stripped);
    return {
      d1: config.d1_databases || [],
      kv: config.kv_namespaces || []
    };
  } catch {
    return null;
  }
}

function parseTomlBlocks(content, blockName) {
  const lines = content.split('\n');
  const blocks = [];
  let current = null;
  const header = `[[${blockName}]]`;

  for (const rawLine of lines) {
    const noComment = rawLine.split('#')[0];
    const line = noComment.trim();
    if (!line) continue;
    if (line === header) {
      if (current) blocks.push(current);
      current = {};
      continue;
    }
    if (line.startsWith('[[') || line.startsWith('[')) {
      if (current) {
        blocks.push(current);
        current = null;
      }
      continue;
    }
    if (!current) continue;
    const match = line.match(/^([A-Za-z0-9_]+)\s*=\s*(.+)$/);
    if (!match) continue;
    let value = match[2].trim();
    if ((value.startsWith('"') && value.endsWith('"')) || (value.startsWith("'") && value.endsWith("'"))) {
      value = value.slice(1, -1);
    }
    current[match[1]] = value;
  }

  if (current) blocks.push(current);
  return blocks;
}

function getNamespaceId(config, bindingName) {
  if (!config?.kv || !bindingName) return null;
  const entry = config.kv.find((ns) => ns.binding === bindingName);
  return entry?.id || null;
}

main().catch((err) => {
  console.error('[export] Failed to build reading export:', err);
  process.exit(1);
});
</file>

<file path="scripts/training/README.md">
# Tarot Vision Training Pipeline

This directory contains the Python-based training pipeline for the Tarot Vision system, replacing the legacy Node.js prototypes.

## Prerequisites

1.  **Python 3.10+**
2.  **CUDA-capable GPU** (recommended for training)
3.  Install dependencies:
    ```bash
    pip install -r requirements.txt
    ```

## Directory Structure

-   `trainLoRA.py`: Main script for fine-tuning the CLIP model using LoRA.
-   `buildVectorIndex.py`: Generates FAISS vector indices for fast card retrieval.
-   `requirements.txt`: Python dependencies.
-   `../../data/raw_images/{deck_name}/`: Place your raw card scans here (e.g., `data/raw_images/rws/`).

## Workflow

### 1. Data Ingestion
Place your high-resolution card scans in `data/raw_images/{deck_name}`.
Filenames should be descriptive (e.g., `01_magician.jpg`, `ace_of_cups.png`) as they are currently used for basic text prompting.

### 2. Train Model
Run the LoRA training script to adapt the CLIP model to your deck's art style.

```bash
python trainLoRA.py --deck rws --epochs 10 --batch_size 4
```

This will save the trained adapters to `models/adapters/rws`.

### 3. Build Vector Index
Generate a FAISS index for the deck using the trained model.

```bash
python buildVectorIndex.py --deck rws --adapter_path models/adapters/rws
```

This will save `index.faiss` and `metadata.json` to `data/indices/rws`.

## Legacy Scripts
-   `buildVisionPrototypes.js`: The old Node.js script for calculating static centroids. Kept for reference but deprecated.
</file>

<file path="scripts/training/requirements.txt">
torch>=2.0.0
transformers>=4.30.0
peft>=0.4.0
datasets>=2.14.0
pillow>=9.5.0
accelerate>=0.21.0
scikit-learn>=1.3.0
numpy>=1.24.0
tqdm>=4.65.0
faiss-cpu>=1.7.4
</file>

<file path="scripts/training/testIndex.py">
import argparse
import os
import json
import torch
import faiss
import numpy as np
from transformers import CLIPProcessor, CLIPModel
from peft import PeftModel

"""
Tarot Vision - Index Verification Script
----------------------------------------
This script loads the generated FAISS index and queries it with a text description
to verify that the training and indexing process was successful.

Usage:
    python scripts/training/testIndex.py --deck rws --query "a tarot card of the magician"
"""

def test_index(args):
    print(f"Testing index for deck: {args.deck}")

    # 1. Load Index and Metadata
    index_path = os.path.join("data", "indices", args.deck, "index.faiss")
    metadata_path = os.path.join("data", "indices", args.deck, "metadata.json")

    if not os.path.exists(index_path) or not os.path.exists(metadata_path):
        print(f"Error: Index or metadata not found in data/indices/{args.deck}")
        return

    index = faiss.read_index(index_path)
    with open(metadata_path, 'r') as f:
        metadata = json.load(f)

    print(f"Loaded index with {index.ntotal} vectors.")

    # 2. Load Model (Base + Adapter)
    device = "cuda" if torch.cuda.is_available() else "cpu"
    model_id = "openai/clip-vit-base-patch32"
    model = CLIPModel.from_pretrained(model_id)
    processor = CLIPProcessor.from_pretrained(model_id)

    adapter_path = os.path.join("models", "adapters", args.deck)
    if os.path.exists(adapter_path):
        print(f"Loading LoRA adapter from {adapter_path}")
        model = PeftModel.from_pretrained(model, adapter_path)
        model = model.merge_and_unload()
    else:
        print("Warning: Adapter not found, using base model.")

    model.to(device)
    model.eval()

    # 3. Encode Query
    print(f"Query: '{args.query}'")
    inputs = processor(text=[args.query], return_tensors="pt", padding=True).to(device)

    with torch.no_grad():
        text_features = model.get_text_features(**inputs)
        # Normalize
        text_features = text_features / text_features.norm(p=2, dim=-1, keepdim=True)
        query_vector = text_features.cpu().numpy().astype('float32')

    # 4. Search
    k = 5 # Top 5 results
    D, I = index.search(query_vector, k)

    print("\n--- Search Results ---")
    for i in range(k):
        idx = I[0][i]
        score = D[0][i]
        if idx < len(metadata):
            card_info = metadata[idx]
            print(f"Rank {i+1}: {card_info['card_name']} (Score: {score:.4f})")
            print(f"        File: {card_info['filename']}")
        else:
            print(f"Rank {i+1}: Unknown Index {idx}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Test Tarot Vision Index")
    parser.add_argument("--deck", type=str, default="rws", help="Deck name")
    parser.add_argument("--query", type=str, default="a tarot card of the fool", help="Text query")

    args = parser.parse_args()
    test_index(args)
</file>

<file path="scripts/training/trainLoRA.py">
import os
import argparse
import torch
from transformers import CLIPProcessor, CLIPModel
from peft import LoraConfig, get_peft_model
from torch.utils.data import Dataset, DataLoader
from PIL import Image
from tqdm import tqdm

"""
Tarot Vision - LoRA Training Script
-----------------------------------
This script implements the Low-Rank Adaptation (LoRA) fine-tuning pipeline for the Tarot Vision model.
It is designed to teach the base CLIP model specific artistic styles (RWS, Thoth, Marseille) and
esoteric symbolism without destroying its pre-trained knowledge.

Usage:
    python trainLoRA.py --deck rws --epochs 5 --batch_size 4
"""

class TarotCardDataset(Dataset):
    def __init__(self, image_dir, processor):
        self.image_dir = image_dir
        self.processor = processor
        self.images = [f for f in os.listdir(image_dir) if f.endswith(('.jpg', '.jpeg', '.png'))]
        if not self.images:
            print(f"Warning: No images found in {image_dir}")

    def __len__(self):
        return len(self.images)

    def __getitem__(self, idx):
        img_name = self.images[idx]
        img_path = os.path.join(self.image_dir, img_name)
        image = Image.open(img_path).convert("RGB")

        # Basic text prompt for now - in future will use detailed descriptions
        # Clean filename to get card name (e.g., "01_magician.jpg" -> "magician")
        clean_name = img_name.split('.')[0].replace('_', ' ').replace('-', ' ')
        text = f"a tarot card of {clean_name}"

        processed = self.processor(
            text=[text],
            images=image,
            return_tensors="pt",
            padding="max_length",
            truncation=True,
            max_length=77
        )

        return {
            "pixel_values": processed["pixel_values"].squeeze(),
            "input_ids": processed["input_ids"].squeeze(),
            "attention_mask": processed["attention_mask"].squeeze()
        }

def train(args):
    print(f"Initializing LoRA training for deck: {args.deck}")

    device = "cuda" if torch.cuda.is_available() else "cpu"
    print(f"Using device: {device}")

    # 1. Load Base Model
    model_id = "openai/clip-vit-base-patch32"
    model = CLIPModel.from_pretrained(model_id)
    processor = CLIPProcessor.from_pretrained(model_id)

    # 2. Configure LoRA
    # Target specific modules in the vision encoder for style adaptation
    config = LoraConfig(
        r=16,
        lora_alpha=16,
        target_modules=["q_proj", "v_proj"],
        lora_dropout=0.1,
        bias="none",
        modules_to_save=["classifier"],
    )

    lora_model = get_peft_model(model, config)
    lora_model.print_trainable_parameters()
    lora_model.to(device)

    # 3. Prepare Data
    dataset_path = os.path.join("data", "raw_images", args.deck)
    if not os.path.exists(dataset_path):
        print(f"Warning: Dataset path {dataset_path} does not exist. Creating dummy dataset for structure verification.")
        os.makedirs(dataset_path, exist_ok=True)

    dataset = TarotCardDataset(dataset_path, processor)
    if len(dataset) == 0:
        print("No data found. Skipping training loop.")
        return

    dataloader = DataLoader(dataset, batch_size=args.batch_size, shuffle=True)

    # 4. Training Loop
    optimizer = torch.optim.AdamW(lora_model.parameters(), lr=5e-5)
    lora_model.train()

    print(f"Starting training for {args.epochs} epochs...")

    for epoch in range(args.epochs):
        total_loss = 0
        progress_bar = tqdm(dataloader, desc=f"Epoch {epoch+1}/{args.epochs}")

        for batch in progress_bar:
            pixel_values = batch["pixel_values"].to(device)
            input_ids = batch["input_ids"].to(device)
            attention_mask = batch["attention_mask"].to(device)

            outputs = lora_model(
                pixel_values=pixel_values,
                input_ids=input_ids,
                attention_mask=attention_mask,
                return_loss=True
            )

            loss = outputs.loss
            loss.backward()

            optimizer.step()
            optimizer.zero_grad()

            total_loss += loss.item()
            progress_bar.set_postfix({"loss": loss.item()})

        avg_loss = total_loss / len(dataloader)
        print(f"Epoch {epoch+1} completed. Average Loss: {avg_loss:.4f}")

    # 5. Save Adapter
    output_dir = os.path.join("models", "adapters", args.deck)
    os.makedirs(output_dir, exist_ok=True)
    lora_model.save_pretrained(output_dir)
    print(f"LoRA adapters saved to {output_dir}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Train LoRA adapter for Tarot Vision")
    parser.add_argument("--deck", type=str, default="rws", help="Target deck style (rws, thoth, marseille)")
    parser.add_argument("--epochs", type=int, default=5)
    parser.add_argument("--batch_size", type=int, default=4)

    args = parser.parse_args()
    train(args)
</file>

<file path="scripts/vision/runVisionPrototype.js">
#!/usr/bin/env node
/**
 * Quick CLI to exercise the TarotVisionPipeline against one or more images.
 * Usage:
 *   node scripts/vision/runVisionPrototype.js <image paths...>
 */
import path from 'node:path';

import { createVisionBackend } from '../../shared/vision/visionBackends.js';

function parseArgs(rawArgs) {
  const args = [];
  const options = {
    scope: 'major',
    maxResults: 5,
    deckStyle: 'rws-1909'
  };

  for (let i = 0; i < rawArgs.length; i++) {
    const arg = rawArgs[i];
    if (arg === '--all-cards') {
      options.scope = 'all';
    } else if (arg === '--max-results') {
      const value = Number(rawArgs[i + 1]);
      if (!Number.isNaN(value)) {
        options.maxResults = value;
        i += 1;
      }
    } else if (arg === '--deck-style') {
      const value = rawArgs[i + 1];
      if (value) {
        options.deckStyle = value;
        i += 1;
      }
    } else {
      args.push(arg);
    }
  }

  return { imageArgs: args, options };
}

async function main() {
  const { imageArgs, options } = parseArgs(process.argv.slice(2));
  if (imageArgs.length === 0) {
    console.error('Usage: node scripts/vision/runVisionPrototype.js [--all-cards] [--max-results N] [--deck-style id] <image paths...>');
    process.exitCode = 1;
    return;
  }

  const imageInputs = imageArgs.map((relativePath) => {
    const resolved = path.resolve(process.cwd(), relativePath).replace(/\\/g, '/');
    return { source: resolved, label: relativePath };
  });

  const backend = await createVisionBackend({
    backendId: 'clip-default',
    cardScope: options.scope,
    maxResults: options.maxResults,
    deckStyle: options.deckStyle
  });

  console.log('Downloading CLIP model (if not cached) and building card embeddings...');
  await backend.warmup();
  const analyses = await backend.analyzeImages(imageInputs);

  analyses.forEach((result) => {
    console.log('\nImage:', result.label || result.imagePath);
    console.log('Top match:', result.topMatch?.cardName ?? 'n/a', 'confidence:', result.confidence?.toFixed(3));
    console.table(result.matches.map((match) => ({
      card: match.cardName,
      score: Number(match.score.toFixed(4))
    })));
  });
}

main().catch((err) => {
  console.error('Vision prototype failed:', err);
  process.exitCode = 1;
});
</file>

<file path="scripts/check-azure-tts.mjs">
#!/usr/bin/env node

/**
 * Azure OpenAI TTS Configuration Checker
 *
 * This script helps diagnose TTS configuration issues by:
 * 1. Checking environment variables
 * 2. Testing the Azure OpenAI endpoint
 * 3. Verifying deployment accessibility
 */

import { config } from 'dotenv';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const rootDir = join(__dirname, '..');

// Load .env.local if it exists
config({ path: join(rootDir, '.env.local') });

const REQUIRED_VARS = [
  'AZURE_OPENAI_ENDPOINT',
  'AZURE_OPENAI_API_KEY',
  'AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT'
];

const OPTIONAL_VARS = [
  'AZURE_OPENAI_API_VERSION',
  'AZURE_OPENAI_GPT_AUDIO_MINI_FORMAT'
];

console.log('🔍 Azure OpenAI TTS Configuration Checker\n');

// Check environment variables
console.log('📋 Environment Variables:\n');

let allPresent = true;

REQUIRED_VARS.forEach(varName => {
  const value = process.env[varName];
  if (value) {
    if (varName === 'AZURE_OPENAI_API_KEY') {
      console.log(`✅ ${varName}: ${value.slice(0, 10)}...${value.slice(-10)} (${value.length} chars)`);
    } else {
      console.log(`✅ ${varName}: ${value}`);
    }
  } else {
    console.log(`❌ ${varName}: NOT SET`);
    allPresent = false;
  }
});

console.log('\n📝 Optional Variables:\n');

OPTIONAL_VARS.forEach(varName => {
  const value = process.env[varName];
  if (value) {
    console.log(`✅ ${varName}: ${value}`);
  } else {
    console.log(`⚪ ${varName}: Not set (will use default)`);
  }
});

if (!allPresent) {
  console.log('\n❌ Missing required environment variables!');
  console.log('\n💡 To fix:');
  console.log('   1. Edit .env.local and fill in the missing values');
  console.log('   2. Get values from Azure Portal:');
  console.log('      https://portal.azure.com → Azure OpenAI → Your Resource → Keys and Endpoint');
  console.log('   3. For deployment name, go to: Deployments tab');
  process.exit(1);
}

// Test Azure OpenAI connection
console.log('\n🔌 Testing Azure OpenAI Connection:\n');

const endpoint = process.env.AZURE_OPENAI_ENDPOINT.replace(/\/+$/, '');
const deployment = process.env.AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT;
const apiKey = process.env.AZURE_OPENAI_API_KEY;
const apiVersion = process.env.AZURE_OPENAI_API_VERSION || '2025-04-01-preview';
const format = process.env.AZURE_OPENAI_GPT_AUDIO_MINI_FORMAT || 'mp3';

const url = `${endpoint}/openai/deployments/${deployment}/audio/speech?api-version=${apiVersion}`;

console.log(`🌐 Endpoint: ${url}`);
console.log(`🎙️  Deployment: ${deployment}`);
console.log(`📦 API Version: ${apiVersion}`);
console.log(`🎵 Format: ${format}\n`);

// Test with a simple request
const testPayload = {
  model: deployment,
  voice: 'nova',
  input: 'Testing Azure OpenAI TTS integration.',
  response_format: format,
  speed: 0.95
};

// Check if deployment supports steerable instructions
const isSteerableModel = deployment.toLowerCase().includes('gpt-4o') ||
                        deployment.toLowerCase().includes('mini-tts') ||
                        deployment.toLowerCase().includes('audio-preview');

if (isSteerableModel) {
  testPayload.instructions = 'Speak gently and clearly, as a test of the text-to-speech system.';
  console.log('✨ Model supports steerable instructions (gpt-4o-mini-tts detected)');
} else {
  console.log('⚪ Model does not support steerable instructions (tts-1/tts-1-hd detected)');
}

console.log('\n📡 Sending test request...\n');

try {
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'api-key': apiKey,
      'content-type': 'application/json'
    },
    body: JSON.stringify(testPayload)
  });

  if (!response.ok) {
    const errorText = await response.text().catch(() => 'Unable to read error response');
    console.log(`❌ Request failed with status ${response.status}`);
    console.log(`\n📄 Error details:\n${errorText}\n`);

    if (response.status === 401) {
      console.log('💡 Fix: Check your AZURE_OPENAI_API_KEY is correct');
    } else if (response.status === 404) {
      console.log('💡 Fix: Check your AZURE_OPENAI_ENDPOINT and deployment name are correct');
      console.log('   Verify the deployment exists in Azure Portal → Deployments tab');
    } else if (response.status === 429) {
      console.log('💡 Fix: Rate limit exceeded or quota reached. Check Azure Portal → Quotas');
    }

    process.exit(1);
  }

  const arrayBuffer = await response.arrayBuffer();
  const audioSize = arrayBuffer.byteLength;

  console.log(`✅ SUCCESS! TTS is working correctly`);
  console.log(`   Audio generated: ${(audioSize / 1024).toFixed(2)} KB`);
  console.log(`   Format: ${format}`);
  console.log(`   Provider: azure-${deployment}\n`);

  console.log('🎉 Your Azure OpenAI TTS integration is configured correctly!');
  console.log('\n📌 Next steps:');
  console.log('   1. For Cloudflare Pages deployment, set these environment variables in:');
  console.log('      Cloudflare Dashboard → Pages → tableau → Settings → Environment variables');
  console.log('   2. For local development with Vite, the .env.local file should work');
  console.log('   3. For Cloudflare Pages Functions, you may need to use wrangler.toml or dashboard\n');

} catch (error) {
  console.log(`❌ Connection failed: ${error.message}\n`);
  console.log('💡 Troubleshooting:');
  console.log('   1. Check your internet connection');
  console.log('   2. Verify AZURE_OPENAI_ENDPOINT is correct');
  console.log('   3. Ensure the Azure OpenAI resource is active');
  console.log('   4. Check firewall/proxy settings\n');
  process.exit(1);
}
</file>

<file path="scripts/checkEnv.js">
#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';

const REQUIRED_SECRETS = [
  'AZURE_OPENAI_ENDPOINT',
  'AZURE_OPENAI_API_KEY',
  'AZURE_OPENAI_GPT5_MODEL',
  'AZURE_OPENAI_TTS_ENDPOINT',
  'AZURE_OPENAI_TTS_API_KEY',
  'AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT',
  'VISION_PROOF_SECRET',
  'ANTHROPIC_API_KEY'
];

const OPTIONAL_FLAGS = [
  'VITE_ENABLE_VISION_RESEARCH',
  'LOG_LLM_PROMPTS',
  'LOG_ENHANCEMENT_TELEMETRY',
  'PROMPT_BUDGET_AZURE',
  'PROMPT_BUDGET_CLAUDE',
  'PROMPT_BUDGET_DEFAULT'
];

function parseDevVars(filePath) {
  if (!fs.existsSync(filePath)) {
    return {};
  }

  const content = fs.readFileSync(filePath, 'utf8');
  return content
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter((line) => line && !line.startsWith('#'))
    .reduce((acc, line) => {
      const [key, ...rest] = line.split('=');
      if (!key) return acc;
      const rawValue = rest.join('=').trim();
      const value = rawValue.replace(/^['"]|['"]$/g, '');
      acc[key.trim()] = value;
      return acc;
    }, {});
}

function resolveVariable(key, envVars, fileVars) {
  const fromProcess = envVars[key];
  if (typeof fromProcess === 'string' && fromProcess.trim().length > 0) {
    return { value: fromProcess, source: 'process.env' };
  }
  const fromFile = fileVars[key];
  if (typeof fromFile === 'string' && fromFile.trim().length > 0) {
    return { value: fromFile, source: '.dev.vars' };
  }
  return null;
}

function run() {
  const devVarsPath = path.resolve(process.cwd(), '.dev.vars');
  const fileVars = parseDevVars(devVarsPath);
  const results = {};

  const missing = [];
  for (const key of REQUIRED_SECRETS) {
    const resolved = resolveVariable(key, process.env, fileVars);
    results[key] = resolved;
    if (!resolved) {
      missing.push(key);
    }
  }

  console.log('🔐 Environment prerequisite check');
  console.log(`- Loaded ${Object.keys(fileVars).length} entries from ${path.basename(devVarsPath)}${fs.existsSync(devVarsPath) ? '' : ' (file not present)'}`);

  for (const [key, entry] of Object.entries(results)) {
    if (entry) {
      console.log(`✔ ${key} (${entry.source})`);
    } else {
      console.log(`✖ ${key} (missing)`);
    }
  }

  if (missing.length > 0) {
    console.error('\nMissing required secrets:', missing.join(', '));
    console.error('Populate .dev.vars (or export env vars) before running dev.sh.');
    process.exitCode = 1;
    return;
  }

  if (OPTIONAL_FLAGS.length > 0) {
    console.log('\nOptional flags (set as needed):');
    OPTIONAL_FLAGS.forEach((flag) => {
      const entry = resolveVariable(flag, process.env, fileVars);
      if (entry) {
        console.log(`• ${flag} (${entry.source})`);
      } else {
        console.log(`• ${flag} (not set)`);
      }
    });
  }

  console.log('\nAll required environment variables are present. You are ready to run dev.sh 🙌');
}

run();
</file>

<file path="scripts/fix-and-deploy.sh">
#!/bin/bash

# Tableau - Fix Configuration and Deploy
# This script fixes the TTS endpoint and redeploys everything
# Updated for Cloudflare Workers (migrated from Pages)

set -e

WORKER_NAME="tableau"

echo "=================================================="
echo "  Mystic Tarot - Fix Configuration and Deploy"
echo "=================================================="
echo ""
echo "This script will:"
echo "  1. Update TTS endpoint (remove incorrect API path)"
echo "  2. Rebuild the project"
echo "  3. Deploy to Cloudflare Workers"
echo ""

# Fix TTS endpoint (remove /openai/v1/chat/completions path)
echo "📝 Step 1: Fixing TTS endpoint URL..."
echo "   Old: https://hperk-mhsylcwu-centralus.openai.azure.com/openai/v1/chat/completions"
echo "   New: https://hperk-mhsylcwu-centralus.openai.azure.com"
echo ""

echo "https://hperk-mhsylcwu-centralus.openai.azure.com" | \
  wrangler secret put AZURE_OPENAI_TTS_ENDPOINT --name "$WORKER_NAME"
echo "✅ TTS endpoint updated in Cloudflare"
echo ""

# Build project
echo "📦 Step 2: Building project..."
npm run build
echo "✅ Build complete"
echo ""

# Deploy
echo "🚀 Step 3: Deploying to Cloudflare Workers..."
echo "   - Static assets from: dist/"
echo "   - Worker entry: src/worker/index.js"
echo ""

wrangler deploy --config wrangler.jsonc

echo ""
echo "=================================================="
echo "  ✅ Deployment Complete!"
echo "=================================================="
echo ""
echo "🧪 Test your deployment:"
echo ""
echo "   # GPT-5.1 Health Check"
echo "   curl https://tableau.YOUR_SUBDOMAIN.workers.dev/api/tarot-reading"
echo ""
echo "   # TTS Health Check"
echo "   curl https://tableau.YOUR_SUBDOMAIN.workers.dev/api/tts"
echo ""
echo "   # Full tarot reading test (vision proof required)"
echo "   # 1) Create a proof by posting base64 photo data"
echo "   curl -X POST https://tableau.YOUR_SUBDOMAIN.workers.dev/api/vision-proof \"
echo "     -H 'Content-Type: application/json' \"
echo "     -d '{\"deckStyle\":\"rws-1909\",\"evidence\":[{\"label\":\"Card 1\",\"dataUrl\":\"data:image/jpeg;base64,REPLACE_ME\"}]}'"
echo "   # 2) Use the returned proof with /api/tarot-reading"
echo "   curl -X POST https://tableau.YOUR_SUBDOMAIN.workers.dev/api/tarot-reading \"
echo "     -H 'Content-Type: application/json' \"
echo "     -d '{\"spreadInfo\":{\"name\":\"One-Card Insight\"},\"cardsInfo\":[{\"position\":\"Card 1\",\"card\":\"The Fool\",\"orientation\":\"upright\",\"meaning\":\"New beginnings\"}],\"userQuestion\":\"Test\",\"visionProof\":{...}}'"
echo ""
</file>

<file path="scripts/migrate-secrets.sh">
#!/bin/bash
# =============================================================================
# Secrets Migration Script: Pages Functions → Workers
# =============================================================================
# This script helps migrate secrets from Cloudflare Pages to Cloudflare Workers.
# 
# Pages secrets are stored separately from Workers secrets, so you need to
# re-add them to the Workers deployment.
#
# Usage:
#   ./scripts/migrate-secrets.sh           # Interactive mode (prompts for values)
#   ./scripts/migrate-secrets.sh --from-env # Uses .dev.vars file values
# =============================================================================

set -e

WORKER_NAME="tableau"

# List of required secrets (must have values)
REQUIRED_SECRETS=(
  "AZURE_OPENAI_ENDPOINT"
  "AZURE_OPENAI_API_KEY"
  "AZURE_OPENAI_GPT5_MODEL"
)

# List of optional secrets (may be empty)
OPTIONAL_SECRETS=(
  "AZURE_OPENAI_TTS_ENDPOINT"
  "AZURE_OPENAI_TTS_API_KEY"
  "AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT"
  "ANTHROPIC_API_KEY"
  "VISION_PROOF_SECRET"
  "HUME_API_KEY"
)

echo "========================================"
echo "Cloudflare Workers Secrets Migration"
echo "========================================"
echo ""
echo "This script will add secrets to Worker: $WORKER_NAME"
echo ""

# Check if wrangler is available
if ! command -v wrangler &> /dev/null; then
  echo "❌ Error: wrangler CLI not found. Install with: npm install -g wrangler"
  exit 1
fi

# Function to add a secret
add_secret() {
  local secret_name=$1
  local secret_value=$2
  
  if [ -n "$secret_value" ]; then
    echo "$secret_value" | wrangler secret put "$secret_name" --name "$WORKER_NAME"
    echo "✅ Added secret: $secret_name"
  else
    echo "⏭️  Skipped (empty): $secret_name"
  fi
}

# Check for --from-env flag
if [ "$1" == "--from-env" ]; then
  echo "📁 Reading secrets from .dev.vars file..."
  
  if [ ! -f ".dev.vars" ]; then
    echo "❌ Error: .dev.vars file not found"
    echo "   Create it from .dev.vars.example first"
    exit 1
  fi
  
  # Source the .dev.vars file
  set -a
  source .dev.vars
  set +a
  
  echo ""
  echo "Adding required secrets..."
  for secret in "${REQUIRED_SECRETS[@]}"; do
    value="${!secret}"
    if [ -z "$value" ]; then
      echo "❌ Error: Required secret $secret is empty in .dev.vars"
      exit 1
    fi
    add_secret "$secret" "$value"
  done
  
  echo ""
  echo "Adding optional secrets..."
  for secret in "${OPTIONAL_SECRETS[@]}"; do
    value="${!secret}"
    add_secret "$secret" "$value"
  done
  
else
  echo "🔐 Interactive mode - you'll be prompted for each secret"
  echo "   (Use --from-env to read from .dev.vars instead)"
  echo ""
  
  echo "Adding required secrets..."
  for secret in "${REQUIRED_SECRETS[@]}"; do
    echo ""
    echo "Enter value for $secret:"
    wrangler secret put "$secret" --name "$WORKER_NAME"
  done
  
  echo ""
  echo "Adding optional secrets (press Enter to skip)..."
  for secret in "${OPTIONAL_SECRETS[@]}"; do
    echo ""
    read -p "Add $secret? (y/N): " yn
    if [ "$yn" == "y" ] || [ "$yn" == "Y" ]; then
      wrangler secret put "$secret" --name "$WORKER_NAME"
    else
      echo "⏭️  Skipped: $secret"
    fi
  done
fi

echo ""
echo "========================================"
echo "✅ Secrets migration complete!"
echo "========================================"
echo ""
echo "To verify secrets are set:"
echo "  wrangler secret list --name $WORKER_NAME"
echo ""
echo "To deploy with new secrets:"
echo "  npm run deploy"
</file>

<file path="scripts/setup-all-environments.sh">
#!/bin/bash

# Setup secrets for BOTH production and preview environments
# This script securely prompts for credentials and uploads to both environments

set -e

PROJECT_NAME="tableau"

echo "Setting up secrets for BOTH production AND preview environments..."
echo ""
echo "⚠️  You will be prompted for your Azure credentials."
echo "    They will be uploaded to both production and preview environments."
echo ""

read -p "Press Enter to continue or Ctrl+C to cancel..."

echo ""
echo "📝 Please provide your Azure OpenAI GPT-5.1 credentials..."
echo ""

# Collect all credentials first
read -p "GPT-5.1 Endpoint (e.g., https://your-resource.openai.azure.com): " gpt5_endpoint
echo ""
echo "GPT-5.1 API Key (input will be hidden):"
read -s gpt5_api_key
echo ""
read -p "GPT-5.1 Deployment Name (e.g., gpt-5.1): " gpt5_model

echo ""
read -p "TTS Endpoint (e.g., https://your-tts-resource.openai.azure.com): " tts_endpoint
echo ""
echo "TTS API Key (input will be hidden):"
read -s tts_api_key
echo ""
read -p "TTS Deployment Name (e.g., gpt-audio-mini): " tts_deployment

# Set secrets for PRODUCTION
echo ""
echo "📝 Setting GPT-5.1 secrets for production..."
echo "$gpt5_endpoint" | wrangler pages secret put AZURE_OPENAI_ENDPOINT --project-name=$PROJECT_NAME
echo "$gpt5_api_key" | wrangler pages secret put AZURE_OPENAI_API_KEY --project-name=$PROJECT_NAME
echo "$gpt5_model" | wrangler pages secret put AZURE_OPENAI_GPT5_MODEL --project-name=$PROJECT_NAME

echo ""
echo "📝 Setting TTS secrets for production..."
echo "$tts_endpoint" | wrangler pages secret put AZURE_OPENAI_TTS_ENDPOINT --project-name=$PROJECT_NAME
echo "$tts_api_key" | wrangler pages secret put AZURE_OPENAI_TTS_API_KEY --project-name=$PROJECT_NAME
echo "$tts_deployment" | wrangler pages secret put AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT --project-name=$PROJECT_NAME

# Set secrets for PREVIEW
echo ""
echo "📝 Setting GPT-5.1 secrets for preview..."
echo "$gpt5_endpoint" | wrangler pages secret put AZURE_OPENAI_ENDPOINT --project-name=$PROJECT_NAME --env=preview
echo "$gpt5_api_key" | wrangler pages secret put AZURE_OPENAI_API_KEY --project-name=$PROJECT_NAME --env=preview
echo "$gpt5_model" | wrangler pages secret put AZURE_OPENAI_GPT5_MODEL --project-name=$PROJECT_NAME --env=preview

echo ""
echo "📝 Setting TTS secrets for preview..."
echo "$tts_endpoint" | wrangler pages secret put AZURE_OPENAI_TTS_ENDPOINT --project-name=$PROJECT_NAME --env=preview
echo "$tts_api_key" | wrangler pages secret put AZURE_OPENAI_TTS_API_KEY --project-name=$PROJECT_NAME --env=preview
echo "$tts_deployment" | wrangler pages secret put AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT --project-name=$PROJECT_NAME --env=preview

echo ""
echo "✅ All secrets set for both production and preview!"
echo ""
echo "Now deploy:"
echo "  npm run deploy"
echo ""
</file>

<file path="scripts/setup-cloudflare-env.sh">
#!/bin/bash
# Setup Cloudflare Workers secrets for Azure TTS
# Updated for Cloudflare Workers (migrated from Pages)

set -e

echo "🔧 Setting up Cloudflare Workers secrets..."
echo ""

WORKER_NAME="tableau"

# Read from .env.local or current environment
ENDPOINT="${AZURE_OPENAI_ENDPOINT:-https://thefoundry.openai.azure.com}"
API_KEY="${AZURE_OPENAI_API_KEY}"
DEPLOYMENT="${AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT:-gpt-4o-mini-tts}"

if [ -z "$API_KEY" ]; then
  echo "❌ Error: AZURE_OPENAI_API_KEY not found in environment"
  echo "   Please export it first or ensure .env.local is loaded"
  exit 1
fi

echo "📋 Configuration to deploy:"
echo "   Endpoint: $ENDPOINT"
echo "   Deployment: $DEPLOYMENT"
echo ""
echo "⚠️  API Key will be set (encrypted)"
echo ""

read -p "Deploy these settings to Cloudflare Workers? (y/N) " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
  echo "Cancelled."
  exit 0
fi

echo ""
echo "🚀 Deploying secrets to Worker: $WORKER_NAME..."

# Set secrets (Workers use secrets for sensitive values, not env vars)
echo "$ENDPOINT" | wrangler secret put AZURE_OPENAI_ENDPOINT --name "$WORKER_NAME"
echo "✅ AZURE_OPENAI_ENDPOINT set"

echo "$API_KEY" | wrangler secret put AZURE_OPENAI_API_KEY --name "$WORKER_NAME"
echo "✅ AZURE_OPENAI_API_KEY set"

echo "$DEPLOYMENT" | wrangler secret put AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT --name "$WORKER_NAME"
echo "✅ AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT set"

echo ""
echo "✅ Secrets deployed to Worker!"
echo ""
echo "🔄 Next steps:"
echo "   1. Deploy the Worker: npm run deploy"
echo "   2. Or run: wrangler deploy --config wrangler.jsonc"
echo ""
echo "📝 Note: Non-secret env vars are configured in wrangler.jsonc"
echo "   (AZURE_OPENAI_GPT_AUDIO_MINI_FORMAT, AZURE_OPENAI_API_VERSION, etc.)"
</file>

<file path="scripts/setup-my-secrets.sh">
#!/bin/bash

# Mystic Tarot - Production Secrets Setup
# This script securely prompts for your Azure OpenAI credentials and uploads them to Cloudflare Pages

set -e

PROJECT_NAME="tableau"

echo "=================================================="
echo "  Mystic Tarot - Cloudflare Pages Secrets Setup"
echo "=================================================="
echo ""
echo "This script will upload your Azure OpenAI credentials"
echo "to Cloudflare Pages as encrypted secrets."
echo ""
echo "⚠️  IMPORTANT: Make sure you have:"
echo "   1. Wrangler installed: npm install -g wrangler"
echo "   2. Authenticated: wrangler login"
echo ""

read -p "Press Enter to continue or Ctrl+C to cancel..."

echo ""
echo "📝 Setting up Azure OpenAI GPT-5.1 (Responses API) secrets..."
echo ""

# GPT-5.1 Endpoint
read -p "Enter your Azure OpenAI Endpoint (e.g., https://your-resource.openai.azure.com): " gpt5_endpoint
echo "$gpt5_endpoint" | wrangler pages secret put AZURE_OPENAI_ENDPOINT --project-name=$PROJECT_NAME
echo "✅ AZURE_OPENAI_ENDPOINT set"

# GPT-5.1 API Key
echo ""
echo "Enter your Azure OpenAI API Key (input will be hidden):"
read -s gpt5_api_key
echo "$gpt5_api_key" | wrangler pages secret put AZURE_OPENAI_API_KEY --project-name=$PROJECT_NAME
echo "✅ AZURE_OPENAI_API_KEY set"

# GPT-5.1 Model Deployment Name
echo ""
read -p "Enter your GPT-5.1 deployment name (e.g., gpt-5.1): " gpt5_model
echo "$gpt5_model" | wrangler pages secret put AZURE_OPENAI_GPT5_MODEL --project-name=$PROJECT_NAME
echo "✅ AZURE_OPENAI_GPT5_MODEL set"

echo ""
echo "📝 Setting up Azure OpenAI TTS secrets..."
echo ""

# TTS Endpoint
read -p "Enter your Azure TTS Endpoint (e.g., https://your-tts-resource.openai.azure.com): " tts_endpoint
echo "$tts_endpoint" | wrangler pages secret put AZURE_OPENAI_TTS_ENDPOINT --project-name=$PROJECT_NAME
echo "✅ AZURE_OPENAI_TTS_ENDPOINT set"

# TTS API Key
echo ""
echo "Enter your Azure TTS API Key (input will be hidden):"
read -s tts_api_key
echo "$tts_api_key" | wrangler pages secret put AZURE_OPENAI_TTS_API_KEY --project-name=$PROJECT_NAME
echo "✅ AZURE_OPENAI_TTS_API_KEY set"

# TTS Deployment Name
echo ""
read -p "Enter your TTS deployment name (e.g., gpt-audio-mini): " tts_deployment
echo "$tts_deployment" | wrangler pages secret put AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT --project-name=$PROJECT_NAME
echo "✅ AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT set"

# Vision proof signing secret
echo ""
read -sp "Enter a random vision proof signing secret (32+ chars): " vision_secret
echo ""
echo "$vision_secret" | wrangler pages secret put VISION_PROOF_SECRET --project-name=$PROJECT_NAME
echo "✅ VISION_PROOF_SECRET set"

echo ""
echo "=================================================="
echo "  ✅ All Secrets Successfully Configured!"
echo "=================================================="
echo ""
echo "🔍 Verifying secrets..."
wrangler pages secret list --project-name=$PROJECT_NAME
echo ""
echo "🚀 Next steps:"
echo "   1. Build your project: npm run build"
echo "   2. Deploy to Cloudflare: npm run deploy"
echo "   3. Test deployment with the vision proof handshake:"
echo "      # (a) Create a proof by POSTing base64 photo data"
echo "      curl -X POST https://tableau-8xz.pages.dev/api/vision-proof \"
echo "        -H 'Content-Type: application/json' \"
echo "        -d '{\"deckStyle\":\"rws-1909\",\"evidence\":[{\"label\":\"Card 1\",\"dataUrl\":\"data:image/jpeg;base64,REPLACE_ME\"}]}'"
echo "      # (b) Use the returned proof when calling /api/tarot-reading"
echo "      curl -X POST https://tableau-8xz.pages.dev/api/tarot-reading \"
echo "        -H 'Content-Type: application/json' \"
echo "        -d '{\"spreadInfo\":{\"name\":\"One-Card Insight\"},\"cardsInfo\":[{\"position\":\"Card 1\",\"card\":\"The Fool\",\"orientation\":\"upright\",\"meaning\":\"New beginnings\"}],\"userQuestion\":\"Test\",\"visionProof\":{...}}'"
echo "      See docs/VISION_PIPELINE.md for helper scripts to automate this flow."
echo ""
</file>

<file path="scripts/setup-secrets.sh">
#!/bin/bash

# Tableau - Cloudflare Workers Secrets Setup
# This script helps you configure all required secrets for production deployment
# Updated for Cloudflare Workers (migrated from Pages)

set -e

WORKER_NAME="tableau"

echo "=================================================="
echo "  Mystic Tarot - Cloudflare Workers Secrets Setup"
echo "=================================================="
echo ""
echo "This script will help you set up encrypted secrets for your"
echo "Cloudflare Worker using the Wrangler CLI."
echo ""
echo "⚠️  IMPORTANT: Make sure you have wrangler installed and authenticated:"
echo "   npm install -g wrangler"
echo "   wrangler login"
echo ""

read -p "Press Enter to continue or Ctrl+C to cancel..."

echo ""
echo "📝 Setting up Azure OpenAI GPT-5.1 (Responses API) secrets..."
echo ""

# AZURE_OPENAI_ENDPOINT
echo "1️⃣  Azure OpenAI Endpoint"
echo "   Example: https://your-resource-name.openai.azure.com"
read -p "   Enter your Azure OpenAI endpoint: " ENDPOINT
echo "$ENDPOINT" | wrangler secret put AZURE_OPENAI_ENDPOINT --name "$WORKER_NAME"
echo "   ✅ AZURE_OPENAI_ENDPOINT set"
echo ""

# AZURE_OPENAI_API_KEY
echo "2️⃣  Azure OpenAI API Key"
echo "   Get from: Azure Portal → Azure OpenAI → Keys and Endpoint"
read -sp "   Enter your Azure OpenAI API key: " API_KEY
echo ""
echo "$API_KEY" | wrangler secret put AZURE_OPENAI_API_KEY --name "$WORKER_NAME"
echo "   ✅ AZURE_OPENAI_API_KEY set"
echo ""

# AZURE_OPENAI_GPT5_MODEL
echo "3️⃣  GPT-5.1 Model Deployment Name"
echo "   Get from: Azure Portal → Azure OpenAI → Deployments"
echo "   Example: gpt-5.1, gpt-5.1-pro, etc."
read -p "   Enter your GPT-5.1 deployment name: " GPT5_MODEL
echo "$GPT5_MODEL" | wrangler secret put AZURE_OPENAI_GPT5_MODEL --name "$WORKER_NAME"
echo "   ✅ AZURE_OPENAI_GPT5_MODEL set"
echo ""

echo "📝 Setting up Azure OpenAI TTS secrets (optional)..."
echo ""
read -p "Do you want to set up TTS secrets now? (y/n): " SETUP_TTS

if [[ "$SETUP_TTS" == "y" || "$SETUP_TTS" == "Y" ]]; then
    # AZURE_OPENAI_TTS_ENDPOINT
    echo "4️⃣  Azure OpenAI TTS Endpoint"
    echo "   (Can be the same as GPT-5.1 endpoint if using same resource)"
    read -p "   Enter your TTS endpoint: " TTS_ENDPOINT
    echo "$TTS_ENDPOINT" | wrangler secret put AZURE_OPENAI_TTS_ENDPOINT --name "$WORKER_NAME"
    echo "   ✅ AZURE_OPENAI_TTS_ENDPOINT set"
    echo ""

    # AZURE_OPENAI_TTS_API_KEY
    echo "5️⃣  Azure OpenAI TTS API Key"
    echo "   (Can be the same as GPT-5.1 API key if using same resource)"
    read -sp "   Enter your TTS API key: " TTS_API_KEY
    echo ""
    echo "$TTS_API_KEY" | wrangler secret put AZURE_OPENAI_TTS_API_KEY --name "$WORKER_NAME"
    echo "   ✅ AZURE_OPENAI_TTS_API_KEY set"
    echo ""

    # AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT
    echo "6️⃣  TTS Deployment Name"
    echo "   Example: tts, tts-1-hd, gpt-4o-mini-tts, etc."
    read -p "   Enter your TTS deployment name: " TTS_DEPLOYMENT
    echo "$TTS_DEPLOYMENT" | wrangler secret put AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT --name "$WORKER_NAME"
    echo "   ✅ AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT set"
    echo ""
else
    echo "   ⏭️  Skipping TTS setup"
    echo ""
fi

echo "=================================================="
echo "  ✅ Secrets Setup Complete!"
echo "=================================================="
echo ""
echo "🔍 To verify your secrets were set correctly, run:"
echo "   wrangler secret list --name $WORKER_NAME"
echo ""
echo "📝 Note: Secret values are encrypted and cannot be viewed after"
echo "         setting them. You can only see the secret names."
echo ""
echo "🚀 Next steps:"
echo "   1. Build your project: npm run build"
echo "   2. Deploy to Cloudflare: npm run deploy"
echo "      (or: wrangler deploy --config wrangler.jsonc)"
echo "   3. Test your deployment with the vision proof handshake:"
echo "      # (a) Create a proof by POSTing base64 photo data"
echo "      curl -X POST https://tableau.YOUR_SUBDOMAIN.workers.dev/api/vision-proof \"
echo "        -H 'Content-Type: application/json' \"
echo "        -d '{\"deckStyle\":\"rws-1909\",\"evidence\":[{\"label\":\"Card 1\",\"dataUrl\":\"data:image/jpeg;base64,REPLACE_ME\"}]}'"
echo "      # (b) Use the returned proof object when calling /api/tarot-reading"
echo "      curl -X POST https://tableau.YOUR_SUBDOMAIN.workers.dev/api/tarot-reading \"
echo "        -H 'Content-Type: application/json' \"
echo "        -d '{\"spreadInfo\":{\"name\":\"One-Card Insight\"},\"cardsInfo\":[{\"position\":\"Card 1\",\"card\":\"The Fool\",\"orientation\":\"upright\",\"meaning\":\"New beginnings\"}],\"userQuestion\":\"Test\",\"visionProof\":{...}}'"
echo "      See docs/VISION_PIPELINE.md for helper scripts to automate this flow."
echo ""
</file>

<file path="scripts/test-azure-responses.mjs">
#!/usr/bin/env node
/**
 * Test Azure OpenAI Responses API integration
 * Run: AZURE_OPENAI_ENDPOINT=xxx AZURE_OPENAI_API_KEY=xxx AZURE_OPENAI_GPT5_MODEL=xxx node scripts/test-azure-responses.mjs
 */

const endpoint = process.env.AZURE_OPENAI_ENDPOINT?.replace(/\/+$/, '');
const apiKey = process.env.AZURE_OPENAI_API_KEY;
const model = process.env.AZURE_OPENAI_GPT5_MODEL;
const apiVersion = process.env.AZURE_OPENAI_RESPONSES_API_VERSION || process.env.AZURE_OPENAI_API_VERSION || 'v1';

console.log('🔍 Testing Azure OpenAI Responses API\n');
console.log('Configuration:');
console.log('- Endpoint:', endpoint ? '✓ Set' : '✗ Missing');
console.log('- API Key:', apiKey ? '✓ Set' : '✗ Missing');
console.log('- Model:', model || '✗ Missing');
console.log('- API Version:', apiVersion);

if (!endpoint || !apiKey || !model) {
  console.error('\n❌ Missing required environment variables');
  console.error('Required: AZURE_OPENAI_ENDPOINT, AZURE_OPENAI_API_KEY, AZURE_OPENAI_GPT5_MODEL');
  process.exit(1);
}

const url = `${endpoint}/openai/v1/responses?api-version=${encodeURIComponent(apiVersion)}`;
console.log('\nRequest URL:', url);

const body = {
  model,
  instructions: 'You are a tarot intention coach. Write ONE open, agency-forward question.',
  input: 'Focus: my career\nTimeframe: this week\nDepth: Focused guidance',
  max_output_tokens: 120,
  reasoning: { effort: 'low' },
  text: { verbosity: 'low' }
};

console.log('\nRequest body:', JSON.stringify(body, null, 2));
console.log('\n📡 Sending request...\n');

try {
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'api-key': apiKey,
      'content-type': 'application/json'
    },
    body: JSON.stringify(body)
  });

  console.log('Response status:', response.status, response.statusText);
  console.log('Response headers:', Object.fromEntries(response.headers.entries()));

  const responseText = await response.text();

  if (!response.ok) {
    console.error('\n❌ Request failed');
    console.error('Status:', response.status);
    console.error('Response:', responseText);
    process.exit(1);
  }

  const data = JSON.parse(responseText);
  console.log('\n✅ Success! Response data:');
  console.log(JSON.stringify(data, null, 2));

  // Try to extract the question
  let question = null;
  if (data.output && Array.isArray(data.output)) {
    for (const block of data.output) {
      if (block.type === 'message') {
        const messagePieces = Array.isArray(block.content) ? block.content : [];
        for (const piece of messagePieces) {
          if (piece.type === 'output_text' && piece.text) {
            question = piece.text.trim();
            break;
          }
        }
      }
      if (question) break;
    }
  }

  if (typeof data.output_text === 'string' && data.output_text.trim()) {
    question = data.output_text.trim();
  }

  if (question) {
    console.log('\n📝 Generated question:', question);
  } else {
    console.warn('\n⚠️  Could not extract question from response');
  }

} catch (error) {
  console.error('\n❌ Error:', error.message);
  console.error(error.stack);
  process.exit(1);
}
</file>

<file path="scripts/test-azure-tts-simple.sh">
#!/bin/bash

# Simple Azure OpenAI TTS Test Script
# Based on Microsoft official documentation
# https://learn.microsoft.com/en-us/azure/ai-foundry/openai/text-to-speech-quickstart

echo "🎙️  Azure OpenAI TTS Simple Test"
echo "================================"
echo ""

# Load environment variables from .env.local if it exists
if [ -f ".env.local" ]; then
    echo "📋 Loading environment variables from .env.local..."
    export $(grep -v '^#' .env.local | xargs)
    echo ""
fi

# Check required variables
if [ -z "$AZURE_OPENAI_ENDPOINT" ]; then
    echo "❌ AZURE_OPENAI_ENDPOINT is not set"
    echo "   Please edit .env.local and add your endpoint"
    exit 1
fi

if [ -z "$AZURE_OPENAI_API_KEY" ]; then
    echo "❌ AZURE_OPENAI_API_KEY is not set"
    echo "   Please edit .env.local and add your API key"
    exit 1
fi

if [ -z "$AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT" ]; then
    echo "❌ AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT is not set"
    echo "   Please edit .env.local and add your deployment name"
    exit 1
fi

DEPLOYMENT_NAME="$AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT"
API_VERSION="${AZURE_OPENAI_API_VERSION:-2025-04-01-preview}"

echo "✅ Configuration:"
echo "   Endpoint: $AZURE_OPENAI_ENDPOINT"
echo "   Deployment: $DEPLOYMENT_NAME"
echo "   API Version: $API_VERSION"
echo ""

# Build the URL
URL="${AZURE_OPENAI_ENDPOINT}/openai/deployments/${DEPLOYMENT_NAME}/audio/speech?api-version=${API_VERSION}"

echo "📡 Testing TTS with a simple request..."
echo "   URL: $URL"
echo ""

# Make the request (based on Microsoft docs)
HTTP_CODE=$(curl -w "%{http_code}" -o speech-test.mp3 "$URL" \
  -H "api-key: $AZURE_OPENAI_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "model": "'"$DEPLOYMENT_NAME"'",
    "input": "Testing Azure OpenAI text to speech. The Fool begins a journey.",
    "voice": "nova"
  }' 2>/dev/null)

echo ""

if [ "$HTTP_CODE" = "200" ]; then
    FILE_SIZE=$(stat -f%z speech-test.mp3 2>/dev/null || stat -c%s speech-test.mp3 2>/dev/null)
    echo "✅ SUCCESS! TTS is working"
    echo "   HTTP Status: $HTTP_CODE"
    echo "   Audio file: speech-test.mp3"
    echo "   Size: $(echo "scale=2; $FILE_SIZE / 1024" | bc) KB"
    echo ""
    echo "🎵 Play the file to hear the audio:"
    echo "   mpg123 speech-test.mp3"
    echo "   or open speech-test.mp3 in your media player"
    echo ""
    echo "🎉 Your Azure OpenAI TTS integration is working correctly!"
elif [ "$HTTP_CODE" = "401" ]; then
    echo "❌ Authentication failed (401)"
    echo "   Check your AZURE_OPENAI_API_KEY"
    cat speech-test.mp3
    rm -f speech-test.mp3
    exit 1
elif [ "$HTTP_CODE" = "404" ]; then
    echo "❌ Deployment not found (404)"
    echo "   Check your endpoint and deployment name"
    echo "   Endpoint: $AZURE_OPENAI_ENDPOINT"
    echo "   Deployment: $DEPLOYMENT_NAME"
    cat speech-test.mp3
    rm -f speech-test.mp3
    exit 1
else
    echo "❌ Request failed with HTTP $HTTP_CODE"
    echo "   Response:"
    cat speech-test.mp3
    rm -f speech-test.mp3
    exit 1
fi
</file>

<file path="scripts/test-azure-tts.mjs">
#!/usr/bin/env node
/**
 * Azure OpenAI TTS Diagnostic Script
 * Tests connection and configuration for the tarot app TTS endpoint.
 */

import { resolve, dirname } from 'path';
import { fileURLToPath } from 'url';
import { readFileSync } from 'fs';

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = resolve(__dirname, '..');

// Load environment variables manually
function loadEnv(filePath) {
  try {
    const content = readFileSync(filePath, 'utf-8');
    const lines = content.split('\n');

    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || trimmed.startsWith('#')) continue;

      const match = trimmed.match(/^([^=]+)=(.*)$/);
      if (match) {
        const key = match[1].trim();
        const value = match[2].trim();
        if (!process.env[key]) {
          process.env[key] = value;
        }
      }
    }
  } catch (error) {
    console.error(`Warning: Could not load ${filePath}:`, error.message);
  }
}

loadEnv(resolve(rootDir, '.env.local'));

const COLORS = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  bold: '\x1b[1m'
};

function log(message, color = 'reset') {
  console.log(`${COLORS[color]}${message}${COLORS.reset}`);
}

function header(message) {
  log(`\n${'='.repeat(60)}`, 'cyan');
  log(message, 'bold');
  log('='.repeat(60), 'cyan');
}

function checkmark() {
  return `${COLORS.green}✓${COLORS.reset}`;
}

function xmark() {
  return `${COLORS.red}✗${COLORS.reset}`;
}

// Configuration from environment
const config_values = {
  endpoint: process.env.AZURE_OPENAI_ENDPOINT,
  apiKey: process.env.AZURE_OPENAI_API_KEY,
  deployment: process.env.AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT,
  apiVersion: process.env.AZURE_OPENAI_API_VERSION || '2025-04-01-preview',
  format: process.env.AZURE_OPENAI_GPT_AUDIO_MINI_FORMAT || 'mp3'
};

header('Azure OpenAI TTS Configuration Diagnostics');

// Step 1: Check environment variables
log('\n📋 Step 1: Environment Variables', 'cyan');

const checks = [
  {
    name: 'AZURE_OPENAI_ENDPOINT',
    value: config_values.endpoint,
    validator: (val) => {
      if (!val) return { valid: false, message: 'Not set' };
      if (val.includes('cognitiveservices.azure.com')) {
        return {
          valid: false,
          message: 'Using legacy endpoint! Should be *.openai.azure.com',
          fix: val.replace('cognitiveservices.azure.com', 'openai.azure.com')
        };
      }
      if (!val.includes('openai.azure.com')) {
        return { valid: false, message: 'Should match pattern: https://*.openai.azure.com' };
      }
      if (val.endsWith('/')) {
        return {
          valid: true,
          warning: 'Ends with trailing slash (will be stripped by code)'
        };
      }
      return { valid: true, message: 'Format looks correct' };
    }
  },
  {
    name: 'AZURE_OPENAI_API_KEY',
    value: config_values.apiKey,
    validator: (val) => {
      if (!val) return { valid: false, message: 'Not set' };
      if (val.length < 32) return { valid: false, message: 'Key seems too short' };
      return { valid: true, message: `Set (length: ${val.length})` };
    }
  },
  {
    name: 'AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT',
    value: config_values.deployment,
    validator: (val) => {
      if (!val) return { valid: false, message: 'Not set' };
      return { valid: true, message: `Set to: "${val}"` };
    }
  },
  {
    name: 'AZURE_OPENAI_API_VERSION',
    value: config_values.apiVersion,
    validator: (val) => {
      const validVersions = ['2024-06-01', '2024-08-01-preview', '2024-10-01-preview', '2025-04-01-preview'];
      if (!val) return { valid: false, message: 'Not set (will default to 2024-06-01)' };
      if (!validVersions.includes(val)) {
        return { valid: true, warning: `Non-standard version: ${val}` };
      }
      return { valid: true, message: `Valid version: ${val}` };
    }
  }
];

let configValid = true;
const fixes = {};

for (const check of checks) {
  const result = check.validator(check.value);
  const status = result.valid ? checkmark() : xmark();

  console.log(`  ${status} ${check.name}`);

  if (result.message) {
    log(`     ${result.message}`, result.valid ? 'green' : 'red');
  }

  if (result.warning) {
    log(`     ⚠ ${result.warning}`, 'yellow');
  }

  if (result.fix) {
    log(`     💡 Suggested fix: ${result.fix}`, 'cyan');
    fixes[check.name] = result.fix;
  }

  if (!result.valid) {
    configValid = false;
  }
}

if (!configValid) {
  log('\n❌ Configuration issues detected. Cannot proceed with API test.', 'red');

  if (Object.keys(fixes).length > 0) {
    log('\n🔧 Suggested fixes for .env.local:', 'yellow');
    for (const [key, fix] of Object.entries(fixes)) {
      log(`   ${key}=${fix}`, 'cyan');
    }
  }

  log('\n📖 Configuration guide:', 'cyan');
  log('   1. Go to Azure Portal: https://portal.azure.com', 'reset');
  log('   2. Navigate to: Azure OpenAI → Your Resource', 'reset');
  log('   3. Keys & Endpoint: Copy endpoint (should be *.openai.azure.com)', 'reset');
  log('   4. Deployments: Verify your deployment name exists', 'reset');

  process.exit(1);
}

log('\n✅ All configuration checks passed!', 'green');

// Step 2: Test API connectivity
header('Step 2: Testing Azure OpenAI TTS API Connection');

const endpoint = config_values.endpoint.replace(/\/+$/, '');
const url = `${endpoint}/openai/deployments/${config_values.deployment}/audio/speech?api-version=${config_values.apiVersion}`;

log(`\n🔗 Endpoint: ${url}`, 'cyan');
log(`🎤 Voice: nova`, 'cyan');
log(`⚙️  Format: ${config_values.format}`, 'cyan');

const testPayload = {
  model: config_values.deployment,
  voice: 'nova',
  input: 'This is a test of the Azure OpenAI text-to-speech service.',
  response_format: config_values.format,
  speed: 0.95
};

// Add steerable instructions if this looks like gpt-4o-mini-tts
if (config_values.deployment.toLowerCase().includes('gpt-4o') ||
    config_values.deployment.toLowerCase().includes('mini-tts')) {
  log(`🎯 Detected steerable model - adding instructions`, 'cyan');
  testPayload.instructions = 'Speak clearly and naturally, as if testing a microphone.';
}

log('\n📤 Sending test request...', 'yellow');

try {
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'api-key': config_values.apiKey,
      'content-type': 'application/json'
    },
    body: JSON.stringify(testPayload)
  });

  log(`\n📥 Response status: ${response.status} ${response.statusText}`,
      response.ok ? 'green' : 'red');

  if (response.ok) {
    const arrayBuffer = await response.arrayBuffer();
    const sizeKB = (arrayBuffer.byteLength / 1024).toFixed(2);

    log(`\n${checkmark()} Success! Audio generated successfully`, 'green');
    log(`   Size: ${sizeKB} KB`, 'green');
    log(`   Format: ${config_values.format}`, 'green');

    log('\n✅ Your Azure OpenAI TTS configuration is working correctly!', 'bold');
    log('\n💡 Next steps:', 'cyan');
    log('   1. If running locally: Restart your dev server (npm run dev)', 'reset');
    log('   2. If deployed: Add these env vars to Cloudflare Pages settings', 'reset');
    log('      → Settings → Environment variables → Production', 'reset');

  } else {
    const errorText = await response.text();
    log(`\n${xmark()} Request failed`, 'red');
    log('\n📄 Error details:', 'yellow');

    try {
      const errorJson = JSON.parse(errorText);
      console.log(JSON.stringify(errorJson, null, 2));

      // Provide specific guidance based on error
      if (errorJson.error?.code === 'DeploymentNotFound') {
        log('\n🔍 Deployment not found. Common issues:', 'yellow');
        log('   • Deployment name must match EXACTLY what you created in Azure', 'reset');
        log('   • Check: Azure Portal → Azure OpenAI → Deployments', 'reset');
        log(`   • Current value: "${config_values.deployment}"`, 'cyan');
      } else if (errorJson.error?.code === 'PermissionDenied' || response.status === 401) {
        log('\n🔑 Authentication failed. Check:', 'yellow');
        log('   • API key is correct and not expired', 'reset');
        log('   • Key matches the resource where deployment exists', 'reset');
      } else if (response.status === 404) {
        log('\n🔍 Endpoint not found. Check:', 'yellow');
        log('   • Endpoint URL format: https://YOUR-RESOURCE.openai.azure.com', 'reset');
        log('   • API version is valid for your region', 'reset');
        log(`   • Current endpoint: ${config_values.endpoint}`, 'cyan');
      }

    } catch {
      log(errorText, 'red');
    }

    process.exit(1);
  }

} catch (error) {
  log(`\n${xmark()} Connection error`, 'red');
  log(`   ${error.message}`, 'red');

  if (error.message.includes('fetch failed') || error.message.includes('ENOTFOUND')) {
    log('\n🌐 Network/DNS issue. Check:', 'yellow');
    log('   • Internet connectivity', 'reset');
    log('   • Endpoint URL is correct', 'reset');
    log('   • No firewall blocking Azure endpoints', 'reset');
  }

  process.exit(1);
}

header('Diagnostic Complete');
</file>

<file path="scripts/test-azure-wrapper.sh">
#!/bin/bash
# Wrapper to test Azure OpenAI Responses API with wrangler secrets

echo "🔐 Fetching Azure configuration from Cloudflare secrets..."

# Get secrets (they're encrypted, so we'll use wrangler to test via a deployed function instead)
echo ""
echo "⚠️  Cannot read encrypted secrets locally."
echo "Instead, let's test via the deployed endpoint with extra logging."
echo ""
echo "Deploying a test version with verbose logging..."
</file>

<file path="scripts/test-graphrag-demo.mjs">
// scripts/test-graphrag-demo.mjs
// Demonstration and automated test of GraphRAG system with real spread examples
// Run with: node scripts/test-graphrag-demo.mjs
//
// This script serves dual purposes:
// 1. Visual demonstration of GraphRAG capabilities for humans
// 2. Automated assertions for CI (exits non-zero on failure)

import assert from 'node:assert/strict';
import { buildGraphContext } from '../functions/lib/graphContext.js';
import { retrievePassages, formatPassagesForPrompt, buildRetrievalSummary } from '../functions/lib/graphRAG.js';

let testsPassed = 0;
let testsFailed = 0;

function assertOk(condition, message) {
  try {
    assert.ok(condition, message);
    testsPassed++;
  } catch (err) {
    testsFailed++;
    console.error(`❌ ASSERTION FAILED: ${message}`);
    console.error(`   ${err.message}`);
  }
}

function assertEqual(actual, expected, message) {
  try {
    assert.strictEqual(actual, expected, message);
    testsPassed++;
  } catch (err) {
    testsFailed++;
    console.error(`❌ ASSERTION FAILED: ${message}`);
    console.error(`   Expected: ${expected}, Got: ${actual}`);
  }
}

console.log('🔮 GraphRAG System Demonstration & Test\n');
console.log('='.repeat(80));
console.log();

// Example 1: Death-Temperance-Star (The Healing Arc)
console.log('📖 Example 1: The Healing Arc (Death → Temperance → Star)\n');
console.log('-'.repeat(80));

const healingArcCards = [
  { name: 'Death', number: 13, orientation: 'upright' },
  { name: 'Temperance', number: 14, orientation: 'upright' },
  { name: 'The Star', number: 17, orientation: 'upright' }
];

const healingContext = buildGraphContext(healingArcCards, { deckStyle: 'rws-1909' });

assertOk(healingContext, 'Healing Arc: Should build graph context');
assertOk(healingContext?.patterns, 'Healing Arc: Should have patterns');
assertOk(healingContext?.graphKeys, 'Healing Arc: Should have graphKeys');

if (healingContext) {
  console.log('✅ Graph Context Built:');
  console.log(`   - Fool's Journey Stage: ${healingContext.graphKeys.foolsJourneyStageKey}`);
  console.log(`   - Complete Triads: ${healingContext.graphKeys.completeTriadIds.join(', ')}`);
  console.log(`   - High Dyads: ${healingContext.graphKeys.dyadPairs.length}`);
  console.log();

  assertEqual(healingContext.graphKeys.foolsJourneyStageKey, 'integration',
    'Healing Arc: Journey stage should be integration');
  assertOk(healingContext.graphKeys.completeTriadIds.includes('death-temperance-star'),
    'Healing Arc: Should detect death-temperance-star triad');

  const passages = retrievePassages(healingContext.graphKeys, { maxPassages: 3 });

  assertOk(passages.length > 0, 'Healing Arc: Should retrieve passages');
  assertOk(passages.length <= 3, 'Healing Arc: Should respect maxPassages limit');
  assertEqual(passages[0].type, 'triad', 'Healing Arc: First passage should be triad (priority 1)');
  assertEqual(passages[0].title, 'The Healing Arc', 'Healing Arc: Triad title should match');

  console.log(`📚 Retrieved ${passages.length} Passages:\n`);
  passages.forEach((p, i) => {
    console.log(`   ${i + 1}. [Priority ${p.priority}] ${p.type}: ${p.title || p.theme}`);
    console.log(`      "${p.text.substring(0, 120)}..."`);
    console.log(`      — ${p.source}`);
    console.log();
  });

  const formatted = formatPassagesForPrompt(passages);
  assertOk(formatted.length > 0, 'Healing Arc: Should produce formatted output');
  assertOk(formatted.includes('Retrieved Wisdom'), 'Healing Arc: Should include header');
  assertOk(formatted.includes('Healing Arc'), 'Healing Arc: Should include triad title');

  console.log('📝 Formatted for LLM Prompt:\n');
  console.log(formatted);
  console.log();

  const summary = buildRetrievalSummary(healingContext.graphKeys, passages);
  assertEqual(summary.patternsDetected.completeTriads, 1,
    'Healing Arc: Summary should show 1 complete triad');
  assertOk(summary.passagesRetrieved >= 1,
    'Healing Arc: Summary should show passages retrieved');

  console.log('📊 Retrieval Summary:');
  console.log(JSON.stringify(summary, null, 2));
}

console.log();
console.log('='.repeat(80));
console.log();

// Example 2: Devil-Tower-Sun (Liberation Arc)
console.log('📖 Example 2: The Liberation Arc (Devil → Tower → Sun)\n');
console.log('-'.repeat(80));

const liberationCards = [
  { name: 'The Devil', number: 15, orientation: 'upright' },
  { name: 'The Tower', number: 16, orientation: 'upright' },
  { name: 'The Sun', number: 19, orientation: 'upright' }
];

const liberationContext = buildGraphContext(liberationCards, { deckStyle: 'rws-1909' });

assertOk(liberationContext, 'Liberation Arc: Should build graph context');

if (liberationContext) {
  console.log('✅ Graph Context Built:');
  console.log(`   - Fool's Journey Stage: ${liberationContext.graphKeys.foolsJourneyStageKey}`);
  console.log(`   - Complete Triads: ${liberationContext.graphKeys.completeTriadIds.join(', ')}`);
  console.log();

  assertEqual(liberationContext.graphKeys.foolsJourneyStageKey, 'culmination',
    'Liberation Arc: Journey stage should be culmination');
  assertOk(liberationContext.graphKeys.completeTriadIds.includes('devil-tower-sun'),
    'Liberation Arc: Should detect devil-tower-sun triad');

  const passages = retrievePassages(liberationContext.graphKeys, { maxPassages: 2 });

  assertOk(passages.length > 0, 'Liberation Arc: Should retrieve passages');
  assertEqual(passages[0].type, 'triad', 'Liberation Arc: First passage should be triad');

  console.log(`📚 Retrieved ${passages.length} Passages:\n`);
  passages.forEach((p, i) => {
    console.log(`   ${i + 1}. ${p.title}`);
    console.log(`      Theme: ${p.theme}`);
    console.log(`      "${p.text.substring(0, 150)}..."`);
    console.log();
  });
}

console.log('='.repeat(80));
console.log();

// Example 3: Mixed Major spread (no complete triad, but Journey + Dyads)
console.log('📖 Example 3: Mixed Major Spread (Journey + Dyads)\n');
console.log('-'.repeat(80));

const mixedCards = [
  { name: 'The Hermit', number: 9, orientation: 'upright' },
  { name: 'The Hanged Man', number: 12, orientation: 'upright' },
  { name: 'Death', number: 13, orientation: 'upright' },
  { name: 'The Star', number: 17, orientation: 'upright' }
];

const mixedContext = buildGraphContext(mixedCards, { deckStyle: 'rws-1909' });

assertOk(mixedContext, 'Mixed Spread: Should build graph context');

if (mixedContext) {
  console.log('✅ Graph Context Built:');
  console.log(`   - Fool's Journey Stage: ${mixedContext.graphKeys.foolsJourneyStageKey}`);
  console.log(`   - Partial Triads: ${mixedContext.graphKeys.triadIds.filter(id => !mixedContext.graphKeys.completeTriadIds.includes(id)).join(', ') || 'none'}`);
  console.log(`   - High Dyads Detected: ${mixedContext.graphKeys.dyadPairs.length}`);
  console.log();

  assertOk(mixedContext.graphKeys.foolsJourneyStageKey,
    'Mixed Spread: Should detect journey stage');

  const passages = retrievePassages(mixedContext.graphKeys, { maxPassages: 4 });

  assertOk(passages.length >= 1, 'Mixed Spread: Should retrieve at least one passage');

  console.log(`📚 Retrieved ${passages.length} Passages (Journey + Dyads):\n`);
  passages.forEach((p, i) => {
    const typeLabel = p.type === 'fools-journey' ? '🎭 Journey' : '🔗 Dyad';
    console.log(`   ${i + 1}. ${typeLabel} [Priority ${p.priority}]`);
    console.log(`      ${p.title || p.theme}`);
    if (p.cardNames) {
      console.log(`      Cards: ${p.cardNames.join(' + ')}`);
    }
    console.log();
  });

  // Verify priority ordering (journey P2 should come before dyad P3)
  const journeyIdx = passages.findIndex(p => p.type === 'fools-journey');
  const dyadIdx = passages.findIndex(p => p.type === 'dyad');
  if (journeyIdx !== -1 && dyadIdx !== -1) {
    assertOk(journeyIdx < dyadIdx, 'Mixed Spread: Journey should precede dyads in ordering');
  }
}

console.log('='.repeat(80));
console.log();

// Example 4: Minor Arcana Suit Progression
console.log('📖 Example 4: Minor Arcana Suit Progression (Wands Beginning)\n');
console.log('-'.repeat(80));

const wandsCards = [
  { name: 'Ace of Wands', suit: 'Wands', rank: 'Ace', rankValue: 1, orientation: 'upright' },
  { name: 'Two of Wands', suit: 'Wands', rank: 'Two', rankValue: 2, orientation: 'upright' },
  { name: 'Three of Wands', suit: 'Wands', rank: 'Three', rankValue: 3, orientation: 'upright' }
];

const wandsContext = buildGraphContext(wandsCards, { deckStyle: 'rws-1909' });

assertOk(wandsContext, 'Wands Spread: Should build graph context');

if (wandsContext) {
  console.log('✅ Graph Context Built:');
  console.log(`   - Suit Progressions: ${wandsContext.graphKeys.suitProgressions.length}`);
  console.log();

  assertOk(wandsContext.graphKeys.suitProgressions.length > 0,
    'Wands Spread: Should detect suit progression');

  const passages = retrievePassages(wandsContext.graphKeys, { maxPassages: 2 });

  if (passages.length > 0) {
    console.log(`📚 Retrieved ${passages.length} Passage(s) for Suit Progression:\n`);
    passages.forEach((p, i) => {
      console.log(`   ${i + 1}. ${p.title}`);
      console.log(`      Suit: ${p.suit}, Stage: ${p.stage}`);
      console.log(`      "${p.text.substring(0, 120)}..."`);
      console.log();
    });

    // Verify suit progression passage has correct metadata
    const suitPassage = passages.find(p => p.type === 'suit-progression');
    if (suitPassage) {
      assertEqual(suitPassage.suit, 'Wands', 'Wands Spread: Passage should be for Wands');
      assertEqual(suitPassage.stage, 'beginning', 'Wands Spread: Stage should be beginning');
    }
  } else {
    console.log('   ℹ️  No passages retrieved (suit progression may not be strong enough)\n');
  }
}

console.log('='.repeat(80));
console.log();

// Example 5: Edge case - Empty/null cards
console.log('📖 Example 5: Edge Cases\n');
console.log('-'.repeat(80));

const nullContext = buildGraphContext(null, { deckStyle: 'rws-1909' });
const emptyContext = buildGraphContext([], { deckStyle: 'rws-1909' });

assertEqual(nullContext, null, 'Edge Case: null cards should return null context');
assertEqual(emptyContext, null, 'Edge Case: empty cards should return null context');

console.log('✅ Edge cases handled correctly:');
console.log('   - null cards → null context');
console.log('   - empty array → null context');
console.log();

// Verify retrievePassages handles edge cases
const nullPassages = retrievePassages(null, { maxPassages: 3 });
const emptyPassages = retrievePassages({}, { maxPassages: 3 });

assertEqual(nullPassages.length, 0, 'Edge Case: null graphKeys should return empty passages');
assertEqual(emptyPassages.length, 0, 'Edge Case: empty graphKeys should return empty passages');

console.log('   - null graphKeys → empty passages');
console.log('   - empty graphKeys → empty passages');
console.log();

console.log('='.repeat(80));
console.log();

// Summary
console.log('✨ GraphRAG System Summary\n');
console.log('   ✅ Knowledge base loaded with curated passages');
console.log('   ✅ Retrieval prioritizes: Triads > Journey > Dyads > Suit Progressions');
console.log('   ✅ Passages formatted for LLM prompt injection');
console.log('   ✅ Zero infrastructure dependencies (in-memory retrieval)');
console.log('   ✅ Edge cases handled gracefully');
console.log();

// Test Results
console.log('='.repeat(80));
console.log();
console.log(`📊 Test Results: ${testsPassed} passed, ${testsFailed} failed`);
console.log();

if (testsFailed > 0) {
  console.log('❌ Some tests failed. See errors above.');
  process.exit(1);
} else {
  console.log('✅ All tests passed!');
  process.exit(0);
}
</file>

<file path="scripts/viewPrompts.js">
#!/usr/bin/env node
/**
 * View Prompts and Readings from METRICS_DB
 * 
 * This script retrieves prompt engineering data stored in Cloudflare KV,
 * allowing you to analyze prompts, readings, and their correlations.
 * 
 * Usage:
 *   node scripts/viewPrompts.js                  # List recent readings
 *   node scripts/viewPrompts.js --id <requestId> # View specific reading
 *   node scripts/viewPrompts.js --export         # Export all to JSONL
 *   node scripts/viewPrompts.js --stats          # Show aggregated statistics
 */

import { spawn } from 'child_process';
import fs from 'fs/promises';
import path from 'path';

const DEFAULT_EXPORT_PATH = 'data/prompt-engineering-export.jsonl';

function parseArgs(args) {
  const options = {
    id: null,
    export: false,
    stats: false,
    limit: 20,
    local: false,
    verbose: false,
    output: DEFAULT_EXPORT_PATH
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--id' && args[i + 1]) {
      options.id = args[++i];
    } else if (arg === '--export') {
      options.export = true;
    } else if (arg === '--stats') {
      options.stats = true;
    } else if (arg === '--limit' && args[i + 1]) {
      options.limit = parseInt(args[++i], 10);
    } else if (arg === '--local') {
      options.local = true;
    } else if (arg === '--out' && args[i + 1]) {
      options.output = args[++i];
    } else if (arg === '--verbose' || arg === '-v') {
      options.verbose = true;
    } else if (arg === '--help' || arg === '-h') {
      printUsage();
      process.exit(0);
    }
  }

  return options;
}

function printUsage() {
  console.log(`
Usage: node scripts/viewPrompts.js [options]

Options:
  --id <requestId>    View a specific reading by request ID
  --export            Export all readings to JSONL file
  --stats             Show aggregated statistics
  --limit <n>         Limit number of results (default: 20)
  --local             Use local KV (for development)
  --out <file>        Output file for export (default: ${DEFAULT_EXPORT_PATH})
  --verbose, -v       Show detailed output
  --help, -h          Show this help message

Examples:
  node scripts/viewPrompts.js                     # List recent readings
  node scripts/viewPrompts.js --id abc123         # View specific reading
  node scripts/viewPrompts.js --stats             # Show statistics
  node scripts/viewPrompts.js --export --out prompts.jsonl
`);
}

/**
 * Strip comments from JSONC while preserving strings containing "//".
 * Processes character-by-character to avoid corrupting URLs.
 */
function stripJsonComments(content) {
  let stripped = '';
  let inString = false;
  let escapeNext = false;

  for (let i = 0; i < content.length; i++) {
    const char = content[i];
    const next = content[i + 1];

    if (escapeNext) {
      stripped += char;
      escapeNext = false;
      continue;
    }

    if (char === '\\' && inString) {
      stripped += char;
      escapeNext = true;
      continue;
    }

    if (char === '"' && !escapeNext) {
      inString = !inString;
      stripped += char;
      continue;
    }

    if (!inString) {
      // Single-line comment
      if (char === '/' && next === '/') {
        while (i < content.length && content[i] !== '\n') {
          i++;
        }
        if (content[i] === '\n') {
          stripped += '\n';
        }
        continue;
      }
      // Multi-line comment
      if (char === '/' && next === '*') {
        i += 2;
        while (i < content.length && !(content[i] === '*' && content[i + 1] === '/')) {
          i++;
        }
        i++;
        continue;
      }
    }

    stripped += char;
  }

  return stripped;
}

async function loadWranglerConfig() {
  try {
    const configPath = path.resolve(process.cwd(), 'wrangler.jsonc');
    const content = await fs.readFile(configPath, 'utf-8');
    const cleaned = stripJsonComments(content);
    return JSON.parse(cleaned);
  } catch (err) {
    console.warn('Could not load wrangler.jsonc:', err.message);
    return null;
  }
}

function getMetricsNamespaceId(config) {
  if (!config?.kv_namespaces) return null;
  const metrics = config.kv_namespaces.find(ns => ns.binding === 'METRICS_DB');
  return metrics?.id || null;
}

async function runWrangler(args) {
  return new Promise((resolve, reject) => {
    const proc = spawn('npx', ['wrangler', ...args], {
      stdio: ['pipe', 'pipe', 'pipe']
    });

    let stdout = '';
    let stderr = '';

    proc.stdout.on('data', (data) => { stdout += data.toString(); });
    proc.stderr.on('data', (data) => { stderr += data.toString(); });

    proc.on('close', (code) => {
      if (code !== 0) {
        reject(new Error(`Wrangler exited with code ${code}: ${stderr}`));
      } else {
        resolve(stdout);
      }
    });
  });
}

async function listKeys(namespaceId, options) {
  const args = [
    'kv', 'key', 'list',
    '--namespace-id', namespaceId,
    '--prefix', 'reading:'
  ];
  
  // Only add --local flag when explicitly requested
  // Remote access is the default behavior for wrangler kv commands
  if (options.local) {
    args.push('--local');
  }

  const output = await runWrangler(args);
  return JSON.parse(output);
}

async function getKey(namespaceId, key, options) {
  const args = [
    'kv', 'key', 'get',
    key,
    '--namespace-id', namespaceId
  ];

  // Only add --local flag when explicitly requested
  // Remote access is the default behavior for wrangler kv commands
  if (options.local) {
    args.push('--local');
  }

  const output = await runWrangler(args);
  return JSON.parse(output);
}

function formatBytes(bytes) {
  if (bytes < 1024) return `${bytes} B`;
  if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
  return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
}

function _formatDuration(ms) {
  if (ms < 1000) return `${ms}ms`;
  return `${(ms / 1000).toFixed(2)}s`;
}

async function showSingleReading(record, options) {
  console.log('\n' + '='.repeat(80));
  console.log(`REQUEST: ${record.requestId}`);
  console.log('='.repeat(80));
  
  console.log(`\nTimestamp:  ${record.timestamp}`);
  console.log(`Provider:   ${record.provider}`);
  console.log(`Spread:     ${record.spreadKey}`);
  console.log(`Deck:       ${record.deckStyle}`);
  console.log(`Context:    ${record.context}`);

  if (record.narrative) {
    console.log('\n--- NARRATIVE METRICS ---');
    console.log(`Card Coverage:      ${(record.narrative.cardCoverage * 100).toFixed(1)}%`);
    console.log(`Missing Cards:      ${record.narrative.missingCards?.join(', ') || 'None'}`);
    console.log(`Hallucinated Cards: ${record.narrative.hallucinatedCards?.join(', ') || 'None'}`);
    if (record.narrative.spine) {
      console.log(`Spine Valid:        ${record.narrative.spine.isValid}`);
      console.log(`Total Sections:     ${record.narrative.spine.totalSections}`);
    }
  }

  if (record.llmUsage) {
    console.log('\n--- LLM USAGE ---');
    console.log(`Input Tokens:       ${record.llmUsage.input_tokens || 'N/A'}`);
    console.log(`Output Tokens:      ${record.llmUsage.output_tokens || 'N/A'}`);
    console.log(`Total Tokens:       ${record.llmUsage.total_tokens || 'N/A'}`);
  }

  if (record.promptEngineering) {
    const pe = record.promptEngineering;
    console.log('\n--- PROMPT ENGINEERING ---');
    console.log(`Combined Hash:      ${pe.hashes?.combined?.slice(0, 16)}...`);
    console.log(`System Fingerprint: ${pe.hashes?.system}`);
    console.log(`User Fingerprint:   ${pe.hashes?.user}`);
    console.log(`Response Fingerprint: ${pe.hashes?.response}`);
    
    if (pe.lengths) {
      console.log(`\nSystem Prompt:      ${formatBytes(pe.lengths.systemPrompt)}`);
      console.log(`User Prompt:        ${formatBytes(pe.lengths.userPrompt)}`);
      console.log(`Response:           ${formatBytes(pe.lengths.response)}`);
      console.log(`Total:              ${formatBytes(pe.lengths.total)}`);
    }

    if (pe.structure?.system) {
      console.log('\n--- SYSTEM PROMPT STRUCTURE ---');
      console.log(`Words:              ${pe.structure.system.wordCount}`);
      console.log(`Lines:              ${pe.structure.system.lineCount}`);
      console.log(`Sections:           ${pe.structure.system.sectionCount}`);
      console.log(`Has Markdown:       ${pe.structure.system.hasMarkdown}`);
      console.log(`Has Lists:          ${pe.structure.system.hasListItems}`);
    }

    if (options.verbose && pe.redacted) {
      console.log('\n--- REDACTED SYSTEM PROMPT ---');
      console.log(pe.redacted.systemPrompt?.slice(0, 2000) || '(empty)');
      if (pe.redacted.systemPrompt?.length > 2000) {
        console.log(`\n... (truncated, full length: ${pe.redacted.systemPrompt.length})`);
      }

      console.log('\n--- REDACTED USER PROMPT ---');
      console.log(pe.redacted.userPrompt?.slice(0, 1000) || '(empty)');
      if (pe.redacted.userPrompt?.length > 1000) {
        console.log(`\n... (truncated, full length: ${pe.redacted.userPrompt.length})`);
      }

      console.log('\n--- REDACTED RESPONSE ---');
      console.log(pe.redacted.response?.slice(0, 2000) || '(empty)');
      if (pe.redacted.response?.length > 2000) {
        console.log(`\n... (truncated, full length: ${pe.redacted.response.length})`);
      }
    }
  } else {
    console.log('\n(No prompt engineering data - may be local-composer or older record)');
  }

  console.log('\n' + '='.repeat(80) + '\n');
}

async function showStats(records) {
  console.log('\n' + '='.repeat(60));
  console.log('PROMPT ENGINEERING STATISTICS');
  console.log('='.repeat(60));

  const total = records.length;
  const withPrompts = records.filter(r => r.promptEngineering).length;
  const byProvider = {};
  const bySpread = {};
  const byDeck = {};
  
  let totalInputTokens = 0;
  let totalOutputTokens = 0;
  let totalCoverage = 0;
  let coverageCount = 0;
  let hallucinationCount = 0;
  
  const promptHashes = new Set();
  const uniquePrompts = new Set();

  for (const r of records) {
    // Count by provider
    byProvider[r.provider] = (byProvider[r.provider] || 0) + 1;
    bySpread[r.spreadKey] = (bySpread[r.spreadKey] || 0) + 1;
    byDeck[r.deckStyle] = (byDeck[r.deckStyle] || 0) + 1;

    // Token usage
    if (r.llmUsage) {
      totalInputTokens += r.llmUsage.input_tokens || 0;
      totalOutputTokens += r.llmUsage.output_tokens || 0;
    }

    // Quality metrics
    if (r.narrative?.cardCoverage != null) {
      totalCoverage += r.narrative.cardCoverage;
      coverageCount++;
    }
    if (r.narrative?.hallucinatedCards?.length > 0) {
      hallucinationCount++;
    }

    // Prompt uniqueness
    if (r.promptEngineering?.hashes?.combined) {
      promptHashes.add(r.promptEngineering.hashes.combined);
    }
    if (r.promptEngineering?.hashes?.system) {
      uniquePrompts.add(r.promptEngineering.hashes.system);
    }
  }

  console.log(`\nTotal Readings:           ${total}`);
  console.log(`With Prompt Data:         ${withPrompts} (${((withPrompts/total)*100).toFixed(1)}%)`);
  console.log(`Unique Prompt Combos:     ${promptHashes.size}`);
  console.log(`Unique System Prompts:    ${uniquePrompts.size}`);

  console.log('\n--- BY PROVIDER ---');
  for (const [provider, count] of Object.entries(byProvider).sort((a, b) => b[1] - a[1])) {
    console.log(`  ${provider.padEnd(20)} ${count}`);
  }

  console.log('\n--- BY SPREAD ---');
  for (const [spread, count] of Object.entries(bySpread).sort((a, b) => b[1] - a[1])) {
    console.log(`  ${spread.padEnd(20)} ${count}`);
  }

  console.log('\n--- BY DECK ---');
  for (const [deck, count] of Object.entries(byDeck).sort((a, b) => b[1] - a[1])) {
    console.log(`  ${deck.padEnd(20)} ${count}`);
  }

  console.log('\n--- QUALITY ---');
  console.log(`  Avg Card Coverage:      ${coverageCount ? ((totalCoverage/coverageCount)*100).toFixed(1) : 'N/A'}%`);
  console.log(`  Readings w/ Hallucinations: ${hallucinationCount} (${((hallucinationCount/total)*100).toFixed(1)}%)`);

  console.log('\n--- TOKEN USAGE ---');
  console.log(`  Total Input Tokens:     ${totalInputTokens.toLocaleString()}`);
  console.log(`  Total Output Tokens:    ${totalOutputTokens.toLocaleString()}`);
  console.log(`  Avg Input per Reading:  ${Math.round(totalInputTokens / (withPrompts || 1)).toLocaleString()}`);
  console.log(`  Avg Output per Reading: ${Math.round(totalOutputTokens / (withPrompts || 1)).toLocaleString()}`);

  console.log('\n' + '='.repeat(60) + '\n');
}

async function main() {
  const options = parseArgs(process.argv.slice(2));
  
  console.log('Loading Wrangler configuration...');
  const config = await loadWranglerConfig();
  const namespaceId = getMetricsNamespaceId(config);

  if (!namespaceId) {
    console.error('Error: METRICS_DB namespace ID not found in wrangler.jsonc');
    console.error('Ensure kv_namespaces includes a METRICS_DB binding.');
    process.exit(1);
  }

  console.log(`Using METRICS_DB namespace: ${namespaceId}`);
  console.log(`Target: ${options.local ? 'local' : 'remote'}\n`);

  // View single reading
  if (options.id) {
    try {
      const key = options.id.startsWith('reading:') ? options.id : `reading:${options.id}`;
      const record = await getKey(namespaceId, key, options);
      await showSingleReading(record, options);
    } catch (err) {
      console.error(`Error fetching reading: ${err.message}`);
      process.exit(1);
    }
    return;
  }

  // List all keys
  console.log('Fetching reading keys...');
  const keys = await listKeys(namespaceId, options);
  console.log(`Found ${keys.length} readings\n`);

  if (keys.length === 0) {
    console.log('No readings found in METRICS_DB.');
    console.log('Readings are stored when using Azure GPT-5 or Claude backends.');
    return;
  }

  // Fetch records
  console.log('Fetching reading records...');
  const records = [];
  const keysToFetch = options.export ? keys : keys.slice(0, options.limit);
  
  for (let i = 0; i < keysToFetch.length; i++) {
    const entry = keysToFetch[i];
    if (!entry?.name) continue;
    
    try {
      const record = await getKey(namespaceId, entry.name, options);
      if (record) records.push(record);
      
      if ((i + 1) % 10 === 0) {
        process.stdout.write(`  Fetched ${i + 1}/${keysToFetch.length}\r`);
      }
    } catch (err) {
      console.warn(`Failed to fetch ${entry.name}: ${err.message}`);
    }
  }
  console.log(`\nLoaded ${records.length} records`);

  // Show stats
  if (options.stats) {
    await showStats(records);
    return;
  }

  // Export
  if (options.export) {
    const outputPath = path.resolve(process.cwd(), options.output);
    await fs.mkdir(path.dirname(outputPath), { recursive: true });
    
    const lines = records.map(r => JSON.stringify(r));
    await fs.writeFile(outputPath, lines.join('\n') + '\n');
    
    console.log(`\nExported ${records.length} readings to ${outputPath}`);
    return;
  }

  // List view (default)
  console.log('\n' + '-'.repeat(100));
  console.log('REQUEST ID'.padEnd(40) + 'PROVIDER'.padEnd(15) + 'SPREAD'.padEnd(12) + 'COVERAGE'.padEnd(10) + 'HAS PROMPTS');
  console.log('-'.repeat(100));
  
  for (const r of records) {
    const coverage = r.narrative?.cardCoverage != null 
      ? `${(r.narrative.cardCoverage * 100).toFixed(0)}%`
      : 'N/A';
    const hasPrompts = r.promptEngineering ? '✓' : '-';
    
    console.log(
      (r.requestId || 'unknown').slice(0, 36).padEnd(40) +
      (r.provider || 'unknown').padEnd(15) +
      (r.spreadKey || 'unknown').padEnd(12) +
      coverage.padEnd(10) +
      hasPrompts
    );
  }
  
  console.log('-'.repeat(100));
  console.log(`\nShowing ${records.length} of ${keys.length} total readings`);
  console.log('Use --id <requestId> to view full details');
  console.log('Use --export to export all readings');
  console.log('Use --stats to see aggregated statistics');
}

main().catch(err => {
  console.error('Fatal error:', err.message);
  process.exit(1);
});
</file>

<file path="shared/contracts/readingSchema.js">
import { z } from 'zod';

const trimmedString = (label) =>
  z
    .string({
      required_error: `${label || 'Value'} is required`,
      invalid_type_error: `${label || 'Value'} must be a string`
    })
    .transform((val) => val.trim())
    .refine((val) => val.length > 0, `${label || 'Value'} is required`);

const orientationSchema = z.enum(['Upright', 'Reversed'], {
  errorMap: () => ({ message: 'orientation must be "Upright" or "Reversed"' })
});

const optionalNumber = () => z.number().int().optional().nullable();

const optionalCleanString = () =>
  z.preprocess((value) => {
    if (value === undefined || value === null) return undefined;
    if (typeof value !== 'string') return value;
    const trimmed = value.trim();
    return trimmed.length > 0 ? trimmed : undefined;
  }, z.string().optional());

export const cardInfoSchema = z
  .object({
    position: trimmedString('position'),
    card: trimmedString('card name'),
    canonicalName: z.string().min(1).optional().nullable(),
    canonicalKey: z.string().min(1).optional().nullable(),
    aliases: z.array(z.string().min(1)).optional().default([]),
    orientation: orientationSchema,
    meaning: trimmedString('meaning'),
    number: optionalNumber(),
    suit: z.string().min(1).optional().nullable(),
    rank: z.string().min(1).optional().nullable(),
    rankValue: optionalNumber(),
    userReflection: z
      .preprocess((value) => {
        if (value === null || value === undefined) return null;
        if (typeof value !== 'string') return null;
        const trimmed = value.trim();
        return trimmed.length > 0 ? trimmed : null;
      }, z.string().min(1).nullable()),
    deckStyle: z.string().optional(),
    canonicalId: z.string().optional()
  })
  .catchall(z.unknown());

export const spreadInfoSchema = z
  .object({
    name: trimmedString('spread name'),
    key: z.string().trim().optional(),
    deckStyle: z.string().trim().optional()
  })
  .catchall(z.unknown());

const optionalVisionProofSchema = z
  .object({
    id: z.string().min(1),
    signature: z.string().min(1),
    createdAt: z.string().optional(),
    expiresAt: z.string().optional(),
    insights: z.array(z.unknown()).optional(),
    deckStyle: z.string().optional()
  })
  .catchall(z.unknown());

const personalizationSchema = z
  .object({
    displayName: z.string().trim().max(50).optional(),
    readingTone: z.enum(['gentle', 'balanced', 'blunt']).optional(),
    spiritualFrame: z.enum(['psychological', 'spiritual', 'mixed', 'playful']).optional(),
    tarotExperience: z.enum(['newbie', 'intermediate', 'experienced']).optional(),
    preferredSpreadDepth: z.enum(['short', 'standard', 'deep']).optional(),
    focusAreas: z.array(z.string().trim().min(1)).optional()
  })
  .catchall(z.unknown());

export const readingRequestSchema = z.object({
  spreadInfo: spreadInfoSchema,
  cardsInfo: z.array(cardInfoSchema).min(1, 'cardsInfo must include at least one card'),
  userQuestion: optionalCleanString(),
  reflectionsText: optionalCleanString(),
  reversalFrameworkOverride: optionalCleanString(),
  deckStyle: optionalCleanString(),
  visionProof: optionalVisionProofSchema.optional(),
  personalization: personalizationSchema.optional()
});

export const readingResponseSchema = z.object({
  reading: trimmedString('reading'),
  spreadAnalysis: z.record(z.any()).nullable().optional(),
  themes: z.record(z.any()).nullable().optional(),
  analysisContext: z.record(z.any()).nullable().optional(),
  visionInsights: z.array(z.any()).optional(),
  provider: z.string().optional(),
  requestId: z.string().optional()
}).catchall(z.unknown());

export function formatZodError(error) {
  if (!error?.issues?.length) return 'Invalid payload.';
  return error.issues
    .map((issue) => `${issue.path.join('.') || 'payload'}: ${issue.message}`)
    .join('; ');
}

export function safeParseReadingRequest(payload) {
  const result = readingRequestSchema.safeParse(payload);
  if (!result.success) {
    return { success: false, error: formatZodError(result.error) };
  }
  return { success: true, data: result.data };
}

export const MINIMUM_CARD_COUNT = 1;
</file>

<file path="shared/journal/stats.js">
export const REVERSED_PATTERN = /reversed/i;

function normalizeEntriesArray(entries) {
  if (!Array.isArray(entries)) {
    return [];
  }
  return entries.filter(Boolean);
}

export function extractRecentThemes(entries, limit = 4) {
  const safeEntries = normalizeEntriesArray(entries);
  if (safeEntries.length === 0) {
    return [];
  }

  const seen = new Set();
  const results = [];

  const sorted = [...safeEntries].sort((a, b) => {
    const tsA = a?.ts || a?.created_at || 0;
    const tsB = b?.ts || b?.created_at || 0;
    return tsB - tsA;
  });

  for (const entry of sorted) {
    if (results.length >= limit) break;
    const themes = entry?.themes || entry?.themes_json || {};
    const candidates = [
      themes?.archetypeDescription,
      themes?.suitFocus,
      themes?.elementalBalance,
      themes?.reversalDescription?.name,
      entry?.context
    ];

    for (const candidate of candidates) {
      const text = typeof candidate === 'string' ? candidate.trim() : '';
      if (text && !seen.has(text)) {
        seen.add(text);
        results.push(text);
        if (results.length >= limit) {
          break;
        }
      }
    }
  }

  return results;
}

export function computeJournalStats(entries) {
  const safeEntries = normalizeEntriesArray(entries);
  if (safeEntries.length === 0) {
    return null;
  }

  let totalCards = 0;
  let reversalCount = 0;
  const cardMap = new Map();
  const contextMap = new Map();
  const monthMap = new Map();

  safeEntries.forEach((entry) => {
    const contextKey = entry?.context || 'general';
    contextMap.set(contextKey, (contextMap.get(contextKey) || 0) + 1);

    const entryDate = entry?.ts
      ? new Date(entry.ts)
      : entry?.created_at
        ? new Date(entry.created_at * 1000)
        : null;

    if (entryDate && !Number.isNaN(entryDate.getTime())) {
      const monthKey = `${entryDate.getFullYear()}-${String(entryDate.getMonth() + 1).padStart(2, '0')}`;
      const label = entryDate.toLocaleString('default', { month: 'short', year: 'numeric' });
      const existing = monthMap.get(monthKey) || { label, count: 0 };
      existing.count += 1;
      monthMap.set(monthKey, existing);
    }

    const cards = Array.isArray(entry?.cards)
      ? entry.cards
      : (() => {
          try {
            return entry?.cards_json ? JSON.parse(entry.cards_json) : [];
          } catch {
            return [];
          }
        })();

    cards.forEach((card) => {
      if (!card) return;
      totalCards += 1;
      const orientationFlag = card?.orientation || (card?.isReversed ? 'reversed' : 'upright');
      const isReversed = REVERSED_PATTERN.test(orientationFlag);
      if (isReversed) {
        reversalCount += 1;
      }
      const cardKey = card?.name || 'Unknown card';
      const aggregate = cardMap.get(cardKey) || { name: cardKey, count: 0, reversed: 0 };
      aggregate.count += 1;
      if (isReversed) {
        aggregate.reversed += 1;
      }
      cardMap.set(cardKey, aggregate);
    });
  });

  const frequentCards = Array.from(cardMap.values())
    .sort((a, b) => b.count - a.count)
    .slice(0, 4);

  const contextBreakdown = Array.from(contextMap.entries()).map(([name, count]) => ({ name, count }));

  const monthlyCadence = Array.from(monthMap.entries())
    .sort((a, b) => a[0].localeCompare(b[0]))
    .slice(-6)
    .map(([, data]) => data);

  const reversalRate = totalCards === 0 ? 0 : Math.round((reversalCount / totalCards) * 100);
  const recentThemes = extractRecentThemes(safeEntries);

  return {
    totalReadings: safeEntries.length,
    totalCards,
    reversalRate,
    frequentCards,
    contextBreakdown,
    monthlyCadence,
    recentThemes
  };
}
</file>

<file path="shared/journal/summary.js">
import { computeJournalStats } from './stats.js';

function formatCardList(entry) {
  const cards = Array.isArray(entry?.cards) ? entry.cards : [];
  if (cards.length === 0) return '';
  return cards
    .slice(0, 4)
    .map(card => `${card.name}${card.orientation ? ` (${card.orientation})` : ''}`)
    .join(', ');
}

export function buildHeuristicJourneySummary(entries, statsOverride) {
  const stats = statsOverride || computeJournalStats(entries);
  if (!stats) {
    return 'Log a few readings to see your journey summary come alive.';
  }

  const opening = `Over ${stats.totalReadings} logged reading${stats.totalReadings === 1 ? '' : 's'}, a ${stats.reversalRate}% reversal tilt and ${stats.totalCards} cards point to the themes you keep circling back to.`;

  const contextLine = stats.contextBreakdown.length > 0
    ? `Top contexts: ${stats.contextBreakdown
        .sort((a, b) => b.count - a.count)
        .slice(0, 3)
        .map(ctx => `${ctx.name} (${ctx.count})`)
        .join(', ')}.`
    : '';

  const cardLine = stats.frequentCards.length > 0
    ? `Recurring cards: ${stats.frequentCards
        .map(card => `${card.name}${card.reversed ? ` · ${card.reversed} rev` : ''}`)
        .join(', ')}.`
    : '';

  const themeLine = stats.recentThemes.length > 0
    ? `Recent themes whisper about ${stats.recentThemes.slice(0, 3).join(', ')}.`
    : '';

  const highlightEntries = Array.isArray(entries)
    ? entries.slice(0, 3).map(entry => {
        const when = entry?.ts ? new Date(entry.ts).toLocaleDateString() : 'recently';
        const context = entry?.context ? `${entry.context} lens` : 'open lens';
        const spread = entry?.spread || entry?.spreadName || 'Reading';
        const cards = formatCardList(entry);
        return `• ${spread} (${context}) on ${when}${cards ? ` featured ${cards}` : ''}.`;
      })
    : [];

  const closing = 'Notice where these threads overlap and invite one grounded action to honor the energy.';

  return [opening, contextLine, cardLine, themeLine, '', ...highlightEntries, '', closing]
    .filter(Boolean)
    .join('\n');
}
</file>

<file path="shared/symbols/symbolAnnotations.js">
// symbolAnnotations.js
// Structured symbol annotations for all 78 RWS cards
// Based on guidetoaitraining.md recommendations (Section 1.5) and imageryHooks.js
// Format per card:
// symbols: array of { object, position, color (optional), meaning }
// dominantColors: array of primary colors with symbolic meanings
// composition: overall layout description
// archetype: core psychological/spiritual archetype

export const SYMBOL_ANNOTATIONS = {
  // MAJOR ARCANA (0-21)
  0: { // The Fool
    symbols: [
      { object: 'sun', position: 'top-left', color: 'yellow', meaning: 'enlightenment, new beginnings' },
      { object: 'dog', position: 'bottom-right', color: 'white', meaning: 'loyalty, instinct, warning' },
      { object: 'cliff', position: 'right-edge', meaning: 'risk, the unknown, leap of faith' },
      { object: 'white rose', position: 'left-hand', color: 'white', meaning: 'purity, innocence' },
      { object: 'bundle', position: 'over-shoulder on stick', color: 'red', meaning: 'subconscious baggage, potential' },
      { object: 'feather', position: 'in hat', color: 'red', meaning: 'air element, freedom' }
    ],
    dominantColors: [
      { color: 'yellow', meaning: 'optimism, joy' },
      { color: 'white', meaning: 'purity, new starts' },
      { color: 'sky-blue', meaning: 'freedom, possibility' }
    ],
    composition: 'figure-on-precipice',
    archetype: 'Divine Fool / Innocent Wanderer'
  },
  1: { // The Magician
    symbols: [
      { object: 'infinity symbol', position: 'above head', meaning: 'eternal potential, as above so below' },
      { object: 'wand', position: 'right hand raised', color: 'white', meaning: 'willpower, fire element' },
      { object: 'cup', position: 'on table', color: 'silver', meaning: 'emotions, water element' },
      { object: 'sword', position: 'on table', color: 'steel', meaning: 'intellect, air element' },
      { object: 'pentacle', position: 'on table', color: 'gold', meaning: 'materiality, earth element' },
      { object: 'red roses', position: 'garden below', color: 'red', meaning: 'passion, manifestation' },
      { object: 'white lilies', position: 'garden below', color: 'white', meaning: 'purity, spiritual wisdom' }
    ],
    dominantColors: [
      { color: 'red', meaning: 'action, passion' },
      { color: 'white', meaning: 'purity, spirit' },
      { color: 'yellow', meaning: 'intellect, energy' }
    ],
    composition: 'channeling-figure-with-tools',
    archetype: 'Master Manifestor / Divine Channel'
  },
  2: { // The High Priestess
    symbols: [
      { object: 'pillars', position: 'flanking throne', color: 'black and white', meaning: 'duality, balance of opposites' },
      { object: 'lunar crown', position: 'on head', color: 'silver', meaning: 'cycles, intuition, feminine mystery' },
      { object: 'scroll', position: 'in lap', meaning: 'hidden knowledge, TORA (Torah/law)' },
      { object: 'veil', position: 'behind throne', color: 'blue', meaning: 'separation of conscious and subconscious' },
      { object: 'pomegranates', position: 'on veil', color: 'red', meaning: 'fertility, abundance, Persephone myth' },
      { object: 'crescent moon', position: 'at feet', color: 'silver', meaning: 'receptivity, subconscious' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'intuition, mystery' },
      { color: 'white', meaning: 'purity, spirit' },
      { color: 'black', meaning: 'unknown, shadow' }
    ],
    composition: 'veiled-throne-between-pillars',
    archetype: 'Mystic Guardian / Inner Knowing'
  },
  3: { // The Empress
    symbols: [
      { object: 'wheat fields', position: 'foreground', color: 'gold', meaning: 'abundance, fertility' },
      { object: 'waterfall', position: 'background', color: 'blue', meaning: 'emotional flow, creativity' },
      { object: 'Venus symbol', position: 'on shield', color: 'red', meaning: 'feminine energy, love, beauty' },
      { object: 'scepter', position: 'right hand', color: 'gold', meaning: 'authority, creative power' },
      { object: 'stars', position: 'in crown', meaning: 'celestial connection, divine feminine' },
      { object: 'pomegranates', position: 'on gown', color: 'red', meaning: 'fertility, sensuality' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'growth, nature' },
      { color: 'red', meaning: 'passion, vitality' },
      { color: 'gold', meaning: 'abundance, warmth' }
    ],
    composition: 'reclining-in-nature',
    archetype: 'Nurturing Creator / Divine Mother'
  },
  4: { // The Emperor
    symbols: [
      { object: 'ram heads', position: 'on throne armrests', color: 'stone', meaning: 'Aries, leadership, initiation' },
      { object: 'mountains', position: 'background', color: 'red-orange', meaning: 'stability, challenges overcome' },
      { object: 'scepter', position: 'right hand', color: 'gold', meaning: 'authority, control' },
      { object: 'orb', position: 'left hand', color: 'gold', meaning: 'dominion, worldly power' },
      { object: 'armor', position: 'under robes', color: 'steel', meaning: 'protection, structure' },
      { object: 'ankh', position: 'on scepter', meaning: 'life, eternal rule' }
    ],
    dominantColors: [
      { color: 'red', meaning: 'power, action' },
      { color: 'orange', meaning: 'ambition, energy' },
      { color: 'gray', meaning: 'stability, authority' }
    ],
    composition: 'enthroned-over-mountains',
    archetype: 'Divine Father / Structured Leader'
  },
  5: { // The Hierophant
    symbols: [
      { object: 'crossed keys', position: 'at feet', color: 'gold', meaning: 'spiritual authority, access to knowledge' },
      { object: 'two acolytes', position: 'kneeling below', meaning: 'teaching, transmission of wisdom' },
      { object: 'raised hand', position: 'right hand', meaning: 'blessing, divine connection' },
      { object: 'triple cross', position: 'on staff', color: 'gold', meaning: 'papal authority, three realms' },
      { object: 'pillars', position: 'behind throne', color: 'gray', meaning: 'stability, tradition' }
    ],
    dominantColors: [
      { color: 'red', meaning: 'spiritual passion' },
      { color: 'white', meaning: 'purity, wisdom' },
      { color: 'gold', meaning: 'divine authority' }
    ],
    composition: 'seated-teacher-with-students',
    archetype: 'Spiritual Guide / Traditional Wisdom'
  },
  6: { // The Lovers
    symbols: [
      { object: 'angel', position: 'above', color: 'red wings', meaning: 'divine blessing, higher guidance' },
      { object: 'tree of knowledge', position: 'behind woman', color: 'green with serpent', meaning: 'choice, temptation' },
      { object: 'tree of life', position: 'behind man', color: 'green with flames', meaning: 'passion, vitality' },
      { object: 'mountain', position: 'background', color: 'purple', meaning: 'spiritual ascent' },
      { object: 'cloud', position: 'around angel', meaning: 'divine intervention' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'growth, harmony' },
      { color: 'red', meaning: 'passion, union' },
      { color: 'purple', meaning: 'spiritual choice' }
    ],
    composition: 'dual-figures-under-angel',
    archetype: 'Sacred Union / Choice Maker'
  },
  7: { // The Chariot
    symbols: [
      { object: 'sphinxes', position: 'pulling chariot', color: 'black and white', meaning: 'opposing forces, balance' },
      { object: 'starry canopy', position: 'above chariot', color: 'blue', meaning: 'celestial protection' },
      { object: 'city', position: 'background', meaning: 'civilization left behind, journey outward' },
      { object: 'wand', position: 'in hand', color: 'gold', meaning: 'willpower, direction' },
      { object: 'armor', position: 'on figure', color: 'silver with symbols', meaning: 'protection, focus' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'control, intuition' },
      { color: 'black/white', meaning: 'duality, balance' },
      { color: 'gold', meaning: 'victory, will' }
    ],
    composition: 'armored-driver-with-sphinxes',
    archetype: 'Victorious Warrior / Directed Will'
  },
  8: { // Strength
    symbols: [
      { object: 'lion', position: 'below figure', color: 'red', meaning: 'inner beast, passion, courage' },
      { object: 'infinity symbol', position: 'above head', meaning: 'eternal strength, patience' },
      { object: 'flowers', position: 'in hair and around waist', color: 'white', meaning: 'gentleness, purity' },
      { object: 'mountains', position: 'background', color: 'green', meaning: 'overcoming challenges' }
    ],
    dominantColors: [
      { color: 'white', meaning: 'purity, gentleness' },
      { color: 'red', meaning: 'passion, vitality' },
      { color: 'green', meaning: 'growth, nature' }
    ],
    composition: 'gentle-figure-with-lion',
    archetype: 'Compassionate Warrior / Inner Strength'
  },
  9: { // The Hermit
    symbols: [
      { object: 'lantern', position: 'right hand raised', meaning: 'inner light, guidance' },
      { object: 'six-pointed star', position: 'inside lantern', color: 'yellow', meaning: 'wisdom, union of opposites' },
      { object: 'staff', position: 'left hand', color: 'gray', meaning: 'support, journey' },
      { object: 'mountain peak', position: 'standing on', color: 'gray', meaning: 'spiritual height, isolation' },
      { object: 'cloak', position: 'on figure', color: 'gray', meaning: 'withdrawal, introspection' }
    ],
    dominantColors: [
      { color: 'gray', meaning: 'neutrality, wisdom' },
      { color: 'yellow', meaning: 'illumination, intellect' },
      { color: 'blue', meaning: 'intuition, depth' }
    ],
    composition: 'solitary-figure-on-peak',
    archetype: 'Wise Seeker / Inner Guide'
  },
  10: { // Wheel of Fortune
    symbols: [
      { object: 'wheel', position: 'center', meaning: 'cycles, change' },
      { object: 'sphinx', position: 'top of wheel', color: 'blue', meaning: 'riddles, mystery' },
      { object: 'snake', position: 'descending left', color: 'green', meaning: 'transformation, descent' },
      { object: 'Anubis', position: 'rising right', color: 'red', meaning: 'rebirth, ascent' },
      { object: 'Hebrew letters', position: 'on wheel', meaning: 'divine name, fate' },
      { object: 'alchemical symbols', position: 'on wheel', meaning: 'elements, transformation' },
      { object: 'four fixed signs', position: 'corners', meaning: 'stability amid change' }
    ],
    dominantColors: [
      { color: 'orange', meaning: 'change, energy' },
      { color: 'blue', meaning: 'mystery, fate' },
      { color: 'yellow', meaning: 'illumination, cycles' }
    ],
    composition: 'turning-wheel-with-figures',
    archetype: 'Cycle Turner / Fate Weaver'
  },
  11: { // Justice
    symbols: [
      { object: 'scales', position: 'left hand', color: 'gold', meaning: 'balance, fairness' },
      { object: 'sword', position: 'right hand', color: 'steel', meaning: 'truth, decision' },
      { object: 'pillars', position: 'flanking throne', color: 'gray', meaning: 'stability, duality' },
      { object: 'purple veil', position: 'behind throne', meaning: 'mystery, higher wisdom' }
    ],
    dominantColors: [
      { color: 'red', meaning: 'action, passion' },
      { color: 'purple', meaning: 'wisdom, royalty' },
      { color: 'gray', meaning: 'neutrality, balance' }
    ],
    composition: 'seated-judge-with-tools',
    archetype: 'Balanced Arbiter / Truth Seeker'
  },
  12: { // The Hanged Man
    symbols: [
      { object: 'tree', position: 'hanging from', color: 'green', meaning: 'living wood, growth through sacrifice' },
      { object: 'halo', position: 'around head', color: 'yellow', meaning: 'enlightenment, divine insight' },
      { object: 'crossed leg', position: 'right leg over left', meaning: 'surrender, new perspective' },
      { object: 'tau cross', position: 'formed by tree', meaning: 'spiritual suspension' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'intuition, surrender' },
      { color: 'yellow', meaning: 'illumination, insight' },
      { color: 'green', meaning: 'growth, nature' }
    ],
    composition: 'inverted-suspension',
    archetype: 'Surrendered Visionary / Sacrificial Seer'
  },
  13: { // Death
    symbols: [
      { object: 'skeleton', position: 'on horse', color: 'black armor', meaning: 'transformation, ending' },
      { object: 'white horse', position: 'mount', meaning: 'purity, forward movement' },
      { object: 'banner', position: 'in hand', color: 'black with white rose', meaning: 'rebirth, mysticism' },
      { object: 'sun', position: 'rising between towers', color: 'gold', meaning: 'new beginnings' },
      { object: 'fallen figures', position: 'on ground', meaning: 'release of old forms' }
    ],
    dominantColors: [
      { color: 'black', meaning: 'ending, mystery' },
      { color: 'white', meaning: 'purity, rebirth' },
      { color: 'gold', meaning: 'dawn, renewal' }
    ],
    composition: 'rider-over-fallen',
    archetype: 'Transformer / Cycle Ender'
  },
  14: { // Temperance
    symbols: [
      { object: 'angel', position: 'center', meaning: 'balance, moderation' },
      { object: 'cups', position: 'pouring between', color: 'gold and silver', meaning: 'alchemical mixing' },
      { object: 'one foot in water', position: 'left foot', meaning: 'subconscious, emotion' },
      { object: 'one foot on land', position: 'right foot', meaning: 'conscious, stability' },
      { object: 'mountain path', position: 'background', meaning: 'journey to enlightenment' },
      { object: 'rising sun', position: 'distant', meaning: 'healing, integration' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'flow, emotion' },
      { color: 'red', meaning: 'action, passion' },
      { color: 'yellow', meaning: 'clarity, healing' }
    ],
    composition: 'pouring-angel-between-elements',
    archetype: 'Alchemical Balancer / Healer'
  },
  15: { // The Devil
    symbols: [
      { object: 'horned figure', position: 'perched on pedestal', meaning: 'shadow self, addiction' },
      { object: 'inverted pentagram', position: 'on forehead', meaning: 'material over spiritual' },
      { object: 'chained figures', position: 'below', meaning: 'bondage, illusion of entrapment' },
      { object: 'tails', position: 'on figures', color: 'grape and flame', meaning: 'base instincts' },
      { object: 'torch', position: 'left hand downward', meaning: 'downward energy, ignorance' }
    ],
    dominantColors: [
      { color: 'black', meaning: 'shadow, bondage' },
      { color: 'red', meaning: 'temptation, passion' },
      { color: 'orange', meaning: 'materialism' }
    ],
    composition: 'perched-devil-with-chained',
    archetype: 'Shadow Binder / Material Tempter'
  },
  16: { // The Tower
    symbols: [
      { object: 'lightning', position: 'striking crown', color: 'white', meaning: 'sudden revelation, destruction' },
      { object: 'tower', position: 'center', color: 'gray', meaning: 'false structures, ego' },
      { object: 'falling figures', position: 'from tower', meaning: 'release, downfall' },
      { object: 'flaming debris', position: 'falling', color: 'yellow', meaning: 'purification by fire' },
      { object: 'gray sky', position: 'background', meaning: 'chaos, upheaval' }
    ],
    dominantColors: [
      { color: 'gray', meaning: 'instability' },
      { color: 'yellow', meaning: 'destruction, enlightenment' },
      { color: 'red', meaning: 'crisis, change' }
    ],
    composition: 'struck-tower-with-falling',
    archetype: 'Sudden Upheaval / Ego Destroyer'
  },
  17: { // The Star
    symbols: [
      { object: 'large star', position: 'overhead', color: 'yellow', meaning: 'hope, guidance' },
      { object: 'seven smaller stars', position: 'around large star', meaning: 'chakras, inspiration' },
      { object: 'naked figure', position: 'kneeling', meaning: 'vulnerability, authenticity' },
      { object: 'pitchers', position: 'pouring water', meaning: 'renewal, giving back' },
      { object: 'pool', position: 'left pitcher to', meaning: 'subconscious' },
      { object: 'land', position: 'right pitcher to', meaning: 'conscious manifestation' },
      { object: 'bird in tree', position: 'background', color: 'ibis', meaning: 'thought, wisdom' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'healing, flow' },
      { color: 'yellow', meaning: 'hope, inspiration' },
      { color: 'green', meaning: 'renewal, nature' }
    ],
    composition: 'pouring-figure-under-stars',
    archetype: 'Hope Bringer / Healer'
  },
  18: { // The Moon
    symbols: [
      { object: 'full moon with face', position: 'center sky', meaning: 'illusion, subconscious' },
      { object: 'two towers', position: 'background', color: 'gray', meaning: 'boundaries, duality' },
      { object: 'dog and wolf', position: 'howling at moon', meaning: 'tame and wild instincts' },
      { object: 'crayfish', position: 'emerging from water', meaning: 'deep subconscious' },
      { object: 'winding path', position: 'through scene', meaning: 'journey through uncertainty' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'mystery, intuition' },
      { color: 'yellow', meaning: 'deceptive light' },
      { color: 'gray', meaning: 'uncertainty' }
    ],
    composition: 'path-through-instincts-under-moon',
    archetype: 'Illusion Navigator / Subconscious Explorer'
  },
  19: { // The Sun
    symbols: [
      { object: 'radiant sun with face', position: 'center sky', meaning: 'vitality, clarity' },
      { object: 'naked child', position: 'on white horse', meaning: 'innocence, joy' },
      { object: 'sunflowers', position: 'background wall', color: 'yellow', meaning: 'happiness, growth' },
      { object: 'red banner', position: "in child's hand", meaning: 'vitality, celebration' },
      { object: 'wall', position: 'behind', color: 'gray', meaning: 'boundaries overcome' }
    ],
    dominantColors: [
      { color: 'yellow', meaning: 'joy, enlightenment' },
      { color: 'red', meaning: 'vitality, energy' },
      { color: 'white', meaning: 'purity, clarity' }
    ],
    composition: 'joyful-rider-under-sun',
    archetype: 'Joyful Illuminator / Vital Force'
  },
  20: { // Judgement
    symbols: [
      { object: 'angel', position: 'in clouds', meaning: 'awakening, rebirth' },
      { object: 'trumpet', position: 'blown by angel', color: 'gold', meaning: 'call to rise' },
      { object: 'rising figures', position: 'from coffins', meaning: 'resurrection, renewal' },
      { object: 'mountains', position: 'background', color: 'gray', meaning: 'obstacles overcome' },
      { object: 'water', position: 'foreground', meaning: 'purification, subconscious' }
    ],
    dominantColors: [
      { color: 'gray', meaning: 'transition' },
      { color: 'blue', meaning: 'purification' },
      { color: 'gold', meaning: 'divine call' }
    ],
    composition: 'rising-figures-under-angel',
    archetype: 'Awakener / Transformer'
  },
  21: { // The World
    symbols: [
      { object: 'dancer', position: 'center', meaning: 'completion, integration' },
      { object: 'wreath', position: 'surrounding dancer', color: 'green', meaning: 'victory, wholeness' },
      { object: 'wands', position: 'in hands', color: 'gold', meaning: 'mastery, balance' },
      { object: 'four fixed signs', position: 'corners', meaning: 'elements in harmony' },
      { object: 'red ribbon', position: 'tying wreath', meaning: 'infinity, cycles' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'completion, growth' },
      { color: 'blue', meaning: 'wholeness, spirit' },
      { color: 'red', meaning: 'vitality, celebration' }
    ],
    composition: 'encircled-dancer',
    archetype: 'Cosmic Integrator / Completed Self'
  },

  // MINOR ARCANA - WANDS
  22: { // Ace of Wands
    symbols: [
      { object: 'hand', position: 'emerging from cloud', meaning: 'divine inspiration' },
      { object: 'sprouting wand', position: 'held in hand', color: 'green leaves', meaning: 'creative potential, growth' },
      { object: 'rolling hills', position: 'background', color: 'green', meaning: 'fertile opportunities' },
      { object: 'distant castle', position: 'far background', meaning: 'goals, achievement' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'growth, potential' },
      { color: 'gray', meaning: 'cloud, divine source' }
    ],
    composition: 'hand-presenting-wand',
    archetype: 'Creative Spark'
  },
  23: { // Two of Wands
    symbols: [
      { object: 'figure', position: 'on battlements', meaning: 'planning, vision' },
      { object: 'globe', position: 'in right hand', color: 'blue/red', meaning: 'world of possibilities' },
      { object: 'wands', position: 'one held, one anchored', meaning: 'choice, direction' }
    ],
    dominantColors: [
      { color: 'red', meaning: 'passion, action' },
      { color: 'blue', meaning: 'vision, planning' }
    ],
    composition: 'overlooking-figure-with-globe',
    archetype: 'Visionary Planner'
  },
  24: { // Three of Wands
    symbols: [
      { object: 'cloaked traveler', position: 'on cliff', meaning: 'foresight, exploration' },
      { object: 'three wands', position: 'rooted beside', meaning: 'initial manifestation' },
      { object: 'ships', position: 'on sea below', meaning: 'opportunities arriving' }
    ],
    dominantColors: [
      { color: 'yellow', meaning: 'optimism, future' },
      { color: 'blue', meaning: 'distance, possibility' }
    ],
    composition: 'watching-traveler-on-cliff',
    archetype: 'Opportunity Seeker'
  },
  25: { // Four of Wands
    symbols: [
      { object: 'garlanded wands', position: 'forming arch', color: 'green/yellow', meaning: 'celebration, homecoming' },
      { object: 'figures', position: 'celebrating beyond', meaning: 'community, joy' },
      { object: 'castle', position: 'background', meaning: 'stability, achievement' }
    ],
    dominantColors: [
      { color: 'yellow', meaning: 'joy, celebration' },
      { color: 'green', meaning: 'growth, harmony' }
    ],
    composition: 'festive-archway',
    archetype: 'Harmonious Celebrant'
  },
  26: { // Five of Wands
    symbols: [
      { object: 'youths', position: 'in group', meaning: 'competition, diversity' },
      { object: 'wands', position: 'brandished', color: 'wood', meaning: 'conflicting ideas' }
    ],
    dominantColors: [
      { color: 'red', meaning: 'conflict, energy' },
      { color: 'blue', meaning: 'communication' }
    ],
    composition: 'clashing-group',
    archetype: 'Competitive Challenger'
  },
  27: { // Six of Wands
    symbols: [
      { object: 'laureled rider', position: 'on horseback', meaning: 'victory, recognition' },
      { object: 'wand', position: 'raised', color: 'laurel', meaning: 'success' },
      { object: 'onlookers', position: 'surrounding', meaning: 'public acclaim' }
    ],
    dominantColors: [
      { color: 'red', meaning: 'triumph' },
      { color: 'white', meaning: 'purity of achievement' }
    ],
    composition: 'victorious-procession',
    archetype: 'Triumphant Leader'
  },
  28: { // Seven of Wands
    symbols: [
      { object: 'guardian', position: 'on hilltop', meaning: 'defense, advantage' },
      { object: 'wand', position: 'thrusting', meaning: 'assertion' },
      { object: 'challengers', position: 'below (implied)', meaning: 'opposition' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'growth through challenge' },
      { color: 'red', meaning: 'courage' }
    ],
    composition: 'defending-high-ground',
    archetype: 'Valiant Defender'
  },
  29: { // Eight of Wands
    symbols: [
      { object: 'eight wands', position: 'streaking through sky', meaning: 'swift movement' },
      { object: 'meadows', position: 'below', color: 'green', meaning: 'clear path' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'progress' },
      { color: 'blue', meaning: 'clarity' }
    ],
    composition: 'flying-wands',
    archetype: 'Swift Messenger'
  },
  30: { // Nine of Wands
    symbols: [
      { object: 'bandaged sentinel', position: 'standing', meaning: 'resilience' },
      { object: 'eight wands', position: 'fence behind', meaning: 'boundaries, experience' },
      { object: 'wand', position: 'gripped', meaning: 'readiness' }
    ],
    dominantColors: [
      { color: 'yellow', meaning: 'vigilance' },
      { color: 'green', meaning: 'healing' }
    ],
    composition: 'wounded-guardian',
    archetype: 'Resilient Protector'
  },
  31: { // Ten of Wands
    symbols: [
      { object: 'figure', position: 'hunched', meaning: 'burden' },
      { object: 'ten wands', position: 'bundled in arms', meaning: 'overcommitment' },
      { object: 'town', position: 'ahead', meaning: 'destination near' }
    ],
    dominantColors: [
      { color: 'red', meaning: 'strain' },
      { color: 'yellow', meaning: 'effort' }
    ],
    composition: 'burdened-traveler',
    archetype: 'Overloaded Carrier'
  },

  // CUPS (32-45)
  32: { // Ace of Cups
    symbols: [
      { object: 'hand', position: 'from cloud', meaning: 'divine offering' },
      { object: 'chalice', position: 'held', color: 'gold', meaning: 'emotional potential' },
      { object: 'dove', position: 'crowning chalice', color: 'white', meaning: 'peace, spirit' },
      { object: 'overflowing water', position: 'from chalice', meaning: 'abundance' },
      { object: 'lotus blossoms', position: 'on water surface', color: 'white', meaning: 'spiritual awakening, purity' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'emotion, flow' },
      { color: 'gold', meaning: 'divine love' },
      { color: 'white', meaning: 'purity, spiritual love' }
    ],
    composition: 'overflowing-chalice',
    archetype: 'Emotional Source'
  },
  33: { // Two of Cups
    symbols: [
      { object: 'two figures', position: 'facing each other', meaning: 'partnership, union' },
      { object: 'cups raised', position: 'in toast', color: 'gold', meaning: 'mutual exchange' },
      { object: 'caduceus', position: 'above cups', meaning: 'healing, balance' },
      { object: 'winged lion', position: 'crowning caduceus', color: 'red', meaning: 'passionate commitment' }
    ],
    dominantColors: [
      { color: 'red', meaning: 'passion, commitment' },
      { color: 'gold', meaning: 'sacred exchange' },
      { color: 'white', meaning: 'purity of connection' }
    ],
    composition: 'mutual-pledge',
    archetype: 'Sacred Partnership'
  },
  34: { // Three of Cups
    symbols: [
      { object: 'three maidens', position: 'in circle', meaning: 'community, celebration' },
      { object: 'raised cups', position: 'in toast', color: 'gold', meaning: 'shared joy' },
      { object: 'fruits and gourds', position: 'at feet', meaning: 'harvest, abundance' },
      { object: 'flowing garments', position: 'on figures', color: 'varied', meaning: 'diversity, harmony' }
    ],
    dominantColors: [
      { color: 'orange', meaning: 'celebration, warmth' },
      { color: 'green', meaning: 'growth, abundance' },
      { color: 'gold', meaning: 'shared prosperity' }
    ],
    composition: 'celebratory-circle',
    archetype: 'Joyful Community'
  },
  35: { // Four of Cups
    symbols: [
      { object: 'seated figure', position: 'under tree', meaning: 'contemplation, withdrawal' },
      { object: 'three cups', position: 'on ground', meaning: 'known options' },
      { object: 'hand from cloud', position: 'offering fourth cup', meaning: 'new possibility' },
      { object: 'crossed arms', position: 'on figure', meaning: 'resistance, introspection' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'stagnation, contemplation' },
      { color: 'gray', meaning: 'apathy, meditation' },
      { color: 'gold', meaning: 'overlooked opportunity' }
    ],
    composition: 'meditative-dissatisfaction',
    archetype: 'Contemplative Refusal'
  },
  36: { // Five of Cups
    symbols: [
      { object: 'cloaked figure', position: 'head bowed', meaning: 'grief, loss' },
      { object: 'three spilled cups', position: 'before figure', color: 'red liquid', meaning: 'what is lost' },
      { object: 'two standing cups', position: 'behind figure', meaning: 'what remains' },
      { object: 'bridge', position: 'background', meaning: 'path forward' },
      { object: 'distant castle', position: 'across water', meaning: 'future hope' }
    ],
    dominantColors: [
      { color: 'black', meaning: 'mourning, sorrow' },
      { color: 'gray', meaning: 'desolation' },
      { color: 'blue', meaning: 'emotional depth' }
    ],
    composition: 'grieving-over-loss',
    archetype: 'Mourning Traveler'
  },
  37: { // Six of Cups
    symbols: [
      { object: 'children', position: 'in courtyard', meaning: 'innocence, nostalgia' },
      { object: 'cups with flowers', position: 'filled with white blooms', meaning: 'sweet memories' },
      { object: 'older child giving', position: 'offering cup', meaning: 'generosity, gift' },
      { object: 'cottages', position: 'background', meaning: 'home, past' }
    ],
    dominantColors: [
      { color: 'yellow', meaning: 'nostalgia, warmth' },
      { color: 'white', meaning: 'innocence, purity' },
      { color: 'green', meaning: 'growth, simplicity' }
    ],
    composition: 'nostalgic-exchange',
    archetype: 'Innocent Gift-Giver'
  },
  38: { // Seven of Cups
    symbols: [
      { object: 'shadowed figure', position: 'silhouette', meaning: 'confusion, choices' },
      { object: 'seven cups on clouds', position: 'floating', meaning: 'illusions, fantasies' },
      { object: 'castle', position: 'in one cup', meaning: 'ambition' },
      { object: 'jewels', position: 'in one cup', meaning: 'wealth, desire' },
      { object: 'laurel wreath', position: 'in one cup', meaning: 'victory, recognition' },
      { object: 'dragon', position: 'in one cup', meaning: 'fear, challenge' },
      { object: 'shrouded figure', position: 'in one cup', meaning: 'mystery' },
      { object: 'serpent', position: 'in one cup', meaning: 'temptation' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'dreams, illusion' },
      { color: 'gray', meaning: 'confusion, fog' },
      { color: 'gold', meaning: 'desire, fantasy' }
    ],
    composition: 'illusory-choices',
    archetype: 'Bewildered Dreamer'
  },
  39: { // Eight of Cups
    symbols: [
      { object: 'cloaked figure', position: 'walking away', meaning: 'departure, seeking' },
      { object: 'eight stacked cups', position: 'left behind', meaning: 'abandoned past' },
      { object: 'gap in cups', position: 'missing ninth', meaning: 'incompleteness' },
      { object: 'moon', position: 'overhead', color: 'pale', meaning: 'intuition, night journey' },
      { object: 'mountains', position: 'ahead', meaning: 'spiritual quest' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'introspection, journey' },
      { color: 'gray', meaning: 'twilight, transition' },
      { color: 'brown', meaning: 'earthly detachment' }
    ],
    composition: 'departing-seeker',
    archetype: 'Spiritual Wanderer'
  },
  40: { // Nine of Cups
    symbols: [
      { object: 'satisfied figure', position: 'seated, arms crossed', meaning: 'contentment, pride' },
      { object: 'nine cups', position: 'arranged in arc', color: 'gold', meaning: 'wishes fulfilled' },
      { object: 'blue draped table', position: 'beneath cups', meaning: 'emotional abundance' },
      { object: 'smile', position: 'on figure', meaning: 'satisfaction' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'emotional fulfillment' },
      { color: 'red', meaning: 'vitality, pleasure' },
      { color: 'gold', meaning: 'achievement' }
    ],
    composition: 'satisfied-abundance',
    archetype: 'Wish Fulfiller'
  },
  41: { // Ten of Cups
    symbols: [
      { object: 'family', position: 'embracing', meaning: 'love, harmony' },
      { object: 'children playing', position: 'foreground', meaning: 'joy, innocence' },
      { object: 'rainbow', position: 'overhead', meaning: 'blessing, promise' },
      { object: 'ten cups', position: 'in rainbow arc', color: 'gold', meaning: 'complete emotional fulfillment' },
      { object: 'cottage', position: 'background', meaning: 'home, security' },
      { object: 'river', position: 'nearby', meaning: 'flow of life' }
    ],
    dominantColors: [
      { color: 'rainbow', meaning: 'complete spectrum of joy' },
      { color: 'green', meaning: 'peace, nature' },
      { color: 'blue', meaning: 'emotional harmony' }
    ],
    composition: 'blessed-family',
    archetype: 'Harmonious Union'
  },
  42: { // Page of Cups
    symbols: [
      { object: 'youth', position: 'standing', meaning: 'emotional curiosity' },
      { object: 'cup', position: 'held forth', color: 'gold', meaning: 'creative offering' },
      { object: 'fish', position: 'emerging from cup', color: 'blue', meaning: 'unexpected message, intuition' },
      { object: 'blue tunic', position: 'on figure', color: 'flowered', meaning: 'imagination, sensitivity' },
      { object: 'gentle waves', position: 'at feet', meaning: 'emotional fluidity' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'imagination, emotion' },
      { color: 'gold', meaning: 'creative potential' },
      { color: 'turquoise', meaning: 'intuitive messages' }
    ],
    composition: 'curious-messenger',
    archetype: 'Imaginative Messenger'
  },
  43: { // Knight of Cups
    symbols: [
      { object: 'armored knight', position: 'on white horse', meaning: 'romantic quest' },
      { object: 'cup', position: 'offered forward', color: 'gold', meaning: 'emotional offering' },
      { object: 'winged helmet', position: 'on head', meaning: 'inspired thought' },
      { object: 'slow-walking horse', position: 'measured pace', color: 'white', meaning: 'dreaminess, idealism' },
      { object: 'river', position: 'background', meaning: 'emotional journey' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'romance, idealism' },
      { color: 'white', meaning: 'purity of intention' },
      { color: 'silver', meaning: 'reflection, emotion' }
    ],
    composition: 'romantic-quester',
    archetype: 'Romantic Idealist'
  },
  44: { // Queen of Cups
    symbols: [
      { object: 'enthroned queen', position: 'by water', meaning: 'emotional mastery' },
      { object: 'ornate cup', position: 'held carefully', color: 'gold with angels', meaning: 'sacred emotion' },
      { object: 'throne', position: 'on shore', color: 'decorated with sea creatures', meaning: 'subconscious realm' },
      { object: 'water', position: 'at throne base', meaning: 'deep feeling' },
      { object: 'pebbled shore', position: 'foreground', meaning: 'boundary of conscious/unconscious' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'intuition, empathy' },
      { color: 'white', meaning: 'purity of feeling' },
      { color: 'silver', meaning: 'lunar wisdom' }
    ],
    composition: 'contemplative-sovereign',
    archetype: 'Empathic Nurturer'
  },
  45: { // King of Cups
    symbols: [
      { object: 'enthroned king', position: 'on turbulent sea', meaning: 'emotional control' },
      { object: 'cup', position: 'held steady', color: 'gold', meaning: 'mastered emotion' },
      { object: 'fish amulet', position: 'around neck', meaning: 'subconscious awareness' },
      { object: 'ship', position: 'background right', meaning: 'journey through emotion' },
      { object: 'fish leaping', position: 'background left', meaning: 'creative unconscious' },
      { object: 'stone throne', position: 'floating', meaning: 'stability amid flux' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'mastered emotion' },
      { color: 'green', meaning: 'balanced feeling' },
      { color: 'gold', meaning: 'mature wisdom' }
    ],
    composition: 'sovereign-on-waters',
    archetype: 'Balanced Emotional Master'
  },

  // SWORDS (46-59)
  46: { // Ace of Swords
    symbols: [
      { object: 'hand', position: 'from cloud', meaning: 'divine clarity' },
      { object: 'upright sword', position: 'held firm', color: 'steel', meaning: 'truth, mental power' },
      { object: 'crown', position: 'on sword tip', color: 'gold', meaning: 'victory of mind' },
      { object: 'laurel and palm', position: 'on crown', meaning: 'triumph, peace' },
      { object: 'mountains', position: 'background', meaning: 'challenges to overcome' }
    ],
    dominantColors: [
      { color: 'gray', meaning: 'clarity, neutrality' },
      { color: 'white', meaning: 'purity of thought' },
      { color: 'gold', meaning: 'crowned truth' }
    ],
    composition: 'triumphant-blade',
    archetype: 'Mental Breakthrough'
  },
  47: { // Two of Swords
    symbols: [
      { object: 'blindfolded figure', position: 'seated', meaning: 'blocked sight, indecision' },
      { object: 'crossed swords', position: 'held in balance', meaning: 'stalemate, equilibrium' },
      { object: 'crescent moon', position: 'overhead', meaning: 'intuition needed' },
      { object: 'rocks in water', position: 'background', meaning: 'hidden obstacles' },
      { object: 'white robe', position: 'on figure', meaning: 'purity, neutrality' }
    ],
    dominantColors: [
      { color: 'white', meaning: 'neutrality, purity' },
      { color: 'blue', meaning: 'calm surface, hidden depth' },
      { color: 'gray', meaning: 'uncertainty' }
    ],
    composition: 'blindfolded-balance',
    archetype: 'Suspended Decision'
  },
  48: { // Three of Swords
    symbols: [
      { object: 'heart', position: 'center', color: 'red', meaning: 'emotional core' },
      { object: 'three swords', position: 'piercing heart', meaning: 'heartbreak, sorrow' },
      { object: 'rain clouds', position: 'background', color: 'gray', meaning: 'grief, tears' },
      { object: 'rain', position: 'falling', meaning: 'cleansing sorrow' }
    ],
    dominantColors: [
      { color: 'gray', meaning: 'sorrow, pain' },
      { color: 'red', meaning: 'wounded heart' },
      { color: 'silver', meaning: 'piercing truth' }
    ],
    composition: 'pierced-heart',
    archetype: 'Heartbreak'
  },
  49: { // Four of Swords
    symbols: [
      { object: 'effigy', position: 'lying in repose', meaning: 'rest, meditation' },
      { object: 'three swords', position: 'on wall', meaning: 'suspended conflict' },
      { object: 'one sword', position: 'beneath effigy', meaning: 'retained awareness' },
      { object: 'praying hands', position: 'on effigy', meaning: 'contemplation, prayer' },
      { object: 'stained glass', position: 'window', meaning: 'sanctuary, sacred space' }
    ],
    dominantColors: [
      { color: 'gold', meaning: 'sacred rest' },
      { color: 'blue', meaning: 'peace, meditation' },
      { color: 'gray', meaning: 'stillness' }
    ],
    composition: 'resting-warrior',
    archetype: 'Meditative Retreat'
  },
  50: { // Five of Swords
    symbols: [
      { object: 'victor', position: 'foreground with smirk', meaning: 'hollow victory' },
      { object: 'five swords', position: 'three held, two abandoned', meaning: 'conflict, defeat' },
      { object: 'defeated figures', position: 'walking away', meaning: 'loss, retreat' },
      { object: 'turbulent sky', position: 'background', meaning: 'discord, unrest' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'envy, discord' },
      { color: 'gray', meaning: 'conflict, tension' },
      { color: 'blue', meaning: 'troubled waters' }
    ],
    composition: 'pyrrhic-victory',
    archetype: 'Hollow Victor'
  },
  51: { // Six of Swords
    symbols: [
      { object: 'boat', position: 'crossing water', meaning: 'transition, passage' },
      { object: 'ferryman', position: 'poling boat', meaning: 'guidance through difficulty' },
      { object: 'woman and child', position: 'passengers', meaning: 'vulnerable travelers' },
      { object: 'six swords', position: 'standing in boat', meaning: 'carried troubles' },
      { object: 'rough water', position: 'left behind', meaning: 'past turmoil' },
      { object: 'calm water', position: 'ahead', meaning: 'future peace' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'emotional journey' },
      { color: 'gray', meaning: 'somber passage' },
      { color: 'yellow', meaning: 'hope ahead' }
    ],
    composition: 'crossing-waters',
    archetype: 'Guided Transition'
  },
  52: { // Seven of Swords
    symbols: [
      { object: 'sneaking figure', position: 'tiptoeing away', meaning: 'stealth, evasion' },
      { object: 'five swords', position: 'bundled in arms', meaning: 'theft, strategy' },
      { object: 'two swords', position: 'left behind', meaning: 'incomplete plan' },
      { object: 'military camp', position: 'background', meaning: 'enemy territory' },
      { object: 'backwards glance', position: 'on figure', meaning: 'caution, guilt' }
    ],
    dominantColors: [
      { color: 'yellow', meaning: 'caution, deception' },
      { color: 'red', meaning: 'danger, urgency' },
      { color: 'orange', meaning: 'cunning' }
    ],
    composition: 'stealthy-escape',
    archetype: 'Cunning Strategist'
  },
  53: { // Eight of Swords
    symbols: [
      { object: 'bound figure', position: 'standing', meaning: 'restriction, helplessness' },
      { object: 'blindfold', position: 'on eyes', meaning: 'self-imposed limitation' },
      { object: 'eight swords', position: 'surrounding loosely', meaning: 'mental prison' },
      { object: 'muddy ground', position: 'at feet', meaning: 'stuck, unclear' },
      { object: 'castle', position: 'distant background', meaning: 'freedom within reach' },
      { object: 'loose bindings', position: 'on figure', meaning: 'escapable situation' }
    ],
    dominantColors: [
      { color: 'gray', meaning: 'imprisonment, confusion' },
      { color: 'red', meaning: 'bound energy' },
      { color: 'blue', meaning: 'distant clarity' }
    ],
    composition: 'self-imprisoned',
    archetype: 'Voluntary Captive'
  },
  54: { // Nine of Swords
    symbols: [
      { object: 'figure', position: 'sitting up in bed', meaning: 'waking nightmare' },
      { object: 'hands on face', position: 'gesture of despair', meaning: 'anguish, worry' },
      { object: 'nine swords', position: 'on wall', meaning: 'mental torment' },
      { object: 'quilt', position: 'on bed', color: 'roses and astrological signs', meaning: 'beauty hidden by fear' },
      { object: 'darkness', position: 'background', meaning: 'night fears' }
    ],
    dominantColors: [
      { color: 'black', meaning: 'nightmares, anxiety' },
      { color: 'red', meaning: 'anguish' },
      { color: 'white', meaning: 'stark clarity of fear' }
    ],
    composition: 'anguished-waking',
    archetype: 'Anxious Mind'
  },
  55: { // Ten of Swords
    symbols: [
      { object: 'fallen figure', position: 'face-down', meaning: 'defeat, ending' },
      { object: 'ten swords', position: 'in back', meaning: 'betrayal, rock bottom' },
      { object: 'black sky', position: 'above', meaning: 'darkest hour' },
      { object: 'dawn light', position: 'horizon', color: 'yellow', meaning: 'new beginning coming' },
      { object: 'calm water', position: 'background', meaning: 'peace after storm' },
      { object: 'red cloak', position: 'on figure', meaning: 'life force, drama' }
    ],
    dominantColors: [
      { color: 'black', meaning: 'ending, finality' },
      { color: 'yellow', meaning: 'approaching dawn' },
      { color: 'red', meaning: 'dramatic conclusion' }
    ],
    composition: 'dramatic-ending',
    archetype: 'Complete Defeat / New Dawn'
  },
  56: { // Page of Swords
    symbols: [
      { object: 'youth', position: 'standing alert', meaning: 'mental vigilance' },
      { object: 'sword', position: 'raised defensively', color: 'steel', meaning: 'intellectual readiness' },
      { object: 'turbulent clouds', position: 'background', meaning: 'mental activity' },
      { object: 'birds', position: 'in flight', meaning: 'thoughts, messages' },
      { object: 'uneven ground', position: 'beneath', meaning: 'testing ideas' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'growth of ideas' },
      { color: 'yellow', meaning: 'mental energy' },
      { color: 'blue', meaning: 'communication' }
    ],
    composition: 'alert-student',
    archetype: 'Curious Investigator'
  },
  57: { // Knight of Swords
    symbols: [
      { object: 'charging knight', position: 'on galloping horse', meaning: 'swift action' },
      { object: 'raised sword', position: 'held high', meaning: 'aggressive intellect' },
      { object: 'white horse', position: 'at full gallop', meaning: 'speed, intensity' },
      { object: 'windswept clouds', position: 'background', meaning: 'mental storm' },
      { object: 'birds', position: 'scattered', meaning: 'disrupted thoughts' },
      { object: 'trees bent', position: 'by wind', meaning: 'force of will' }
    ],
    dominantColors: [
      { color: 'white', meaning: 'clarity, speed' },
      { color: 'blue', meaning: 'intellectual force' },
      { color: 'gray', meaning: 'stormy energy' }
    ],
    composition: 'charging-warrior',
    archetype: 'Forceful Intellect'
  },
  58: { // Queen of Swords
    symbols: [
      { object: 'enthroned queen', position: 'upright', meaning: 'clear judgment' },
      { object: 'upright sword', position: 'in right hand', meaning: 'discernment, truth' },
      { object: 'raised left hand', position: 'beckoning', meaning: 'invitation to honesty' },
      { object: 'butterflies', position: 'on throne', meaning: 'transformation through clarity' },
      { object: 'clouds', position: 'background', meaning: 'mental realm' },
      { object: 'bird', position: 'in sky', meaning: 'freedom of thought' }
    ],
    dominantColors: [
      { color: 'blue', meaning: 'clear thought' },
      { color: 'white', meaning: 'purity of mind' },
      { color: 'gray', meaning: 'objectivity' }
    ],
    composition: 'judicious-sovereign',
    archetype: 'Clear-Minded Judge'
  },
  59: { // King of Swords
    symbols: [
      { object: 'enthroned king', position: 'upright', meaning: 'intellectual authority' },
      { object: 'upright sword', position: 'in right hand', meaning: 'justice, logic' },
      { object: 'butterflies', position: 'on throne', meaning: 'mental transformation' },
      { object: 'crescent moons', position: 'on throne', meaning: 'intuitive intellect' },
      { object: 'trees', position: 'background left', meaning: 'natural wisdom' },
      { object: 'clouds', position: 'background right', meaning: 'realm of ideas' }
    ],
    dominantColors: [
      { color: 'purple', meaning: 'wisdom, authority' },
      { color: 'blue', meaning: 'mental mastery' },
      { color: 'white', meaning: 'objective truth' }
    ],
    composition: 'authoritative-judge',
    archetype: 'Intellectual Master'
  },

  // PENTACLES (60-73)
  60: { // Ace of Pentacles
    symbols: [
      { object: 'hand', position: 'from cloud', meaning: 'divine gift' },
      { object: 'pentacle', position: 'held forth', color: 'gold', meaning: 'material opportunity' },
      { object: 'garden', position: 'below', color: 'lush', meaning: 'fertile ground' },
      { object: 'archway', position: 'background', meaning: 'entrance to manifestation' },
      { object: 'mountains', position: 'distant', meaning: 'long-term goals' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'growth, prosperity' },
      { color: 'gold', meaning: 'wealth, potential' },
      { color: 'white', meaning: 'pure opportunity' }
    ],
    composition: 'offered-abundance',
    archetype: 'Material Seed'
  },
  61: { // Two of Pentacles
    symbols: [
      { object: 'juggler', position: 'in motion', meaning: 'balance, adaptability' },
      { object: 'two pentacles', position: 'in infinity loop', color: 'gold', meaning: 'dynamic balance' },
      { object: 'infinity symbol', position: 'formed by ribbon', meaning: 'endless cycle' },
      { object: 'ships on waves', position: 'background', meaning: 'ups and downs' },
      { object: 'dancing posture', position: 'on figure', meaning: 'graceful adjustment' }
    ],
    dominantColors: [
      { color: 'red', meaning: 'energy, action' },
      { color: 'blue', meaning: 'flow, adaptation' },
      { color: 'gold', meaning: 'value in motion' }
    ],
    composition: 'dynamic-juggling',
    archetype: 'Flexible Balancer'
  },
  62: { // Three of Pentacles
    symbols: [
      { object: 'craftsman', position: 'on bench', meaning: 'skilled work' },
      { object: 'architect and monk', position: 'consulting', meaning: 'collaboration, expertise' },
      { object: 'three pentacles', position: 'in archway', color: 'carved', meaning: 'recognized skill' },
      { object: 'cathedral', position: 'being built', meaning: 'sacred work' },
      { object: 'plans', position: 'held', meaning: 'design, planning' }
    ],
    dominantColors: [
      { color: 'gray', meaning: 'stone, foundation' },
      { color: 'gold', meaning: 'valued skill' },
      { color: 'brown', meaning: 'earthly craft' }
    ],
    composition: 'collaborative-craft',
    archetype: 'Master Craftsperson'
  },
  63: { // Four of Pentacles
    symbols: [
      { object: 'seated figure', position: 'on cube', meaning: 'stability, control' },
      { object: 'pentacle on crown', position: 'head', meaning: 'fixation on security' },
      { object: 'pentacle clasped', position: 'to chest', meaning: 'holding tight' },
      { object: 'pentacles under feet', position: 'grounded on', meaning: 'possessiveness' },
      { object: 'city', position: 'background', meaning: 'material world' }
    ],
    dominantColors: [
      { color: 'gray', meaning: 'rigidity, control' },
      { color: 'gold', meaning: 'hoarded wealth' },
      { color: 'red', meaning: 'fear of loss' }
    ],
    composition: 'guarded-possession',
    archetype: 'Cautious Hoarder'
  },
  64: { // Five of Pentacles
    symbols: [
      { object: 'two beggars', position: 'in snow', meaning: 'hardship, poverty' },
      { object: 'crutches', position: 'supporting one', meaning: 'injury, need' },
      { object: 'stained glass window', position: 'above', color: 'five pentacles lit', meaning: 'help available' },
      { object: 'church', position: 'beside them', meaning: 'sanctuary ignored' },
      { object: 'snow', position: 'falling', meaning: 'cold, isolation' }
    ],
    dominantColors: [
      { color: 'black', meaning: 'hardship, darkness' },
      { color: 'white', meaning: 'cold, barrenness' },
      { color: 'gold', meaning: 'unnoticed help' }
    ],
    composition: 'passing-sanctuary',
    archetype: 'Suffering Outsider'
  },
  65: { // Six of Pentacles
    symbols: [
      { object: 'merchant', position: 'standing', meaning: 'generosity, power' },
      { object: 'scales', position: 'in left hand', color: 'balanced', meaning: 'fair exchange' },
      { object: 'coins', position: 'given from right hand', meaning: 'charity, sharing' },
      { object: 'two beggars', position: 'kneeling', meaning: 'receiving, dependence' },
      { object: 'six pentacles', position: 'on ground', meaning: 'distributed wealth' }
    ],
    dominantColors: [
      { color: 'purple', meaning: 'wealth, generosity' },
      { color: 'red', meaning: 'action, giving' },
      { color: 'gold', meaning: 'prosperity shared' }
    ],
    composition: 'generous-exchange',
    archetype: 'Benevolent Giver'
  },
  66: { // Seven of Pentacles
    symbols: [
      { object: 'farmer', position: 'leaning on hoe', meaning: 'pause, assessment' },
      { object: 'seven pentacles', position: 'on vine', color: 'growing', meaning: 'investment bearing fruit' },
      { object: 'cultivated plants', position: 'foreground', meaning: 'labor, patience' },
      { object: 'contemplative posture', position: 'on figure', meaning: 'evaluation, waiting' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'growth, patience' },
      { color: 'gold', meaning: 'developing rewards' },
      { color: 'brown', meaning: 'earthly effort' }
    ],
    composition: 'patient-cultivator',
    archetype: 'Patient Investor'
  },
  67: { // Eight of Pentacles
    symbols: [
      { object: 'craftsman', position: 'at bench', meaning: 'dedication, skill' },
      { object: 'hammer and chisel', position: 'in hands', meaning: 'focused work' },
      { object: 'eight pentacles', position: 'six completed, one in progress, one waiting', meaning: 'methodical mastery' },
      { object: 'town', position: 'distant', meaning: 'isolation for focus' },
      { object: 'apron', position: 'on figure', meaning: 'practical work' }
    ],
    dominantColors: [
      { color: 'gray', meaning: 'discipline, craft' },
      { color: 'gold', meaning: 'skill developing' },
      { color: 'red', meaning: 'effort, dedication' }
    ],
    composition: 'devoted-artisan',
    archetype: 'Diligent Apprentice'
  },
  68: { // Nine of Pentacles
    symbols: [
      { object: 'elegant figure', position: 'in garden', meaning: 'self-sufficiency, luxury' },
      { object: 'hooded falcon', position: 'on hand', meaning: 'discipline, self-control' },
      { object: 'nine pentacles', position: 'on grapevines', color: 'abundant', meaning: 'earned prosperity' },
      { object: 'manor', position: 'background', meaning: 'established wealth' },
      { object: 'snail', position: 'at base', meaning: 'slow, steady progress' }
    ],
    dominantColors: [
      { color: 'yellow', meaning: 'achievement, satisfaction' },
      { color: 'green', meaning: 'abundance, nature' },
      { color: 'gold', meaning: 'refined success' }
    ],
    composition: 'self-sufficient-grace',
    archetype: 'Independent Achiever'
  },
  69: { // Ten of Pentacles
    symbols: [
      { object: 'elder', position: 'seated', meaning: 'legacy, wisdom' },
      { object: 'family', position: 'in courtyard', meaning: 'generations, inheritance' },
      { object: 'child', position: 'with dogs', meaning: 'future, innocence' },
      { object: 'ten pentacles', position: 'in Tree of Life pattern', meaning: 'complete manifestation' },
      { object: 'archway', position: 'entrance', meaning: 'established home' },
      { object: 'coat of arms', position: 'on wall', meaning: 'lineage, tradition' }
    ],
    dominantColors: [
      { color: 'gold', meaning: 'wealth, completion' },
      { color: 'red', meaning: 'vitality, family' },
      { color: 'white', meaning: 'purity of legacy' }
    ],
    composition: 'generational-prosperity',
    archetype: 'Legacy Builder'
  },
  70: { // Page of Pentacles
    symbols: [
      { object: 'youth', position: 'standing in field', meaning: 'practical learning' },
      { object: 'pentacle', position: 'held aloft', color: 'gold', meaning: 'new opportunity' },
      { object: 'flowering field', position: 'surrounding', meaning: 'fertile ground' },
      { object: 'mountains', position: 'distant', meaning: 'future goals' },
      { object: 'absorbed gaze', position: 'on pentacle', meaning: 'focus, study' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'growth, potential' },
      { color: 'gold', meaning: 'opportunity, value' },
      { color: 'brown', meaning: 'grounded learning' }
    ],
    composition: 'studious-youth',
    archetype: 'Eager Student'
  },
  71: { // Knight of Pentacles
    symbols: [
      { object: 'armored knight', position: 'on heavy horse', meaning: 'methodical progress' },
      { object: 'pentacle', position: 'held carefully', color: 'gold', meaning: 'cautious responsibility' },
      { object: 'black horse', position: 'standing still', meaning: 'patience, steadiness' },
      { object: 'plowed field', position: 'background', meaning: 'prepared ground' },
      { object: 'solid posture', position: 'on figure', meaning: 'reliability' }
    ],
    dominantColors: [
      { color: 'black', meaning: 'steadiness, solidity' },
      { color: 'green', meaning: 'practical growth' },
      { color: 'gold', meaning: 'valued work' }
    ],
    composition: 'steady-guardian',
    archetype: 'Reliable Worker'
  },
  72: { // Queen of Pentacles
    symbols: [
      { object: 'enthroned queen', position: 'in nature', meaning: 'nurturing abundance' },
      { object: 'pentacle', position: 'gazed upon in lap', color: 'gold', meaning: 'material wisdom' },
      { object: 'rabbit', position: 'at feet', meaning: 'fertility, prosperity' },
      { object: 'roses', position: 'surrounding throne', color: 'red', meaning: 'beauty, sensuality' },
      { object: 'fruit trees', position: 'background', meaning: 'cultivated abundance' },
      { object: 'goat', position: 'on throne', meaning: 'Capricorn, earthly mastery' }
    ],
    dominantColors: [
      { color: 'green', meaning: 'nature, nurturing' },
      { color: 'red', meaning: 'sensual vitality' },
      { color: 'gold', meaning: 'generous prosperity' }
    ],
    composition: 'nurturing-sovereign',
    archetype: 'Abundant Nurturer'
  },
  73: { // King of Pentacles
    symbols: [
      { object: 'enthroned king', position: 'in castle', meaning: 'mastered wealth' },
      { object: 'pentacle', position: 'in right hand', color: 'gold', meaning: 'material success' },
      { object: 'scepter', position: 'in left hand', meaning: 'authority, control' },
      { object: 'bull', position: 'on throne', meaning: 'Taurus, earthly power' },
      { object: 'grapes', position: 'on robe', meaning: 'abundance, luxury' },
      { object: 'castle', position: 'background', meaning: 'established empire' },
      { object: 'roses', position: 'at base', color: 'blooming', meaning: 'cultivated success' }
    ],
    dominantColors: [
      { color: 'purple', meaning: 'wealth, royalty' },
      { color: 'gold', meaning: 'mastered prosperity' },
      { color: 'green', meaning: 'sustained growth' }
    ],
    composition: 'prosperous-sovereign',
    archetype: 'Material Master'
  },

  // WANDS COURT CARDS (74-77)
  74: { // Page of Wands
    symbols: [
      { object: 'youth', position: 'standing alert', meaning: 'enthusiasm, exploration' },
      { object: 'sprouting wand', position: 'held upright', color: 'green leaves', meaning: 'creative potential' },
      { object: 'pyramids', position: 'background', meaning: 'ancient wisdom, adventure' },
      { object: 'salamanders', position: 'on tunic', color: 'orange', meaning: 'fire element, transformation' },
      { object: 'desert', position: 'surrounding', meaning: 'unexplored territory' }
    ],
    dominantColors: [
      { color: 'orange', meaning: 'creative fire' },
      { color: 'yellow', meaning: 'optimism, exploration' },
      { color: 'green', meaning: 'fresh growth' }
    ],
    composition: 'eager-explorer',
    archetype: 'Enthusiastic Messenger'
  },
  75: { // Knight of Wands
    symbols: [
      { object: 'armored knight', position: 'on rearing horse', meaning: 'passionate action' },
      { object: 'sprouting wand', position: 'held aloft', color: 'green', meaning: 'living energy' },
      { object: 'yellow horse', position: 'mid-leap', meaning: 'enthusiasm, speed' },
      { object: 'salamanders', position: 'on armor', color: 'orange', meaning: 'fire spirit' },
      { object: 'pyramids', position: 'distant', meaning: 'questing spirit' },
      { object: 'plume', position: 'on helmet', color: 'red', meaning: 'bold confidence' }
    ],
    dominantColors: [
      { color: 'yellow', meaning: 'energy, action' },
      { color: 'red', meaning: 'passion, courage' },
      { color: 'orange', meaning: 'creative fire' }
    ],
    composition: 'charging-adventurer',
    archetype: 'Passionate Adventurer'
  },
  76: { // Queen of Wands
    symbols: [
      { object: 'enthroned queen', position: 'confident', meaning: 'creative leadership' },
      { object: 'sprouting wand', position: 'in right hand', color: 'green', meaning: 'living inspiration' },
      { object: 'sunflower', position: 'in left hand', meaning: 'vitality, warmth' },
      { object: 'black cat', position: 'at feet', meaning: 'independence, intuition' },
      { object: 'lions', position: 'on throne', meaning: 'courage, strength' },
      { object: 'pyramids', position: 'background', meaning: 'enduring power' }
    ],
    dominantColors: [
      { color: 'yellow', meaning: 'warmth, vitality' },
      { color: 'orange', meaning: 'creative fire' },
      { color: 'red', meaning: 'passionate leadership' }
    ],
    composition: 'radiant-sovereign',
    archetype: 'Charismatic Leader'
  },
  77: { // King of Wands
    symbols: [
      { object: 'enthroned king', position: 'commanding', meaning: 'visionary leadership' },
      { object: 'sprouting wand', position: 'held firmly', color: 'green leaves', meaning: 'living vision' },
      { object: 'lions', position: 'on throne and at feet', meaning: 'courage, dominance' },
      { object: 'salamanders', position: 'on robe and throne', color: 'orange', meaning: 'fire mastery' },
      { object: 'crown', position: 'on head', color: 'gold', meaning: 'creative authority' },
      { object: 'salamander biting tail', position: 'at base', meaning: 'self-sustaining energy' }
    ],
    dominantColors: [
      { color: 'orange', meaning: 'creative mastery' },
      { color: 'red', meaning: 'bold leadership' },
      { color: 'gold', meaning: 'visionary authority' }
    ],
    composition: 'commanding-sovereign',
    archetype: 'Visionary Entrepreneur'
  }
};

export function getSymbolAnnotation(cardNumber) {
  return SYMBOL_ANNOTATIONS[cardNumber] || null;
}
</file>

<file path="shared/vision/cardNameMapping.js">
import { MAJOR_ARCANA } from '../../src/data/majorArcana.js';
import { MINOR_ARCANA } from '../../src/data/minorArcana.js';
import { getDeckAlias } from './deckAssets.js';

const aliasCache = new Map();

function normalizeKey(value) {
  if (typeof value !== 'string') return null;
  const trimmed = value.trim().toLowerCase();
  return trimmed || null;
}

function registerName(map, name, canonical) {
  const key = normalizeKey(name);
  if (!key || map.has(key)) {
    return;
  }
  map.set(key, canonical);
}

function registerAliasVariants(map, alias, canonical) {
  if (!alias) return;
  registerName(map, alias, canonical);

  if (alias.includes('(') && alias.includes(')')) {
    const before = alias.split('(')[0];
    registerName(map, before, canonical);
    const inside = alias.slice(alias.indexOf('(') + 1, alias.indexOf(')'));
    registerName(map, inside, canonical);
  }
}

function buildAliasMap(deckStyle = 'rws-1909') {
  const map = new Map();
  const cards = [...MAJOR_ARCANA, ...MINOR_ARCANA];

  // FIRST PASS: Register deck-specific aliases (Thoth, Marseille) → RWS canonical names
  // This must happen BEFORE registering RWS self-references to avoid collision
  // e.g., Thoth "Knight of Cups" → RWS "King of Cups" must be registered
  // before RWS "Knight of Cups" → "Knight of Cups"
  if (deckStyle !== 'rws-1909') {
    cards.forEach((card) => {
      if (!card?.name) return;
      const alias = getDeckAlias(card, deckStyle);
      if (alias && alias !== card.name) {
        registerAliasVariants(map, alias, card.name);
      }
    });
  }

  // SECOND PASS: Register RWS canonical names → themselves
  // This allows RWS names to work as-is, while deck aliases take priority
  cards.forEach((card) => {
    if (!card?.name) return;
    registerName(map, card.name, card.name);
  });

  return map;
}

export function canonicalizeCardName(name, deckStyle = 'rws-1909') {
  const key = normalizeKey(name);
  if (!key) return null;
  if (!aliasCache.has(deckStyle)) {
    aliasCache.set(deckStyle, buildAliasMap(deckStyle));
  }
  const lookup = aliasCache.get(deckStyle);
  return lookup.get(key) || (typeof name === 'string' ? name.trim() : null);
}

export function canonicalCardKey(name, deckStyle = 'rws-1909') {
  const canonical = canonicalizeCardName(name, deckStyle);
  return canonical ? canonical.toLowerCase() : null;
}
</file>

<file path="shared/vision/deckAssets.js">
export const THOTH_MAJOR_ALIASES = {
  0: 'The Fool',
  1: 'The Magus',
  2: 'The Priestess',
  3: 'The Empress',
  4: 'The Emperor',
  5: 'The Hierophant',
  6: 'The Lovers',
  7: 'The Chariot',
  8: 'Adjustment',
  9: 'The Hermit',
  10: 'Fortune',
  11: 'Lust',
  12: 'The Hanged Man',
  13: 'Death',
  14: 'Art',
  15: 'The Devil',
  16: 'The Tower',
  17: 'The Star',
  18: 'The Moon',
  19: 'The Sun',
  20: 'The Aeon',
  21: 'The Universe'
};

const THOTH_MINOR_TITLES = {
  Wands: {
    1: 'Root of Fire',
    2: 'Dominion',
    3: 'Virtue',
    4: 'Completion',
    5: 'Strife',
    6: 'Victory',
    7: 'Valour',
    8: 'Swiftness',
    9: 'Strength',
    10: 'Oppression'
  },
  Cups: {
    1: 'Root of Water',
    2: 'Love',
    3: 'Abundance',
    4: 'Luxury',
    5: 'Disappointment',
    6: 'Pleasure',
    7: 'Debauch',
    8: 'Indolence',
    9: 'Happiness',
    10: 'Satiety'
  },
  Swords: {
    1: 'Root of Air',
    2: 'Peace',
    3: 'Sorrow',
    4: 'Truce',
    5: 'Defeat',
    6: 'Science',
    7: 'Futility',
    8: 'Interference',
    9: 'Cruelty',
    10: 'Ruin'
  },
  Pentacles: {
    1: 'Root of Earth',
    2: 'Change',
    3: 'Works',
    4: 'Power',
    5: 'Worry',
    6: 'Success',
    7: 'Failure',
    8: 'Prudence',
    9: 'Gain',
    10: 'Wealth'
  }
};

const THOTH_SUIT_ALIASES = {
  Pentacles: 'Disks',
  Wands: 'Wands',
  Cups: 'Cups',
  Swords: 'Swords'
};

const THOTH_COURT_ALIASES = {
  Page: 'Princess',
  Knight: 'Prince',
  Queen: 'Queen',
  King: 'Knight'
};

const THOTH_RANK_LABELS = {
  1: 'Ace',
  2: 'Two',
  3: 'Three',
  4: 'Four',
  5: 'Five',
  6: 'Six',
  7: 'Seven',
  8: 'Eight',
  9: 'Nine',
  10: 'Ten'
};

export const MARSEILLE_MAJOR_ALIASES = {
  0: 'Le Mat',
  1: 'Le Bateleur',
  2: 'La Papesse',
  3: "L'Imperatrice",
  4: "L'Empereur",
  5: 'Le Pape',
  6: "L'Amoureux",
  7: 'Le Chariot',
  8: 'La Justice',
  9: "L'Hermite",
 10: 'La Roue de Fortune',
 11: 'La Force',
 12: 'Le Pendu',
 13: 'La Mort',
 14: 'Temperance',
 15: 'Le Diable',
 16: 'La Maison Dieu',
 17: "L'Etoile",
 18: 'La Lune',
 19: 'Le Soleil',
 20: 'Le Jugement',
 21: 'Le Monde'
};

const MARSEILLE_SUIT_PREFIX = {
  Wands: 'clubs',
  Cups: 'cups',
  Swords: 'swords',
  Pentacles: 'coins'
};

const MARSEILLE_SUIT_ALIASES = {
  Wands: 'Batons',
  Cups: 'Coupes',
  Swords: 'Epees',
  Pentacles: 'Coins'
};

const MARSEILLE_COURT_ALIASES = {
  Page: 'Valet',
  Knight: 'Chevalier',
  Queen: 'Reine',
  King: 'Roi'
};

const slugify = (value = '') =>
  value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '');

const pad2 = (value) => String(value ?? '').padStart(2, '0');

function buildThothMinorAlias(card) {
  const suitTitles = THOTH_MINOR_TITLES[card?.suit];
  if (!suitTitles || typeof card?.rankValue !== 'number') {
    return card?.name || 'Unknown card';
  }
  const suitAlias = THOTH_SUIT_ALIASES[card.suit] || card.suit;
  if (card.rankValue >= 11) {
    const baseRank = { 11: 'Page', 12: 'Knight', 13: 'Queen', 14: 'King' }[card.rankValue];
    const aliasRank = THOTH_COURT_ALIASES[baseRank] || baseRank || 'Court';
    return `${aliasRank} of ${suitAlias}`;
  }
  const rankLabel = THOTH_RANK_LABELS[card.rankValue] || card.rank;
  const epithet = suitTitles[card.rankValue];
  if (epithet) {
    return `${epithet} (${rankLabel} of ${suitAlias})`;
  }
  return `${rankLabel} of ${suitAlias}`;
}

export function getThothAlias(card) {
  if (typeof card?.number === 'number') {
    return THOTH_MAJOR_ALIASES[card.number] || card?.name || 'Major Arcana';
  }
  return buildThothMinorAlias(card);
}

export function getThothImagePath(card) {
  if (typeof card?.number === 'number') {
    const alias = getThothAlias(card);
    return `/images/cards/thoth/thoth_major_${pad2(card.number)}_${slugify(alias)}.png`;
  }
  if (!card?.suit || typeof card?.rankValue !== 'number') {
    return null;
  }
  const suitAlias = (THOTH_SUIT_ALIASES[card.suit] || card.suit).toLowerCase();
  if (card.rankValue >= 11) {
    const baseRank = { 11: 'Page', 12: 'Knight', 13: 'Queen', 14: 'King' }[card.rankValue];
    const aliasRank = THOTH_COURT_ALIASES[baseRank] || baseRank || 'Court';
    return `/images/cards/thoth/thoth_${suitAlias}_${pad2(card.rankValue)}_${slugify(
      `${aliasRank}-${suitAlias}`
    )}.png`;
  }
  const rankLabel = THOTH_RANK_LABELS[card.rankValue] || card.rank || card.rankValue;
  const epithet = THOTH_MINOR_TITLES[card.suit]?.[card.rankValue];
  const slugSource = epithet ? `${rankLabel}-${suitAlias}-${epithet}` : `${rankLabel}-${suitAlias}`;
  return `/images/cards/thoth/thoth_${suitAlias}_${pad2(card.rankValue)}_${slugify(slugSource)}.png`;
}

export function getMarseilleAlias(card) {
  if (typeof card?.number === 'number') {
    const alias = MARSEILLE_MAJOR_ALIASES[card.number];
    if (alias) {
      return card?.name && card.name !== alias ? `${alias} (RWS: ${card.name})` : alias;
    }
  }
  if (card?.suit && card?.rank) {
    const suitAlias = MARSEILLE_SUIT_ALIASES[card.suit] || card.suit;
    const rankAlias = MARSEILLE_COURT_ALIASES[card.rank] || card.rank;
    const label = `${rankAlias} of ${suitAlias}`;
    if (card?.name && card.name !== label) {
      return `${label} (RWS: ${card.name})`;
    }
    return label;
  }
  return card?.name || 'Tarot de Marseille card';
}

export function getMarseilleImagePath(card) {
  if (typeof card?.number === 'number') {
    return `/images/cards/marseille/major${pad2(card.number)}.jpg`;
  }
  if (!card?.suit || typeof card?.rankValue !== 'number') {
    return null;
  }
  const prefix = MARSEILLE_SUIT_PREFIX[card.suit];
  if (!prefix) return null;
  return `/images/cards/marseille/${prefix}${pad2(card.rankValue)}.jpg`;
}

export function getDeckAlias(card, deckId) {
  if (deckId === 'thoth-a1') {
    return getThothAlias(card);
  }
  if (deckId === 'marseille-classic') {
    return getMarseilleAlias(card);
  }
  return card?.name || 'Tarot card';
}

export function getDeckImagePath(card, deckId) {
  if (deckId === 'thoth-a1') {
    return getThothImagePath(card);
  }
  if (deckId === 'marseille-classic') {
    return getMarseilleImagePath(card);
  }
  return card?.image || null;
}

export function getDeckSuitAlias(suit, deckId) {
  if (!suit) return suit;
  if (deckId === 'thoth-a1') {
    return THOTH_SUIT_ALIASES[suit] || suit;
  }
  if (deckId === 'marseille-classic') {
    return MARSEILLE_SUIT_ALIASES[suit] || suit;
  }
  return suit;
}

export function getDeckCourtAlias(rank, deckId) {
  if (!rank) return rank;
  if (deckId === 'thoth-a1') {
    return THOTH_COURT_ALIASES[rank] || rank;
  }
  if (deckId === 'marseille-classic') {
    return MARSEILLE_COURT_ALIASES[rank] || rank;
  }
  return rank;
}
</file>

<file path="shared/vision/deckProfiles.js">
import {
  getThothAlias,
  getThothImagePath,
  getMarseilleAlias,
  getMarseilleImagePath,
  getDeckSuitAlias,
  getDeckCourtAlias
} from './deckAssets.js';

const DECK_PROFILES = {
  'rws-1909': {
    id: 'rws-1909',
    label: 'Rider-Waite-Smith (1909)',
    promptCue:
      'Classic Pamela Colman Smith watercolor palette with bold ink outlines and theatrical staging.',
    palette: ['sunlit yellows', 'lapis blues', 'crimson accents', 'stone gray backdrops'],
    texture: 'Hand-painted inks on watercolor paper with a slightly muted finish.',
    aliasResolver: (card) => card?.name || 'Tarot card',
    imageResolver: (card) => card?.image || null,
    assetScanDir: '.',
    suitAliasResolver: (suit) => getDeckSuitAlias(suit, 'rws-1909'),
    courtAliasResolver: (rank) => getDeckCourtAlias(rank, 'rws-1909')
  },
  'thoth-a1': {
    id: 'thoth-a1',
    label: 'Thoth (Crowley/Harris A1)',
    promptCue:
      'Abstract, prismatic geometry with layered astrological sigils and Art Deco gradients.',
    palette: ['electric teal', 'magenta', 'saffron gold', 'deep indigo shadows'],
    texture: 'Oil and watercolor washes blended into airbrushed gradients.',
    aliasResolver: getThothAlias,
    imageResolver: getThothImagePath,
    assetScanDir: 'thoth',
    suitAliasResolver: (suit) => getDeckSuitAlias(suit, 'thoth-a1'),
    courtAliasResolver: (rank) => getDeckCourtAlias(rank, 'thoth-a1')
  },
  'marseille-classic': {
    id: 'marseille-classic',
    label: 'Tarot de Marseille (18th century scans)',
    promptCue: 'Woodcut line work with flat primary colors and medieval heraldry.',
    palette: ['carmine red', 'cobalt blue', 'sunflower yellow', 'bone white'],
    texture: 'Bold, block-printed textures with minimal shading.',
    aliasResolver: getMarseilleAlias,
    imageResolver: getMarseilleImagePath,
    assetScanDir: 'marseille',
    suitAliasResolver: (suit) => getDeckSuitAlias(suit, 'marseille-classic'),
    courtAliasResolver: (rank) => getDeckCourtAlias(rank, 'marseille-classic')
  }
};

export function getDeckProfile(deckStyle = 'rws-1909') {
  return DECK_PROFILES[deckStyle] || DECK_PROFILES['rws-1909'];
}

export { DECK_PROFILES };
</file>

<file path="shared/vision/fineTuneCache.js">
let payloadPromise = null;
const deckCache = new Map();
let fsModulePromise = null;
let pathModulePromise = null;

function getFsModule() {
  if (!fsModulePromise) {
    if (typeof process === 'undefined' || process.release?.name !== 'node') {
      fsModulePromise = Promise.resolve(null);
    } else {
      fsModulePromise = import('node:fs/promises')
        .then((mod) => mod.default || mod)
        .catch(() => null);
    }
  }
  return fsModulePromise;
}

function getPathModule() {
  if (!pathModulePromise) {
    if (typeof process === 'undefined' || process.release?.name !== 'node') {
      pathModulePromise = Promise.resolve(null);
    } else {
      pathModulePromise = import('node:path')
        .then((mod) => mod.default || mod)
        .catch(() => null);
    }
  }
  return pathModulePromise;
}

async function resolveAdapterPath() {
  if (typeof process === 'undefined' || typeof process.cwd !== 'function') {
    return null;
  }
  if (process.env.VISION_ADAPTER_PATH) {
    return process.env.VISION_ADAPTER_PATH;
  }
  const path = await getPathModule();
  const cwd = process.cwd();
  if (path) {
    return path.resolve(cwd, 'data/vision/fine-tuned/prototypes.json');
  }
  return `${cwd}/data/vision/fine-tuned/prototypes.json`;
}

async function loadPayload() {
  if (payloadPromise) {
    return payloadPromise;
  }
  payloadPromise = (async () => {
    const fs = await getFsModule();
    if (!fs) {
      return null;
    }
    const adapterPath = await resolveAdapterPath();
    if (!adapterPath) {
      return null;
    }
    try {
      const raw = await fs.readFile(adapterPath, 'utf-8');
      return JSON.parse(raw);
    } catch (err) {
      if (err?.code !== 'ENOENT') {
        console.warn('[fineTuneCache] Unable to read fine-tuned prototypes:', err.message || err);
      }
      return null;
    }
  })();
  return payloadPromise;
}

export async function loadFineTunedPrototypes(deckStyle) {
  if (!deckStyle) {
    return null;
  }
  if (deckCache.has(deckStyle)) {
    return deckCache.get(deckStyle);
  }
  const payload = await loadPayload();
  const entry = payload?.deckStyles?.[deckStyle] || null;
  deckCache.set(deckStyle, entry);
  return entry;
}
</file>

<file path="shared/vision/minorSymbolLexicon.js">
const SUIT_SYNONYMS = {
  Batons: 'Wands',
  Staffs: 'Wands',
  Staves: 'Wands',
  Clubs: 'Wands',
  Coupes: 'Cups',
  Chalices: 'Cups',
  Epees: 'Swords',
  Blades: 'Swords',
  Coins: 'Pentacles',
  Disks: 'Pentacles',
  Discs: 'Pentacles',
  Deniers: 'Pentacles'
};

const RANK_SYNONYMS = {
  Princess: 'Page',
  Prince: 'Knight',
  Valet: 'Page',
  Chevalier: 'Knight',
  Reine: 'Queen',
  Roi: 'King'
};

const SUIT_CONTEXT = {
  Wands: {
    element: 'Fire',
    symbolSingular: 'budding wooden wand',
    symbolPlural: 'flame-etched wands',
    environment: 'desert horizon with pyramids and cloudless sky',
    palette: [
      { color: 'amber', meaning: 'creative ignition' },
      { color: 'saffron', meaning: 'bold confidence' },
      { color: 'sienna', meaning: 'grounded stamina' }
    ],
    suitSymbols: [
      { object: 'sprouting leaves on wands', position: 'around staves', meaning: 'living inspiration taking root' },
      { object: 'pyramids and bare mountains', position: 'distant horizon', meaning: 'long-range quests and tests' }
    ]
  },
  Cups: {
    element: 'Water',
    symbolSingular: 'ornate chalice overflowing with water',
    symbolPlural: 'engraved cups',
    environment: 'lush riverbanks with lotus and reflective pools',
    palette: [
      { color: 'cerulean', meaning: 'emotional clarity' },
      { color: 'seafoam', meaning: 'intuitive gentleness' },
      { color: 'silver', meaning: 'moonlit reflection' }
    ],
    suitSymbols: [
      { object: 'flowing streams', position: 'foreground waters', meaning: 'feelings in motion' },
      { object: 'lotus blossoms', position: 'near chalices', meaning: 'spiritual receptivity' }
    ]
  },
  Swords: {
    element: 'Air',
    symbolSingular: 'steel sword with gleaming edge',
    symbolPlural: 'razor-sharp swords',
    environment: 'wind-swept plains with storm clouds and distant mountains',
    palette: [
      { color: 'ice blue', meaning: 'detached insight' },
      { color: 'slate gray', meaning: 'mental trials' },
      { color: 'white', meaning: 'clarifying truth' }
    ],
    suitSymbols: [
      { object: 'storm clouds', position: 'upper sky', meaning: 'charged mental atmosphere' },
      { object: 'fluttering birds or banners', position: 'mid-air', meaning: 'swift messages and thoughts' }
    ]
  },
  Pentacles: {
    element: 'Earth',
    symbolSingular: 'engraved golden pentacle',
    symbolPlural: 'garden pentacles',
    environment: 'verdant fields, vineyards, and stone gateways',
    palette: [
      { color: 'forest green', meaning: 'steady growth' },
      { color: 'gold', meaning: 'material abundance' },
      { color: 'russet', meaning: 'grounded effort' }
    ],
    suitSymbols: [
      { object: 'cultivated fields', position: 'foreground earth', meaning: 'patient stewardship' },
      { object: 'stone archways', position: 'background structures', meaning: 'legacy and craftsmanship' }
    ]
  }
};

const RANK_BLUEPRINTS = {
  Ace: {
    archetype: (ctx) => `${ctx.element} Seed`,
    composition: 'divine-hand presents singular symbol against expansive sky',
    symbolTemplates: [
      { object: 'divine hand emerging from cloud with {symbolSingular}', position: 'center', meaning: `pure ${'{element}'} potential entering the scene` },
      { object: 'crown or laurels hovering', position: 'above symbol', meaning: 'gifted opportunity ready to be claimed' },
      { object: '{environment}', position: 'beneath hand', meaning: 'open landscape waiting for new action' }
    ]
  },
  Two: {
    archetype: (ctx) => `${ctx.element} Duality Gate`,
    composition: 'paired symbols framing a horizon line',
    symbolTemplates: [
      { object: 'two {symbolPlural}', position: 'foreground balancing posture', meaning: 'decision, contrast, or mirrored forces' },
      { object: 'crossed arms or stance', position: 'figure posture', meaning: 'moment of weighing possibilities' },
      { object: '{environment}', position: 'background', meaning: 'context that demands balanced planning' }
    ]
  },
  Three: {
    archetype: (ctx) => `${ctx.element} Expansion Arc`,
    composition: 'triad motif showing momentum or collaboration',
    symbolTemplates: [
      { object: 'three {symbolPlural}', position: 'arranged in progressive line', meaning: 'growth through cooperation and foresight' },
      { object: 'figure observing horizon or architecture', position: 'mid-scene', meaning: 'vision expanding outward' },
      { object: '{environment}', position: 'distance', meaning: 'opportunities launching beyond comfort zone' }
    ]
  },
  Four: {
    archetype: (ctx) => `${ctx.element} Foundation`,
    composition: 'square or pavilion structure implying stability',
    symbolTemplates: [
      { object: 'four {symbolPlural}', position: 'forming square/pillar', meaning: 'structure, ritual, milestone' },
      { object: 'seated or standing figure', position: 'center', meaning: 'holding space, pausing to appreciate' },
      { object: '{environment}', position: 'surroundings', meaning: 'sheltered stage for celebration or rest' }
    ]
  },
  Five: {
    archetype: (ctx) => `${ctx.element} Stress Point`,
    composition: 'dynamic tension with disruption',
    symbolTemplates: [
      { object: 'five {symbolPlural}', position: 'scattered/clashing', meaning: 'conflict, scarcity, or testing ground' },
      { object: 'figures in turmoil or adversity', position: 'foreground action', meaning: 'challenge demanding resilience' },
      { object: '{environment}', position: 'harsh backdrop', meaning: 'conditions that amplify the lesson' }
    ]
  },
  Six: {
    archetype: (ctx) => `${ctx.element} Restoration`,
    composition: 'central exchange or harmonious flow',
    symbolTemplates: [
      { object: 'six {symbolPlural}', position: 'balanced arrangement', meaning: 'reciprocity, healing, generosity' },
      { object: 'giver and receiver figures', position: 'mid-scene', meaning: 'support in motion' },
      { object: '{environment}', position: 'calmer backdrop', meaning: 'peace returning after imbalance' }
    ]
  },
  Seven: {
    archetype: (ctx) => `${ctx.element} Assessment`,
    composition: 'figure pausing amid work or defense',
    symbolTemplates: [
      { object: 'seven {symbolPlural}', position: 'stacked or arrayed', meaning: 'inventory of progress and strategy' },
      { object: 'standing figure evaluating', position: 'foreground', meaning: 'moment to reassess effort or boundaries' },
      { object: '{environment}', position: 'surrounding terrain', meaning: 'field of ongoing labor or opposition' }
    ]
  },
  Eight: {
    archetype: (ctx) => `${ctx.element} Movement`,
    composition: 'strong directional lines showing transition',
    symbolTemplates: [
      { object: 'eight {symbolPlural}', position: 'diagonal or stacked motion', meaning: 'momentum, departure, or quick progress' },
      { object: 'figure in action or exiting scene', position: 'foreground', meaning: 'choice to move toward alignment' },
      { object: '{environment}', position: 'dynamic backdrop', meaning: 'landscape stretching toward next phase' }
    ]
  },
  Nine: {
    archetype: (ctx) => `${ctx.element} Culmination`,
    composition: 'almost-complete structure or solitary focus',
    symbolTemplates: [
      { object: 'nine {symbolPlural}', position: 'framing figure or sanctuary', meaning: 'fruits of labor, boundaries, refinement' },
      { object: 'solitary figure', position: 'center', meaning: 'self-possession, vigilance, or luxury' },
      { object: '{environment}', position: 'contained garden or guarded space', meaning: 'personal domain requiring upkeep' }
    ]
  },
  Ten: {
    archetype: (ctx) => `${ctx.element} Completion`,
    composition: 'full tableau showing legacy or burden release',
    symbolTemplates: [
      { object: 'ten {symbolPlural}', position: 'fully packed scene', meaning: 'culmination, saturation, or heavy load' },
      { object: 'family/figures interacting', position: 'foreground narrative', meaning: 'transfer of lessons across generations' },
      { object: '{environment}', position: 'spanning backdrop', meaning: 'world built by sustained effort' }
    ]
  },
  Page: {
    archetype: (ctx) => `${ctx.element} Messenger`,
    composition: 'youthful figure holding suit emblem',
    symbolTemplates: [
      { object: 'page holding {symbolSingular}', position: 'center posture', meaning: 'student energy, curiosity, news' },
      { object: 'fresh terrain', position: 'surrounding ground', meaning: 'learning field where mistakes are OK' },
      { object: '{environment}', position: 'background', meaning: 'elemental classroom for exploration' }
    ]
  },
  Knight: {
    archetype: (ctx) => `${ctx.element} Quest`,
    composition: 'mounted figure charging or focusing force',
    symbolTemplates: [
      { object: 'knight on steed with {symbolSingular}', position: 'center motion', meaning: 'pursuit, activism, mission' },
      { object: 'steed posture (rearing, pacing, still)', position: 'horse body', meaning: 'style of momentum specific to suit' },
      { object: '{environment}', position: 'terrain ahead', meaning: 'conditions the quest must cross' }
    ]
  },
  Queen: {
    archetype: (ctx) => `${ctx.element} Sovereign`,
    composition: 'throne-scene with rich symbolism',
    symbolTemplates: [
      { object: 'queen enthroned with {symbolSingular}', position: 'center', meaning: 'mature mastery with receptive influence' },
      { object: 'fauna, familiars, or motifs', position: 'at throne base', meaning: 'embodied wisdom of the suit' },
      { object: '{environment}', position: 'court or landscape', meaning: 'domain nurtured through emotional intelligence' }
    ]
  },
  King: {
    archetype: (ctx) => `${ctx.element} Architect`,
    composition: 'commanding figure structuring the realm',
    symbolTemplates: [
      { object: 'king with {symbolSingular}', position: 'center authority', meaning: 'strategic leadership and accountability' },
      { object: 'architectural motifs (pillars, city walls)', position: 'throne backdrop', meaning: 'systems stewarded by the king' },
      { object: '{environment}', position: 'landscape', meaning: 'kingdom shaped by long-term stewardship' }
    ]
  }
};

function interpolate(template, context) {
  if (!template) return '';
  return template.replace(/\{(\w+)\}/g, (_, key) => context[key] || '');
}

export function getMinorSymbolAnnotation(card) {
  if (!card) return null;
  const suitKey = card.suit ? (SUIT_SYNONYMS[card.suit] || card.suit) : null;
  const rankKey = card.rank ? (RANK_SYNONYMS[card.rank] || card.rank) : null;
  if (!suitKey || !rankKey) return null;
  const suitContext = SUIT_CONTEXT[suitKey];
  const rankBlueprint = RANK_BLUEPRINTS[rankKey];
  if (!suitContext || !rankBlueprint) return null;

  const templateContext = {
    element: suitContext.element,
    symbolSingular: suitContext.symbolSingular,
    symbolPlural: suitContext.symbolPlural,
    environment: suitContext.environment
  };

  const rankSymbols = rankBlueprint.symbolTemplates.map((template) => ({
    object: interpolate(template.object, templateContext),
    position: template.position,
    meaning: interpolate(template.meaning, templateContext)
  }));

  const symbols = [...rankSymbols, ...suitContext.suitSymbols].slice(0, 6);
  const dominantColors = suitContext.palette;
  const composition = `${rankBlueprint.composition} within ${suitContext.environment}`;
  const archetype = rankBlueprint.archetype(templateContext);

  return {
    symbols,
    dominantColors,
    composition,
    archetype
  };
}
</file>

<file path="shared/vision/symbolDetector.js">
import { pipeline, RawImage } from '@xenova/transformers';
import { SYMBOL_ANNOTATIONS } from '../symbols/symbolAnnotations.js';
import { getMinorSymbolAnnotation } from './minorSymbolLexicon.js';

function getEnvValue(key) {
  if (typeof process !== 'undefined' && process?.env?.[key]) {
    return process.env[key];
  }
  if (typeof import.meta !== 'undefined' && import.meta?.env?.[key]) {
    return import.meta.env[key];
  }
  return null;
}

const MODEL_OVERRIDE =
  getEnvValue('SYMBOL_DETECTOR_MODEL') ||
  getEnvValue('VITE_SYMBOL_DETECTOR_MODEL');
const MODEL_PRESET = (getEnvValue('SYMBOL_DETECTOR_PRESET') || '').toLowerCase();

const DEFAULT_MODEL = MODEL_OVERRIDE
  || (MODEL_PRESET === 'fast' ? 'Xenova/owlvit-base-patch32' : 'Xenova/owlvit-large-patch14');
const DEFAULT_THRESHOLD = Number.parseFloat(getEnvValue('SYMBOL_DETECTOR_THRESHOLD')) || 0.05;
const DEFAULT_HEATMAP_GRID = Number.parseInt(getEnvValue('SYMBOL_HEATMAP_GRID') || '7', 10);
const SYMBOL_SYNONYMS = {
  sun: ['sun', 'solar disk', 'sunlight', 'sunrise'],
  moon: ['moon', 'luna', 'crescent'],
  dog: ['dog', 'canine', 'wolf', 'hound'],
  cat: ['cat', 'feline'],
  lion: ['lion', 'big cat'],
  horse: ['horse', 'steed'],
  crown: ['crown', 'tiara', 'coronet'],
  wand: ['wand', 'staff', 'rod'],
  cup: ['cup', 'chalice', 'goblet'],
  sword: ['sword', 'blade'],
  pentacle: ['pentacle', 'coin', 'disk', 'disc'],
  coin: ['coin', 'pentacle', 'disk', 'disc'],
  star: ['star', 'pentagram'],
  tower: ['tower', 'castle'],
  throne: ['throne', 'chair'],
  wing: ['wing', 'angel wing'],
  angel: ['angel', 'archangel'],
  bird: ['bird', 'dove', 'eagle'],
  flower: ['flower', 'rose', 'lily', 'sunflower'],
  tree: ['tree', 'branch', 'trunk'],
  pillar: ['pillar', 'column'],
  mountain: ['mountain', 'cliff', 'peak'],
  river: ['river', 'stream', 'waterfall'],
  water: ['water', 'stream', 'river'],
  boat: ['boat', 'ship', 'canoe'],
  angelwing: ['angel wing', 'wing'],
  shield: ['shield', 'emblem'],
  scale: ['scale', 'balance'],
  torch: ['torch', 'lantern', 'lamp'],
  hand: ['hand', 'palm'],
  figure: ['figure', 'person', 'human'],
  child: ['child', 'kid', 'youth'],
  fish: ['fish', 'koi'],
  snake: ['snake', 'serpent'],
  banner: ['banner', 'flag'],
  bundle: ['bundle', 'knapsack', 'satchel', 'bag'],
  feather: ['feather', 'plume'],
  rose: ['rose', 'flower'],
  cliff: ['cliff', 'ledge', 'precipice'],
  sunflowers: ['sunflower', 'flower'],
  grapes: ['grape', 'fruit'],
  scales: ['scales', 'balance'],
  wheel: ['wheel', 'circle', 'mandala']
};

const STOPWORDS = new Set([
  'a',
  'an',
  'the',
  'with',
  'and',
  'or',
  'of',
  'on',
  'in',
  'at',
  'over',
  'under',
  'around',
  'through',
  'for',
  'near',
  'by',
  'to',
  'from',
  'up',
  'down',
  'scene',
  'background',
  'foreground',
  'center',
  'left',
  'right',
  'top',
  'bottom'
]);

const HEATMAP_FOCUS_THRESHOLD = 0.75;

function clamp01(value) {
  return Math.max(0, Math.min(1, value));
}

function buildDetectionHeatmap(detections = [], gridSize = DEFAULT_HEATMAP_GRID || 7) {
  const effectiveGrid = Number.isFinite(gridSize) && gridSize > 1 ? gridSize : 7;
  if (!Array.isArray(detections) || detections.length === 0) {
    return null;
  }

  const grid = Array.from({ length: effectiveGrid }, () => Array(effectiveGrid).fill(0));

  detections.forEach((det) => {
    if (!det?.box || typeof det.score !== 'number') return;
    const startX = Math.max(0, Math.min(effectiveGrid - 1, Math.floor(det.box.xmin * effectiveGrid)));
    const endX = Math.max(0, Math.min(effectiveGrid - 1, Math.floor(det.box.xmax * effectiveGrid)));
    const startY = Math.max(0, Math.min(effectiveGrid - 1, Math.floor(det.box.ymin * effectiveGrid)));
    const endY = Math.max(0, Math.min(effectiveGrid - 1, Math.floor(det.box.ymax * effectiveGrid)));
    for (let y = startY; y <= endY; y += 1) {
      for (let x = startX; x <= endX; x += 1) {
        grid[y][x] += det.score;
      }
    }
  });

  const flat = grid.flat();
  const max = Math.max(...flat, 0);
  const normalized = max
    ? grid.map((row) => row.map((value) => Number((value / max).toFixed(4))))
    : grid.map((row) => row.map(() => 0));

  const focusRegions = [];
  normalized.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value >= HEATMAP_FOCUS_THRESHOLD) {
        focusRegions.push({ x, y, intensity: value });
      }
    });
  });

  return {
    gridSize: effectiveGrid,
    heatmap: normalized,
    stats: {
      max: Number(max.toFixed(4)),
      min: 0
    },
    focusRegions
  };
}

const POSITION_KEYWORDS = {
  top: ['top', 'upper', 'sky', 'crown'],
  bottom: ['bottom', 'ground', 'base', 'earth'],
  left: ['left', 'west'],
  right: ['right', 'east'],
  center: ['center', 'middle', 'mid']
};

function normalizeLabel(value = '') {
  return value.toLowerCase().replace(/[^a-z0-9]+/g, ' ').trim();
}

function singularize(token = '') {
  if (token.endsWith('ies')) {
    return token.slice(0, -3) + 'y';
  }
  if (token.endsWith('ves')) {
    return token.slice(0, -3) + 'f';
  }
  if (token.endsWith('s') && token.length > 3) {
    return token.slice(0, -1);
  }
  return token;
}

function buildSymbolTerms(symbolObject = '') {
  const normalized = normalizeLabel(symbolObject);
  if (!normalized) return [];
  const tokens = normalized
    .split(' ')
    .map((token) => token.trim())
    .filter((token) => token && !STOPWORDS.has(token));

  const terms = new Set();
  if (symbolObject) {
    terms.add(symbolObject.toLowerCase());
  }

  for (let i = 0; i < tokens.length; i += 1) {
    const token = tokens[i];
    const singular = singularize(token);
    terms.add(token);
    terms.add(singular);
    const synonyms = SYMBOL_SYNONYMS[singular] || SYMBOL_SYNONYMS[token] || [];
    synonyms.forEach((syn) => terms.add(syn));

    if (i < tokens.length - 1) {
      terms.add(`${token} ${tokens[i + 1]}`);
    }
  }

  return Array.from(terms).filter(Boolean);
}

function formatPrompt(term) {
  const trimmed = term.trim();
  if (!trimmed) return null;
  if (/^(a|an|the)\s/i.test(trimmed)) {
    return trimmed;
  }
  const article = /^[aeiou]/i.test(trimmed) ? 'an' : 'a';
  return `${article} ${trimmed}`;
}

function getAnnotation(card) {
  if (typeof card?.number === 'number' && SYMBOL_ANNOTATIONS?.[card.number]) {
    return SYMBOL_ANNOTATIONS[card.number];
  }
  if (card?.suit && card?.rank) {
    return getMinorSymbolAnnotation(card);
  }
  return null;
}

function getExpectedSymbols(card) {
  const annotation = getAnnotation(card);
  if (!annotation?.symbols || !annotation.symbols.length) {
    return null;
  }
  return annotation.symbols;
}

function centerFromBox(box = {}) {
  const x = box.xmin != null && box.xmax != null ? (box.xmin + box.xmax) / 2 : null;
  const y = box.ymin != null && box.ymax != null ? (box.ymin + box.ymax) / 2 : null;
  return { x, y };
}

function resolvePositionKeyword(position = '') {
  const lower = position.toLowerCase();
  if (POSITION_KEYWORDS.top.some((token) => lower.includes(token))) return 'top';
  if (POSITION_KEYWORDS.bottom.some((token) => lower.includes(token))) return 'bottom';
  if (POSITION_KEYWORDS.left.some((token) => lower.includes(token))) return 'left';
  if (POSITION_KEYWORDS.right.some((token) => lower.includes(token))) return 'right';
  if (POSITION_KEYWORDS.center.some((token) => lower.includes(token))) return 'center';
  return null;
}

function positionMatches(box, symbolPosition) {
  if (!symbolPosition || !box) return true;
  const keyword = resolvePositionKeyword(symbolPosition);
  if (!keyword) return true;
  const { x, y } = centerFromBox(box);
  if (x == null || y == null) return true;
  switch (keyword) {
    case 'top':
      return y <= 0.4;
    case 'bottom':
      return y >= 0.6;
    case 'left':
      return x <= 0.4;
    case 'right':
      return x >= 0.6;
    case 'center':
      return y > 0.35 && y < 0.65 && x > 0.35 && x < 0.65;
    default:
      return true;
  }
}

function normalizeBox(box = {}, dimensions = { width: 1, height: 1 }) {
  const width = dimensions.width || 1;
  const height = dimensions.height || 1;
  return {
    xmin: Number(clamp01((box.xmin ?? 0) / width).toFixed(3)),
    ymin: Number(clamp01((box.ymin ?? 0) / height).toFixed(3)),
    xmax: Number(clamp01((box.xmax ?? 0) / width).toFixed(3)),
    ymax: Number(clamp01((box.ymax ?? 0) / height).toFixed(3))
  };
}

export class SymbolDetector {
  constructor({ model = DEFAULT_MODEL, threshold = DEFAULT_THRESHOLD, heatmapGridSize = DEFAULT_HEATMAP_GRID, preset = null } = {}) {
    const resolvedModel = (!MODEL_OVERRIDE && preset === 'fast') ? 'Xenova/owlvit-base-patch32' : model;
    this.model = resolvedModel;
    this.preset = preset;
    this.threshold = threshold;
    this.heatmapGridSize = Number.isFinite(heatmapGridSize) && heatmapGridSize > 1 ? heatmapGridSize : (DEFAULT_HEATMAP_GRID || 7);
    this._detectorPromise = null;
  }

  async _getDetector() {
    if (!this._detectorPromise) {
      this._detectorPromise = pipeline('zero-shot-object-detection', this.model);
    }
    return this._detectorPromise;
  }

  async verifySymbols(imageSource, card) {
    const expectedSymbols = getExpectedSymbols(card);
    if (!expectedSymbols || expectedSymbols.length === 0) {
      return null;
    }

    const detector = await this._getDetector();
    const rawImage = await RawImage.read(imageSource);
    const { candidateLabels, labelLookup } = this._buildCandidateLabels(expectedSymbols);

    if (!candidateLabels.length) {
      return {
        expectedCount: expectedSymbols.length,
        detectedCount: 0,
        matchRate: 0,
        matches: expectedSymbols.map((symbol) => ({
          object: symbol.object,
          expectedPosition: symbol.position || null,
          found: false,
          confidence: 0,
          detectionLabel: null
        })),
        missingSymbols: expectedSymbols.map((symbol) => symbol.object),
        unexpectedDetections: []
      };
    }

    const detections = await detector(rawImage, candidateLabels, {
      threshold: this.threshold
    });

    const normalizedDetections = Array.isArray(detections)
      ? detections
          .map((det, index) => ({
            label: det.label,
            score: Number(det.score?.toFixed?.(4) ?? 0),
            box: normalizeBox(det.box || {}, { width: rawImage.width, height: rawImage.height }),
            id: `${det.label || 'object'}-${index}`
          }))
          .sort((a, b) => b.score - a.score)
      : [];

    const heatmap = buildDetectionHeatmap(normalizedDetections, this.heatmapGridSize);

    const matchedDetectionIds = new Set();

    const matches = expectedSymbols.map((symbol, symbolIndex) => {
      const detection = normalizedDetections.find((det) => {
        const candidates = labelLookup.get(det.label) || [];
        const isCandidate = candidates.includes(symbolIndex);
        if (!isCandidate) return false;
        return positionMatches(det.box, symbol.position);
      });

      if (detection) {
        matchedDetectionIds.add(detection.id);
      }

      return {
        object: symbol.object,
        expectedPosition: symbol.position || null,
        found: Boolean(detection),
        confidence: detection?.score ?? 0,
        detectionLabel: detection?.label || null,
        box: detection?.box || null
      };
    });

    const foundCount = matches.filter((match) => match.found).length;
    const matchRate = Number((foundCount / expectedSymbols.length).toFixed(4));
    const missingSymbols = matches
      .filter((match) => !match.found)
      .map((match) => match.object);

    const unexpectedDetections = normalizedDetections
      .filter((det) => !matchedDetectionIds.has(det.id))
      .slice(0, 5)
      .map((det) => ({ label: det.label, confidence: det.score, box: det.box }));

    return {
      expectedCount: expectedSymbols.length,
      detectedCount: foundCount,
      matchRate,
      matches: matches.slice(0, 8),
      missingSymbols: missingSymbols.slice(0, 5),
      unexpectedDetections,
      heatmap
    };
  }
  _buildCandidateLabels(symbols = []) {
    const labelLookup = new Map();
    const orderedLabels = [];

    symbols.forEach((symbol, index) => {
      const terms = buildSymbolTerms(symbol.object);
      if (!terms.length) return;
      terms.forEach((term) => {
        const prompt = formatPrompt(term);
        if (!prompt) return;
        orderedLabels.push(prompt);
        const mapping = labelLookup.get(prompt) || [];
        mapping.push(index);
        labelLookup.set(prompt, mapping);
      });
    });

    const uniqueLabels = Array.from(new Set(orderedLabels));
    return { candidateLabels: uniqueLabels, labelLookup };
  }
}

export async function analyzeSymbolVerification(imageSource, card, options = {}) {
  const detector = new SymbolDetector(options);
  return detector.verifySymbols(imageSource, card);
}
</file>

<file path="shared/vision/tarotVisionPipeline.js">
import {
  AutoTokenizer,
  AutoProcessor,
  CLIPTextModelWithProjection,
  CLIPVisionModelWithProjection,
  RawImage,
  Tensor
} from '@xenova/transformers';

import { MAJOR_ARCANA } from '../../src/data/majorArcana.js';
import { MINOR_ARCANA } from '../../src/data/minorArcana.js';
import { SYMBOL_ANNOTATIONS } from '../symbols/symbolAnnotations.js';
import { getMinorSymbolAnnotation } from './minorSymbolLexicon.js';
import { getDeckProfile } from './deckProfiles.js';
import { SymbolDetector } from './symbolDetector.js';
import { loadFineTunedPrototypes } from './fineTuneCache.js';
import { VISUAL_TONE_ANCHORS, VISUAL_EMOTION_ANCHORS, selectTopDescriptors } from './visualSemantics.js';

const DEFAULT_MODEL = 'Xenova/clip-vit-base-patch32';
const DEFAULT_SCOPE = 'major';
const DEFAULT_MAX_RESULTS = 5;
const IS_BROWSER = typeof window !== 'undefined';
const NODE_BASE_URL = !IS_BROWSER && typeof process !== 'undefined'
  ? (() => {
      const cwdNormalized = process.cwd().replace(/\\/g, '/');
      const ensured = cwdNormalized.endsWith('/') ? cwdNormalized : `${cwdNormalized}/`;
      return new URL(`file://${encodeURI(ensured)}`);
    })()
  : null;

const POSITION_KEYWORDS = {
  top: ['top', 'upper', 'crown'],
  bottom: ['bottom', 'lower', 'base'],
  left: ['left', 'west'],
  right: ['right', 'east'],
  center: ['center', 'middle', 'mid']
};

const CARD_LOOKUP = (() => {
  const map = new Map();
  [...MAJOR_ARCANA, ...MINOR_ARCANA].forEach((card) => {
    if (!card?.name) return;
    map.set(card.name.toLowerCase(), card);
  });
  return map;
})();

function normalizeAssetPath(pathCandidate) {
  if (!pathCandidate) return null;
  if (IS_BROWSER) {
    return pathCandidate;
  }
  if (pathCandidate.startsWith('public/')) {
    return pathCandidate;
  }
  const sanitized = pathCandidate.startsWith('/') ? pathCandidate.slice(1) : pathCandidate;
  return `public/${sanitized}`;
}

function resolveCardImageSource(card, deckProfile) {
  if (!card) return null;
  const override = deckProfile?.imageOverrides?.[card.name];
  const imageByDeck = deckProfile?.id && card?.images ? card.images[deckProfile.id] : null;
  const candidate =
    deckProfile?.imageResolver?.(card) ||
    override?.path ||
    imageByDeck ||
    card?.image ||
    override ||
    null;
  return normalizeAssetPath(candidate);
}

function getAnnotation(card) {
  if (typeof card?.number === 'number' && SYMBOL_ANNOTATIONS?.[card.number]) {
    return SYMBOL_ANNOTATIONS[card.number];
  }
  if (card?.suit && card?.rank) {
    return getMinorSymbolAnnotation(card);
  }
  return null;
}

function buildPrompt(card, deckProfile, aliasName) {
  const annotation = getAnnotation(card);
  const symbolSnippets = annotation?.symbols
    ?.map((symbol) => {
      const color = symbol.color ? `${symbol.color} ` : '';
      return `${color}${symbol.object} (${symbol.meaning})`;
    })
    .slice(0, 4)
    .join(', ');

  const dominantColors = annotation?.dominantColors
    ?.map((entry) => `${entry.color}: ${entry.meaning}`)
    .slice(0, 3)
    .join(', ');

  const displaySuit = card.suit ? (deckProfile?.suitAliasResolver?.(card.suit) || card.suit) : null;
  const suitDescriptor = displaySuit ? `Suit: ${displaySuit}.` : '';
  const displayRank = card.rank ? (deckProfile?.courtAliasResolver?.(card.rank) || card.rank) : null;
  const rankDescriptor = displayRank ? `Rank: ${displayRank}.` : '';
  const keywords = card.upright || card.meaning || '';

  const visualNotes = [symbolSnippets, dominantColors]
    .filter(Boolean)
    .join(' | ');

  const deckCue = deckProfile?.promptCue
    ? `${deckProfile.promptCue} Palette cues: ${deckProfile.palette.join(', ')}. Texture: ${deckProfile.texture}`
    : '';

  const presentedName = aliasName || card.name;
  const aliasNote =
    aliasName && aliasName !== card.name ? ` (RWS base: ${card.name})` : '';

  return `${deckCue} Card: ${presentedName}${aliasNote}. ${suitDescriptor} ${rankDescriptor} Keywords: ${keywords}. Visual motifs: ${visualNotes}.`;
}

function buildCardLibrary(scope = DEFAULT_SCOPE, deckProfile) {
  const baseCards = scope === 'all' ? [...MAJOR_ARCANA, ...MINOR_ARCANA] : MAJOR_ARCANA;
  return baseCards.map((card, index) => {
    const alias = deckProfile?.aliasResolver?.(card);
    return {
      id: card.number != null ? card.number : `${card.suit}-${card.rank}-${index}`,
      label: alias || card.name,
      canonicalName: card.name,
      sourceCard: card,
      prompt: buildPrompt(card, deckProfile, alias),
      imageSource: resolveCardImageSource(card, deckProfile)
    };
  });
}

function cosineSimilarity(a, b) {
  if (!a || !b || a.length !== b.length) return 0;
  let dot = 0;
  for (let i = 0; i < a.length; i++) {
    dot += a[i] * b[i];
  }
  return dot;
}

function selectBestScore({ imageScore, textScore, adapterScore }) {
  let bestValue = -Infinity;
  let basis = 'text';
  const candidates = [
    ['adapter', adapterScore],
    ['image', imageScore],
    ['text', textScore]
  ];
  candidates.forEach(([label, value]) => {
    if (typeof value === 'number' && Number.isFinite(value) && value > bestValue) {
      bestValue = value;
      basis = label;
    }
  });
  if (!Number.isFinite(bestValue)) {
    return { score: 0, basis: 'text' };
  }
  return { score: bestValue, basis };
}

function toArray(bufferLike) {
  if (!bufferLike) return [];
  if (Array.isArray(bufferLike)) return bufferLike;
  if (ArrayBuffer.isView(bufferLike)) return Array.from(bufferLike);
  return Array.from(bufferLike);
}

function normalizeVector(vector) {
  const norm = Math.sqrt(vector.reduce((sum, value) => sum + value * value, 0));
  if (!norm || Number.isNaN(norm)) return vector;
  return vector.map((value) => value / norm);
}

function lookupCardByName(name) {
  if (!name || typeof name !== 'string') return null;
  return CARD_LOOKUP.get(name.trim().toLowerCase()) || null;
}

function positionStringToCell(position, gridSize) {
  const fallback = Math.floor(gridSize / 2);
  if (!position || typeof position !== 'string') {
    return { x: fallback, y: fallback };
  }
  const lower = position.toLowerCase();
  let x = fallback;
  let y = fallback;
  if (POSITION_KEYWORDS.left.some((token) => lower.includes(token))) {
    x = 0;
  } else if (POSITION_KEYWORDS.right.some((token) => lower.includes(token))) {
    x = gridSize - 1;
  }

  if (POSITION_KEYWORDS.top.some((token) => lower.includes(token))) {
    y = 0;
  } else if (POSITION_KEYWORDS.bottom.some((token) => lower.includes(token))) {
    y = gridSize - 1;
  } else if (POSITION_KEYWORDS.center.some((token) => lower.includes(token))) {
    y = fallback;
  }

  return {
    x: Math.max(0, Math.min(gridSize - 1, x)),
    y: Math.max(0, Math.min(gridSize - 1, y))
  };
}

function reshapeHeatmap(values, gridSize) {
  const rows = [];
  for (let y = 0; y < gridSize; y += 1) {
    const rowStart = y * gridSize;
    rows.push(values.slice(rowStart, rowStart + gridSize));
  }
  return rows;
}

function normalizeHeatmap(heatmap) {
  const flat = heatmap.flat();
  const max = Math.max(...flat, 0);
  if (!max) {
    return {
      normalized: heatmap.map((row) => row.map(() => 0)),
      max,
      min: 0
    };
  }
  const min = Math.min(...flat, 0);
  return {
    normalized: heatmap.map((row) => row.map((value) => Number((value / max).toFixed(4)))),
    max,
    min
  };
}

function deriveFocusRegions(heatmap, threshold = 0.65) {
  const normalized = heatmap;
  const regions = [];
  normalized.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value >= threshold) {
        regions.push({ x, y, intensity: Number(value.toFixed(4)) });
      }
    });
  });
  return regions.sort((a, b) => b.intensity - a.intensity).slice(0, 8);
}

function alignSymbolsToHeatmap(symbols = [], heatmap, gridSize) {
  if (!Array.isArray(symbols) || symbols.length === 0) return null;
  const flatMax = Math.max(...heatmap.flat(), 0) || 1;
  return symbols.map((symbol) => {
    const cell = positionStringToCell(symbol.position || '', gridSize);
    const score = heatmap[cell.y]?.[cell.x] ?? 0;
    return {
      object: symbol.object,
      position: symbol.position,
      attentionScore: Number((score / flatMax).toFixed(4)),
      isModelFocused: score / flatMax >= 0.65
    };
  });
}

function extractAttentionSummary(attentions) {
  if (!attentions || !Array.isArray(attentions) || !attentions.length) return null;
  const lastLayer = attentions[attentions.length - 1];
  if (!(lastLayer instanceof Tensor)) {
    return null;
  }
  const [batch, heads, tokens] = lastLayer.dims || [];
  if (!batch || !heads || !tokens || tokens <= 1) {
    return null;
  }
  const patchCount = tokens - 1;
  const gridSize = Math.max(1, Math.round(Math.sqrt(patchCount)));
  const denom = batch * heads || 1;
  const patchScores = new Array(patchCount).fill(0);
  for (let b = 0; b < batch; b += 1) {
    for (let h = 0; h < heads; h += 1) {
      for (let patch = 0; patch < patchCount; patch += 1) {
        const tokenIdx = patch + 1; // skip CLS token
        const idx = (((b * heads) + h) * tokens + 0) * tokens + tokenIdx;
        patchScores[patch] += lastLayer.data[idx] || 0;
      }
    }
  }
  const averaged = patchScores.map((value) => value / denom);
  while (averaged.length < gridSize * gridSize) {
    averaged.push(0);
  }
  const heatmap = reshapeHeatmap(averaged.slice(0, gridSize * gridSize), gridSize);
  const { normalized, max, min } = normalizeHeatmap(heatmap);
  const focusRegions = deriveFocusRegions(normalized);
  return {
    gridSize,
    heatmap: normalized,
    stats: {
      max: Number(max.toFixed(4)),
      min: Number(min.toFixed(4))
    },
    focusRegions
  };
}

function decorateAttentionWithSymbols(attentionSummary, card) {
  if (!attentionSummary || !card) return attentionSummary;
  const annotation = getAnnotation(card);
  if (!annotation) return attentionSummary;
  const symbolAlignment = alignSymbolsToHeatmap(annotation.symbols, attentionSummary.heatmap, attentionSummary.gridSize);
  return {
    ...attentionSummary,
    symbolAlignment
  };
}

export class TarotVisionPipeline {
  constructor({
    model = DEFAULT_MODEL,
    quantized = true,
    cardScope = DEFAULT_SCOPE,
    maxResults = DEFAULT_MAX_RESULTS,
    deckStyle = 'rws-1909'
  } = {}) {
    this.model = model;
    this.quantized = quantized;
    this.cardScope = cardScope;
    this.maxResults = maxResults;
    this.deckProfile = getDeckProfile(deckStyle);

    this.cardLibrary = buildCardLibrary(cardScope, this.deckProfile);
    this._cardEmbeddingsPromise = null;
    this._textStackPromise = null;
    this._visionStackPromise = null;
    this._symbolDetectorPromise = null;
    this._visualAnchorsPromise = null;
  }

  async _getTextStack() {
    if (!this._textStackPromise) {
      this._textStackPromise = (async () => {
        const tokenizer = await AutoTokenizer.from_pretrained(this.model);
        const model = await CLIPTextModelWithProjection.from_pretrained(this.model, {
          quantized: this.quantized,
          progress_callback: null
        });
        return { tokenizer, model };
      })();
    }
    return this._textStackPromise;
  }

  async _getVisionStack() {
    if (!this._visionStackPromise) {
      this._visionStackPromise = (async () => {
        const processor = await AutoProcessor.from_pretrained(this.model);
        const model = await CLIPVisionModelWithProjection.from_pretrained(this.model, {
          quantized: this.quantized,
          progress_callback: null
        });
        return { processor, model };
      })();
    }
    return this._visionStackPromise;
  }

  async _getSymbolDetector() {
    if (!this._symbolDetectorPromise) {
      this._symbolDetectorPromise = Promise.resolve(new SymbolDetector());
    }
    return this._symbolDetectorPromise;
  }

  async _getVisualAnchors() {
    if (!this._visualAnchorsPromise) {
      this._visualAnchorsPromise = (async () => {
        const anchors = {
          tone: {},
          emotion: {}
        };

        // Embed tone anchors
        for (const category in VISUAL_TONE_ANCHORS) {
          for (const anchor of VISUAL_TONE_ANCHORS[category]) {
            const vector = await this._embedPrompt(anchor.text);
            anchors.tone[anchor.label] = vector;
          }
        }

        // Embed emotion anchors
        for (const anchor of VISUAL_EMOTION_ANCHORS) {
          const vector = await this._embedPrompt(anchor.text);
          anchors.emotion[anchor.label] = vector;
        }

        return anchors;
      })();
    }
    return this._visualAnchorsPromise;
  }

  async _embedPrompt(prompt) {
    const { tokenizer, model } = await this._getTextStack();
    const tokenized = tokenizer(prompt, { padding: true, truncation: true });
    const { text_embeds } = await model(tokenized);
    return normalizeVector(toArray(text_embeds.data));
  }

  async _embedImage(imageSource, { includeAttention = false } = {}) {
    const normalizedSource = normalizeImageSource(imageSource);
    const rawImage = await RawImage.read(normalizedSource);
    const { processor, model } = await this._getVisionStack();
    const processed = await processor(rawImage);
    const visionInputs = {
      ...processed,
      output_attentions: includeAttention
    };
    const { image_embeds, attentions } = await model(visionInputs);
    return {
      resolvedPath: normalizedSource,
      vector: normalizeVector(toArray(image_embeds.data)),
      attention: includeAttention ? extractAttentionSummary(attentions) : null
    };
  }

  async _ensureCardEmbeddings() {
    if (!this._cardEmbeddingsPromise) {
      this._cardEmbeddingsPromise = (async () => {
        const embeddings = [];
        const adapterData = await loadFineTunedPrototypes(this.deckProfile.id);
        const adapterCards = adapterData?.cards || {};
        for (const card of this.cardLibrary) {
          const textVector = await this._embedPrompt(card.prompt);
          let imageVector = null;
          if (card.imageSource) {
            try {
              const embeddedImage = await this._embedImage(card.imageSource);
              imageVector = embeddedImage.vector;
            } catch (err) {
              console.warn(`Failed to embed reference image for ${card.label}:`, err.message);
            }
          }

          const canonicalKey = card.canonicalName || card.cardName;
          const adapterEntry = adapterCards[canonicalKey] || adapterCards[card.cardName];
          const adapterVector = adapterEntry?.embedding ? normalizeVector(adapterEntry.embedding) : null;

          embeddings.push({
            cardId: card.id,
            cardName: card.label,
            canonicalName: card.canonicalName,
            cardMetadata: card.sourceCard,
            textVector,
            imageVector,
            adapterVector,
            adapterMeta: adapterEntry ? { count: adapterEntry.count || 0 } : null
          });
        }
        return embeddings;
      })();
    }
    return this._cardEmbeddingsPromise;
  }

  async analyzeImages(imageInputs = [], options = {}) {
    if (!Array.isArray(imageInputs) || imageInputs.length === 0) {
      throw new Error('analyzeImages requires at least one image source');
    }

    const cardEmbeddings = await this._ensureCardEmbeddings();
    const analyses = [];
    const includeAttention = Boolean(options.includeAttention);
    const includeSymbols = Boolean(options.includeSymbols);
    // Default to true for prototype purposes
    const includeVisualProfile = options.includeVisualProfile !== false;
    
    const deckStyle = this.deckProfile.id;
    const symbolDetector = includeSymbols ? await this._getSymbolDetector() : null;
    const visualAnchors = includeVisualProfile ? await this._getVisualAnchors() : null;

    for (const input of imageInputs) {
      const normalized = normalizeInput(input);
      const { resolvedPath, vector: imageVector, attention: rawAttention } = await this._embedImage(normalized.source, {
        includeAttention
      });
      const matches = cardEmbeddings
        .map((card) => {
          const imageScore = card.imageVector ? cosineSimilarity(imageVector, card.imageVector) : null;
          const textScore = card.textVector ? cosineSimilarity(imageVector, card.textVector) : null;
          const adapterScore = card.adapterVector ? cosineSimilarity(imageVector, card.adapterVector) : null;
          const { score, basis } = selectBestScore({ imageScore, textScore, adapterScore });
          return {
            cardId: card.cardId,
            cardName: card.cardName,
            canonicalName: card.canonicalName,
            score,
            basis,
            components: {
              imageScore,
              textScore,
              adapterScore
            },
            cardMetadata: card.cardMetadata,
            adapterMeta: card.adapterMeta || null
          };
        })
        .sort((a, b) => b.score - a.score)
        .slice(0, this.maxResults);

      let attention = rawAttention;
      if (includeAttention && attention && matches[0]?.canonicalName) {
        const card = lookupCardByName(matches[0].canonicalName) || lookupCardByName(matches[0].cardName);
        attention = decorateAttentionWithSymbols(attention, card);
      }

      let symbolVerification = null;
      if (includeSymbols && symbolDetector && matches[0]?.cardMetadata) {
        try {
          symbolVerification = await symbolDetector.verifySymbols(resolvedPath, matches[0].cardMetadata, {
            deckStyle
          });
        } catch (err) {
          console.warn('Symbol detection failed:', err);
        }
      }

      if ((!attention || !attention.heatmap) && symbolVerification?.heatmap && matches[0]?.cardMetadata) {
        attention = decorateAttentionWithSymbols(symbolVerification.heatmap, matches[0].cardMetadata);
      }
      
      let visualProfile = null;
      if (includeVisualProfile && visualAnchors) {
        const toneScores = {};
        const emotionScores = {};

        for (const [label, anchorVec] of Object.entries(visualAnchors.tone)) {
          toneScores[label] = cosineSimilarity(imageVector, anchorVec);
        }
        
        for (const [label, anchorVec] of Object.entries(visualAnchors.emotion)) {
          emotionScores[label] = cosineSimilarity(imageVector, anchorVec);
        }

        visualProfile = {
          tone: selectTopDescriptors(toneScores),
          emotion: selectTopDescriptors(emotionScores)
        };
      }

      analyses.push({
        imagePath: resolvedPath,
        label: normalized.label,
        matches,
        topMatch: matches[0] || null,
        confidence: matches[0]?.score ?? 0,
        attention,
        symbolVerification,
        visualProfile
      });
    }

    return analyses;
  }
}

export default TarotVisionPipeline;

function normalizeInput(input) {
  if (typeof input === 'string') {
    return { source: input, label: input };
  }
  if (input && typeof input === 'object') {
    const label = input.label || input.name || input.source || 'uploaded-image';
    const source = input.source || input.dataUrl || input.url;
    if (!source) {
      throw new Error('Image input objects must include a source/dataUrl/url property.');
    }
    return { source, label };
  }
  throw new Error('Unsupported image input type.');
}

function normalizeImageSource(source) {
  if (typeof source === 'string') {
    if (!IS_BROWSER) {
      if (source.startsWith('http') || source.startsWith('data:')) {
        return source;
      }
      if (!NODE_BASE_URL) {
        return source;
      }
      const resolved = new URL(source, NODE_BASE_URL);
      let filePath = decodeURIComponent(resolved.pathname);
      if (/^\/[A-Za-z]:/.test(filePath)) {
        filePath = filePath.slice(1);
      }
      return filePath;
    }
    return source;
  }
  throw new Error('Image source must be a string path, URL, or data URL.');
}
</file>

<file path="shared/vision/visionBackends.js">
// Lazy load TarotVisionPipeline to avoid bundling @xenova/transformers at import time
// This prevents Workers runtime errors when the vision code is loaded but not used
let TarotVisionPipelineClass = null;

async function getTarotVisionPipeline() {
  if (!TarotVisionPipelineClass) {
    const module = await import('./tarotVisionPipeline.js');
    TarotVisionPipelineClass = module.TarotVisionPipeline;
  }
  return TarotVisionPipelineClass;
}

const VISION_BACKENDS = {
  'clip-default': {
    id: 'clip-default',
    label: 'TarotVision CLIP ViT (default)',
    create: async (options = {}) => {
      const Pipeline = await getTarotVisionPipeline();
      return new Pipeline(options);
    }
  }
};

function resolveBackendDescriptor(backendId) {
  if (backendId && VISION_BACKENDS[backendId]) {
    return VISION_BACKENDS[backendId];
  }
  return VISION_BACKENDS['clip-default'];
}

export async function createVisionBackend(options = {}) {
  const descriptor = resolveBackendDescriptor(options.backendId);
  const instance = await descriptor.create(options);
  return {
    id: descriptor.id,
    label: descriptor.label,
    instance,
    analyzeImages: (inputs, analysisOptions) => instance.analyzeImages(inputs, analysisOptions),
    warmup: () => (typeof instance._ensureCardEmbeddings === 'function' ? instance._ensureCardEmbeddings() : Promise.resolve()),
    getDeckProfile: () => instance.deckProfile
  };
}

export function listVisionBackends() {
  return Object.keys(VISION_BACKENDS);
}
</file>

<file path="shared/vision/visualSemantics.js">
// Shared definitions for Visual Semantic Profiling
// These anchors are used to translate raw image vectors into narrative-ready descriptors.

export const VISUAL_TONE_ANCHORS = {
  brightness: [
    { label: 'bright', text: 'A bright, high-key image filled with light' },
    { label: 'shadowy', text: 'A dark, low-key image filled with shadows' }
  ],
  saturation: [
    { label: 'vibrant', text: 'A vibrant, highly saturated colorful image' },
    { label: 'muted', text: 'A desaturated, muted, or monochromatic image' }
  ],
  complexity: [
    { label: 'minimalist', text: 'A simple, minimalist image with empty space' },
    { label: 'intricate', text: 'A complex, detailed, busy image' }
  ],
  style: [
    { label: 'traditional', text: 'A classic, traditional woodcut or line art style' },
    { label: 'modern', text: 'A modern, digital, or photographic style' },
    { label: 'abstract', text: 'An abstract, symbolic, or surreal image' }
  ]
};

export const VISUAL_EMOTION_ANCHORS = [
  { label: 'peaceful', text: 'A peaceful, calm, and serene atmosphere' },
  { label: 'chaotic', text: 'A chaotic, turbulent, and intense atmosphere' },
  { label: 'joyful', text: 'A joyful, celebratory, and positive atmosphere' },
  { label: 'melancholic', text: 'A sad, melancholic, or heavy atmosphere' },
  { label: 'mysterious', text: 'A mysterious, esoteric, and hidden atmosphere' },
  { label: 'direct', text: 'A clear, direct, and revealing atmosphere' }
];

/**
 * Select the top matching descriptors from a set of scores.
 * @param {Object} scores - Map of label -> similarity score
 * @param {number} threshold - Minimum similarity to be considered relevant
 * @returns {Array<string>} List of relevant descriptors
 */
export function selectTopDescriptors(scores, threshold = 0.2) {
  return Object.entries(scores)
    .filter(([_, score]) => score >= threshold)
    .sort((a, b) => b[1] - a[1])
    .map(([label]) => label);
}
</file>

<file path="shared/fallbackAudio.js">
// Shared fallback audio waveform generator.
// Creates a short, calming sine-wave clip encoded as a WAV data URI
// so both the Cloudflare worker and the browser can provide audible
// feedback when real TTS is unavailable.

export function generateFallbackWaveform(text = '') {
  const sampleRate = 22050;
  const words = typeof text === 'string'
    ? text.trim().split(/\s+/).filter(Boolean).length || 1
    : 1;
  const durationSeconds = Math.max(1.5, Math.min(12, words * 0.8));
  const totalSamples = Math.floor(sampleRate * durationSeconds);
  const baseFrequency = 200 + Math.min(300, words * 40);
  const sweepFrequency = baseFrequency + Math.min(260, text.length || 0);
  const amplitude = 0.4;

  const buffer = new ArrayBuffer(44 + totalSamples * 2);
  const view = new DataView(buffer);

  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + totalSamples * 2, true);
  writeString(view, 8, 'WAVE');

  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true); // Subchunk1Size
  view.setUint16(20, 1, true); // Audio format (PCM)
  view.setUint16(22, 1, true); // Number of channels (mono)
  view.setUint32(24, sampleRate, true); // Sample rate
  view.setUint32(28, sampleRate * 2, true); // Byte rate (SampleRate * NumChannels * BitsPerSample/8)
  view.setUint16(32, 2, true); // Block align
  view.setUint16(34, 16, true); // Bits per sample

  writeString(view, 36, 'data');
  view.setUint32(40, totalSamples * 2, true);

  const dataView = new DataView(buffer, 44);
  for (let i = 0; i < totalSamples; i += 1) {
    const time = i / sampleRate;
    const sweep = baseFrequency + (sweepFrequency - baseFrequency) * (i / totalSamples);
    const envelope = Math.sin(Math.PI * Math.min(1, time / durationSeconds));
    const sample = Math.sin(2 * Math.PI * sweep * time) * amplitude * envelope;
    dataView.setInt16(i * 2, sample * 0x7fff, true);
  }

  const wavBytes = new Uint8Array(buffer);
  const base64Audio = uint8ToBase64(wavBytes);
  return `data:audio/wav;base64,${base64Audio}`;
}

function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i += 1) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}

function uint8ToBase64(uint8Array) {
  if (typeof Buffer !== 'undefined') {
    return Buffer.from(uint8Array).toString('base64');
  }

  let binary = '';
  const chunkSize = 0x8000;
  for (let i = 0; i < uint8Array.length; i += chunkSize) {
    const chunk = uint8Array.subarray(i, i + chunkSize);
    binary += String.fromCharCode(...chunk);
  }
  if (typeof btoa === 'function') {
    return btoa(binary);
  }
  if (typeof Buffer !== 'undefined') {
    return Buffer.from(binary, 'binary').toString('base64');
  }
  throw new Error('No base64 encoder available in this environment.');
}
</file>

<file path="src/components/onboarding/AccountSetup.jsx">
import { useState } from 'react';
import { ArrowLeft, ArrowRight, User, EnvelopeSimple, Lock, Check, CircleNotch, CloudArrowUp, Warning } from '@phosphor-icons/react';
import { useReducedMotion } from '../../hooks/useReducedMotion';
import { useLandscape } from '../../hooks/useLandscape';
import { useAuth } from '../../contexts/AuthContext';

/**
 * AccountSetup - Step 2 of onboarding
 *
 * Explains benefits of account creation and provides
 * inline registration form. Users can skip if preferred.
 */
export function AccountSetup({ onNext, onBack }) {
  const prefersReducedMotion = useReducedMotion();
  const isLandscape = useLandscape();
  const { isAuthenticated, user, register, login, loading: authLoading } = useAuth();

  const [mode, setMode] = useState('register'); // 'register' or 'login'
  const [email, setEmail] = useState('');
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState(null);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError(null);
    setIsSubmitting(true);

    let result;
    if (mode === 'register') {
      result = await register(email, username, password);
    } else {
      result = await login(email, password);
    }

    setIsSubmitting(false);

    if (result.success) {
      onNext();
    } else {
      const defaultError = mode === 'register'
        ? 'Registration failed. Please try again.'
        : 'Sign in failed. Check your email and password.';
      setError(result.error || defaultError);
    }
  };

  const toggleMode = () => {
    setMode(prev => prev === 'register' ? 'login' : 'register');
    setError(null);
  };

  // If already authenticated, show success state
  if (isAuthenticated && user) {
    return (
      <div className="flex flex-col h-full">
        {/* Header */}
        <div
          className={`text-center mb-4 sm:mb-6 ${prefersReducedMotion ? '' : 'animate-fade-in-up'}`}
        >
          <h2 className={`font-serif text-main ${isLandscape ? 'text-xl' : 'text-2xl sm:text-3xl'}`}>
            You&apos;re All Set
          </h2>
        </div>

        {/* Already authenticated content */}
        <div className="flex-1 flex flex-col items-center justify-center">
          <div
            className={`rounded-2xl border border-success/30 bg-success/10 p-6 text-center max-w-sm ${
              prefersReducedMotion ? '' : 'animate-fade-in-up'
            }`}
            style={{ animationDelay: '0.1s' }}
          >
            <div className="w-16 h-16 mx-auto mb-4 rounded-full bg-success/20 flex items-center justify-center">
              <Check className="w-8 h-8 text-success" weight="bold" aria-hidden="true" />
            </div>
            <p className="text-lg text-main font-medium mb-2">
              You&apos;re signed in as {user.username || user.email}
            </p>
            <p className="text-sm text-muted">
              Your readings will sync across devices automatically.
            </p>
          </div>
        </div>

        {/* Navigation */}
        <div className={`flex gap-3 pt-4 pb-safe-bottom ${isLandscape ? 'pt-2' : 'pt-6'}`}>
          <button
            type="button"
            onClick={onBack}
            className="flex items-center justify-center gap-1 min-h-[48px] px-4 py-3 rounded-xl border border-secondary/40 text-muted hover:text-main hover:border-secondary/60 transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2 focus-visible:ring-offset-main"
          >
            <ArrowLeft className="w-4 h-4" />
            <span className="hidden xs:inline">Back</span>
          </button>
          <button
            type="button"
            onClick={onNext}
            className="flex-1 flex items-center justify-center gap-2 min-h-[48px] px-6 py-3 rounded-xl bg-accent text-surface font-semibold text-base transition hover:bg-accent/90 active:scale-[0.98] touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main"
          >
            Continue
            <ArrowRight className="w-5 h-5" weight="bold" />
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col h-full">
      {/* Header */}
      <div
        className={`text-center mb-4 sm:mb-6 ${prefersReducedMotion ? '' : 'animate-fade-in-up'}`}
      >
        <h2 className={`font-serif text-main ${isLandscape ? 'text-xl' : 'text-2xl sm:text-3xl'}`}>
          {mode === 'register' ? 'Save Your Journey' : 'Welcome Back'}
        </h2>
        <p className={`text-muted mt-2 max-w-md mx-auto ${isLandscape ? 'text-sm' : ''}`}>
          {mode === 'register'
            ? 'Create an account to keep your readings safe and synced.'
            : 'Sign in to access your saved readings.'}
        </p>
      </div>

      {/* Main content */}
      <div className="flex-1 overflow-y-auto space-y-4 sm:space-y-6">
        {/* Benefits - only show for registration */}
        {mode === 'register' && (
          <div
            className={`rounded-2xl border border-accent/20 bg-surface/50 p-5 ${
              prefersReducedMotion ? '' : 'animate-fade-in-up'
            } ${isLandscape ? 'p-4' : ''}`}
            style={{ animationDelay: '0.1s' }}
          >
            <div className="flex items-center gap-3 mb-3">
              <div className="w-10 h-10 rounded-full bg-accent/10 border border-accent/30 flex items-center justify-center">
                <CloudArrowUp className="w-5 h-5 text-accent" weight="duotone" aria-hidden="true" />
              </div>
              <h3 className="font-medium text-main">Benefits of an account</h3>
            </div>
            <ul className={`space-y-2 ${isLandscape ? 'text-sm' : ''}`}>
              <li className="flex items-start gap-2 text-muted">
                <Check className="w-4 h-4 text-accent shrink-0 mt-0.5" weight="bold" aria-hidden="true" />
                <span>Sync your readings across devices</span>
              </li>
              <li className="flex items-start gap-2 text-muted">
                <Check className="w-4 h-4 text-accent shrink-0 mt-0.5" weight="bold" aria-hidden="true" />
                <span>Track patterns over time</span>
              </li>
              <li className="flex items-start gap-2 text-muted">
                <Check className="w-4 h-4 text-accent shrink-0 mt-0.5" weight="bold" aria-hidden="true" />
                <span>Never lose your insights</span>
              </li>
            </ul>
          </div>
        )}

        {/* Registration form */}
        <form
          onSubmit={handleSubmit}
          className={`space-y-4 ${prefersReducedMotion ? '' : 'animate-fade-in-up'}`}
          style={{ animationDelay: '0.2s' }}
        >
          {/* Error message */}
          {error && (
            <div className="flex items-center gap-2 p-3 rounded-xl bg-error/10 border border-error/30 text-error text-sm">
              <Warning className="w-5 h-5 shrink-0" weight="fill" aria-hidden="true" />
              <span>{error}</span>
            </div>
          )}

          {/* Email input */}
          <div>
            <label htmlFor="signup-email" className="flex items-center gap-2 text-sm text-accent mb-2">
              <EnvelopeSimple className="w-4 h-4" weight="duotone" aria-hidden="true" />
              Email
            </label>
            <input
              id="signup-email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="you@example.com"
              required
              autoComplete="email"
              className="w-full bg-surface border border-primary/40 rounded-xl px-4 py-3 text-base text-main placeholder-muted/70 focus:outline-none focus:border-primary focus:ring-1 focus:ring-primary/70 transition-all"
            />
          </div>

          {/* Username input - only for registration */}
          {mode === 'register' && (
            <div>
              <label htmlFor="signup-username" className="flex items-center gap-2 text-sm text-accent mb-2">
                <User className="w-4 h-4" weight="duotone" aria-hidden="true" />
                Username
              </label>
              <input
                id="signup-username"
                type="text"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                placeholder="Choose a username"
                required
                autoComplete="username"
                className="w-full bg-surface border border-primary/40 rounded-xl px-4 py-3 text-base text-main placeholder-muted/70 focus:outline-none focus:border-primary focus:ring-1 focus:ring-primary/70 transition-all"
              />
            </div>
          )}

          {/* Password input */}
          <div>
            <label htmlFor="signup-password" className="flex items-center gap-2 text-sm text-accent mb-2">
              <Lock className="w-4 h-4" weight="duotone" aria-hidden="true" />
              Password
            </label>
            <input
              id="signup-password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder={mode === 'register' ? 'Create a password' : 'Enter your password'}
              required
              autoComplete={mode === 'register' ? 'new-password' : 'current-password'}
              minLength={mode === 'register' ? 8 : undefined}
              className="w-full bg-surface border border-primary/40 rounded-xl px-4 py-3 text-base text-main placeholder-muted/70 focus:outline-none focus:border-primary focus:ring-1 focus:ring-primary/70 transition-all"
            />
            {mode === 'register' && (
              <p className="text-xs text-muted mt-1">At least 8 characters</p>
            )}
          </div>

          {/* Submit button */}
          <button
            type="submit"
            disabled={isSubmitting || authLoading}
            className="w-full flex items-center justify-center gap-2 min-h-[48px] px-6 py-3 rounded-xl bg-accent text-surface font-semibold text-base transition hover:bg-accent/90 active:scale-[0.98] disabled:opacity-50 disabled:cursor-not-allowed touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main"
          >
            {isSubmitting ? (
              <>
                <CircleNotch className="w-5 h-5 animate-spin" aria-hidden="true" />
                {mode === 'register' ? 'Creating account...' : 'Signing in...'}
              </>
            ) : (
              <>
                {mode === 'register' ? 'Create Account' : 'Sign In'}
                <ArrowRight className="w-5 h-5" weight="bold" />
              </>
            )}
          </button>

          {/* Mode toggle */}
          <p className="text-center text-sm text-muted">
            {mode === 'register' ? (
              <>
                Already have an account?{' '}
                <button
                  type="button"
                  onClick={toggleMode}
                  className="text-accent hover:underline focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent"
                >
                  Sign in
                </button>
              </>
            ) : (
              <>
                New here?{' '}
                <button
                  type="button"
                  onClick={toggleMode}
                  className="text-accent hover:underline focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent"
                >
                  Create an account
                </button>
              </>
            )}
          </p>
        </form>
      </div>

      {/* Navigation */}
      <div className={`flex flex-col gap-3 pt-4 pb-safe-bottom ${isLandscape ? 'pt-2' : 'pt-6'}`}>
        <div className="flex gap-3">
          <button
            type="button"
            onClick={onBack}
            className="flex items-center justify-center gap-1 min-h-[48px] px-4 py-3 rounded-xl border border-secondary/40 text-muted hover:text-main hover:border-secondary/60 transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2 focus-visible:ring-offset-main"
          >
            <ArrowLeft className="w-4 h-4" />
            <span className="hidden xs:inline">Back</span>
          </button>
          <button
            type="button"
            onClick={onNext}
            className="flex-1 min-h-[48px] px-4 py-3 text-muted hover:text-main text-sm transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2 focus-visible:ring-offset-main"
          >
            Skip
          </button>
        </div>
        <p className="text-xs text-muted text-center">
          You can always create an account later from Settings
        </p>
      </div>
    </div>
  );
}
</file>

<file path="src/components/onboarding/index.js">
export { OnboardingWizard } from './OnboardingWizard';
export { WelcomeHero } from './WelcomeHero';
export { SpreadEducation } from './SpreadEducation';
export { QuestionCrafting } from './QuestionCrafting';
export { RitualIntro } from './RitualIntro';
export { AccountSetup } from './AccountSetup';
export { JournalIntro } from './JournalIntro';
export { JourneyBegin } from './JourneyBegin';
export { OnboardingProgress } from './OnboardingProgress';
</file>

<file path="src/components/onboarding/JournalIntro.jsx">
import { ArrowLeft, ArrowRight, Notebook, ClockCounterClockwise, Sparkle, MagnifyingGlass, PencilLine, CloudCheck, HardDrive } from '@phosphor-icons/react';
import { useReducedMotion } from '../../hooks/useReducedMotion';
import { useLandscape } from '../../hooks/useLandscape';
import { useAuth } from '../../contexts/AuthContext';

/**
 * JournalIntro - Step 6 of onboarding
 *
 * Introduces the journal feature and explains its benefits.
 * Shows sync status based on authentication state.
 */
export function JournalIntro({ onNext, onBack }) {
  const prefersReducedMotion = useReducedMotion();
  const isLandscape = useLandscape();
  const { isAuthenticated } = useAuth();

  const journalBenefits = [
    {
      icon: ClockCounterClockwise,
      title: 'Track patterns across readings',
      description: 'See recurring themes and symbols emerge over time',
    },
    {
      icon: MagnifyingGlass,
      title: 'Revisit past insights anytime',
      description: 'Search and browse your complete reading history',
    },
    {
      icon: Sparkle,
      title: 'Watch your understanding deepen',
      description: 'Notice how your interpretations evolve with practice',
    },
    {
      icon: PencilLine,
      title: 'Add personal reflections',
      description: 'Capture your own thoughts alongside each reading',
    },
  ];

  return (
    <div className="flex flex-col h-full">
      {/* Header */}
      <div
        className={`text-center mb-4 sm:mb-6 ${prefersReducedMotion ? '' : 'animate-fade-in-up'}`}
      >
        <h2 className={`font-serif text-main ${isLandscape ? 'text-xl' : 'text-2xl sm:text-3xl'}`}>
          Your Tarot Journal
        </h2>
        <p className={`text-muted mt-2 max-w-md mx-auto ${isLandscape ? 'text-sm' : ''}`}>
          A personal space to collect and reflect on your readings.
        </p>
      </div>

      {/* Main content */}
      <div className="flex-1 overflow-y-auto space-y-4 sm:space-y-6">
        {/* Visual preview */}
        <div
          className={`flex justify-center ${prefersReducedMotion ? '' : 'animate-fade-in-up'}`}
          style={{ animationDelay: '0.1s' }}
        >
          <div className="relative">
            <div className="w-24 h-24 sm:w-28 sm:h-28 rounded-2xl bg-gradient-to-br from-accent/20 to-primary/20 border border-accent/30 flex items-center justify-center">
              <Notebook
                className="w-12 h-12 sm:w-14 sm:h-14 text-accent"
                weight="duotone"
                aria-hidden="true"
              />
            </div>
            <div className="absolute -top-2 -right-2 w-8 h-8 rounded-full bg-gold/20 border border-gold/40 flex items-center justify-center">
              <Sparkle className="w-4 h-4 text-gold" weight="fill" aria-hidden="true" />
            </div>
          </div>
        </div>

        {/* Benefits list */}
        <div
          className={`space-y-3 ${prefersReducedMotion ? '' : 'animate-fade-in-up'} ${
            isLandscape ? 'grid grid-cols-2 gap-3 space-y-0' : ''
          }`}
          style={{ animationDelay: '0.2s' }}
        >
          {journalBenefits.map((benefit, index) => {
            const Icon = benefit.icon;
            return (
              <div
                key={index}
                className="flex items-start gap-3 p-4 rounded-xl border border-secondary/20 bg-surface/50"
              >
                <div className="w-10 h-10 shrink-0 rounded-full bg-accent/10 border border-accent/30 flex items-center justify-center">
                  <Icon className="w-5 h-5 text-accent" weight="duotone" aria-hidden="true" />
                </div>
                <div>
                  <h3 className="text-sm font-medium text-main">{benefit.title}</h3>
                  {!isLandscape && (
                    <p className="text-xs text-muted mt-0.5">{benefit.description}</p>
                  )}
                </div>
              </div>
            );
          })}
        </div>

        {/* Sync status */}
        <div
          className={`rounded-2xl border p-4 ${
            isAuthenticated
              ? 'border-success/30 bg-success/5'
              : 'border-secondary/20 bg-surface/30'
          } ${prefersReducedMotion ? '' : 'animate-fade-in-up'}`}
          style={{ animationDelay: '0.3s' }}
        >
          <div className="flex items-center gap-3">
            {isAuthenticated ? (
              <>
                <div className="w-10 h-10 shrink-0 rounded-full bg-success/20 flex items-center justify-center">
                  <CloudCheck className="w-5 h-5 text-success" weight="fill" aria-hidden="true" />
                </div>
                <div>
                  <p className="text-sm font-medium text-main">Synced to your account</p>
                  <p className="text-xs text-muted">Your journal is backed up and accessible anywhere</p>
                </div>
              </>
            ) : (
              <>
                <div className="w-10 h-10 shrink-0 rounded-full bg-secondary/20 flex items-center justify-center">
                  <HardDrive className="w-5 h-5 text-muted" weight="duotone" aria-hidden="true" />
                </div>
                <div>
                  <p className="text-sm font-medium text-main">Saved locally on this device</p>
                  <p className="text-xs text-muted">
                    Your journal stays private on this browser. Create an account to sync across devices.
                  </p>
                </div>
              </>
            )}
          </div>
        </div>
      </div>

      {/* Navigation */}
      <div className={`flex gap-3 pt-4 pb-safe-bottom ${isLandscape ? 'pt-2' : 'pt-6'}`}>
        <button
          type="button"
          onClick={onBack}
          className="flex items-center justify-center gap-1 min-h-[48px] px-4 py-3 rounded-xl border border-secondary/40 text-muted hover:text-main hover:border-secondary/60 transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2 focus-visible:ring-offset-main"
        >
          <ArrowLeft className="w-4 h-4" />
          <span className="hidden xs:inline">Back</span>
        </button>
        <button
          type="button"
          onClick={onNext}
          className="flex-1 flex items-center justify-center gap-2 min-h-[48px] px-6 py-3 rounded-xl bg-accent text-surface font-semibold text-base transition hover:bg-accent/90 active:scale-[0.98] touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main"
        >
          Continue
          <ArrowRight className="w-5 h-5" weight="bold" />
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/onboarding/JourneyBegin.jsx">
import { Star, Sparkle, ArrowLeft, Play, Lightbulb, Check, GearSix } from '@phosphor-icons/react';
import { SPREADS } from '../../data/spreads';
import { useReducedMotion } from '../../hooks/useReducedMotion';
import { useLandscape } from '../../hooks/useLandscape';
import { usePreferences } from '../../contexts/PreferencesContext';
import { useAuth } from '../../contexts/AuthContext';

// Labels for personalization options
const SPREAD_DEPTH_LABELS = {
  short: 'quick check-in',
  standard: 'balanced',
  deep: 'deep dive',
};

const READING_TONE_LABELS = {
  gentle: 'gentle & encouraging',
  balanced: 'honest but kind',
  blunt: 'blunt',
};

const SPIRITUAL_FRAME_LABELS = {
  psychological: 'psychological',
  spiritual: 'spiritual',
  mixed: 'balanced',
  playful: 'playful',
};

const FOCUS_AREA_LABELS = {
  love: 'love & relationships',
  career: 'career & money',
  self_worth: 'self-worth',
  healing: 'healing & growth',
  creativity: 'creativity',
  spirituality: 'spiritual path',
};

/**
 * JourneyBegin - Step 7 of onboarding
 *
 * Final celebration step that summarizes selections
 * and shows personalization recap before launching the first reading.
 */
export function JourneyBegin({ selectedSpread, question, onBegin, onBack }) {
  const prefersReducedMotion = useReducedMotion();
  const isLandscape = useLandscape();
  const { personalization } = usePreferences();
  const { isAuthenticated } = useAuth();

  const spread = SPREADS[selectedSpread];
  const hasQuestion = question && question.trim().length > 0;

  // Build focus areas label
  const focusAreasLabel = (personalization.focusAreas || [])
    .map((area) => FOCUS_AREA_LABELS[area])
    .join(', ');

  return (
    <div className="flex flex-col h-full">
      {/* Hero celebration */}
      <div className="flex-1 flex flex-col items-center justify-center text-center overflow-y-auto">
        {/* Animated stars/sparkles */}
        <div
          className={`relative mb-4 ${prefersReducedMotion ? '' : 'animate-fade-in-up'} ${
            isLandscape ? 'mb-2' : 'mb-6'
          }`}
          style={{ animationDelay: '0.1s' }}
        >
          <div className="relative">
            <Star
              className={`text-gold ${isLandscape ? 'w-14 h-14' : 'w-20 h-20 sm:w-24 sm:h-24'}`}
              weight="duotone"
              aria-hidden="true"
            />
            <Sparkle
              className="absolute -top-2 -right-1 w-6 h-6 text-accent"
              weight="fill"
              aria-hidden="true"
            />
            <Sparkle
              className="absolute bottom-0 -left-3 w-5 h-5 text-primary"
              weight="fill"
              aria-hidden="true"
            />
          </div>
        </div>

        {/* Encouraging message */}
        <div
          className={prefersReducedMotion ? '' : 'animate-fade-in-up'}
          style={{ animationDelay: '0.2s' }}
        >
          <h2
            className={`font-serif text-main mb-2 ${
              isLandscape ? 'text-xl' : 'text-2xl sm:text-3xl'
            }`}
          >
            You&apos;re Ready
          </h2>
          <p
            className={`text-muted max-w-md mx-auto leading-relaxed ${
              isLandscape ? 'text-sm' : 'text-base'
            }`}
          >
            Stay open to what feels true. The cards will meet you where you are.
          </p>
        </div>

        {/* Personalization recap */}
        <div
          className={`mt-4 w-full max-w-md ${
            prefersReducedMotion ? '' : 'animate-fade-in-up'
          } ${isLandscape ? 'mt-3' : 'mt-6 sm:mt-8'}`}
          style={{ animationDelay: '0.3s' }}
        >
          <div className="rounded-2xl border border-accent/30 bg-surface/60 backdrop-blur-sm p-4 sm:p-5 text-left">
            <h3 className="text-xs uppercase tracking-widest text-accent mb-3 flex items-center gap-2">
              <Sparkle className="w-3.5 h-3.5" weight="fill" />
              Your Personalized Setup
            </h3>

            <div className="space-y-2">
              {/* Display name */}
              <div className="flex items-start gap-2 text-sm">
                <Check className="w-4 h-4 text-accent shrink-0 mt-0.5" weight="bold" aria-hidden="true" />
                <span className="text-muted">
                  We&apos;ll call you{' '}
                  <span className="text-main font-medium">
                    {personalization.displayName || 'you'}
                  </span>
                </span>
              </div>

              {/* Spread depth */}
              <div className="flex items-start gap-2 text-sm">
                <Check className="w-4 h-4 text-accent shrink-0 mt-0.5" weight="bold" aria-hidden="true" />
                <span className="text-muted">
                  We&apos;ll start with{' '}
                  <span className="text-main font-medium">
                    {SPREAD_DEPTH_LABELS[personalization.preferredSpreadDepth] || 'balanced'}
                  </span>{' '}
                  readings
                </span>
              </div>

              {/* Focus areas */}
              <div className="flex items-start gap-2 text-sm">
                <Check className="w-4 h-4 text-accent shrink-0 mt-0.5" weight="bold" aria-hidden="true" />
                <span className="text-muted">
                  We&apos;ll focus on{' '}
                  <span className="text-main font-medium">
                    {focusAreasLabel || "whatever's on your mind"}
                  </span>
                </span>
              </div>

              {/* Reading tone and frame */}
              <div className="flex items-start gap-2 text-sm">
                <Check className="w-4 h-4 text-accent shrink-0 mt-0.5" weight="bold" aria-hidden="true" />
                <span className="text-muted">
                  Readings will be{' '}
                  <span className="text-main font-medium">
                    {READING_TONE_LABELS[personalization.readingTone] || 'honest but kind'}
                  </span>{' '}
                  with a{' '}
                  <span className="text-main font-medium">
                    {SPIRITUAL_FRAME_LABELS[personalization.spiritualFrame] || 'balanced'}
                  </span>{' '}
                  lens
                </span>
              </div>

              {/* Journal sync status */}
              <div className="flex items-start gap-2 text-sm">
                <Check className="w-4 h-4 text-accent shrink-0 mt-0.5" weight="bold" aria-hidden="true" />
                <span className="text-muted">
                  Your journal is{' '}
                  <span className="text-main font-medium">
                    {isAuthenticated ? 'synced to your account' : 'saved locally'}
                  </span>
                </span>
              </div>
            </div>

            {/* Settings note */}
            <p className="mt-3 pt-3 border-t border-secondary/20 text-xs text-muted flex items-center gap-1">
              <GearSix className="w-3.5 h-3.5 shrink-0" aria-hidden="true" />
              You can tweak all of this anytime in Settings → &quot;Reading style&quot;
            </p>
          </div>
        </div>

        {/* First reading info */}
        {!isLandscape && (
          <div
            className={`mt-4 w-full max-w-md rounded-xl border border-secondary/20 bg-surface/30 p-4 text-left ${
              prefersReducedMotion ? '' : 'animate-fade-in-up'
            }`}
            style={{ animationDelay: '0.4s' }}
          >
            <h4 className="text-xs uppercase tracking-widest text-muted mb-2">First Reading</h4>
            <div className="flex items-center justify-between">
              <span className="text-sm text-muted">Spread</span>
              <span className="text-sm text-main font-medium">
                {spread?.name || 'One-Card Insight'}
              </span>
            </div>
            {hasQuestion && (
              <p className="text-sm text-main italic mt-2 leading-relaxed">
                &quot;{question}&quot;
              </p>
            )}
          </div>
        )}

        {/* Tip */}
        {!isLandscape && (
          <p
            className={`mt-4 text-xs text-muted max-w-sm mx-auto flex items-start gap-1.5 ${
              prefersReducedMotion ? '' : 'animate-fade-in-up'
            }`}
            style={{ animationDelay: '0.5s' }}
          >
            <Lightbulb className="w-4 h-4 text-accent shrink-0 mt-0.5" weight="fill" />
            <span>
              <strong className="text-main">Tip:</strong> Take a breath before you draw. Let your
              mind settle on your question or simply be open to what appears.
            </span>
          </p>
        )}
      </div>

      {/* Navigation */}
      <div className={`flex gap-3 pt-4 pb-safe-bottom ${isLandscape ? 'pt-2' : 'pt-6'}`}>
        <button
          type="button"
          onClick={onBack}
          className="flex items-center justify-center gap-1 min-h-[48px] px-4 py-3 rounded-xl border border-secondary/40 text-muted hover:text-main hover:border-secondary/60 transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2 focus-visible:ring-offset-main"
        >
          <ArrowLeft className="w-4 h-4" />
          <span className="hidden xs:inline">Back</span>
        </button>
        <button
          type="button"
          onClick={onBegin}
          className="flex-1 flex items-center justify-center gap-2 min-h-[52px] px-6 py-3 rounded-xl bg-gradient-to-r from-accent to-gold text-surface font-bold text-lg shadow-lg shadow-accent/25 transition hover:shadow-xl hover:shadow-accent/30 active:scale-[0.98] touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main"
        >
          <Play className="w-5 h-5" weight="fill" />
          Begin Your Reading
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/onboarding/OnboardingProgress.jsx">
import { Check } from '@phosphor-icons/react';
import { useReducedMotion } from '../../hooks/useReducedMotion';

const STEP_LABELS = [
  'Welcome',
  'Account',
  'Spreads',
  'Question',
  'Ritual',
  'Journal',
  'Begin',
];

/**
 * OnboardingProgress - Progress indicator for onboarding wizard
 *
 * Shows current step and allows navigation to previously visited steps.
 * Mobile-compact design with dots, expanding to labels on larger screens.
 */
export function OnboardingProgress({
  currentStep,
  totalSteps,
  onStepSelect,
  allowNavigation = true,
}) {
  const prefersReducedMotion = useReducedMotion();

  return (
    <div className="flex-1">
      {/* Mobile: compact dots with horizontal scroll on very narrow screens */}
      <nav
        className="flex items-center gap-1.5 xs:gap-2 sm:hidden overflow-x-auto scrollbar-none px-1.5 xxs:px-2"
        aria-label="Onboarding progress"
      >
        {Array.from({ length: totalSteps }, (_, i) => {
          const step = i + 1;
          const isCompleted = step < currentStep;
          const isCurrent = step === currentStep;
          const isAccessible = allowNavigation && step <= currentStep;

          return (
            <button
              key={step}
              type="button"
              onClick={() => isAccessible && onStepSelect?.(step)}
              disabled={!isAccessible}
              className={`relative min-w-[2rem] w-8 h-8 xs:min-w-[2.25rem] xs:w-9 xs:h-9 rounded-full flex items-center justify-center shrink-0 transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main ${
                isCurrent
                  ? 'bg-accent text-surface'
                  : isCompleted
                  ? 'bg-accent/20 text-accent'
                  : 'bg-surface-muted text-muted'
              } ${isAccessible && !isCurrent ? 'hover:bg-accent/30' : ''} ${
                !isAccessible ? 'cursor-not-allowed opacity-50' : ''
              }`}
              aria-label={`Step ${step}: ${STEP_LABELS[i] || `Step ${step}`}${
                isCompleted ? ' (completed)' : isCurrent ? ' (current)' : ''
              }`}
              aria-current={isCurrent ? 'step' : undefined}
            >
              {isCompleted ? (
                <Check className="w-3.5 h-3.5 xs:w-4 xs:h-4" weight="bold" />
              ) : (
                <span className="text-[0.6rem] xxs:text-[0.65rem] xs:text-[0.7rem] font-semibold">{step}</span>
              )}
            </button>
          );
        })}
      </nav>

      {/* Desktop: labels with connecting line */}
      <nav
        className="hidden sm:flex flex-wrap items-center gap-1"
        aria-label="Onboarding progress"
      >
        {Array.from({ length: totalSteps }, (_, i) => {
          const step = i + 1;
          const isCompleted = step < currentStep;
          const isCurrent = step === currentStep;
          const isAccessible = allowNavigation && step <= currentStep;
          const isLast = step === totalSteps;

          return (
            <div key={step} className="flex items-center">
              <button
                type="button"
                onClick={() => isAccessible && onStepSelect?.(step)}
                disabled={!isAccessible}
                className={`flex items-center gap-2 px-3 py-1.5 rounded-full transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main ${
                  isCurrent
                    ? 'bg-accent text-surface'
                    : isCompleted
                    ? 'bg-accent/10 text-accent hover:bg-accent/20'
                    : 'text-muted'
                } ${!isAccessible ? 'cursor-not-allowed opacity-50' : ''}`}
                aria-label={`${STEP_LABELS[i] || `Step ${step}`}${
                  isCompleted ? ' (completed)' : isCurrent ? ' (current)' : ''
                }`}
                aria-current={isCurrent ? 'step' : undefined}
              >
                <span
                  className={`w-5 h-5 rounded-full flex items-center justify-center text-xs font-semibold ${
                    isCurrent
                      ? 'bg-surface/20 text-surface'
                      : isCompleted
                      ? 'bg-accent/20 text-accent'
                      : 'bg-surface-muted/50 text-muted'
                  }`}
                >
                  {isCompleted ? (
                    <Check className="w-3 h-3" weight="bold" />
                  ) : (
                    step
                  )}
                </span>
                <span className="text-[0.65rem] sm:text-xs lg:text-sm font-medium">{STEP_LABELS[i]}</span>
              </button>

              {/* Connector line */}
              {!isLast && (
                <div
                  className={`w-4 h-px mx-1 ${
                    isCompleted ? 'bg-accent/40' : 'bg-secondary/20'
                  } ${prefersReducedMotion ? '' : 'transition-colors duration-300'}`}
                  aria-hidden="true"
                />
              )}
            </div>
          );
        })}
      </nav>
    </div>
  );
}
</file>

<file path="src/components/onboarding/OnboardingWizard.jsx">
import { useState, useRef, useId } from 'react';
import FocusTrap from 'focus-trap-react';
import { X } from '@phosphor-icons/react';
import { useModalA11y, createBackdropHandler } from '../../hooks/useModalA11y';
import { useReducedMotion } from '../../hooks/useReducedMotion';
import { useLandscape } from '../../hooks/useLandscape';
import { WelcomeHero } from './WelcomeHero';
import { SpreadEducation } from './SpreadEducation';
import { QuestionCrafting } from './QuestionCrafting';
import { RitualIntro } from './RitualIntro';
import { AccountSetup } from './AccountSetup';
import { JournalIntro } from './JournalIntro';
import { JourneyBegin } from './JourneyBegin';
import { OnboardingProgress } from './OnboardingProgress';

const TOTAL_STEPS = 7;

/**
 * OnboardingWizard - Multi-step onboarding flow for new users
 *
 * Guides users through:
 * 1. Welcome & introduction to tarot (+ name, experience level)
 * 2. Account setup (optional registration)
 * 3. Learning about spreads (+ depth/focus preferences)
 * 4. Crafting their first question (+ tone/frame preferences)
 * 5. Understanding the ritual (+ ritual preference)
 * 6. Journal introduction
 * 7. Beginning their journey (summary + launch)
 *
 * @param {boolean} isOpen - Whether wizard is visible
 * @param {function} onComplete - Called with { selectedSpread, question } when finished
 * @param {function} onSelectSpread - Called when user selects a spread in step 3
 * @param {string} initialSpread - Pre-selected spread key for replay (default: 'single')
 * @param {string} initialQuestion - Pre-filled question for replay (default: '')
 */
export function OnboardingWizard({ isOpen, onComplete, onSelectSpread, initialSpread = 'single', initialQuestion = '' }) {
  const [currentStep, setCurrentStep] = useState(1);
  const [selectedSpread, setSelectedSpread] = useState(initialSpread || 'single');
  const [question, setQuestion] = useState(initialQuestion || '');

  // Track previous isOpen to detect open transitions
  const [prevIsOpen, setPrevIsOpen] = useState(isOpen);

  // Reset state when wizard opens (replay scenario) to pick up current values.
  // This pattern (adjusting state during render) is React-recommended over useEffect
  // for syncing state with prop changes. See: https://react.dev/learn/you-might-not-need-an-effect
  if (isOpen && !prevIsOpen) {
    setPrevIsOpen(true);
    setCurrentStep(1);
    setSelectedSpread(initialSpread || 'single');
    setQuestion(initialQuestion || '');
  } else if (!isOpen && prevIsOpen) {
    setPrevIsOpen(false);
  }

  const prefersReducedMotion = useReducedMotion();
  const isLandscape = useLandscape();

  const modalRef = useRef(null);
  const closeButtonRef = useRef(null);
  const titleId = useId();

  // Modal accessibility: useModalA11y handles scroll lock, escape key, and focus restoration.
  // Focus trapping is delegated to the FocusTrap library (trapFocus: false) because it provides
  // more robust handling for complex modals with dynamic step content, where focusable elements
  // change between steps. This matches the pattern used in GuidedIntentionCoach and ConfirmModal.
  useModalA11y(isOpen, {
    onClose: () => handleSkip(),
    containerRef: modalRef,
    trapFocus: false, // Disabled - FocusTrap library handles focus trapping
    initialFocusRef: closeButtonRef,
  });

  const handleNext = () => {
    if (currentStep < TOTAL_STEPS) {
      setCurrentStep(currentStep + 1);
    }
  };

  const handleBack = () => {
    if (currentStep > 1) {
      setCurrentStep(currentStep - 1);
    }
  };

  const handleSkip = () => {
    // Mark onboarding as complete and close, passing any selections made so far
    onComplete?.({ selectedSpread, question });
  };

  const handleSpreadSelect = (spreadKey) => {
    setSelectedSpread(spreadKey);
    onSelectSpread?.(spreadKey);
  };

  const handleQuestionChange = (newQuestion) => {
    setQuestion(newQuestion);
  };

  const handleSkipRitual = () => {
    // Complete onboarding immediately - user wants to start reading now
    onComplete?.({ selectedSpread, question });
  };

  const handleBegin = () => {
    // Complete onboarding and pass selections to parent
    onComplete?.({ selectedSpread, question });
  };

  const handleStepSelect = (step) => {
    // Allow navigation to previously visited steps only
    // User selections (spread, question) are preserved in state during navigation
    if (step <= currentStep) {
      setCurrentStep(step);
    }
  };

  if (!isOpen) {
    return null;
  }

  const renderStep = () => {
    switch (currentStep) {
      case 1:
        return (
          <WelcomeHero
            onNext={handleNext}
          />
        );
      case 2:
        return (
          <AccountSetup
            onNext={handleNext}
            onBack={handleBack}
          />
        );
      case 3:
        return (
          <SpreadEducation
            selectedSpread={selectedSpread}
            onSelectSpread={handleSpreadSelect}
            onNext={handleNext}
            onBack={handleBack}
          />
        );
      case 4:
        return (
          <QuestionCrafting
            question={question}
            onQuestionChange={handleQuestionChange}
            onNext={handleNext}
            onBack={handleBack}
          />
        );
      case 5:
        return (
          <RitualIntro
            onNext={handleNext}
            onBack={handleBack}
            onSkipRitual={handleSkipRitual}
          />
        );
      case 6:
        return (
          <JournalIntro
            onNext={handleNext}
            onBack={handleBack}
          />
        );
      case 7:
        return (
          <JourneyBegin
            selectedSpread={selectedSpread}
            question={question}
            onBegin={handleBegin}
            onBack={handleBack}
          />
        );
      default:
        return null;
    }
  };

  return (
    <div
      className={`fixed inset-0 z-[100] flex items-stretch sm:items-center justify-center bg-main/95 backdrop-blur-sm px-safe-left px-safe-right py-safe-top pb-safe-bottom ${
        prefersReducedMotion ? '' : 'animate-fade-in'
      }`}
      onClick={createBackdropHandler(handleSkip)}
    >
      <FocusTrap
        active={isOpen}
        focusTrapOptions={{
          initialFocus: () => closeButtonRef.current,
          escapeDeactivates: false,
          clickOutsideDeactivates: false,
          returnFocusOnDeactivate: false,
          allowOutsideClick: true,
        }}
      >
        <div
          ref={modalRef}
          role="dialog"
          aria-modal="true"
          aria-labelledby={titleId}
          className={`relative w-full h-full onboarding-modal overflow-hidden bg-main flex flex-col ${
            prefersReducedMotion ? '' : 'animate-pop-in'
          }`}
          onClick={(e) => e.stopPropagation()}
        >
          {/* Mystical background gradient */}
          <div
            className="absolute inset-0 pointer-events-none"
            style={{
              background: `
                radial-gradient(ellipse at 20% 0%, rgba(244, 207, 150, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 100%, rgba(169, 146, 255, 0.06) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(240, 143, 177, 0.04) 0%, transparent 60%)
              `,
            }}
            aria-hidden="true"
          />

          {/* Header with close button and progress */}
          <header
            className={`sticky top-0 z-30 pt-safe-top bg-main/95 backdrop-blur supports-[backdrop-filter]:backdrop-blur-lg border-b border-white/5 shadow-lg shadow-main/40 ${
              isLandscape ? 'py-1.5' : 'py-3 xs:py-4'
            }`}
          >
            <div className="flex flex-wrap items-center gap-2 xs:gap-3 px-2 xxs:px-3 sm:px-6 pl-safe-left pr-safe-right">
              <h1 id={titleId} className="sr-only">
                Welcome to Mystic Tarot
              </h1>
              <button
                ref={closeButtonRef}
                type="button"
                onClick={handleSkip}
                className="order-1 sm:order-2 self-start sm:self-center ml-auto sm:ml-0 flex items-center justify-center min-w-[44px] min-h-[44px] rounded-full text-muted hover:text-main hover:bg-surface/50 transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main"
                aria-label="Skip onboarding"
              >
                <X className="w-5 h-5" weight="bold" />
              </button>
              <div className="order-2 sm:order-1 flex-1 min-w-0 w-full sm:w-auto">
                <OnboardingProgress
                  currentStep={currentStep}
                  totalSteps={TOTAL_STEPS}
                  onStepSelect={handleStepSelect}
                  allowNavigation={true}
                />
              </div>
            </div>
          </header>

          {/* Main content area - scrollable */}
          <main
            className="relative z-10 flex-1 overflow-y-auto overflow-x-hidden scroll-smooth pt-safe-top pb-safe-bottom pl-safe-left pr-safe-right onboarding-modal__scroll"
            style={{
              scrollPaddingTop: 'calc(4.5rem + env(safe-area-inset-top, 0.75rem))',
              scrollPaddingBottom: 'calc(2rem + env(safe-area-inset-bottom, 1rem))',
              scrollbarGutter: 'stable both-edges',
              overscrollBehavior: 'contain',
              WebkitOverflowScrolling: 'touch'
            }}
          >
            <div className={`w-full max-w-3xl mx-auto min-h-full ${isLandscape ? 'px-2 xxs:px-3 py-2 sm:px-4' : 'px-3 xxs:px-4 md:px-6 py-4 xs:py-5 md:py-8'}`}>
              {renderStep()}
            </div>
          </main>
        </div>
      </FocusTrap>
    </div>
  );
}
</file>

<file path="src/components/onboarding/QuestionCrafting.jsx">
import { useState, useMemo } from 'react';
import { ArrowLeft, ArrowRight, Sparkle, Lightning, Check, X } from '@phosphor-icons/react';
import { EXAMPLE_QUESTIONS } from '../../data/exampleQuestions';
import { scoreQuestion, getQualityLevel } from '../../lib/questionQuality';
import { useReducedMotion } from '../../hooks/useReducedMotion';
import { useLandscape } from '../../hooks/useLandscape';
import { usePreferences } from '../../contexts/PreferencesContext';

// Additional example questions for onboarding
const ONBOARDING_EXAMPLES = [
  'What should I focus on this week for personal growth?',
  'How can I navigate this career transition with clarity?',
  'What energy do I need to cultivate in my relationships?',
  'What lesson am I meant to learn from this challenge?',
  'How can I find balance between work and personal life?',
];

// Number of additional onboarding examples to show (adds variety without overwhelming)
const MAX_ADDITIONAL_EXAMPLES = 2;

const READING_TONE_OPTIONS = [
  { value: 'gentle', label: 'Gentle & encouraging' },
  { value: 'balanced', label: 'Honest but kind' },
  { value: 'blunt', label: 'Blunt, no sugar-coating' },
];

const SPIRITUAL_FRAME_OPTIONS = [
  { value: 'psychological', label: 'Mostly self-reflection / psychology' },
  { value: 'spiritual', label: 'Spiritual & intuitive' },
  { value: 'mixed', label: 'Mix of both' },
  { value: 'playful', label: 'Just vibes & fun' },
];

/**
 * QuestionCrafting - Step 4 of onboarding
 *
 * Teaches users how to craft effective tarot questions
 * with real-time quality feedback.
 * Also collects reading tone and spiritual framing preferences.
 */
export function QuestionCrafting({ question, onQuestionChange, onNext, onBack }) {
  const [showTips, setShowTips] = useState(false);
  const prefersReducedMotion = useReducedMotion();
  const isLandscape = useLandscape();
  const { personalization, setReadingTone, setSpiritualFrame } = usePreferences();

  const quality = useMemo(() => scoreQuestion(question), [question]);
  const qualityLevel = useMemo(() => getQualityLevel(quality.score), [quality.score]);

  const handleExampleClick = (example) => {
    onQuestionChange(example);
  };

  const allExamples = [...EXAMPLE_QUESTIONS, ...ONBOARDING_EXAMPLES.slice(0, MAX_ADDITIONAL_EXAMPLES)];

  return (
    <div className="flex flex-col h-full">
      {/* Header */}
      <div
        className={`text-center mb-4 sm:mb-6 ${prefersReducedMotion ? '' : 'animate-fade-in-up'}`}
      >
        <h2 className={`font-serif text-main ${isLandscape ? 'text-xl' : 'text-2xl sm:text-3xl'}`}>
          Craft Your Question
        </h2>
        <p className={`text-muted mt-2 max-w-md mx-auto ${isLandscape ? 'text-sm' : ''}`}>
          A clear, open-ended question helps the cards speak to what matters most.
        </p>
      </div>

      {/* Main content */}
      <div className="flex-1 overflow-y-auto space-y-4 sm:space-y-6">
        {/* Question input */}
        <div
          className={prefersReducedMotion ? '' : 'animate-fade-in-up'}
          style={{ animationDelay: '0.1s' }}
        >
          <label htmlFor="question-input" className="block text-sm text-accent mb-2">
            Your question or intention
          </label>
          <textarea
            id="question-input"
            value={question}
            onChange={(e) => onQuestionChange(e.target.value)}
            placeholder="e.g., What energy should I focus on this week?"
            rows={isLandscape ? 2 : 4}
            className={`w-full bg-surface border border-primary/40 rounded-xl px-3 xxs:px-4 py-3 text-base text-main placeholder-muted resize-none focus:outline-none focus:border-primary focus:ring-1 focus:ring-primary/70 transition-all ${isLandscape ? 'min-h-[4rem] max-h-[30vh]' : 'min-h-[6rem] xs:min-h-[7rem] sm:min-h-[8rem]'}`}
          />
        </div>

        {/* Quality indicator */}
        {question.trim().length > 0 && (
          <div
            className={`rounded-xl border border-secondary/20 bg-surface/50 p-4 ${
              prefersReducedMotion ? '' : 'animate-fade-in'
            }`}
          >
            <div className="flex items-center justify-between mb-2">
              <span className="text-xs text-muted">Question quality</span>
              <span className="flex items-center gap-1 text-sm font-medium">
                <span>{qualityLevel.emoji}</span>
                <span className="text-main">{qualityLevel.label}</span>
              </span>
            </div>

            {/* Progress bar */}
            <div className="h-2 w-full rounded-full bg-surface-muted/80 overflow-hidden">
              <div
                className={`h-full transition-all duration-300 ${
                  quality.score >= 85
                    ? 'bg-success'
                    : quality.score >= 65
                    ? 'bg-accent'
                    : quality.score >= 40
                    ? 'bg-gold'
                    : 'bg-secondary'
                }`}
                style={{ width: `${Math.min(100, quality.score)}%` }}
              />
            </div>

            {/* Feedback chips */}
            {quality.feedback.length > 0 && (
              <div className="mt-3 flex flex-wrap gap-2">
                {quality.feedback.slice(0, 2).map((tip, i) => (
                  <span
                    key={i}
                    className="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-accent/10 text-xs text-accent"
                  >
                    <Lightning className="w-3 h-3" weight="fill" />
                    {tip}
                  </span>
                ))}
              </div>
            )}

            {/* Success indicators */}
            {quality.score >= 65 && (
              <div className="mt-3 flex flex-wrap gap-2">
                {quality.openEnded && (
                  <span className="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-success/10 text-xs text-success">
                    <Check className="w-3 h-3" weight="bold" />
                    Open-ended
                  </span>
                )}
                {quality.specific && (
                  <span className="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-success/10 text-xs text-success">
                    <Check className="w-3 h-3" weight="bold" />
                    Specific
                  </span>
                )}
                {quality.actionable && (
                  <span className="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-success/10 text-xs text-success">
                    <Check className="w-3 h-3" weight="bold" />
                    Actionable
                  </span>
                )}
              </div>
            )}
          </div>
        )}

        {/* Tips section - collapsible on mobile */}
        <div
          className={prefersReducedMotion ? '' : 'animate-fade-in-up'}
          style={{ animationDelay: '0.2s' }}
        >
          <button
            type="button"
            onClick={() => setShowTips(!showTips)}
            className="flex items-center justify-between w-full text-left py-2 text-sm text-accent hover:text-main transition sm:cursor-default"
            aria-expanded={showTips}
          >
            <span className="flex items-center gap-2">
              <Sparkle className="w-4 h-4" weight="fill" />
              Tips for great questions
            </span>
            <span className="sm:hidden text-xs text-muted">
              {showTips ? 'Hide' : 'Show'}
            </span>
          </button>

          <div
            className={`space-y-2 mt-2 ${
              showTips || !isLandscape ? 'block' : 'hidden sm:block'
            }`}
          >
            <div className="flex items-start gap-3 p-3 rounded-lg bg-surface/30">
              <span className="w-6 h-6 shrink-0 rounded-full bg-success/10 text-success flex items-center justify-center">
                <Check className="w-3.5 h-3.5" weight="bold" />
              </span>
              <div>
                <p className="text-sm text-main">Use &quot;How&quot; or &quot;What&quot;</p>
                <p className="text-xs text-muted">Open-ended questions invite deeper exploration</p>
              </div>
            </div>
            <div className="flex items-start gap-3 p-3 rounded-lg bg-surface/30">
              <span className="w-6 h-6 shrink-0 rounded-full bg-success/10 text-success flex items-center justify-center">
                <Check className="w-3.5 h-3.5" weight="bold" />
              </span>
              <div>
                <p className="text-sm text-main">Be specific about timing</p>
                <p className="text-xs text-muted">&quot;This week&quot; or &quot;this month&quot; adds focus</p>
              </div>
            </div>
            <div className="flex items-start gap-3 p-3 rounded-lg bg-surface/30">
              <span className="w-6 h-6 shrink-0 rounded-full bg-error/10 text-error flex items-center justify-center">
                <X className="w-3.5 h-3.5" weight="bold" />
              </span>
              <div>
                <p className="text-sm text-main">Avoid yes/no questions</p>
                <p className="text-xs text-muted">&quot;Will I...&quot; limits the insight you receive</p>
              </div>
            </div>
          </div>
        </div>

        {/* Example questions */}
        <div
          className={prefersReducedMotion ? '' : 'animate-fade-in-up'}
          style={{ animationDelay: '0.3s' }}
        >
          <p className="text-xs text-muted mb-2">Try an example:</p>
          <div className="flex flex-wrap gap-2">
            {allExamples.slice(0, isLandscape ? 3 : 5).map((example, i) => (
              <button
                key={i}
                type="button"
                onClick={() => handleExampleClick(example)}
                className="min-h-[44px] w-full xxs:w-auto px-3 xs:px-4 py-2 rounded-full border border-secondary/30 bg-surface/50 text-xs xs:text-sm text-muted hover:text-main hover:border-accent/50 transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent"
              >
                {example.length > 35 ? example.slice(0, 35) + '...' : example}
              </button>
            ))}
          </div>
        </div>

        {/* Personalization: Reading Tone */}
        <div
          className={`mt-6 rounded-2xl border border-accent/20 bg-surface/50 p-5 ${
            prefersReducedMotion ? '' : 'animate-fade-in-up'
          } ${isLandscape ? 'mt-4 p-4' : ''}`}
          style={{ animationDelay: '0.4s' }}
        >
          <p className="text-sm text-accent mb-3">
            How do you like your readings?
          </p>
          <div className="flex flex-wrap gap-2">
            {READING_TONE_OPTIONS.map((option) => {
              const isSelected = personalization.readingTone === option.value;
              return (
                <button
                  key={option.value}
                  type="button"
                  onClick={() => setReadingTone(option.value)}
                  className={`min-h-[44px] px-4 py-2 rounded-full border text-sm font-medium transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main ${
                    isSelected
                      ? 'bg-accent text-surface border-accent'
                      : 'bg-surface/50 text-muted border-secondary/30 hover:border-accent/50 hover:text-main'
                  }`}
                  aria-pressed={isSelected}
                >
                  {option.label}
                </button>
              );
            })}
          </div>
        </div>

        {/* Personalization: Spiritual Framing */}
        {!isLandscape && (
          <div
            className={`mt-4 rounded-2xl border border-accent/20 bg-surface/50 p-5 ${
              prefersReducedMotion ? '' : 'animate-fade-in-up'
            }`}
            style={{ animationDelay: '0.5s' }}
          >
            <p className="text-sm text-accent mb-3">
              How should we frame things?
            </p>
            <div className="flex flex-wrap gap-2">
              {SPIRITUAL_FRAME_OPTIONS.map((option) => {
                const isSelected = personalization.spiritualFrame === option.value;
                return (
                  <button
                    key={option.value}
                    type="button"
                    onClick={() => setSpiritualFrame(option.value)}
                    className={`min-h-[44px] px-4 py-2 rounded-full border text-sm font-medium transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main ${
                      isSelected
                        ? 'bg-accent text-surface border-accent'
                        : 'bg-surface/50 text-muted border-secondary/30 hover:border-accent/50 hover:text-main'
                    }`}
                    aria-pressed={isSelected}
                  >
                    {option.label}
                  </button>
                );
              })}
            </div>
          </div>
        )}
      </div>

      {/* Navigation */}
      <div className={`flex gap-3 pt-4 pb-safe-bottom ${isLandscape ? 'pt-2' : 'pt-6'}`}>
        <button
          type="button"
          onClick={onBack}
          className="flex items-center justify-center gap-1 min-h-[48px] px-4 py-3 rounded-xl border border-secondary/40 text-muted hover:text-main hover:border-secondary/60 transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2 focus-visible:ring-offset-main"
        >
          <ArrowLeft className="w-4 h-4" />
          <span className="hidden xs:inline">Back</span>
        </button>
        <button
          type="button"
          onClick={onNext}
          className="flex-1 flex items-center justify-center gap-2 min-h-[48px] px-6 py-3 rounded-xl bg-accent text-surface font-semibold text-base transition hover:bg-accent/90 active:scale-[0.98] touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main"
        >
          {question.trim() ? 'Continue' : 'Skip'}
          <ArrowRight className="w-5 h-5" weight="bold" />
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/onboarding/RitualIntro.jsx">
import { ArrowLeft, ArrowRight, Hand, Scissors, Sparkle, Lightbulb, ToggleLeft, ToggleRight } from '@phosphor-icons/react';
import { useReducedMotion } from '../../hooks/useReducedMotion';
import { useLandscape } from '../../hooks/useLandscape';
import { usePreferences } from '../../contexts/PreferencesContext';

/**
 * RitualIntro - Step 5 of onboarding
 *
 * Explains the optional ritual mechanics (knock and cut)
 * and their symbolic meaning.
 * Also allows users to set their ritual preference.
 */
export function RitualIntro({ onNext, onBack, onSkipRitual }) {
  const prefersReducedMotion = useReducedMotion();
  const isLandscape = useLandscape();
  const { personalization, setShowRitualSteps } = usePreferences();

  const handleSkipAndStart = () => {
    // Set ritual preference to minimal when user chooses to skip
    setShowRitualSteps(false);
    onSkipRitual?.();
  };

  return (
    <div className="flex flex-col h-full">
      {/* Header */}
      <div
        className={`text-center mb-4 sm:mb-6 ${prefersReducedMotion ? '' : 'animate-fade-in-up'}`}
      >
        <h2 className={`font-serif text-main ${isLandscape ? 'text-xl' : 'text-2xl sm:text-3xl'}`}>
          The Ritual
        </h2>
        <p className={`text-muted mt-2 max-w-md mx-auto ${isLandscape ? 'text-sm' : ''}`}>
          A mindful moment to connect with the deck before your reading.
        </p>
      </div>

      {/* Main content */}
      <div className="flex-1 overflow-y-auto space-y-4 sm:space-y-6">
        {/* Introduction */}
        <div
          className={`text-center ${prefersReducedMotion ? '' : 'animate-fade-in-up'}`}
          style={{ animationDelay: '0.1s' }}
        >
          <div className="inline-flex items-center gap-2 px-4 py-2 rounded-full bg-accent/10 border border-accent/20 text-sm text-accent">
            <Sparkle className="w-4 h-4" weight="fill" />
            Adds meaning, not magic
          </div>
        </div>

        {/* Ritual steps */}
        <div
          className={`grid gap-4 xxs:gap-5 ${isLandscape ? 'grid-cols-2' : 'grid-cols-1 sm:grid-cols-2'}`}
        >
          {/* Knock */}
          <div
            className={`rounded-2xl border border-accent/20 bg-surface/50 p-5 ${
              prefersReducedMotion ? '' : 'animate-fade-in-up'
            }`}
            style={{ animationDelay: '0.2s' }}
          >
            <div className="flex items-center gap-3 mb-3">
              <div className="w-12 h-12 rounded-full bg-accent/10 border border-accent/30 flex items-center justify-center">
                <Hand className="w-6 h-6 text-accent" weight="duotone" />
              </div>
              <div>
                <h3 className="font-serif text-main text-lg">Knock</h3>
                <p className="text-xs text-accent">Step 1</p>
              </div>
            </div>
            <p className={`text-muted leading-relaxed ${isLandscape ? 'text-sm' : ''}`}>
              Tap the deck to signal your intention. Each knock adds a bit of randomness to how
              cards are shuffled — your personal touch on the reading.
            </p>
            <div className="mt-3 pt-3 border-t border-secondary/20">
              <p className="text-xs text-muted italic flex items-center gap-1">
                <Lightbulb className="w-3.5 h-3.5 text-accent shrink-0" weight="fill" />
                Symbolizes: &quot;I&apos;m ready to receive guidance.&quot;
              </p>
            </div>
          </div>

          {/* Cut */}
          <div
            className={`rounded-2xl border border-accent/20 bg-surface/50 p-5 ${
              prefersReducedMotion ? '' : 'animate-fade-in-up'
            }`}
            style={{ animationDelay: '0.3s' }}
          >
            <div className="flex items-center gap-3 mb-3">
              <div className="w-12 h-12 rounded-full bg-accent/10 border border-accent/30 flex items-center justify-center">
                <Scissors className="w-6 h-6 text-accent" weight="duotone" />
              </div>
              <div>
                <h3 className="font-serif text-main text-lg">Cut</h3>
                <p className="text-xs text-accent">Step 2</p>
              </div>
            </div>
            <p className={`text-muted leading-relaxed ${isLandscape ? 'text-sm' : ''}`}>
              Choose where to split the deck. This determines the starting point for your draw —
              your intuition guiding which cards surface.
            </p>
            <div className="mt-3 pt-3 border-t border-secondary/20">
              <p className="text-xs text-muted italic flex items-center gap-1">
                <Lightbulb className="w-3.5 h-3.5 text-accent shrink-0" weight="fill" />
                Symbolizes: &quot;I trust my inner wisdom.&quot;
              </p>
            </div>
          </div>
        </div>

        {/* Why ritual matters - collapsed in landscape */}
        {!isLandscape && (
          <div
            className={`rounded-xl border border-secondary/20 bg-surface/30 p-4 ${
              prefersReducedMotion ? '' : 'animate-fade-in-up'
            }`}
            style={{ animationDelay: '0.4s' }}
          >
            <h4 className="text-sm font-medium text-main mb-2">Why include a ritual?</h4>
            <p className="text-xs text-muted leading-relaxed">
              The ritual isn&apos;t about mystical powers — it&apos;s about{' '}
              <strong className="text-main">creating space</strong> for reflection. Taking a
              moment to knock and cut helps you transition from daily busyness into a more
              contemplative state, making the reading feel more personal and meaningful.
            </p>
          </div>
        )}

        {/* Ritual preference toggle */}
        <div
          className={`rounded-2xl border border-accent/20 bg-surface/50 p-5 ${
            prefersReducedMotion ? '' : 'animate-fade-in-up'
          } ${isLandscape ? 'p-4' : ''}`}
          style={{ animationDelay: '0.45s' }}
        >
          <p className="text-sm text-accent mb-3">
            Your default ritual preference
          </p>
          <div className="flex flex-col gap-2 sm:flex-row sm:gap-4">
            <button
              type="button"
              onClick={() => setShowRitualSteps(true)}
              className={`flex items-center gap-3 min-h-[44px] px-4 py-3 rounded-xl border text-left transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main ${
                personalization.showRitualSteps
                  ? 'bg-accent/10 border-accent text-main'
                  : 'bg-surface/50 border-secondary/30 text-muted hover:border-accent/50'
              }`}
              aria-pressed={personalization.showRitualSteps}
            >
              <ToggleRight
                className={`w-6 h-6 shrink-0 ${
                  personalization.showRitualSteps ? 'text-accent' : 'text-muted'
                }`}
                weight={personalization.showRitualSteps ? 'fill' : 'regular'}
                aria-hidden="true"
              />
              <span className="text-sm font-medium">Always show ritual steps</span>
            </button>
            <button
              type="button"
              onClick={() => setShowRitualSteps(false)}
              className={`flex items-center gap-3 min-h-[44px] px-4 py-3 rounded-xl border text-left transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main ${
                !personalization.showRitualSteps
                  ? 'bg-accent/10 border-accent text-main'
                  : 'bg-surface/50 border-secondary/30 text-muted hover:border-accent/50'
              }`}
              aria-pressed={!personalization.showRitualSteps}
            >
              <ToggleLeft
                className={`w-6 h-6 shrink-0 ${
                  !personalization.showRitualSteps ? 'text-accent' : 'text-muted'
                }`}
                weight={!personalization.showRitualSteps ? 'fill' : 'regular'}
                aria-hidden="true"
              />
              <span className="text-sm font-medium">Keep ritual minimal</span>
            </button>
          </div>
          <p className="text-xs text-muted mt-3">
            These choices steer how much ritual guidance we surface; revisit them later under Settings if your practice shifts.
          </p>
        </div>

      </div>

      {/* Navigation */}
      <div className={`flex flex-col gap-3 pt-4 pb-safe-bottom ${isLandscape ? 'pt-2' : 'pt-6'}`}>
        <div className="flex gap-3">
          <button
            type="button"
            onClick={onBack}
            className="flex items-center justify-center gap-1 min-h-[48px] px-4 py-3 rounded-xl border border-secondary/40 text-muted hover:text-main hover:border-secondary/60 transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2 focus-visible:ring-offset-main"
          >
            <ArrowLeft className="w-4 h-4" />
            <span className="hidden xs:inline">Back</span>
          </button>
          <button
            type="button"
            onClick={onNext}
            className="flex-1 flex items-center justify-center gap-2 min-h-[48px] px-6 py-3 rounded-xl bg-accent text-surface font-semibold text-base transition hover:bg-accent/90 active:scale-[0.98] touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main"
          >
            I understand — continue
            <ArrowRight className="w-5 h-5" weight="bold" />
          </button>
        </div>
        <button
          type="button"
          onClick={handleSkipAndStart}
          className="w-full min-h-[44px] px-3 xxs:px-4 py-2 text-muted hover:text-main text-xs xxs:text-sm transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2 focus-visible:ring-offset-main"
        >
          Skip and start reading
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/onboarding/SpreadEducation.jsx">
import { useState } from 'react';
import { ArrowLeft, ArrowRight, Check, Info } from '@phosphor-icons/react';
import { SPREADS } from '../../data/spreads';
import { useReducedMotion } from '../../hooks/useReducedMotion';
import { useLandscape } from '../../hooks/useLandscape';
import { useSmallScreen } from '../../hooks/useSmallScreen';
import { usePreferences } from '../../contexts/PreferencesContext';

// Import spread artwork
import oneCardArt from '../../../selectorimages/onecard.png';
import threeCardArt from '../../../selectorimages/3card.png';
import decisionArt from '../../../selectorimages/decision.png';

// Beginner-friendly spreads for onboarding
const BEGINNER_SPREADS = ['single', 'threeCard', 'decision'];

const SPREAD_ART = {
  single: { src: oneCardArt, alt: 'One-card spread layout' },
  threeCard: { src: threeCardArt, alt: 'Three-card spread layout' },
  decision: { src: decisionArt, alt: 'Decision spread layout' },
};

const SPREAD_DESCRIPTIONS = {
  single: {
    tagline: 'Perfect for beginners',
    explanation: 'Draw a single card to focus on the core energy of your question. Simple and powerful.',
    positions: ['One card representing the central theme or guidance'],
  },
  threeCard: {
    tagline: 'Tell your story',
    explanation: 'Three cards reveal past influences, present situation, and future possibilities.',
    positions: ['Past — what led you here', 'Present — where you stand', 'Future — potential ahead'],
  },
  decision: {
    tagline: 'Compare your paths',
    explanation: 'When facing a choice, see the energy and outcomes of different options.',
    positions: [
      'Heart of the decision',
      'Path A — energy & likely outcome',
      'Path B — energy & likely outcome',
      'What clarifies the best path',
      'What to remember about your free will',
    ],
  },
};

const SPREAD_DEPTH_OPTIONS = [
  { value: 'short', label: 'Quick check-ins (1–2 cards)' },
  { value: 'standard', label: 'Balanced (3–5 cards)' },
  { value: 'deep', label: 'Deep dives (bigger spreads)' },
];

const FOCUS_AREA_OPTIONS = [
  { value: 'love', label: 'Love & relationships' },
  { value: 'career', label: 'Career & money' },
  { value: 'self_worth', label: 'Self-worth & confidence' },
  { value: 'healing', label: 'Healing & growth' },
  { value: 'creativity', label: 'Creativity & projects' },
  { value: 'spirituality', label: 'Spiritual path' },
];

/**
 * SpreadEducation - Step 3 of onboarding
 *
 * Teaches users about different spread types and lets them
 * select their first spread for the reading.
 * Also collects preferred spread depth and focus areas.
 */
export function SpreadEducation({ selectedSpread, onSelectSpread, onNext, onBack }) {
  const [expandedSpread, setExpandedSpread] = useState(null);
  const prefersReducedMotion = useReducedMotion();
  const isLandscape = useLandscape();
  const isSmallScreen = useSmallScreen();
  const { personalization, setPreferredSpreadDepth, toggleFocusArea } = usePreferences();

  const handleSpreadClick = (spreadKey) => {
    onSelectSpread(spreadKey);
    // Auto-expand on selection for mobile
    if (isSmallScreen && expandedSpread !== spreadKey) {
      setExpandedSpread(spreadKey);
    }
  };

  const toggleExpanded = (spreadKey, e) => {
    e.stopPropagation();
    setExpandedSpread(expandedSpread === spreadKey ? null : spreadKey);
  };

  return (
    <div className="flex flex-col h-full">
      {/* Header */}
      <div
        className={`text-center mb-4 sm:mb-6 ${prefersReducedMotion ? '' : 'animate-fade-in-up'}`}
      >
        <h2 className={`font-serif text-main ${isLandscape ? 'text-xl' : 'text-2xl sm:text-3xl'}`}>
          Match Your Spread
        </h2>
        <p className={`text-muted mt-2 max-w-md mx-auto ${isLandscape ? 'text-sm' : ''}`}>
          A spread is how cards are laid out. Each position has a meaning that shapes the reading.
        </p>
      </div>

      {/* Spread cards */}
      <div className="flex-1 overflow-y-auto">
        {/* Use 2 columns in landscape on small screens to prevent cramped cards */}
        <div className={`grid gap-3 xs:gap-4 ${isLandscape ? 'grid-cols-2 lg:grid-cols-3' : 'grid-cols-1 md:grid-cols-3'}`}>
          {BEGINNER_SPREADS.map((spreadKey, index) => {
            const spread = SPREADS[spreadKey];
            const description = SPREAD_DESCRIPTIONS[spreadKey];
            const art = SPREAD_ART[spreadKey];
            const isSelected = selectedSpread === spreadKey;
            const isExpanded = expandedSpread === spreadKey;

            return (
              <button
                key={spreadKey}
                type="button"
                onClick={() => handleSpreadClick(spreadKey)}
                className={`relative flex flex-col text-left rounded-2xl border overflow-hidden transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main touch-manipulation ${
                  isSelected
                    ? 'border-accent bg-accent/10 ring-1 ring-accent/50'
                    : 'border-secondary/30 bg-surface/50 hover:border-accent/50 hover:bg-surface/70'
                } ${prefersReducedMotion ? '' : 'animate-fade-in-up'}`}
                style={{ animationDelay: `${index * 0.1}s` }}
                aria-pressed={isSelected}
              >
                {/* Selection indicator */}
                {isSelected && (
                  <div className="absolute top-3 right-3 z-10 w-6 h-6 rounded-full bg-accent flex items-center justify-center">
                    <Check className="w-4 h-4 text-surface" weight="bold" />
                  </div>
                )}

                {/* Spread artwork */}
                <div className="relative aspect-video sm:aspect-[16/10] bg-gradient-to-br from-surface to-main overflow-hidden">
                  {art && (
                    <img
                      src={art.src}
                      alt={art.alt}
                      className="w-full h-full object-cover opacity-80"
                      loading="lazy"
                    />
                  )}
                  {/* Overlay gradient */}
                  <div
                    className="absolute inset-0 bg-gradient-to-t from-surface/90 via-transparent to-transparent"
                    aria-hidden="true"
                  />
                </div>

                {/* Content */}
                <div className="p-4 flex-1 flex flex-col">
                  <div className="flex items-start justify-between gap-2">
                    <div>
                      <h3 className="font-serif text-main text-base sm:text-lg leading-tight">
                        {spread.name}
                      </h3>
                      <p className="text-xs text-accent mt-0.5">{description.tagline}</p>
                    </div>
                    <span className="shrink-0 px-2 py-0.5 rounded-full bg-secondary/20 text-xs text-muted">
                      {spread.count} {spread.count === 1 ? 'card' : 'cards'}
                    </span>
                  </div>

                  <p className={`text-xs xs:text-sm text-muted mt-2 leading-relaxed ${isLandscape ? 'hidden' : 'hidden xs:block'}`}>
                    {description.explanation}
                  </p>

                  {/* Expandable positions info - mobile only */}
                  {isSmallScreen && !isLandscape && (
                    <>
                      <button
                        type="button"
                        onClick={(e) => toggleExpanded(spreadKey, e)}
                        className="flex items-center gap-1 mt-3 text-xs text-accent hover:text-main transition"
                        aria-expanded={isExpanded}
                      >
                        <Info className="w-3.5 h-3.5" weight="bold" />
                        {isExpanded ? 'Hide positions' : 'Show positions'}
                      </button>

                      {isExpanded && (
                        <div className="mt-3 pt-3 border-t border-secondary/20 space-y-1.5">
                          {description.positions.map((position, i) => (
                            <div key={i} className="flex items-start gap-2 text-xs">
                              <span className="w-5 h-5 shrink-0 rounded-full bg-accent/10 text-accent flex items-center justify-center font-medium">
                                {i + 1}
                              </span>
                              <span className="text-muted pt-0.5">{position}</span>
                            </div>
                          ))}
                        </div>
                      )}
                    </>
                  )}

                  {/* Desktop positions - always visible */}
                  {!isSmallScreen && !isLandscape && (
                    <div className="mt-3 pt-3 border-t border-secondary/20 space-y-1.5">
                      {description.positions.map((position, i) => (
                        <div key={i} className="flex items-start gap-2 text-xs">
                          <span className="w-5 h-5 shrink-0 rounded-full bg-accent/10 text-accent flex items-center justify-center font-medium">
                            {i + 1}
                          </span>
                          <span className="text-muted pt-0.5">{position}</span>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </button>
            );
          })}
        </div>

        {/* Personalization: Spread Depth Preference */}
        <div
          className={`mt-6 rounded-2xl border border-accent/20 bg-surface/50 p-5 ${
            prefersReducedMotion ? '' : 'animate-fade-in-up'
          } ${isLandscape ? 'mt-4 p-4' : ''}`}
          style={{ animationDelay: '0.5s' }}
        >
          <p className="text-sm text-accent mb-3">
            What kind of readings do you like most?
          </p>
          <p className="text-xs text-muted mb-3">
            This preference helps us tailor recommendations for this session.
          </p>
          <div className="flex flex-wrap gap-2">
            {SPREAD_DEPTH_OPTIONS.map((option) => {
              const isSelected = personalization.preferredSpreadDepth === option.value;
              return (
                <button
                  key={option.value}
                  type="button"
                  onClick={() => setPreferredSpreadDepth(option.value)}
                  className={`min-h-[44px] px-4 py-2 rounded-full border text-sm font-medium transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main ${
                    isSelected
                      ? 'bg-accent text-surface border-accent'
                      : 'bg-surface/50 text-muted border-secondary/30 hover:border-accent/50 hover:text-main'
                  }`}
                  aria-pressed={isSelected}
                >
                  {option.label}
                </button>
              );
            })}
          </div>
        </div>

        {/* Personalization: Focus Areas */}
        {!isLandscape && (
          <div
            className={`mt-6 rounded-2xl border border-accent/20 bg-surface/50 p-5 ${
              prefersReducedMotion ? '' : 'animate-fade-in-up'
            }`}
            style={{ animationDelay: '0.6s' }}
          >
            <p className="text-sm text-accent mb-3">
              What are you most curious about right now?
            </p>
            <p className="text-xs text-muted mb-3">
              This helps us suggest spreads you&apos;ll actually use
            </p>
            <div className="flex flex-wrap gap-2">
              {FOCUS_AREA_OPTIONS.map((option) => {
                const isSelected = (personalization.focusAreas || []).includes(option.value);
                return (
                  <button
                    key={option.value}
                    type="button"
                    onClick={() => toggleFocusArea(option.value)}
                    className={`min-h-[44px] px-4 py-2 rounded-full border text-sm font-medium transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main ${
                      isSelected
                        ? 'bg-accent text-surface border-accent'
                        : 'bg-surface/50 text-muted border-secondary/30 hover:border-accent/50 hover:text-main'
                    }`}
                    aria-pressed={isSelected}
                  >
                    {isSelected && (
                      <Check className="w-4 h-4 inline mr-1" weight="bold" aria-hidden="true" />
                    )}
                    {option.label}
                  </button>
                );
              })}
            </div>
          </div>
        )}
      </div>

      {/* Navigation */}
      <div className={`flex gap-3 pt-4 pb-safe-bottom ${isLandscape ? 'pt-2' : 'pt-6'}`}>
        <button
          type="button"
          onClick={onBack}
          className="flex items-center justify-center gap-1 min-h-[48px] min-w-[44px] px-2.5 xs:px-3 sm:px-4 py-3 rounded-xl border border-secondary/40 text-muted hover:text-main hover:border-secondary/60 transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2 focus-visible:ring-offset-main"
        >
          <ArrowLeft className="w-4 h-4" />
          <span className="hidden xs:inline">Back</span>
        </button>
        <button
          type="button"
          onClick={onNext}
          disabled={!selectedSpread}
          className="flex-1 flex items-center justify-center gap-2 min-h-[48px] px-4 xs:px-5 sm:px-6 py-3 rounded-xl bg-accent text-surface font-semibold text-base transition hover:bg-accent/90 active:scale-[0.98] disabled:opacity-50 disabled:cursor-not-allowed touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main"
        >
          Continue
          <ArrowRight className="w-5 h-5" weight="bold" />
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/onboarding/WelcomeHero.jsx">
import { Sparkle, Moon, Star, ArrowRight, Eye, Path, Lightbulb, User } from '@phosphor-icons/react';
import { useReducedMotion } from '../../hooks/useReducedMotion';
import { useLandscape } from '../../hooks/useLandscape';
import { usePreferences } from '../../contexts/PreferencesContext';

const EXPERIENCE_OPTIONS = [
  { value: 'newbie', label: 'Brand new' },
  { value: 'intermediate', label: 'I know the basics' },
  { value: 'experienced', label: 'Pretty experienced' },
];

/**
 * WelcomeHero - Step 1 of onboarding
 *
 * Introduces users to tarot as a tool for self-reflection,
 * emphasizing guidance over fortune-telling.
 * Also collects display name and tarot experience level.
 */
export function WelcomeHero({ onNext }) {
  const prefersReducedMotion = useReducedMotion();
  const isLandscape = useLandscape();
  const { personalization, setDisplayName, setTarotExperience } = usePreferences();

  return (
    <div className="flex flex-col h-full">
      {/* Hero content - centered vertically */}
      <div className="flex-1 flex flex-col items-center justify-center text-center">
        {/* Mystical icon cluster */}
        <div
          className={`relative mb-6 ${isLandscape ? 'mb-4' : 'mb-8'} ${
            prefersReducedMotion ? '' : 'animate-fade-in-up'
          }`}
          style={{ animationDelay: '0.1s' }}
        >
          <div className="relative">
            <Moon
              className="w-16 h-16 sm:w-20 sm:h-20 text-accent"
              weight="duotone"
              aria-hidden="true"
            />
            <Star
              className="absolute -top-2 -right-2 w-6 h-6 sm:w-8 sm:h-8 text-gold"
              weight="fill"
              aria-hidden="true"
            />
            <Sparkle
              className="absolute -bottom-1 -left-3 w-5 h-5 sm:w-6 sm:h-6 text-primary"
              weight="fill"
              aria-hidden="true"
            />
          </div>
        </div>

        {/* Welcome text */}
        <div
          className={prefersReducedMotion ? '' : 'animate-fade-in-up'}
          style={{ animationDelay: '0.2s' }}
        >
          <h2
            className={`font-serif text-main mb-3 ${
              isLandscape ? 'text-2xl' : 'text-3xl sm:text-4xl'
            }`}
          >
            Welcome to Mystic Tarot
          </h2>
          <p
            className={`text-muted max-w-md mx-auto leading-relaxed ${
              isLandscape ? 'text-sm' : 'text-base sm:text-lg'
            }`}
          >
            A space for reflection, clarity, and personal insight
          </p>
        </div>

        {/* What is tarot explanation */}
        <div
          className={`mt-6 sm:mt-8 max-w-lg mx-auto ${
            prefersReducedMotion ? '' : 'animate-fade-in-up'
          } ${isLandscape ? 'mt-4' : ''}`}
          style={{ animationDelay: '0.3s' }}
        >
          <div className="rounded-2xl border border-accent/20 bg-surface/50 backdrop-blur-sm p-5 sm:p-6">
            <h3 className="text-accent font-serif text-lg mb-3 flex items-center gap-2">
              <Sparkle className="w-4 h-4" weight="fill" aria-hidden="true" />
              What is tarot?
            </h3>
            <p className={`text-muted leading-relaxed ${isLandscape ? 'text-sm' : ''}`}>
              Tarot is a mirror, not a crystal ball. The cards invite you to explore your thoughts and possibilities—a <strong className="text-main">conversation with yourself</strong> through symbolic imagery.
            </p>
          </div>
        </div>

        {/* Key principles - hidden in landscape for space */}
        {!isLandscape && (
          <div
            className={`mt-6 grid grid-cols-1 xs:grid-cols-3 gap-4 max-w-lg mx-auto ${
              prefersReducedMotion ? '' : 'animate-fade-in-up'
            }`}
            style={{ animationDelay: '0.4s' }}
          >
            <div className="text-center">
              <div className="w-10 h-10 mx-auto mb-2 rounded-full bg-accent/10 border border-accent/30 flex items-center justify-center">
                <Eye className="w-5 h-5 text-accent" weight="duotone" aria-hidden="true" />
              </div>
              <p className="text-xs text-muted">Reflect & explore</p>
            </div>
            <div className="text-center">
              <div className="w-10 h-10 mx-auto mb-2 rounded-full bg-accent/10 border border-accent/30 flex items-center justify-center">
                <Path className="w-5 h-5 text-accent" weight="duotone" aria-hidden="true" />
              </div>
              <p className="text-xs text-muted">Embrace free will</p>
            </div>
              <div className="text-center">
                <div className="w-10 h-10 mx-auto mb-2 rounded-full bg-accent/10 border border-accent/30 flex items-center justify-center">
                  <Lightbulb className="w-5 h-5 text-accent" weight="duotone" aria-hidden="true" />
                </div>
                <p className="text-xs text-muted">Follow what resonates</p>
              </div>
          </div>
        )}

        {/* Personalization Section */}
        <div
          className={`mt-6 w-full max-w-md mx-auto space-y-5 ${
            prefersReducedMotion ? '' : 'animate-fade-in-up'
          } ${isLandscape ? 'mt-3 space-y-3' : ''}`}
          style={{ animationDelay: '0.5s' }}
        >
          {/* Display name input */}
          <div className="text-left">
            <label
              htmlFor="display-name"
              className="flex items-center gap-2 text-sm text-accent mb-2"
            >
              <User className="w-4 h-4" weight="duotone" aria-hidden="true" />
              What should we call you?
            </label>
            <input
              id="display-name"
              type="text"
              value={personalization.displayName}
              onChange={(e) => setDisplayName(e.target.value)}
              placeholder="Used to personalize your readings"
              className="w-full bg-surface border border-primary/40 rounded-xl min-h-[44px] px-3 xxs:px-4 py-3 text-sm xxs:text-base text-main placeholder-muted/70 focus:outline-none focus:border-primary focus:ring-1 focus:ring-primary/70 transition-all"
              autoComplete="given-name"
            />
          </div>

          {/* Tarot experience chips */}
          <div className="text-left">
            <p className="text-sm text-accent mb-2">
              How familiar are you with tarot?
            </p>
            <div className="flex flex-col xs:flex-row flex-wrap gap-2 w-full">
              {EXPERIENCE_OPTIONS.map((option) => {
                const isSelected = personalization.tarotExperience === option.value;
                return (
                  <button
                    key={option.value}
                    type="button"
                    onClick={() => setTarotExperience(option.value)}
                    className={`min-h-[44px] w-full xs:w-auto px-3 xxs:px-4 sm:px-5 py-2.5 rounded-full border text-sm font-medium text-center xs:text-left transition touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main ${
                      isSelected
                        ? 'bg-accent text-surface border-accent'
                        : 'bg-surface/50 text-muted border-secondary/30 hover:border-accent/50 hover:text-main'
                    }`}
                    aria-pressed={isSelected}
                  >
                    {option.label}
                  </button>
                );
              })}
            </div>
          </div>
        </div>
      </div>

      {/* Actions - sticky at bottom */}
      <div
        className={`flex flex-col gap-3 pt-4 pb-safe-bottom ${isLandscape ? 'pt-2' : 'pt-6'}`}
      >
        <button
          type="button"
          onClick={onNext}
          className="w-full flex items-center justify-center gap-2 min-h-[48px] px-4 xxs:px-5 py-3 rounded-xl bg-accent text-surface font-semibold text-sm xxs:text-base transition hover:bg-accent/90 active:scale-[0.98] touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main"
        >
          Continue
          <ArrowRight className="w-5 h-5" weight="bold" />
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/share/CollaborativeNotesPanel.jsx">
import { useMemo, useState, useEffect, useId, useCallback, useRef } from 'react';

const ALIAS_STORAGE_KEY = 'mystic-share-alias';

/**
 * Format timestamp with relative time for recent timestamps
 */
function formatTimestamp(ts) {
  if (!ts) return 'never';

  const date = new Date(ts);
  if (isNaN(date.getTime())) return 'recently';

  const now = Date.now();
  const diff = now - date.getTime();

  // Relative time for recent
  if (diff < 60000) return 'just now';
  if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
  if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;

  // Absolute for older
  return date.toLocaleDateString(undefined, {
    month: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: '2-digit'
  });
}

/**
 * LocalStorage-backed state for client-side usage.
 * Reads once during initial render and debounces writes.
 */
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    try {
      if (typeof window === 'undefined' || !window.localStorage) {
        return initialValue;
      }
      const stored = window.localStorage.getItem(key);
      return stored !== null ? stored : initialValue;
    } catch {
      // localStorage unavailable
      return initialValue;
    }
  });

  // Debounced save to localStorage
  const saveTimeoutRef = useRef(null);
  const setAndPersist = useCallback((newValue) => {
    setValue(newValue);

    // Debounce localStorage writes
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }
    saveTimeoutRef.current = setTimeout(() => {
      try {
        if (typeof window === 'undefined' || !window.localStorage) {
          return;
        }
        // Handle empty strings by removing the key, otherwise persist the value
        if (newValue === '' || newValue === null || newValue === undefined) {
          window.localStorage.removeItem(key);
        } else {
          window.localStorage.setItem(key, newValue);
        }
      } catch {
        // localStorage unavailable
      }
    }, 500);
  }, [key]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, []);

  return [value, setAndPersist];
}

export function CollaborativeNotesPanel({
  notes = [],
  cards = [],
  onSubmit,
  isSubmitting,
  onRefresh,
  error,
  selectedPosition,
  onSelectedPositionChange,
  lastSyncedAt
}) {
  const [authorName, setAuthorName] = useLocalStorage(ALIAS_STORAGE_KEY, '');
  const [cardPosition, setCardPosition] = useState(selectedPosition || '');
  const [body, setBody] = useState('');
  const [statusMessage, setStatusMessage] = useState('');
  const [isRefreshing, setIsRefreshing] = useState(false);

  // Generate unique IDs for accessibility
  const nameInputId = useId();
  const positionSelectId = useId();
  const bodyTextareaId = useId();
  const statusId = useId();

  // Sync external position changes
  useEffect(() => {
    if (selectedPosition !== undefined) {
      setCardPosition(selectedPosition || '');
    }
  }, [selectedPosition]);

  const sortedNotes = useMemo(() => {
    return [...notes].sort((a, b) => a.createdAt - b.createdAt);
  }, [notes]);

  const handleSubmit = async (event) => {
    event.preventDefault();
    const text = body.trim();
    if (!text) {
      setStatusMessage('Add a note before sending.');
      return;
    }
    try {
      await onSubmit?.({
        authorName: authorName.trim(),
        body: text,
        cardPosition: cardPosition || null
      });
      setBody('');
      setStatusMessage('Shared!');
      setTimeout(() => setStatusMessage(''), 2500);
    } catch (submitError) {
      setStatusMessage(submitError?.message || 'Unable to add note.');
    }
  };

  const handlePositionChange = (value) => {
    setCardPosition(value);
    onSelectedPositionChange?.(value);
  };

  const handleRefresh = async () => {
    if (isRefreshing || !onRefresh) return;
    setIsRefreshing(true);
    try {
      await onRefresh();
    } finally {
      setIsRefreshing(false);
    }
  };

  return (
    <section
      className="rounded-3xl border border-secondary/30 bg-surface/85 p-5 sm:p-6 shadow-xl"
      aria-labelledby="collab-notes-title"
    >
      <header className="flex items-center justify-between gap-3">
        <h3 id="collab-notes-title" className="text-lg sm:text-xl font-serif text-main">
          Shared reflections
        </h3>
        {onRefresh && (
          <button
            type="button"
            onClick={handleRefresh}
            disabled={isRefreshing}
            aria-label="Refresh shared notes"
            className="inline-flex items-center gap-2 rounded-full border border-secondary/40 px-3 py-1.5 text-xs font-medium text-secondary transition-colors
              hover:bg-secondary/10 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/70 focus-visible:ring-offset-2
              disabled:opacity-60 disabled:cursor-not-allowed"
          >
            {isRefreshing ? 'Refreshing…' : 'Refresh'}
          </button>
        )}
      </header>

      <p className="mt-1 text-xs text-secondary/70">
        Last synced: <time dateTime={lastSyncedAt ? new Date(lastSyncedAt).toISOString() : undefined}>
          {formatTimestamp(lastSyncedAt)}
        </time>
      </p>

      {error && (
        <p className="mt-3 text-sm text-error" role="alert">
          {error}
        </p>
      )}

      {/* Notes list with responsive max-height */}
      <div
        className="mt-4 space-y-3 overflow-y-auto pr-1 max-h-[min(240px,40vh)]"
        style={{ WebkitOverflowScrolling: 'touch' }}
        aria-label={`${sortedNotes.length} reflection${sortedNotes.length === 1 ? '' : 's'}`}
      >
        {sortedNotes.length === 0 && (
          <p className="text-sm text-muted py-4 text-center">
            No reflections yet. Be the first to leave a note.
          </p>
        )}
        {sortedNotes.map((note) => (
          <article
            key={note.id}
            className="rounded-2xl border border-accent/20 bg-surface-muted/70 p-3"
          >
            <div className="flex items-center justify-between gap-2 text-xs text-secondary/90">
              <span className="font-semibold truncate">{note.authorName || 'Anonymous'}</span>
              <time
                dateTime={new Date(note.createdAt).toISOString()}
                className="text-secondary/70 shrink-0"
              >
                {formatTimestamp(note.createdAt)}
              </time>
            </div>
            {note.cardPosition && (
              <p className="mt-1 text-xs uppercase tracking-[0.12em] text-accent/70">
                {note.cardPosition}
              </p>
            )}
            <p className="mt-2 text-sm text-main/90 whitespace-pre-wrap break-words">
              {note.body}
            </p>
          </article>
        ))}
      </div>

      <form onSubmit={handleSubmit} className="mt-5 space-y-3">
        <div className="flex flex-col gap-3 sm:flex-row">
          <div className="flex-1">
            <label htmlFor={nameInputId} className="sr-only">
              Display name
            </label>
            <input
              id={nameInputId}
              type="text"
              value={authorName}
              onChange={(event) => setAuthorName(event.target.value)}
              placeholder="Display name"
              aria-label="Your display name for this note"
              className="w-full min-h-[44px] rounded-2xl border border-secondary/30 bg-surface-muted/70 px-4 py-2.5 text-sm text-main placeholder:text-muted/60
                focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/50"
              maxLength={40}
            />
          </div>
          <div className="flex-1">
            <label htmlFor={positionSelectId} className="sr-only">
              Card position to comment on
            </label>
            <select
              id={positionSelectId}
              value={cardPosition}
              onChange={(event) => handlePositionChange(event.target.value)}
              aria-label="Select which card position to comment on"
              className="w-full min-h-[44px] rounded-2xl border border-secondary/30 bg-surface-muted/70 px-4 py-2.5 text-sm text-main
                focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/50"
            >
              <option value="">Whole spread</option>
              {cards.map((card, index) => (
                <option
                  key={`${card.position || card.name}-${index}`}
                  value={card.position || card.name}
                >
                  {card.position || card.name}
                </option>
              ))}
            </select>
          </div>
        </div>

        <div>
          <label htmlFor={bodyTextareaId} className="sr-only">
            Your reflection
          </label>
          <textarea
            id={bodyTextareaId}
            value={body}
            onChange={(event) => setBody(event.target.value)}
            rows={3}
            placeholder="Share what you're seeing..."
            aria-label="Your reflection on this spread"
            maxLength={600}
            className="w-full rounded-2xl border border-secondary/30 bg-surface-muted/70 px-4 py-3 text-sm text-main placeholder:text-muted/60
              focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/50 resize-none"
          />
        </div>

        <div className="flex items-center justify-between gap-3">
          <span className="text-xs text-muted/70" aria-label={`${body.length} of 600 characters used`}>
            {body.length} / 600
          </span>
          <button
            type="submit"
            disabled={isSubmitting || !body.trim()}
            className="min-h-[44px] rounded-full border border-secondary/60 px-5 py-2.5 text-sm font-medium text-secondary transition-colors touch-manipulation
              hover:bg-secondary/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/70 focus-visible:ring-offset-2
              disabled:opacity-60 disabled:cursor-not-allowed"
          >
            {isSubmitting ? 'Sending…' : 'Share note'}
          </button>
        </div>

        {/* Status message with live region for screen readers */}
        <div
          id={statusId}
          role="status"
          aria-live="polite"
          className={statusMessage ? 'text-xs text-secondary/80' : 'sr-only'}
        >
          {statusMessage}
        </div>
      </form>
    </section>
  );
}
</file>

<file path="src/components/share/SharedSpreadView.jsx">
import { useMemo, useRef } from 'react';
import { SPREADS } from '../../data/spreads';
import { MAJOR_ARCANA } from '../../data/majorArcana';
import { MINOR_ARCANA } from '../../data/minorArcana';

const FALLBACK_IMAGE = '/images/cards/RWS1909_-_00_Fool.jpeg';

/**
 * Lazy singleton for card lookup to avoid running on every import
 */
let _cardLookup = null;
function getCardLookup() {
  if (!_cardLookup) {
    _cardLookup = [...MAJOR_ARCANA, ...MINOR_ARCANA].reduce((acc, card) => {
      acc[card.name] = card;
      return acc;
    }, {});
  }
  return _cardLookup;
}

function getOrientationMeaning(card) {
  const lookup = getCardLookup();
  const reference = lookup[card.name] || lookup[card.canonicalName] || card;
  const upright = reference?.upright || card?.upright || '';
  const reversed = reference?.reversed || card?.reversed || '';
  const orientation = card?.orientation || '';
  const isReversed = orientation.toLowerCase().includes('reversed');
  return isReversed ? reversed || upright : upright || reversed;
}

function getCardImage(card) {
  if (!card) return FALLBACK_IMAGE;
  if (card.image) return card.image;
  const lookup = getCardLookup();
  const lookupOrder = [card.name, card.canonicalName, card.card];
  for (const key of lookupOrder) {
    const match = key && lookup[key];
    if (match?.image) return match.image;
  }
  return FALLBACK_IMAGE;
}

function deriveSpreadPositions(entry) {
  if (!entry) return [];
  const spreadDefinition = entry.spreadKey ? SPREADS[entry.spreadKey] : null;
  if (spreadDefinition?.positions) {
    return spreadDefinition.positions;
  }
  return Array.isArray(entry.cards)
    ? entry.cards.map((_, index) => `Position ${index + 1}`)
    : [];
}

function mapNotes(notes) {
  // Sort once, then group by position
  const sorted = [...notes].sort((a, b) => a.createdAt - b.createdAt);
  return sorted.reduce((acc, note) => {
    const key = note.cardPosition || 'general';
    (acc[key] ??= []).push(note);
    return acc;
  }, {});
}

function NoteAvatars({ notes }) {
  if (!notes?.length) return null;

  // Get the most recent 3 notes (by createdAt descending)
  const sorted = [...notes].sort((a, b) => b.createdAt - a.createdAt);
  const latest = sorted.slice(0, 3);
  const remaining = notes.length - latest.length;

  return (
    <div
      className="flex items-center gap-1"
      aria-label={`${notes.length} note${notes.length === 1 ? '' : 's'} on this card`}
    >
      {latest.map((note) => {
        // Use initials or fallback to "??" for consistency across platforms
        const initials = note.authorName?.trim()?.slice(0, 2)?.toUpperCase() || '??';
        return (
          <span
            key={note.id}
            className="flex h-6 w-6 items-center justify-center rounded-full bg-secondary/30 text-[0.65rem] font-semibold text-secondary"
            title={note.authorName || 'Anonymous'}
            aria-hidden="true"
          >
            {initials}
          </span>
        );
      })}
      {remaining > 0 && (
        <span className="text-xs text-secondary/80" aria-hidden="true">
          +{remaining}
        </span>
      )}
    </div>
  );
}

export function SharedSpreadView({ entry, notes = [], selectedPosition, onSelectPosition }) {
  const positions = useMemo(() => deriveSpreadPositions(entry), [entry]);
  const noteMap = useMemo(() => mapNotes(notes), [notes]);
  // Track which images have failed to prevent infinite error loops
  const failedImagesRef = useRef(new Set());

  // Improved grid logic with better responsive handling
  const gridClass = useMemo(() => {
    if (!entry) return 'grid grid-cols-1';

    const cardCount = entry.cards?.length ?? 0;

    if (entry.spreadKey === 'celtic') return 'cc-grid';
    if (cardCount === 0) return 'grid grid-cols-1';
    if (cardCount === 1) return 'grid grid-cols-1 max-w-sm mx-auto';
    if (cardCount === 2) return 'grid grid-cols-1 sm:grid-cols-2 max-w-2xl mx-auto';
    if (cardCount === 3) return 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3';
    if (cardCount <= 4) return 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4';
    return 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3';
  }, [entry]);

  if (!entry) {
    return null;
  }

  const generalNotes = noteMap.general || [];

  const handleImageError = (event, cardName) => {
    const img = event.currentTarget;
    // Prevent infinite loop - only set fallback once per image
    if (!failedImagesRef.current.has(cardName)) {
      failedImagesRef.current.add(cardName);
      img.src = FALLBACK_IMAGE;
    }
  };

  return (
    <div className="space-y-6">
      <div className={`${gridClass} gap-4`} role="list" aria-label="Cards in this spread">
        {entry.cards?.map((card, index) => {
          const positionLabel = card.position || positions[index] || `Card ${index + 1}`;
          const positionNotes = noteMap[positionLabel] || [];
          const active = selectedPosition === positionLabel;
          const orientation = card.orientation || 'Upright';
          const isReversed = orientation.toLowerCase().includes('reversed');
          const meaning = getOrientationMeaning(card) || 'Meaning unavailable';

          return (
            <button
              key={`${card.name}-${index}`}
              type="button"
              role="listitem"
              onClick={() => onSelectPosition?.(positionLabel)}
              aria-pressed={active}
              aria-label={`${positionLabel}: ${card.name}, ${orientation}. ${positionNotes.length} note${positionNotes.length === 1 ? '' : 's'}. Click to target for note.`}
              className={`group w-full rounded-2xl border bg-surface/70 p-4 text-left shadow-lg transition-all duration-200
                focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/60 focus-visible:ring-offset-2
                active:scale-[0.98] touch-manipulation
                ${active
                  ? 'border-secondary/70 ring-1 ring-secondary/30'
                  : 'border-secondary/20 hover:border-secondary/40 hover:shadow-xl'
                }
                ${entry.spreadKey === 'celtic' ? 'modern-surface' : ''}`}
            >
              <div className="flex items-center justify-between gap-2">
                <p className="text-xs uppercase tracking-[0.2em] text-secondary">{positionLabel}</p>
                {positionNotes.length > 0 && (
                  <span className="rounded-full bg-secondary/10 px-2 py-0.5 text-xs text-secondary">
                    {positionNotes.length} note{positionNotes.length === 1 ? '' : 's'}
                  </span>
                )}
              </div>

              <div className="mt-3 flex flex-col items-center text-center">
                {/* Card image container with proper aspect ratio */}
                <div className="aspect-[2/3.5] w-full max-w-[200px] overflow-hidden rounded-xl border border-primary/30 bg-surface-muted/50">
                  <img
                    src={getCardImage(card)}
                    alt={`${card.name}, ${orientation}`}
                    className={`w-full h-full object-contain ${isReversed ? 'rotate-180' : ''}`}
                    loading="lazy"
                    onError={(e) => handleImageError(e, card.name)}
                  />
                </div>
                <p className="mt-3 font-serif text-lg text-main">{card.name}</p>
                <span className="text-xs uppercase tracking-[0.2em] text-secondary/70">{orientation}</span>
                <p className="mt-2 text-sm text-muted line-clamp-3">{meaning}</p>
              </div>

              <div className="mt-4 flex items-center justify-between">
                <NoteAvatars notes={positionNotes} />
                {active && (
                  <span className="rounded-full border border-secondary/60 px-2.5 py-1 text-xs text-secondary">
                    Targeting note
                  </span>
                )}
              </div>
            </button>
          );
        })}
      </div>

      {/* General notes section */}
      {generalNotes.length > 0 && (
        <section
          className="rounded-2xl border border-secondary/20 bg-surface/70 p-4 shadow-inner"
          aria-labelledby="general-notes-heading"
        >
          <h3 id="general-notes-heading" className="text-xs uppercase tracking-[0.3em] text-secondary">
            Whole spread reflections
          </h3>
          <div
            className="mt-3 space-y-2 max-h-48 overflow-y-auto pr-1"
            style={{ WebkitOverflowScrolling: 'touch' }}
          >
            {generalNotes.map((note) => (
              <article key={note.id} className="rounded-xl border border-accent/20 bg-surface-muted/70 p-3">
                <header className="flex items-center justify-between gap-2 text-xs text-secondary/90">
                  <span className="font-semibold truncate">{note.authorName || 'Anonymous'}</span>
                  <time
                    dateTime={new Date(note.createdAt).toISOString()}
                    className="text-secondary/70 shrink-0"
                  >
                    {new Date(note.createdAt).toLocaleString(undefined, {
                      month: 'short',
                      day: 'numeric',
                      hour: 'numeric',
                      minute: '2-digit'
                    })}
                  </time>
                </header>
                <p className="mt-2 text-sm text-main/90 whitespace-pre-wrap break-words">{note.body}</p>
              </article>
            ))}
          </div>
        </section>
      )}
    </div>
  );
}
</file>

<file path="src/components/ArchetypeJourney.jsx">
import { useState, useEffect, useRef, useCallback } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { normalizeAnalyticsShape, getGrowthPrompt, getBadgeIcon } from '../lib/archetypeJourney';
import { ConfirmModal } from './ConfirmModal';

/**
 * Accessible modal for displaying growth prompts
 */
function GrowthPromptModal({ cardName, prompt, onClose }) {
  const modalRef = useRef(null);
  const closeButtonRef = useRef(null);
  const previousFocusRef = useRef(null);

  // Focus management
  useEffect(() => {
    previousFocusRef.current = document.activeElement;
    document.body.style.overflow = 'hidden';

    // Focus the close button when modal opens
    requestAnimationFrame(() => {
      closeButtonRef.current?.focus();
    });

    return () => {
      document.body.style.overflow = '';
      // Restore focus when modal closes
      if (previousFocusRef.current?.focus) {
        previousFocusRef.current.focus();
      }
    };
  }, []);

  // Keyboard handling
  const handleKeyDown = useCallback((event) => {
    if (event.key === 'Escape') {
      event.preventDefault();
      onClose();
      return;
    }

    // Focus trap
    if (event.key === 'Tab') {
      const focusableElements = modalRef.current?.querySelectorAll(
        'button:not([disabled]), [tabindex]:not([tabindex="-1"])'
      );
      if (!focusableElements?.length) return;

      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];

      if (event.shiftKey && document.activeElement === firstElement) {
        event.preventDefault();
        lastElement?.focus();
      } else if (!event.shiftKey && document.activeElement === lastElement) {
        event.preventDefault();
        firstElement?.focus();
      }
    }
  }, [onClose]);

  // Prevent backdrop click from propagating
  const handleBackdropClick = (event) => {
    if (event.target === event.currentTarget) {
      onClose();
    }
  };

  return (
    <div
      className="fixed inset-0 z-[100] flex items-center justify-center"
      onKeyDown={handleKeyDown}
    >
      {/* Backdrop */}
      <div
        className="absolute inset-0 bg-black/50 backdrop-blur-sm animate-fade-in"
        onClick={handleBackdropClick}
        aria-hidden="true"
      />

      {/* Modal content */}
      <div
        ref={modalRef}
        role="dialog"
        aria-modal="true"
        aria-labelledby="growth-prompt-title"
        className="relative z-10 w-full max-w-md mx-4 rounded-2xl border border-accent/40 bg-surface/98 shadow-2xl animate-slide-up p-6 focus:outline-none"
        tabIndex={-1}
      >
        <h3
          id="growth-prompt-title"
          className="text-lg font-serif text-accent mb-3"
        >
          {cardName}
        </h3>
        <p className="text-muted text-sm leading-relaxed">{prompt}</p>
        <button
          ref={closeButtonRef}
          type="button"
          onClick={onClose}
          className="mt-4 w-full min-h-[44px] px-4 py-2.5 rounded-lg bg-accent/15 border border-accent/40 text-accent hover:bg-accent/25 transition text-sm font-medium
            focus:outline-none focus-visible:ring-2 focus-visible:ring-accent/50 focus-visible:ring-offset-2 touch-manipulation"
        >
          Close
        </button>
      </div>
    </div>
  );
}

/**
 * Archetype Journey Analytics Dashboard
 *
 * Displays gamified analytics:
 * - Top 5 cards this month
 * - Streak badges (e.g., "Tower appeared 3x in Nov")
 * - Trend sparkline per Major Arcana
 * - Growth prompts linked to badges
 */
export default function ArchetypeJourney() {
  const { isAuthenticated } = useAuth();
  const [analytics, setAnalytics] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [preferences, setPreferences] = useState({
    archetype_journey_enabled: true,
    show_badges: true
  });
  const [confirmReset, setConfirmReset] = useState(false);
  const [growthPromptModal, setGrowthPromptModal] = useState(null);

  useEffect(() => {
    if (isAuthenticated) {
      loadAnalytics();
    } else {
      setLoading(false);
    }
  }, [isAuthenticated]);

  const loadAnalytics = async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch('/api/archetype-journey', {
        credentials: 'include'
      });

      if (!response.ok) {
        if (response.status === 403) {
          const data = await response.json();
          if (data.enabled === false) {
            setPreferences({ archetype_journey_enabled: false, show_badges: false });
            setLoading(false);
            return;
          }
        }
        throw new Error('Failed to load analytics');
      }

      const data = await response.json();
      // Normalize to ensure all arrays exist
      setAnalytics(normalizeAnalyticsShape(data.analytics));
    } catch (err) {
      console.error('Failed to load archetype journey:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  const toggleAnalytics = async () => {
    try {
      const newEnabled = !preferences.archetype_journey_enabled;
      const response = await fetch('/api/archetype-journey/preferences', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          archetype_journey_enabled: newEnabled
        })
      });

      if (response.ok) {
        setPreferences({ ...preferences, archetype_journey_enabled: newEnabled });
        if (newEnabled) {
          loadAnalytics();
        }
      }
    } catch (err) {
      console.error('Failed to update preferences:', err);
    }
  };

  const handleResetConfirm = async () => {
    try {
      const response = await fetch('/api/archetype-journey/reset', {
        method: 'POST',
        credentials: 'include'
      });

      if (response.ok) {
        setAnalytics(null);
        loadAnalytics();
      }
    } catch (err) {
      console.error('Failed to reset analytics:', err);
    }
  };

  if (!isAuthenticated) {
    return (
      <div className="archetype-journey-placeholder">
        <p className="text-muted">
          Sign in to track which archetypal energies appear most frequently in your readings.
        </p>
      </div>
    );
  }

  if (loading) {
    return (
      <div className="archetype-journey-loading">
        <p>Loading archetype journey...</p>
      </div>
    );
  }

  if (!preferences.archetype_journey_enabled) {
    return (
      <div className="archetype-journey-disabled">
        <p className="text-muted">Archetype journey analytics are disabled.</p>
        <button onClick={toggleAnalytics} className="btn btn-secondary">
          Enable Analytics
        </button>
      </div>
    );
  }

  if (error) {
    return (
      <div className="archetype-journey-error">
        <p className="error-message">Failed to load analytics: {error}</p>
        <button onClick={loadAnalytics} className="btn btn-secondary">
          Retry
        </button>
      </div>
    );
  }

  if (!analytics || !Array.isArray(analytics.topCards) || analytics.topCards.length === 0) {
    return (
      <div className="archetype-journey-empty">
        <h3>Your Archetype Journey</h3>
        <p className="text-muted">
          Complete readings to discover which archetypal energies appear most in your journey.
        </p>
        <div className="preferences-controls">
          <button onClick={toggleAnalytics} className="btn btn-link">
            Disable Analytics
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="archetype-journey">
      <div className="archetype-journey-header">
        <h3>Your Archetype Journey</h3>
        <p className="subtitle">
          {analytics.currentMonth} · {analytics.totalReadingsThisMonth} reading{analytics.totalReadingsThisMonth !== 1 ? 's' : ''}
        </p>
      </div>

      {/* Top 5 Cards This Month */}
      <section className="top-cards-section">
        <h4>Most Frequent Energies</h4>
        <div className="top-cards-grid">
          {analytics.topCards.map((card, index) => (
            <div key={card.card_name} className="top-card-item">
              <div className="card-rank">#{index + 1}</div>
              <div className="card-info">
                <div className="card-name">{card.card_name}</div>
                <div className="card-count">{card.count}× this month</div>
              </div>
              {card.card_number !== null && card.card_number <= 21 && (
                <div className="growth-prompt-link">
                  <button
                    onClick={() => showGrowthPrompt(card)}
                    className="btn-link"
                    aria-label={`View growth prompt for ${card.card_name}`}
                  >
                    What does this mean?
                  </button>
                </div>
              )}
            </div>
          ))}
        </div>
      </section>

      {/* Streak Badges */}
      {Array.isArray(analytics.streaks) && analytics.streaks.length > 0 && (
        <section className="streaks-section">
          <h4>Recent Patterns</h4>
          <div className="streaks-grid">
            {analytics.streaks.map((streak) => (
              <div key={streak.cardName} className="streak-badge">
                <div className="badge-icon">🔥</div>
                <div className="badge-info">
                  <div className="badge-title">{streak.cardName}</div>
                  <div className="badge-description">
                    Appeared {streak.count}× in {streak.month}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </section>
      )}

      {/* Badges */}
      {preferences.show_badges && Array.isArray(analytics.badges) && analytics.badges.length > 0 && (
        <section className="badges-section">
          <h4>Achievements</h4>
          <div className="badges-grid">
            {analytics.badges.map((badge) => (
              <div key={badge.badge_key} className="achievement-badge">
                <div className="badge-icon">
                  {getBadgeIcon(badge.badge_type)}
                </div>
                <div className="badge-info">
                  <div className="badge-title">{badge.card_name || 'Milestone'}</div>
                  <div className="badge-description">
                    {badge.metadata.context || 'Achievement unlocked'}
                  </div>
                  <div className="badge-date">
                    {new Date(badge.earned_at * 1000).toLocaleDateString()}
                  </div>
                </div>
              </div>
            ))}
          </div>
        </section>
      )}

      {/* Trends Sparkline (simplified) */}
      {Array.isArray(analytics.trends) && analytics.trends.length > 0 && (
        <section className="trends-section">
          <h4>Six-Month Patterns</h4>
          <div className="trends-info">
            <p className="text-muted">
              {Object.keys(analytics.majorArcanaFrequency).length} Major Arcana cards appeared this month
            </p>
          </div>
        </section>
      )}

      {/* Preferences Footer */}
      <div className="archetype-journey-footer">
        <button onClick={toggleAnalytics} className="btn btn-link">
          Disable Analytics
        </button>
        <button onClick={() => setConfirmReset(true)} className="btn btn-link text-danger">
          Reset Data
        </button>
      </div>

      {/* Modals */}
      <ConfirmModal
        isOpen={confirmReset}
        onClose={() => setConfirmReset(false)}
        onConfirm={handleResetConfirm}
        title="Reset Archetype Journey Data"
        message="Are you sure you want to reset all archetype journey data? This action cannot be undone."
        confirmText="Reset Data"
        cancelText="Cancel"
        variant="danger"
      />

      {growthPromptModal && (
        <GrowthPromptModal
          cardName={growthPromptModal.cardName}
          prompt={growthPromptModal.prompt}
          onClose={() => setGrowthPromptModal(null)}
        />
      )}
    </div>
  );

  /**
   * Show growth prompt for a card
   */
  function showGrowthPrompt(card) {
    const prompt = getGrowthPrompt(card.card_name);
    setGrowthPromptModal({
      cardName: card.card_name,
      prompt
    });
  }
}
</file>

<file path="src/components/ArchetypeJourneySection.jsx">
import { useState, useEffect, useCallback, useRef } from 'react';
import { TrendUp, Medal, Fire, ArrowsClockwise, Sparkle } from '@phosphor-icons/react';
import { normalizeAnalyticsShape, getBadgeIcon } from '../lib/archetypeJourney';

function parseTimestamp(value) {
  if (!value) return null;
  if (typeof value === 'number') {
    return value < 1e12 ? value * 1000 : value;
  }
  if (typeof value === 'string' && /^\d+$/.test(value)) {
    const numeric = Number(value);
    return Number.isFinite(numeric) ? (numeric < 1e12 ? numeric * 1000 : numeric) : null;
  }
  const date = new Date(value);
  return Number.isNaN(date.getTime()) ? null : date.getTime();
}

function formatTimestampLabel(value) {
  const ms = parseTimestamp(value);
  if (!ms) return null;
  const date = new Date(ms);
  if (Number.isNaN(date.getTime())) return null;
  return date.toLocaleString(undefined, {
    month: 'short',
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
}

const RUN_META_KEY_PREFIX = 'archetype_run_meta';

/**
 * Get user-scoped localStorage key for run metadata.
 * Falls back to a default key if userId is not provided.
 */
function getRunMetaKey(userId) {
  return userId ? `${RUN_META_KEY_PREFIX}_${userId}` : null;
}

/**
 * Loading skeleton for analytics sections
 */
function AnalyticsSkeleton() {
  return (
    <div className="rounded-3xl border border-secondary/20 bg-surface/40 p-5 animate-pulse">
      <div className="flex items-center gap-2 mb-4">
        <div className="h-3 w-3 rounded bg-secondary/20" />
        <div className="h-3 w-28 rounded bg-secondary/20" />
      </div>
      <div className="space-y-3">
        {[1, 2, 3].map((i) => (
          <div key={i} className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <div className="h-5 w-5 rounded-full bg-secondary/10" />
              <div className="h-4 w-24 rounded bg-secondary/10" />
            </div>
            <div className="h-4 w-8 rounded bg-secondary/10" />
          </div>
        ))}
      </div>
    </div>
  );
}

/**
 * Empty state component with backfill option
 */
function EmptyState({ onBackfill, isBackfilling, backfillResult }) {
  const abortControllerRef = useRef(null);

  const handleClick = useCallback(() => {
    // Abort any previous backfill
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    abortControllerRef.current = new AbortController();
    onBackfill(abortControllerRef.current.signal);
  }, [onBackfill]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  return (
    <section
      className="rounded-3xl border border-secondary/20 bg-surface/40 p-5"
      aria-labelledby="archetype-journey-empty-heading"
    >
      <h3
        id="archetype-journey-empty-heading"
        className="mb-3 flex items-center gap-2 text-xs font-bold uppercase tracking-wider text-accent/80"
      >
        <Sparkle className="h-3 w-3" aria-hidden="true" />
        Archetype Journey
      </h3>

      {backfillResult ? (
        <div className="text-sm text-secondary/80">
          <p className="mb-2 text-primary">
            {backfillResult.success ? 'Backfill complete!' : 'Backfill failed'}
          </p>
          {backfillResult.success && backfillResult.stats && (
            <ul className="space-y-1 text-xs text-muted">
              <li>{backfillResult.stats.entriesProcessed} entries processed</li>
              <li>{backfillResult.stats.cardsTracked} cards tracked</li>
              {backfillResult.stats.badgesAwarded > 0 && (
                <li>{backfillResult.stats.badgesAwarded} badges awarded</li>
              )}
            </ul>
          )}
          {!backfillResult.success && (
            <p className="text-xs text-error">{backfillResult.message || 'Please try again'}</p>
          )}
        </div>
      ) : (
        <>
          <p className="mb-4 text-sm text-muted leading-relaxed">
            Track which cards appear most often in your readings to discover recurring archetypal themes in your journey.
          </p>

          <button
            onClick={handleClick}
            disabled={isBackfilling}
            aria-label="Analyze journal for archetype journey"
            className={`
              flex items-center gap-2 px-4 py-2 rounded-full text-xs font-medium
              border border-accent/30 text-accent
              hover:bg-accent/10 hover:border-accent/50
              active:bg-accent/20
              disabled:opacity-50 disabled:cursor-not-allowed
              transition
            `}
          >
            <ArrowsClockwise
              className={`h-3.5 w-3.5 ${isBackfilling ? 'animate-spin' : ''}`}
              aria-hidden="true"
            />
            {isBackfilling ? 'Analyzing readings...' : 'Analyze past readings'}
          </button>

          <p className="mt-3 text-[11px] text-secondary/50">
            This will scan your journal entries and build your card frequency data.
          </p>
          {backfillResult?.success && backfillResult?.stats?.entriesProcessed > 0 && (
            <p className="mt-1 text-[10px] text-secondary/60">
              Last run processed {backfillResult.stats.entriesProcessed} entries.
            </p>
          )}
        </>
      )}
    </section>
  );
}

/**
 * Archetype Journey Section
 *
 * Displays gamified analytics to embed within JournalInsightsPanel:
 * - Top 5 cards this month
 * - Streak badges
 * - Growth prompts
 */
export function ArchetypeJourneySection({ isAuthenticated, userId, showEmptyState = true }) {
  const [analytics, setAnalytics] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [isDisabled, setIsDisabled] = useState(false);
  const [isBackfilling, setIsBackfilling] = useState(false);
  const [backfillResult, setBackfillResult] = useState(null);
  const [runMeta, setRunMeta] = useState({ lastAnalyzedAt: null, entriesProcessed: null });
  const reloadControllerRef = useRef(null);

  // Load run metadata from user-scoped localStorage when userId changes
  useEffect(() => {
    if (typeof window === 'undefined') return;

    // Clear metadata when not authenticated or no userId
    if (!isAuthenticated || !userId) {
      setRunMeta({ lastAnalyzedAt: null, entriesProcessed: null });
      return;
    }

    const key = getRunMetaKey(userId);
    if (!key) return;

    try {
      const stored = JSON.parse(localStorage.getItem(key) || 'null');
      if (stored && typeof stored === 'object') {
        setRunMeta({
          lastAnalyzedAt: stored.lastAnalyzedAt ?? null,
          entriesProcessed: stored.entriesProcessed ?? null
        });
      } else {
        setRunMeta({ lastAnalyzedAt: null, entriesProcessed: null });
      }
    } catch (err) {
      console.warn('Failed to parse stored run metadata', err);
      setRunMeta({ lastAnalyzedAt: null, entriesProcessed: null });
    }
  }, [isAuthenticated, userId]);

  const updateRunMeta = useCallback((incoming) => {
    // If incoming is null/undefined, reset the metadata
    const shouldReset = incoming === null || incoming === undefined;

    setRunMeta((prev) => {
      const next = shouldReset
        ? { lastAnalyzedAt: null, entriesProcessed: null }
        : {
            lastAnalyzedAt: incoming.lastAnalyzedAt ?? prev.lastAnalyzedAt ?? null,
            entriesProcessed: incoming.entriesProcessed ?? prev.entriesProcessed ?? null
          };

      // Only persist if we have a valid user-scoped key
      if (typeof window !== 'undefined' && userId) {
        const key = getRunMetaKey(userId);
        if (key) {
          try {
            if (shouldReset) {
              localStorage.removeItem(key);
            } else {
              localStorage.setItem(key, JSON.stringify(next));
            }
          } catch (err) {
            console.warn('Failed to persist run metadata', err);
          }
        }
      }
      return next;
    });
  }, [userId]);

  const loadAnalytics = useCallback(async (signal) => {
    setLoading(true);
    setError(null);
    setIsDisabled(false);

    try {
      const response = await fetch('/api/archetype-journey', {
        credentials: 'include',
        signal
      });

      if (!response.ok) {
        if (response.status === 403) {
          // Analytics disabled by user preference
          setIsDisabled(true);
          setLoading(false);
          return;
        }
        throw new Error('Failed to load analytics');
      }

      const data = await response.json();
      // Normalize to ensure all arrays exist
      const normalized = normalizeAnalyticsShape(data.analytics);
      setAnalytics(normalized);
      updateRunMeta({
        lastAnalyzedAt: normalized?.stats?.lastAnalyzedAt ?? data.analytics?.lastRunAt ?? null,
        entriesProcessed: normalized?.stats?.entriesProcessed ?? null
      });
    } catch (err) {
      // Don't set error state for abort
      if (err.name === 'AbortError') return;
      console.error('Failed to load archetype journey:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, [updateRunMeta]);

  const handleBackfill = useCallback(async (signal) => {
    setIsBackfilling(true);
    setBackfillResult(null);

    try {
      const response = await fetch('/api/archetype-journey-backfill', {
        method: 'POST',
        credentials: 'include',
        signal
      });

      const data = await response.json();

      if (!response.ok) {
        setBackfillResult({ success: false, message: data.error || 'Backfill failed' });
        return;
      }

      setBackfillResult({ success: true, stats: data.stats });
      updateRunMeta({
        lastAnalyzedAt: Date.now(),
        entriesProcessed: data.stats?.entriesProcessed ?? data.stats?.cardsTracked ?? null
      });

      // Reload analytics after successful backfill
      if (data.stats?.cardsTracked > 0) {
        // Reload with slight delay to let DB settle
        await new Promise(resolve => setTimeout(resolve, 300));
        if (!signal?.aborted) {
          if (reloadControllerRef.current) {
            reloadControllerRef.current.abort();
          }
          const reloadController = new AbortController();
          reloadControllerRef.current = reloadController;
          try {
            await loadAnalytics(reloadController.signal);
          } finally {
            if (reloadControllerRef.current === reloadController) {
              reloadControllerRef.current = null;
            }
          }
        }
      }
    } catch (err) {
      if (err.name === 'AbortError') return;
      console.error('Backfill failed:', err);
      setBackfillResult({ success: false, message: err.message });
    } finally {
      setIsBackfilling(false);
    }
  }, [loadAnalytics, updateRunMeta]);

  useEffect(() => {
    if (!isAuthenticated) {
      setLoading(false);
      return;
    }

    const controller = new AbortController();
    loadAnalytics(controller.signal);

    return () => controller.abort();
  }, [isAuthenticated, loadAnalytics]);

  useEffect(() => {
    return () => {
      if (reloadControllerRef.current) {
        reloadControllerRef.current.abort();
      }
    };
  }, []);

  // Show nothing if not authenticated
  if (!isAuthenticated) {
    return null;
  }

  // Show loading skeleton while fetching
  if (loading) {
    return <AnalyticsSkeleton />;
  }

  // Feature disabled by user - show nothing (they can enable in UserMenu)
  if (isDisabled) {
    return null;
  }

  // Log errors but don't show them to user (graceful degradation)
  if (error) {
    console.error('ArchetypeJourneySection error:', error);
    return null;
  }

  // No data yet - show empty state with backfill option
  if (!analytics || analytics.topCards.length === 0) {
    if (!showEmptyState) {
      return null;
    }
    return (
      <EmptyState
        onBackfill={handleBackfill}
        isBackfilling={isBackfilling}
        backfillResult={backfillResult}
      />
    );
  }

  const sectionBlocks = [];

  if (analytics.topCards.length > 0) {
    sectionBlocks.push({
      key: 'topCards',
      content: (
        <>
          <div className="mb-4 flex items-center gap-2 text-xs font-bold uppercase tracking-wider text-accent/80">
            <TrendUp className="h-3 w-3" aria-hidden="true" />
            Top Cards
          </div>
          <ul className="space-y-2" aria-label="Your top 5 most frequently appearing cards this month">
            {analytics.topCards.slice(0, 5).map((card, index) => (
              <li key={`${card.card_name}-${index}`} className="flex items-center justify-between text-sm">
                <div className="flex items-center gap-2">
                  <span className="flex h-5 w-5 items-center justify-center rounded-full bg-secondary/10 text-xs font-medium text-secondary" aria-hidden="true">
                    {index + 1}
                  </span>
                  <span className="text-muted">
                    <span className="sr-only">Rank {index + 1}: </span>
                    {card.card_name}
                  </span>
                </div>
                <span className="text-secondary/60" aria-label={`appeared ${card.count} times`}>
                  {card.count}×
                </span>
              </li>
            ))}
          </ul>
        </>
      )
    });
  }

  if (analytics.streaks.length > 0) {
    sectionBlocks.push({
      key: 'patterns',
      content: (
        <>
          <div className="mb-4 flex items-center gap-2 text-xs font-bold uppercase tracking-wider text-accent/80">
            <Fire className="h-3 w-3" aria-hidden="true" />
            Recent Patterns
          </div>
          <ul className="space-y-3" aria-label="Cards appearing frequently this month">
            {analytics.streaks.slice(0, 3).map((streak) => (
              <li key={streak.cardName} className="flex items-center gap-3">
                <div
                  className="flex h-8 w-8 items-center justify-center rounded-full bg-accent/10 text-accent"
                  aria-hidden="true"
                  title="Pattern highlight"
                >
                  <Fire className="h-4 w-4" />
                </div>
                <div className="flex-1">
                  <p className="text-sm font-medium text-secondary">{streak.cardName}</p>
                  <p className="text-xs text-secondary/60">
                    Appeared {streak.count} time{streak.count === 1 ? '' : 's'} this month
                  </p>
                </div>
              </li>
            ))}
          </ul>
          {analytics.streaks.length > 3 && (
            <p className="mt-3 text-xs text-secondary/50">
              +{analytics.streaks.length - 3} more pattern{analytics.streaks.length - 3 !== 1 ? 's' : ''}
            </p>
          )}
        </>
      )
    });
  }

  if (analytics.badges.length > 0) {
    sectionBlocks.push({
      key: 'achievements',
      content: (
        <>
          <div className="mb-4 flex items-center gap-2 text-xs font-bold uppercase tracking-wider text-accent/80">
            <Medal className="h-3 w-3" aria-hidden="true" />
            Achievements
          </div>
          <ul className="space-y-2" aria-label="Your earned achievements">
            {analytics.badges.slice(0, 3).map((badge) => {
              const BadgeIcon = getBadgeIcon(badge.badge_type);
              return (
                <li key={badge.badge_key} className="flex items-start gap-2">
                  <span className="text-lg" title={badge.card_name || 'Achievement badge'}>
                    <BadgeIcon className="h-4 w-4" aria-hidden="true" />
                  </span>
                  <div className="flex-1">
                    <p className="text-sm font-medium text-secondary">
                      {badge.card_name || 'Milestone'}
                    </p>
                    <p className="text-xs text-secondary/60">
                      {badge.metadata?.context || 'Achievement unlocked'}
                    </p>
                  </div>
                </li>
              );
            })}
          </ul>
        </>
      )
    });
  }

  const topCardWithLastSeen = analytics.topCards.find((card) => card.last_seen);
  const lastAnalyzedLabel = formatTimestampLabel(runMeta.lastAnalyzedAt || analytics.stats?.lastAnalyzedAt || topCardWithLastSeen?.last_seen);
  const processedCaptionCount = runMeta.entriesProcessed ?? analytics.stats?.entriesProcessed ?? analytics.stats?.totalReadings ?? null;
  const runCaptionParts = [];
  if (lastAnalyzedLabel) {
    runCaptionParts.push(`Last analyzed ${lastAnalyzedLabel}`);
  }
  if (processedCaptionCount) {
    runCaptionParts.push(`${processedCaptionCount} entries processed`);
  }
  const runCaption = runCaptionParts.join(' · ');

  return (
    <section className="rounded-3xl border border-secondary/30 bg-surface/70 p-5 space-y-5" aria-labelledby="archetype-journey-heading">
      <div>
        <p className="text-[11px] uppercase tracking-[0.3em] text-secondary/70">Archetype Journey</p>
        <h3 id="archetype-journey-heading" className="text-lg font-serif text-main">{analytics.currentMonth}</h3>
        <p className="text-xs text-secondary/60">
          {analytics.stats?.thisMonth ?? 0} entries this month · Avg {analytics.stats?.avgPerWeek ?? 0}/week · {analytics.stats?.totalReadings ?? 0} total
        </p>
        {runCaption && (
          <p className="text-[11px] text-secondary/60">
            {runCaption}
          </p>
        )}
      </div>
      {sectionBlocks.length > 0 ? (
        <div className="space-y-5 divide-y divide-secondary/15">
          {sectionBlocks.map((section, index) => (
            <div key={section.key} className={index === 0 ? '' : 'pt-5'}>
              {section.content}
            </div>
          ))}
        </div>
      ) : (
        <p className="text-sm text-secondary/70">Run more readings to unlock archetype analytics.</p>
      )}
    </section>
  );
}
</file>

<file path="src/components/AudioControls.jsx">
import { SpeakerHigh, SpeakerSlash, MusicNotes, Info, Waveform } from '@phosphor-icons/react';
import { Tooltip } from './Tooltip';
import { GlowToggle } from './GlowToggle';
import { usePreferences } from '../contexts/PreferencesContext';

/**
 * AudioControls - Unified audio settings panel
 * Groups Voice (TTS) and Ambience controls together
 */
export function AudioControls({ className = '' }) {
  const { voiceOn, setVoiceOn, ambienceOn, setAmbienceOn, autoNarrate, setAutoNarrate, ttsProvider, setTtsProvider } = usePreferences();

  const controlShellClass =
    'rounded-3xl border border-secondary/25 bg-surface/80 p-3 xs:p-4 sm:p-5 shadow-md shadow-secondary/15 backdrop-blur-lg';
  const tileBaseClass =
    'group flex items-center gap-2 xs:gap-3 rounded-2xl border border-secondary/20 bg-surface/75 px-3 py-2 xs:py-2.5 transition-colors duration-200 touch-manipulation min-h-[56px]';
  const activeTileClass =
    'border-secondary/50 bg-secondary/10 shadow-lg shadow-secondary/25';
  const inactiveTileClass = 'hover:border-accent/35 hover:bg-surface/80';

  const iconWrapperBase =
    'flex h-8 w-8 xs:h-9 xs:w-9 flex-shrink-0 items-center justify-center rounded-xl border transition-colors duration-200';
  const activeIconWrapper =
    'border-secondary/60 bg-secondary/20 text-secondary shadow-md shadow-secondary/20';
  const inactiveIconWrapper =
    'border-accent/25 bg-surface/85 text-muted group-hover:text-main';

  // Info button - subtle icon, 44px touch target but no visible border
  const infoButtonClass =
    'inline-flex min-w-[44px] min-h-[44px] items-center justify-center rounded-full text-muted/60 transition hover:text-accent focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60 touch-manipulation -ml-2 -mr-3';

  const VoiceIcon = voiceOn ? SpeakerHigh : SpeakerSlash;

  const audioToggles = [
    {
      id: 'voice-toggle',
      label: 'Reader voice',
      tooltipContent: 'Gentle narration for card flips and full readings.',
      tooltipAria: 'About reader voice narration',
      srDescription:
        'Enable AI-generated voice narration for card reveals and full readings.',
      active: voiceOn,
      Icon: VoiceIcon,
      onMessage: 'Narration will read card reveals and full readings.',
      offMessage: 'Voice narration stays muted.',
      onToggle: value => setVoiceOn(value),
      disabled: false
    },
    {
      id: 'auto-narrate-toggle',
      label: 'Auto-narrate',
      tooltipContent: voiceOn
        ? 'Automatically play narration as your reading streams in (first view only).'
        : 'Enable "Reader voice" first to use auto-narration.',
      tooltipAria: 'About auto-narration with streaming',
      srDescription: 'Automatically start voice narration when a new reading appears.',
      active: autoNarrate && voiceOn,
      Icon: SpeakerHigh,
      onMessage: 'Narration starts automatically with new readings.',
      offMessage: voiceOn ? "You'll tap \"Read this aloud\" manually." : 'Requires Reader voice to be enabled.',
      onToggle: value => setAutoNarrate(value),
      disabled: !voiceOn
    },
    {
      id: 'ambience-toggle',
      label: 'Table ambience',
      tooltipContent:
        'Soft shuffle, candle crackle, and mystic room tone beneath your reading.',
      tooltipAria: 'About ambience soundscape',
      srDescription: 'Play soft background ambience sound during readings.',
      active: ambienceOn,
      Icon: MusicNotes,
      onMessage: 'Ambient table sounds are playing.',
      offMessage: 'Ambient sounds are muted.',
      onToggle: value => setAmbienceOn(value),
      disabled: false
    }
  ];

  return (
    <div className={`${controlShellClass} ${className}`}>
      <div className="mb-3">
        <h3 className="flex items-center gap-2 font-serif text-xs uppercase tracking-[0.12em] text-accent sm:text-sm">
          <SpeakerHigh className="h-4 w-4" aria-hidden="true" />
          Audio Settings
        </h3>
        <p className="mt-1 text-[0.7rem] text-muted">
          Voice narration, auto-play, and ambient soundscape
        </p>
      </div>

      <div
        className="grid grid-cols-1 gap-2 sm:grid-cols-2 lg:grid-cols-3"
        role="group"
        aria-label="Audio controls"
      >
        {audioToggles.map(item => {
          const ItemIcon = item.Icon;
          const labelId = `${item.id}-label`;
          const descriptionId = `${item.id}-description`;

          return (
            <div
              key={item.id}
              className={`${tileBaseClass} ${item.active ? activeTileClass : inactiveTileClass} ${item.disabled ? 'opacity-50' : ''}`}
            >
              <span
                className={`${iconWrapperBase} ${
                  item.active ? activeIconWrapper : inactiveIconWrapper
                }`}
                aria-hidden="true"
              >
                <ItemIcon className="h-4 w-4" />
              </span>

              <div className="min-w-0 flex-1">
                <div className="flex items-center gap-1.5">
                  <span id={labelId} className={`text-sm font-semibold ${item.disabled ? 'text-muted' : 'text-main'}`}>
                    {item.label}
                  </span>
                  <Tooltip
                    content={item.tooltipContent}
                    position="top"
                    triggerClassName={infoButtonClass}
                    ariaLabel={item.tooltipAria}
                  >
                    <Info className="h-3.5 w-3.5" />
                  </Tooltip>
                </div>
                <span id={descriptionId} className="sr-only">
                  {item.srDescription}
                </span>
              </div>

              <GlowToggle
                checked={item.active}
                onChange={item.onToggle}
                disabled={item.disabled}
                labelId={labelId}
                describedBy={descriptionId}
              />
            </div>
          );
        })}
      </div>

      {/* Voice Engine Selector */}
      {voiceOn && (
        <div className="mt-3 xs:mt-4 pt-3 xs:pt-4 border-t border-secondary/20">
          <div className="flex items-center gap-2 mb-2">
            <Waveform className="h-4 w-4 text-accent" aria-hidden="true" />
            <span className="text-xs font-semibold text-accent uppercase tracking-wide">Voice Engine</span>
            <Tooltip
              content="Hume AI offers emotionally expressive voices with natural prosody. Azure provides reliable, clear narration."
              position="top"
              triggerClassName={infoButtonClass}
              ariaLabel="About voice engine options"
            >
              <Info className="h-3.5 w-3.5" />
            </Tooltip>
          </div>
          <div className="flex gap-2" role="radiogroup" aria-label="Select voice engine">
            <button
              type="button"
              role="radio"
              aria-checked={ttsProvider === 'hume'}
              onClick={() => setTtsProvider('hume')}
              className={`flex-1 min-h-[52px] px-2 xs:px-3 py-2 rounded-xl text-sm font-medium transition-all touch-manipulation ${
                ttsProvider === 'hume'
                  ? 'bg-primary/20 border-2 border-primary text-primary shadow-md'
                  : 'bg-surface/60 border border-secondary/30 text-muted hover:text-main hover:border-secondary/50 active:bg-surface/80'
              }`}
            >
              <span className="block font-semibold text-xs xs:text-sm">Hume AI</span>
              <span className="block text-[0.65rem] xs:text-xs opacity-75">Expressive</span>
            </button>
            <button
              type="button"
              role="radio"
              aria-checked={ttsProvider === 'azure'}
              onClick={() => setTtsProvider('azure')}
              className={`flex-1 min-h-[52px] px-2 xs:px-3 py-2 rounded-xl text-sm font-medium transition-all touch-manipulation ${
                ttsProvider === 'azure'
                  ? 'bg-primary/20 border-2 border-primary text-primary shadow-md'
                  : 'bg-surface/60 border border-secondary/30 text-muted hover:text-main hover:border-secondary/50 active:bg-surface/80'
              }`}
            >
              <span className="block font-semibold text-xs xs:text-sm">Azure</span>
              <span className="block text-[0.65rem] xs:text-xs opacity-75">Clear</span>
            </button>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/AuthModal.jsx">
import { useState, useEffect, useRef } from 'react';
import FocusTrap from 'focus-trap-react';
import { X, Eye, EyeSlash } from '@phosphor-icons/react';
import { useAuth } from '../contexts/AuthContext';
import { useModalA11y, createBackdropHandler } from '../hooks/useModalA11y';
import { useSmallScreen } from '../hooks/useSmallScreen';

export default function AuthModal({ isOpen, onClose }) {
  const { register, login, error: authError } = useAuth();
  const isSmallScreen = useSmallScreen();
  const [mode, setMode] = useState('login'); // 'login' or 'register'
  const [email, setEmail] = useState('');
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState('');
  const modalRef = useRef(null);
  const firstInputRef = useRef(null);

  // Use modal accessibility hook for scroll lock, escape key, and focus restoration
  // trapFocus: false because FocusTrap library handles focus trapping
  useModalA11y(isOpen, {
    onClose,
    containerRef: modalRef,
    trapFocus: false,
    initialFocusRef: firstInputRef,
  });

  // Reset password visibility when mode changes
  useEffect(() => {
    setShowPassword(false);
    setShowConfirmPassword(false);
  }, [mode]);

  if (!isOpen) return null;

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setSuccess('');
    setLoading(true);

    try {
      if (mode === 'register') {
        // Validate registration fields
        if (!email || !username || !password || !confirmPassword) {
          setError('All fields are required');
          return;
        }

        if (password !== confirmPassword) {
          setError('Passwords do not match');
          return;
        }

        if (password.length < 8) {
          setError('Password must be at least 8 characters');
          return;
        }

        const result = await register(email, username, password);

        if (result.success) {
          setSuccess('Account created successfully!');
          setTimeout(() => {
            onClose();
          }, 1500);
        } else {
          setError(result.error || 'Registration failed');
        }
      } else {
        // Login
        if (!email || !password) {
          setError('Email and password are required');
          return;
        }

        const result = await login(email, password);

        if (result.success) {
          setSuccess('Logged in successfully!');
          setTimeout(() => {
            onClose();
          }, 1000);
        } else {
          setError(result.error || 'Login failed');
        }
      }
    } catch (err) {
      setError(err.message || 'An error occurred');
    } finally {
      setLoading(false);
    }
  };

  const switchMode = () => {
    setMode(mode === 'login' ? 'register' : 'login');
    setError('');
    setSuccess('');
    // Preserve email when switching modes
    setUsername('');
    setPassword('');
    setConfirmPassword('');
  };

  const inputBaseClasses = `
    w-full px-4 py-3 min-h-[48px]
    bg-surface-muted border border-primary/30 rounded-lg
    text-main placeholder-main/40
    focus:outline-none focus:ring-2 focus:ring-primary/50 focus:border-primary/50
    disabled:opacity-60 disabled:cursor-not-allowed
    transition-colors
  `;

  const errorId = error || authError ? 'auth-error' : undefined;

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-main/90 backdrop-blur-sm animate-fade-in p-4"
      onClick={createBackdropHandler(onClose)}
    >
      <FocusTrap
        active={isOpen}
        focusTrapOptions={{
          initialFocus: () => firstInputRef.current,
          escapeDeactivates: false,
          clickOutsideDeactivates: false,
          returnFocusOnDeactivate: false,
          allowOutsideClick: true,
        }}
      >
        <div
          ref={modalRef}
          role="dialog"
          aria-modal="true"
          aria-labelledby="auth-modal-title"
          aria-describedby={errorId}
          className={`relative w-full bg-surface rounded-2xl border border-primary/40 shadow-2xl animate-pop-in max-h-[90vh] overflow-y-auto ${isSmallScreen ? 'max-w-full mx-2' : 'max-w-md'}`}
        >
          {/* Close button - 44px touch target */}
          <button
            onClick={onClose}
            className="
              absolute top-3 right-3 z-10
              flex items-center justify-center
              w-11 h-11 min-w-[44px] min-h-[44px]
              rounded-full
              text-accent hover:text-main hover:bg-accent/10
              active:bg-accent/20 active:scale-95
              transition touch-manipulation
              focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60
            "
            aria-label="Close dialog"
          >
            <X className="w-5 h-5" aria-hidden="true" />
          </button>

          {/* Header */}
          <div className="px-6 sm:px-8 pt-8 pb-5 border-b border-primary/20">
            <h2 id="auth-modal-title" className="text-2xl font-serif text-accent pr-8">
              {mode === 'login' ? 'Welcome Back' : 'Create Account'}
            </h2>
            <p className="mt-2 text-sm text-muted">
              {mode === 'login'
                ? 'Sign in to access your journal across devices'
                : 'Register to save your readings to the cloud'}
            </p>
          </div>

          {/* Form */}
          <form onSubmit={handleSubmit} className="px-6 sm:px-8 py-6">
            <div className="space-y-4">
              {/* Email */}
              <div>
                <label htmlFor="auth-email" className="block text-sm font-medium text-accent mb-1.5">
                  Email
                </label>
                <input
                  ref={firstInputRef}
                  type="email"
                  id="auth-email"
                  name="email"
                  autoComplete="email"
                  inputMode="email"
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className={inputBaseClasses}
                  placeholder="you@example.com"
                  required
                  disabled={loading}
                  aria-invalid={Boolean(error || authError)}
                />
              </div>

              {/* Username (register only) */}
              {mode === 'register' && (
                <div>
                  <label htmlFor="auth-username" className="block text-sm font-medium text-accent mb-1.5">
                    Username
                  </label>
                  <input
                    type="text"
                    id="auth-username"
                    name="username"
                    autoComplete="username"
                    value={username}
                    onChange={(e) => setUsername(e.target.value)}
                    className={inputBaseClasses}
                    placeholder="Choose a username"
                    required
                    disabled={loading}
                    pattern="[a-zA-Z0-9_]{3,30}"
                    title="3-30 characters, letters, numbers, and underscores only"
                    aria-describedby="username-hint"
                  />
                  <p id="username-hint" className="mt-1 text-xs text-muted">
                    3-30 characters, letters, numbers, and underscores
                  </p>
                </div>
              )}

              {/* Password */}
              <div>
                <label htmlFor="auth-password" className="block text-sm font-medium text-accent mb-1.5">
                  Password
                </label>
                <div className="relative">
                  <input
                    type={showPassword ? 'text' : 'password'}
                    id="auth-password"
                    name="password"
                    autoComplete={mode === 'login' ? 'current-password' : 'new-password'}
                    value={password}
                    onChange={(e) => setPassword(e.target.value)}
                    className={`${inputBaseClasses} pr-12`}
                    placeholder={mode === 'register' ? 'At least 8 characters' : 'Enter your password'}
                    required
                    disabled={loading}
                    minLength={8}
                    aria-invalid={Boolean(error || authError)}
                    aria-describedby={mode === 'register' ? 'password-hint' : undefined}
                  />
                  <button
                    type="button"
                    onClick={() => setShowPassword(!showPassword)}
                    className="
                      absolute right-1 top-1/2 -translate-y-1/2
                      flex items-center justify-center
                      w-10 h-10 min-w-[40px] min-h-[40px]
                      rounded-lg
                      text-muted hover:text-accent
                      active:bg-accent/10
                      transition touch-manipulation
                      focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60
                    "
                    aria-label={showPassword ? 'Hide password' : 'Show password'}
                    aria-pressed={showPassword}
                  >
                    {showPassword ? (
                      <EyeSlash className="w-5 h-5" aria-hidden="true" />
                    ) : (
                      <Eye className="w-5 h-5" aria-hidden="true" />
                    )}
                  </button>
                </div>
                {mode === 'register' && (
                  <p id="password-hint" className="mt-1 text-xs text-muted">
                    Minimum 8 characters
                  </p>
                )}
              </div>

              {/* Confirm Password (register only) */}
              {mode === 'register' && (
                <div>
                  <label htmlFor="auth-confirm-password" className="block text-sm font-medium text-accent mb-1.5">
                    Confirm Password
                  </label>
                  <div className="relative">
                    <input
                      type={showConfirmPassword ? 'text' : 'password'}
                      id="auth-confirm-password"
                      name="confirmPassword"
                      autoComplete="new-password"
                      value={confirmPassword}
                      onChange={(e) => setConfirmPassword(e.target.value)}
                      className={`${inputBaseClasses} pr-12`}
                      placeholder="Confirm your password"
                      required
                      disabled={loading}
                      minLength={8}
                      aria-invalid={Boolean(error && error.includes('match'))}
                    />
                    <button
                      type="button"
                      onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                      className="
                        absolute right-1 top-1/2 -translate-y-1/2
                        flex items-center justify-center
                        w-10 h-10 min-w-[40px] min-h-[40px]
                        rounded-lg
                        text-muted hover:text-accent
                        active:bg-accent/10
                        transition touch-manipulation
                        focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60
                      "
                      aria-label={showConfirmPassword ? 'Hide password' : 'Show password'}
                      aria-pressed={showConfirmPassword}
                    >
                      {showConfirmPassword ? (
                        <EyeSlash className="w-5 h-5" aria-hidden="true" />
                      ) : (
                        <Eye className="w-5 h-5" aria-hidden="true" />
                      )}
                    </button>
                  </div>
                </div>
              )}
            </div>

            {/* Error message */}
            {(error || authError) && (
              <div
                id="auth-error"
                role="alert"
                className="mt-4 p-3 bg-error/10 border border-error/40 rounded-lg"
              >
                <p className="text-sm text-error">{error || authError}</p>
              </div>
            )}

            {/* Success message */}
            {success && (
              <div role="status" className="mt-4 p-3 bg-secondary/10 border border-secondary/40 rounded-lg">
                <p className="text-sm text-secondary">{success}</p>
              </div>
            )}

            {/* Submit button */}
            <button
              type="submit"
              disabled={loading}
              className="
                mt-6 w-full px-6 py-3 min-h-[48px]
                bg-primary hover:bg-primary/90 active:bg-primary/80
                text-white font-medium rounded-lg
                transition touch-manipulation
                disabled:opacity-50 disabled:cursor-not-allowed
                focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/60
                focus-visible:ring-offset-2 focus-visible:ring-offset-surface
              "
            >
              {loading ? (
                <span className="flex items-center justify-center">
                  <svg
                    className="animate-spin -ml-1 mr-3 h-5 w-5 text-white"
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    aria-hidden="true"
                  >
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" />
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                  </svg>
                  {mode === 'login' ? 'Signing in...' : 'Creating account...'}
                </span>
              ) : (
                mode === 'login' ? 'Sign In' : 'Create Account'
              )}
            </button>

            {/* Switch mode */}
            <div className="mt-6 text-center">
              <button
                type="button"
                onClick={switchMode}
                className="
                  text-sm text-accent hover:text-accent/80
                  underline underline-offset-2
                  disabled:opacity-50 disabled:cursor-not-allowed
                  touch-manipulation
                  focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60
                  rounded px-2 py-1
                "
                disabled={loading}
              >
                {mode === 'login'
                  ? "Don't have an account? Register"
                  : 'Already have an account? Sign in'}
              </button>
            </div>
          </form>

          {/* Footer */}
          <div className="px-6 sm:px-8 pb-6 pt-4 border-t border-primary/20">
            <p className="text-xs text-muted/60 text-center">
              Your readings are private. We never share your data.
            </p>
          </div>
        </div>
      </FocusTrap>
    </div>
  );
}
</file>

<file path="src/components/CameraCapture.jsx">
import { useRef, useEffect, useState } from 'react';
import { ImagePreview } from './ImagePreview';
import { useLandscape } from '../hooks/useLandscape';

const hasUuidSupport = typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function';

const createCaptureId = () => {
  if (hasUuidSupport) {
    return crypto.randomUUID();
  }
  const random = Math.random().toString(36).slice(2, 8);
  return `capture-${Date.now()}-${random}`;
};

export function CameraCapture({ onCapture, onCancel }) {
  const videoRef = useRef(null);
  const [stream, setStream] = useState(null);
  const [capturedImage, setCapturedImage] = useState(null);
  const [error, setError] = useState(null);
  const isLandscape = useLandscape();

  useEffect(() => {
    async function getCameraStream() {
      try {
        const mediaStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment' },
        });
        if (videoRef.current) {
          videoRef.current.srcObject = mediaStream;
        }
        setStream(mediaStream);
      } catch (err) {
        console.error('Error accessing camera:', err);
        setError('Could not access the camera. Please ensure permissions are granted and try again.');
      }
    }

    if (!stream) {
      getCameraStream();
    }

    return () => {
      if (stream) {
        stream.getTracks().forEach(track => track.stop());
      }
    };
  }, [stream]);

  const handleCapture = () => {
    if (!videoRef.current) return;

    const canvas = document.createElement('canvas');
    canvas.width = videoRef.current.videoWidth;
    canvas.height = videoRef.current.videoHeight;
    const context = canvas.getContext('2d');
    context.drawImage(videoRef.current, 0, 0, canvas.width, canvas.height);

    canvas.toBlob(blob => {
      const file = new File([blob], 'capture.jpg', { type: 'image/jpeg' });
      const captureId = createCaptureId();
      file.__visionUploadId = captureId;
      file.__visionLabel = `Camera capture ${new Date().toISOString()}`;
      setCapturedImage(file);
    }, 'image/jpeg');
  };

  const handleConfirm = () => {
    if (capturedImage) {
      onCapture([capturedImage]);
    }
  };

  const handleRetake = () => {
    setCapturedImage(null);
  };

  if (capturedImage) {
    return <ImagePreview image={capturedImage} onConfirm={handleConfirm} onRetake={handleRetake} />;
  }

  // In landscape: controls on right side; in portrait: controls at bottom
  // Using safe-area-inset for notch/Dynamic Island support
  const containerClass = isLandscape
    ? 'fixed inset-0 z-50 flex flex-row items-center justify-center bg-black animate-fade-in'
    : 'fixed inset-0 z-50 flex flex-col items-center justify-center bg-black animate-fade-in';

  return (
    <div className={containerClass}>
      {error ? (
        <div 
          className="text-white text-center p-4"
          style={{
            paddingTop: 'max(1rem, env(safe-area-inset-top))',
            paddingBottom: 'max(1rem, env(safe-area-inset-bottom))',
            paddingLeft: 'max(1rem, env(safe-area-inset-left))',
            paddingRight: 'max(1rem, env(safe-area-inset-right))'
          }}
        >
          <p className="text-sm xs:text-base">{error}</p>
          <button 
            onClick={onCancel} 
            className="mt-4 px-6 py-3 min-h-[44px] bg-red-600 hover:bg-red-700 rounded-lg text-sm font-medium transition touch-manipulation"
          >
            Close
          </button>
        </div>
      ) : (
        <video ref={videoRef} autoPlay playsInline className="w-full h-full object-cover" />
      )}
      
      {/* Controls - positioned with safe area insets */}
      <div 
        className={`
          absolute bg-black/60 backdrop-blur-sm
          flex items-center justify-center
          ${isLandscape 
            ? 'right-0 top-0 bottom-0 flex-col gap-4 xs:gap-6 w-20 xs:w-24' 
            : 'bottom-0 left-0 right-0 flex-row gap-6 xs:gap-8 py-4 xs:py-6'
          }
        `}
        style={isLandscape ? {
          paddingTop: 'max(0.75rem, env(safe-area-inset-top))',
          paddingBottom: 'max(0.75rem, env(safe-area-inset-bottom))',
          paddingRight: 'max(0.75rem, env(safe-area-inset-right))'
        } : {
          paddingBottom: 'max(1rem, env(safe-area-inset-bottom))',
          paddingLeft: 'max(1rem, env(safe-area-inset-left))',
          paddingRight: 'max(1rem, env(safe-area-inset-right))'
        }}
      >
        {/* Cancel button - 44px minimum touch target */}
        <button 
          onClick={onCancel} 
          className="min-w-[44px] min-h-[44px] px-4 py-2 text-white text-sm font-medium hover:text-white/80 transition touch-manipulation rounded-lg active:bg-white/10"
        >
          Cancel
        </button>
        
        {/* Capture button - large touch target */}
        <button
          onClick={handleCapture}
          disabled={!stream}
          className={`
            ${isLandscape ? 'w-14 h-14 xs:w-16 xs:h-16' : 'w-16 h-16 xs:w-20 xs:h-20'}
            rounded-full bg-white border-4 border-gray-300 
            disabled:opacity-50 disabled:cursor-not-allowed
            transition touch-manipulation
            active:scale-95 active:border-gray-400
            focus-visible:outline-none focus-visible:ring-4 focus-visible:ring-white/50
          `}
          aria-label="Capture photo"
        />
        
        {/* Spacer for centering in portrait mode */}
        {!isLandscape && <div className="w-14 xs:w-16" aria-hidden />}
      </div>
    </div>
  );
}
</file>

<file path="src/components/Card.jsx">
import { useEffect, useMemo, useRef, useState, useCallback } from 'react';
import { motion, useAnimation } from 'framer-motion';
import { ArrowsOut, HandPointing, ArrowLeft, ArrowRight, NotePencil, CaretUp } from '@phosphor-icons/react';
import { CARD_LOOKUP, FALLBACK_IMAGE, getCardImage } from '../lib/cardLookup';
import { CardSymbolInsights } from './CardSymbolInsights';
import { InteractiveCardOverlay } from './InteractiveCardOverlay';
import { useReducedMotion } from '../hooks/useReducedMotion';
import { useSmallScreen } from '../hooks/useSmallScreen';
import { useLandscape } from '../hooks/useLandscape';

// Haptic feedback helper
const vibrate = (pattern) => {
  if (typeof navigator !== 'undefined' && navigator.vibrate) {
    navigator.vibrate(pattern);
  }
};

export function Card({
  card,
  index,
  isRevealed,
  onReveal,
  position,
  reflections,
  setReflections,
  onCardClick,
  staggerDelay = 0
}) {
  const reflectionValue = reflections?.[index] ?? '';
  const textareaRef = useRef(null);
  const userInitiatedRevealRef = useRef(false);
  const animationStartedRef = useRef(false);
  const prefersReducedMotion = useReducedMotion();
  const isSmallScreen = useSmallScreen(640); // < sm breakpoint
  const isLandscape = useLandscape();

  // Mobile: collapsible reflection section (starts collapsed unless has content)
  const [showReflection, setShowReflection] = useState(() => Boolean(reflectionValue));

  // Local state to manage the visual reveal sequence
  const [isVisuallyRevealed, setIsVisuallyRevealed] = useState(isRevealed);
  const controls = useAnimation();
  const hasMounted = useRef(false);

  const cardImage = useMemo(() => getCardImage(card), [card]);

  useEffect(() => {
    // Entry animation
    if (!hasMounted.current) {
      controls.start({
        opacity: 1,
        y: 0,
        scale: 1,
        rotateY: 0,
        transition: prefersReducedMotion ? { duration: 0 } : { type: "spring", stiffness: 260, damping: 20 }
      });
      hasMounted.current = true;
    }
  }, [controls, prefersReducedMotion]);

  useEffect(() => {
    if (isRevealed && userInitiatedRevealRef.current) {
      // Focus textarea after animation completes (animation is ~300ms)
      const delay = prefersReducedMotion ? 50 : 350;

      const focusTimer = setTimeout(() => {
        if (textareaRef.current) {
          textareaRef.current.focus();
        }
      }, delay);

      userInitiatedRevealRef.current = false;
      return () => clearTimeout(focusTimer);
    } else {
      userInitiatedRevealRef.current = false;
    }
  }, [isRevealed, prefersReducedMotion]);

  const handleReveal = useCallback(() => {
    userInitiatedRevealRef.current = true;
    onReveal(index);
  }, [onReveal, index]);

  // Swipe gesture state
  const touchStartRef = useRef({ x: 0, y: 0, time: 0 });
  const [swipeOffset, setSwipeOffset] = useState(0);
  const [showSwipeHint, setShowSwipeHint] = useState(true);

  // Swipe-to-reveal gesture handler
  const handleSwipeReveal = useCallback((direction) => {
    if (isRevealed || isVisuallyRevealed) return;

    vibrate(10);

    // Visual swipe animation before reveal
    if (!prefersReducedMotion) {
      controls.start({
        x: direction === 'right' ? 50 : -50,
        opacity: 0.7,
        transition: { duration: 0.15 }
      }).then(() => {
        handleReveal();
        controls.start({ x: 0, opacity: 1 });
      });
    } else {
      handleReveal();
    }
  }, [isRevealed, isVisuallyRevealed, handleReveal, controls, prefersReducedMotion]);

  // Touch gesture tracking for swipe
  const handleTouchStart = useCallback((e) => {
    if (isRevealed) return;
    touchStartRef.current = {
      x: e.touches[0].clientX,
      y: e.touches[0].clientY,
      time: Date.now()
    };
    setShowSwipeHint(false);
  }, [isRevealed]);

  const handleTouchMove = useCallback((e) => {
    if (isRevealed) return;
    const dx = e.touches[0].clientX - touchStartRef.current.x;
    // Only track horizontal movement, cap at 100px
    setSwipeOffset(Math.max(-100, Math.min(100, dx)));
  }, [isRevealed]);

  const handleTouchEnd = useCallback((e) => {
    if (isRevealed) return;

    const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
    const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
    const dt = Date.now() - touchStartRef.current.time;

    // Reset offset
    setSwipeOffset(0);

    // Responsive swipe thresholds (more forgiving on small screens)
    const vw = typeof window !== 'undefined' ? window.innerWidth : 1024;
    const isVerySmall = vw < 375;
    const isSmall = vw < 440;
    const distanceThreshold = isVerySmall ? 35 : isSmall ? 42 : 50;
    const timeThreshold = isVerySmall ? 350 : isSmall ? 320 : 300;
    const horizontalAdvantage = isSmallScreen ? 1.2 : 1.5;

    const horizontalDominant = Math.abs(dx) > Math.abs(dy) * horizontalAdvantage;

    if (Math.abs(dx) > distanceThreshold && horizontalDominant && dt < timeThreshold) {
      handleSwipeReveal(dx > 0 ? 'right' : 'left');
    }
  }, [isRevealed, handleSwipeReveal, isSmallScreen]);

  // Reset visual state when a revealed card is returned to an unrevealed state
  useEffect(() => {
    // When card becomes unrevealed, reset animation tracking
    if (!isRevealed) {
      animationStartedRef.current = false;
    }

    if (isRevealed || !isVisuallyRevealed) {
      return undefined;
    }

    const resetVisualState = () => {
      setIsVisuallyRevealed(false);
      controls.set({ rotateY: 0, opacity: 1 });
    };

    const canUseRaf = typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function';
    const handleId = canUseRaf
      ? window.requestAnimationFrame(resetVisualState)
      : setTimeout(resetVisualState, 0);

    return () => {
      if (canUseRaf) {
        window.cancelAnimationFrame(handleId);
      } else {
        clearTimeout(handleId);
      }
    };
  }, [isRevealed, isVisuallyRevealed, controls]);

  // Handle the flip animation sequence
  useEffect(() => {
    // Only start animation when isRevealed becomes true and we haven't animated yet
    if (!isRevealed || animationStartedRef.current) {
      return;
    }

    // Mark animation as started immediately to prevent re-triggers
    animationStartedRef.current = true;

    let isActive = true;
    let staggerTimeoutId = null;

    const clearStaggerTimeout = () => {
      if (staggerTimeoutId) {
        clearTimeout(staggerTimeoutId);
        staggerTimeoutId = null;
      }
    };

    const sequence = async () => {
      if (import.meta.env.DEV) {
        console.log(`Card ${index} starting reveal sequence. Stagger: ${staggerDelay}`);
      }

      const duration = prefersReducedMotion ? 0 : 0.25;
      const springTransition = prefersReducedMotion ? { duration: 0 } : { type: "spring", stiffness: 260, damping: 20 };

      if (staggerDelay > 0 && !prefersReducedMotion) {
        await new Promise(resolve => {
          staggerTimeoutId = setTimeout(() => {
            resolve();
            staggerTimeoutId = null;
          }, staggerDelay * 1000);
        });
        if (!isActive) return;
      }

      if (!isActive) return;
      if (import.meta.env.DEV) {
        console.log(`Card ${index} starting Phase 1 (rotate 90)`);
      }
      await controls.start({
        rotateY: 90,
        opacity: 0.8,
        transition: { duration: duration, ease: "easeIn" }
      });
      if (!isActive) return;

      if (import.meta.env.DEV) {
        console.log(`Card ${index} Phase 2 (swap content)`);
      }
      setIsVisuallyRevealed(true);
      if (!isActive) return;

      if (import.meta.env.DEV) {
        console.log(`Card ${index} starting Phase 3 (rotate 0)`);
      }
      await controls.start({
        rotateY: 0,
        opacity: 1,
        transition: springTransition
      });

      if (import.meta.env.DEV) {
        console.log(`Card ${index} reveal complete`);
      }
    };

    sequence();

    return () => {
      isActive = false;
      clearStaggerTimeout();
      // Don't call controls.stop() here - let the animation complete naturally
    };
    // Intentionally only depend on isRevealed to start animation once
    // Other values are read from refs or are stable
  }, [isRevealed, staggerDelay, controls, index, prefersReducedMotion]);

  // Get card meaning
  const originalCard = CARD_LOOKUP[card.name] || card;
  const meaning = card.isReversed ? originalCard.reversed : originalCard.upright;

  // Character count warning thresholds
  const charCount = reflectionValue.length;
  const charCountClass = charCount > 480 ? 'text-error' : charCount > 450 ? 'text-warning' : 'text-accent/70';

  return (
    <div
      key={`${card.name}-${index}`}
      className={`modern-surface border border-secondary/40 overflow-hidden ${isVisuallyRevealed ? 'z-10' : 'z-0'}`}
      style={{ position: 'relative' }}
    >
      {/* Position Label */}
      <div className="bg-surface/80 p-2 sm:p-3 border-b border-secondary/40">
        <h3 className="text-accent font-serif text-center font-semibold text-sm sm:text-base">{position}</h3>
      </div>

      {/* Card */}
      <div className="p-3 sm:p-4 md:p-6" style={{ perspective: '1000px' }}>
        <motion.div
          initial={{ opacity: 0, y: 50, scale: 0.9, rotateY: 0 }}
          animate={controls}
          transition={{ type: "spring", stiffness: 260, damping: 20 }}
          className={`transition-all duration-500 transform rounded-lg ${!isVisuallyRevealed ? '' : 'group'}`}
          style={{
            transformStyle: 'preserve-3d',
            position: 'relative',
            zIndex: isVisuallyRevealed ? 1 : 'auto',
            backfaceVisibility: 'visible',
            WebkitBackfaceVisibility: 'visible'
          }}
        >
          {!isVisuallyRevealed ? (
            <button
              onClick={handleReveal}
              onKeyDown={event => {
                if (event.key === 'Enter' || event.key === ' ') {
                  event.preventDefault();
                  handleReveal();
                }
              }}
              onTouchStart={handleTouchStart}
              onTouchMove={handleTouchMove}
              onTouchEnd={handleTouchEnd}
              aria-label={`${position}. Tap to reveal.`}
              className={`card-swipe-container relative h-full ${isLandscape ? 'min-h-[200px] max-h-[280px]' : 'min-h-[45vh] min-h-[45svh] max-h-[65vh] max-h-[65svh]'} sm:min-h-[24rem] sm:max-h-none flex flex-col items-center justify-center gap-4 p-4 sm:p-6 w-full cursor-pointer hover:bg-surface-muted/70 hover:scale-105 transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/70 focus-visible:ring-offset-2 focus-visible:ring-offset-main`}
            >
              {/* Card back with mystical design */}
              <div
                className="relative w-full max-w-[280px] aspect-[2/3] mx-auto rounded-xl border-2 border-primary/30 shadow-2xl overflow-hidden transition-transform"
                style={{ transform: `translateX(${swipeOffset * 0.5}px)` }}
              >
                <img
                  src="/cardback.png"
                  alt="Card back - tap or swipe to reveal"
                  className="w-full h-full object-cover"
                  loading="eager"
                />

                {/* Swipe hint arrows */}
                {showSwipeHint && !prefersReducedMotion && (
                  <>
                    <div className="card-swipe-hint card-swipe-hint--left swipe-hint">
                      <ArrowLeft className="w-6 h-6 text-primary/60" aria-hidden="true" />
                    </div>
                    <div className="card-swipe-hint card-swipe-hint--right swipe-hint">
                      <ArrowRight className="w-6 h-6 text-primary/60" aria-hidden="true" />
                    </div>
                  </>
                )}
              </div>

              {/* Tap/swipe to reveal instruction */}
              <div className="flex flex-col items-center gap-2 mt-2">
                <span className="inline-flex items-center gap-2 rounded-full border border-primary/60 bg-surface/90 px-4 py-2 text-sm font-semibold text-main shadow-md shadow-primary/30">
                  <HandPointing className="w-4 h-4" aria-hidden="true" />
                  <span>Tap to reveal</span>
                </span>
              </div>
            </button>
          ) : (
            <div className={`transition-all relative h-full ${isLandscape ? 'min-h-[200px] max-h-[280px]' : 'min-h-[45vh] min-h-[45svh] max-h-[65vh] max-h-[65svh]'} sm:min-h-[24rem] sm:max-h-none flex flex-col items-center`}>
              {/* Card content area - restructured to avoid nested interactives */}
              <div className="relative w-full">
                {/* Zoom Icon - primary keyboard target for modal */}
                <button
                  type="button"
                  onClick={() => onCardClick?.(card, position, index)}
                  className="absolute top-2 right-2 z-20 min-h-[44px] min-w-[44px] flex items-center justify-center bg-surface-muted/80 rounded-full text-accent border border-primary/30 shadow-lg backdrop-blur-sm hover:bg-surface-muted transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary touch-manipulation"
                  aria-label={`View details for ${card.name}`}
                >
                  <ArrowsOut className="w-5 h-5" />
                </button>

                {/* Card image area - clickable for modal (keyboard users use the zoom button above) */}
                <div
                  onClick={() => onCardClick?.(card, position, index)}
                  className="cursor-pointer hover:bg-surface-muted/40 transition-colors rounded-lg"
                >
                  {/* Rider-Waite Card Image with Interactive Overlay */}
                  <motion.div
                    layoutId={`card-image-${index}`}
                    className={`mx-auto mb-3 max-w-[65%] sm:max-w-[280px] ${card.isReversed ? 'rotate-180' : ''}`}
                  >
                    <div className="relative aspect-[2/3]">
                      <img
                        src={cardImage}
                        alt={`${card.name}${card.isReversed ? ' (Reversed)' : ''}`}
                        className="w-full h-full object-cover rounded-lg shadow-lg border-2 border-primary/30"
                        loading="lazy"
                        decoding="async"
                        onError={event => {
                          const target = event.currentTarget;
                          if (!target) return;
                          console.error(`Failed to load image: ${cardImage}`);
                          target.onerror = null;
                          target.src = FALLBACK_IMAGE;
                        }}
                      />
                      {/* Interactive symbol overlay */}
                      <InteractiveCardOverlay card={card} />
                    </div>
                  </motion.div>

                  <div className="text-center mb-3">
                    <span
                      className={`inline-block px-3 py-1 rounded-full text-xs-plus font-semibold tracking-wide ${card.isReversed
                        ? 'bg-surface-muted/90 text-accent border border-accent/50'
                        : 'bg-secondary/10 text-secondary border border-secondary/60'
                        }`}
                    >
                      {card.isReversed ? 'Reversed' : 'Upright'}
                    </span>
                  </div>

                  <div className="mb-4 flex justify-center">
                    <CardSymbolInsights card={card} position={position} />
                  </div>

                  <div className="bg-surface/85 rounded p-4 border border-secondary/40 touch-pan-y">
                    <p className="text-main text-sm sm:text-base leading-relaxed">
                      {meaning}
                    </p>
                  </div>
                </div>
              </div>

              {/* Reflection textarea - collapsible on mobile to reduce density */}
              <div className="mt-3 w-full">
                {/* Mobile: toggle button when collapsed */}
                {isSmallScreen && !showReflection ? (
                  <button
                    type="button"
                    onClick={() => {
                      setShowReflection(true);
                      // Focus textarea after state update
                      setTimeout(() => textareaRef.current?.focus(), 50);
                    }}
                    className="w-full flex items-center justify-center gap-2 px-3 py-2.5 rounded-lg border border-secondary/30 bg-surface/60 text-muted hover:text-main hover:border-secondary/50 transition-colors touch-manipulation min-h-[44px]"
                    aria-expanded="false"
                    aria-controls={`reflection-${index}`}
                  >
                    <NotePencil className="w-4 h-4" aria-hidden="true" />
                    <span className="text-sm">
                      {reflectionValue ? 'Edit reflection' : 'Add reflection'}
                    </span>
                    {reflectionValue && (
                      <span className="text-xs text-secondary ml-1">({reflectionValue.length})</span>
                    )}
                  </button>
                ) : (
                  <>
                    {/* Mobile: collapsible header with toggle */}
                    {isSmallScreen && (
                      <button
                        type="button"
                        onClick={() => setShowReflection(false)}
                        className="w-full flex items-center justify-between mb-1.5 text-muted hover:text-main transition-colors"
                        aria-expanded="true"
                        aria-controls={`reflection-${index}`}
                      >
                        <span className="text-xs-plus">What resonates for you?</span>
                        <CaretUp className="w-4 h-4" aria-hidden="true" />
                      </button>
                    )}
                    {/* Desktop: static label */}
                    {!isSmallScreen && (
                      <label htmlFor={`reflection-${index}`} className="text-muted text-xs-plus sm:text-sm block mb-1">
                        What resonates for you?
                      </label>
                    )}
                    <textarea
                      ref={textareaRef}
                      id={`reflection-${index}`}
                      value={reflectionValue}
                      onChange={event =>
                        setReflections(prev => ({ ...prev, [index]: event.target.value }))
                      }
                      rows={isSmallScreen ? 3 : 4}
                      maxLength={500}
                      className="w-full bg-surface/85 border border-secondary/40 rounded p-2 min-h-[3.5rem] sm:min-h-[4.5rem] resize-y text-main text-base leading-relaxed focus:outline-none focus:ring-1 focus:ring-secondary/55 touch-pan-y"
                      placeholder="What resonates? (optional)"
                      aria-describedby={`char-count-${index}`}
                    />
                    <div
                      id={`char-count-${index}`}
                      className={`mt-1 text-xs text-right ${charCountClass}`}
                      aria-live="polite"
                    >
                      {charCount} / 500
                    </div>
                  </>
                )}
              </div>
            </div>
          )}
        </motion.div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/CardModal.jsx">
import { useRef } from 'react';
import { motion } from 'framer-motion';
import { X } from '@phosphor-icons/react';
import { FALLBACK_IMAGE, getCardImage, getCanonicalCard } from '../lib/cardLookup';
import { CardSymbolInsights } from './CardSymbolInsights';
import { useModalA11y } from '../hooks/useModalA11y';

export function CardModal({ card, isOpen, onClose, position, layoutId }) {
    const modalRef = useRef(null);
    const titleId = `card-modal-title-${layoutId || 'default'}`;
    const descId = `card-modal-desc-${layoutId || 'default'}`;

    // Shared modal accessibility: scroll lock, escape key, focus trap, focus restoration
    useModalA11y(isOpen, {
        onClose,
        containerRef: modalRef,
        scrollLockStrategy: 'fixed', // Prevents iOS bounce
    });

    if (!isOpen || !card) return null;

    const originalCard = getCanonicalCard(card);
    const meaning = card.isReversed ? originalCard.reversed : originalCard.upright;
    const cardImage = getCardImage(card);

    return (
        <div
            className="fixed inset-0 z-[100] flex items-center justify-center p-4 sm:p-6"
            role="dialog"
            aria-modal="true"
            aria-labelledby={titleId}
            aria-describedby={descId}
        >
            <motion.div
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                className="absolute inset-0 bg-main/90 backdrop-blur-sm"
                onClick={onClose}
                aria-hidden="true"
            />

            <motion.div
                layoutId={layoutId}
                ref={modalRef}
                className="relative w-full max-w-lg max-h-[85dvh] overflow-y-auto bg-surface border border-primary/30 rounded-2xl shadow-2xl shadow-black/50 flex flex-col"
                tabIndex={-1}
                role="document"
                style={{
                    // Safe area padding for notch/Dynamic Island
                    paddingTop: 'max(1.5rem, env(safe-area-inset-top))',
                    paddingRight: 'max(1rem, env(safe-area-inset-right))',
                    paddingBottom: 'max(1.5rem, env(safe-area-inset-bottom))',
                    paddingLeft: 'max(1rem, env(safe-area-inset-left))'
                }}
            >
                <button
                    onClick={onClose}
                    className="absolute top-3 right-3 p-3 text-accent/70 hover:text-main hover:bg-white/10 rounded-full transition-colors z-10 touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary"
                    style={{
                        // Ensure close button respects safe area
                        top: 'max(0.75rem, env(safe-area-inset-top))',
                        right: 'max(0.75rem, env(safe-area-inset-right))'
                    }}
                    aria-label="Close modal"
                >
                    <X className="w-6 h-6" />
                </button>

                <div className="p-6 sm:p-8 flex flex-col items-center text-center">
                    <h3 className="text-accent font-serif text-lg sm:text-xl mb-2">{position}</h3>
                    <h2 id={titleId} className="text-2xl sm:text-3xl font-serif text-main mb-6">
                        {card.name} {card.isReversed && <span className="text-primary/60 text-lg align-middle">(Reversed)</span>}
                    </h2>

                    <motion.div
                        layoutId={layoutId ? `card-image-${layoutId.split('-')[1]}` : undefined}
                        className={`relative w-full max-w-[300px] aspect-[2/3] mb-8 ${card.isReversed ? 'rotate-180' : ''}`}
                    >
                        <img
                            src={cardImage}
                            alt={card.name}
                            className="w-full h-auto rounded-xl shadow-2xl border-2 border-primary/20"
                            loading="lazy"
                            onError={(event) => {
                                event.currentTarget.src = FALLBACK_IMAGE;
                            }}
                        />
                    </motion.div>

                    <div className="w-full space-y-6 text-left">
                        <div className="bg-surface-muted/50 rounded-xl p-5 border border-primary/10">
                            <h4 className="text-accent font-semibold mb-2 text-sm uppercase tracking-wider">Meaning</h4>
                            <p id={descId} className="text-main/90 leading-relaxed text-lg">
                                {meaning}
                            </p>
                        </div>

                        <div className="flex justify-center">
                            <CardSymbolInsights card={card} position={position} />
                        </div>
                    </div>
                </div>
            </motion.div>
        </div>
    );
}
</file>

<file path="src/components/CardSymbolInsights.jsx">
import { useMemo, useState, useRef, useEffect, useCallback } from 'react';
import { Info, X } from '@phosphor-icons/react';
import { buildCardInsights } from '../lib/cardInsights';
import { titleCase } from '../lib/textUtils';

// Focusable element selectors for focus trap
const FOCUSABLE_SELECTORS = [
  'a[href]',
  'button:not([disabled])',
  'textarea:not([disabled])',
  'input:not([disabled])',
  'select:not([disabled])',
  '[tabindex]:not([tabindex="-1"])',
  '[contenteditable]'
].join(', ');

/**
 * Hook to detect if viewport is mobile-sized with debounced resize handling
 */
function useIsMobile(breakpoint = 640, debounceMs = 100) {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    let timeoutId = null;

    function checkMobile() {
      setIsMobile(window.innerWidth < breakpoint);
    }

    function handleResize() {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      timeoutId = setTimeout(checkMobile, debounceMs);
    }

    // Initial check
    checkMobile();

    window.addEventListener('resize', handleResize, { passive: true });
    return () => {
      window.removeEventListener('resize', handleResize);
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [breakpoint, debounceMs]);

  return isMobile;
}

/**
 * Symbol content display - shared between tooltip and bottom sheet
 */
function SymbolContent({ insights, onClose, showCloseButton = false }) {
  const orientationLabel = insights.isReversed ? 'Reversed' : 'Upright';
  const keywordsPreview = insights.keywords.slice(0, 3).join(', ');

  return (
    <div className="text-left">
      {showCloseButton && (
        <div className="flex items-center justify-between mb-3">
          <p className="text-sm font-semibold text-main">
            {insights.name}
            <span className="ml-2 text-xs uppercase tracking-widest text-secondary/80">
              {orientationLabel}
            </span>
          </p>
          <button
            type="button"
            onClick={onClose}
            className="min-h-[44px] min-w-[44px] -mr-2 flex items-center justify-center rounded-full text-secondary hover:bg-secondary/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/70"
            aria-label="Close symbol insights"
          >
            <X className="h-5 w-5" />
          </button>
        </div>
      )}
      {!showCloseButton && (
        <p className="text-sm font-semibold text-main">
          {insights.name}
          <span className="ml-2 text-xs uppercase tracking-widest text-secondary/80">
            {orientationLabel}
          </span>
        </p>
      )}
      {keywordsPreview && (
        <p className="mt-1 text-xs text-accent/80">
          <span className="font-medium">Keywords:</span> {keywordsPreview}
        </p>
      )}
      {insights.archetype && (
        <p className="mt-2 text-xs text-secondary/80">
          <span className="font-medium">Archetype:</span> {insights.archetype}
        </p>
      )}
      {insights.symbols.length > 0 && (
        <div className="mt-3">
          <h4 className="text-xs font-semibold uppercase tracking-[0.2em] text-accent/80">Symbols</h4>
          <ul className="mt-2 space-y-2 text-xs text-main/90" role="list">
            {insights.symbols.map((symbol, index) => (
              <li key={`${symbol.object}-${index}`} className="flex flex-col">
                <span>
                  <span className="font-semibold text-accent">{titleCase(symbol.object)}</span>
                  {symbol.position && (
                    <span className="ml-1 text-accent/60">({symbol.position})</span>
                  )}
                </span>
                <span className="text-muted mt-0.5">{symbol.meaning}</span>
              </li>
            ))}
          </ul>
        </div>
      )}
      {insights.colors.length > 0 && (
        <div className="mt-3">
          <h4 className="text-xs font-semibold uppercase tracking-[0.2em] text-accent/80">Palette</h4>
          <ul className="mt-2 space-y-1 text-xs text-muted" role="list">
            {insights.colors.map((color, index) => (
              <li key={`${color.color}-${index}`}>
                <span className="font-semibold text-secondary">{color.color}</span>
                <span className="ml-1 text-accent/70">— {color.meaning}</span>
              </li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

/**
 * Mobile bottom sheet for symbol insights
 */
function BottomSheet({ isOpen, onClose, children }) {
  const sheetRef = useRef(null);
  const previousFocusRef = useRef(null);

  // Focus management
  useEffect(() => {
    if (isOpen) {
      previousFocusRef.current = document.activeElement;
      document.body.style.overflow = 'hidden';
      requestAnimationFrame(() => {
        sheetRef.current?.focus();
      });
    } else {
      document.body.style.overflow = '';
      if (previousFocusRef.current?.focus) {
        previousFocusRef.current.focus();
      }
    }
    return () => {
      document.body.style.overflow = '';
    };
  }, [isOpen]);

  // Keyboard handling with focus trap
  const handleKeyDown = useCallback((event) => {
    if (event.key === 'Escape') {
      event.preventDefault();
      onClose();
      return;
    }

    // Focus trap on Tab key
    if (event.key === 'Tab' && sheetRef.current) {
      const focusable = sheetRef.current.querySelectorAll(FOCUSABLE_SELECTORS);
      if (!focusable.length) {
        event.preventDefault();
        sheetRef.current.focus();
        return;
      }

      const first = focusable[0];
      const last = focusable[focusable.length - 1];

      if (!event.shiftKey && document.activeElement === last) {
        event.preventDefault();
        first.focus();
      } else if (event.shiftKey && document.activeElement === first) {
        event.preventDefault();
        last.focus();
      }
    }
  }, [onClose]);

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-50 flex items-end justify-center"
      onKeyDown={handleKeyDown}
    >
      {/* Backdrop */}
      <div
        className="absolute inset-0 bg-black/50 backdrop-blur-sm animate-fade-in"
        onClick={onClose}
        aria-hidden="true"
      />
      {/* Sheet */}
      <div
        ref={sheetRef}
        role="dialog"
        aria-modal="true"
        aria-label="Card symbol insights"
        tabIndex={-1}
        className="relative z-10 w-full max-w-lg max-h-[80vh] overflow-y-auto rounded-t-3xl border-t border-x border-secondary/30 bg-surface/98 p-5 pb-[max(1.25rem,env(safe-area-inset-bottom))] shadow-2xl animate-slide-up focus:outline-none"
        onClick={(e) => e.stopPropagation()}
      >
        {/* Drag handle indicator */}
        <div className="absolute top-2 left-1/2 -translate-x-1/2 w-10 h-1 rounded-full bg-secondary/30" aria-hidden="true" />
        <div className="mt-2">
          {children}
        </div>
      </div>
    </div>
  );
}

export function CardSymbolInsights({ card, position }) {
  const insights = useMemo(() => buildCardInsights(card), [card]);
  const [isOpen, setIsOpen] = useState(false);
  const isMobile = useIsMobile();
  const containerRef = useRef(null);
  const tooltipRef = useRef(null);
  const closeTimeoutRef = useRef(null);

  // Generate unique IDs for accessibility
  const safePosition = typeof position === 'string'
    ? position.replace(/\s+/g, '-').toLowerCase()
    : 'slot';
  const safeName = card?.name ? card.name.replace(/\s+/g, '-').toLowerCase() : 'card';
  const tooltipId = `card-symbol-tooltip-${safeName}-${safePosition}`;

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (closeTimeoutRef.current) {
        clearTimeout(closeTimeoutRef.current);
      }
    };
  }, []);

  const cancelCloseTimeout = useCallback(() => {
    if (closeTimeoutRef.current) {
      clearTimeout(closeTimeoutRef.current);
      closeTimeoutRef.current = null;
    }
  }, []);

  // Delayed close to allow moving between trigger and tooltip
  const handleOpen = useCallback(() => {
    cancelCloseTimeout();
    setIsOpen(true);
  }, [cancelCloseTimeout]);

  const handleClose = useCallback(() => {
    cancelCloseTimeout();
    closeTimeoutRef.current = setTimeout(() => {
      setIsOpen(false);
      closeTimeoutRef.current = null;
    }, 150);
  }, [cancelCloseTimeout]);

  const handleToggle = useCallback((event) => {
    event.stopPropagation();
    setIsOpen(prev => !prev);
  }, []);

  const handleCloseImmediate = useCallback(() => {
    cancelCloseTimeout();
    setIsOpen(false);
  }, [cancelCloseTimeout]);

  const handleBlur = useCallback((event) => {
    const nextFocus = event.relatedTarget;
    if (nextFocus && containerRef.current?.contains(nextFocus)) {
      cancelCloseTimeout();
      return;
    }
    handleClose();
  }, [cancelCloseTimeout, handleClose]);

  if (!insights) {
    return null;
  }

  // Mobile: use bottom sheet
  if (isMobile) {
    return (
      <>
        <button
          type="button"
          onClick={handleToggle}
          aria-expanded={isOpen}
          aria-haspopup="dialog"
          className="inline-flex items-center justify-center gap-2 min-h-[44px] min-w-[44px] rounded-full border border-secondary/60 bg-surface/80 px-4 py-2 text-sm text-secondary hover:border-secondary active:bg-secondary/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/70 focus-visible:ring-offset-2 touch-manipulation transition-colors"
        >
          <Info className="h-4 w-4" aria-hidden="true" />
          <span>Card symbols</span>
        </button>
        <BottomSheet isOpen={isOpen} onClose={handleCloseImmediate}>
          <SymbolContent
            insights={insights}
            onClose={handleCloseImmediate}
            showCloseButton
          />
        </BottomSheet>
      </>
    );
  }

  // Desktop: use tooltip with proper positioning
  return (
    <div
      ref={containerRef}
      className="relative inline-block text-left"
      onMouseEnter={handleOpen}
      onMouseLeave={handleClose}
    >
      <button
        type="button"
        aria-expanded={isOpen}
        aria-haspopup="dialog"
        aria-controls={tooltipId}
        onClick={handleToggle}
        onFocus={handleOpen}
        onBlur={handleBlur}
        className="inline-flex items-center justify-center gap-2 min-h-[44px] min-w-[44px] rounded-full border border-secondary/60 bg-surface/80 px-4 py-2 text-sm text-secondary hover:border-secondary active:bg-secondary/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/70 focus-visible:ring-offset-2 transition-colors"
      >
        <Info className="h-4 w-4" aria-hidden="true" />
        <span>Card symbols</span>
      </button>

      {/* Desktop popover - positioned to avoid overflow */}
      <div
        ref={tooltipRef}
        id={tooltipId}
        role="dialog"
        aria-label="Card symbol insights"
        onMouseEnter={handleOpen}
        onMouseLeave={handleClose}
        onBlur={handleBlur}
        className={`absolute z-30 mt-2 w-72 max-w-[calc(100vw-2rem)] rounded-2xl border border-secondary/40 bg-surface/98 p-4 shadow-2xl backdrop-blur-sm transition-all duration-200
          left-0 sm:left-auto sm:right-0
          ${isOpen
            ? 'opacity-100 translate-y-0 visible'
            : 'opacity-0 -translate-y-2 invisible pointer-events-none'
          }`}
      >
        <button
          type="button"
          onClick={handleCloseImmediate}
          className="absolute top-2 right-2 text-secondary hover:text-main focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/70 rounded-full"
          aria-label="Close symbol insights"
        >
          ×
        </button>
        <SymbolContent insights={insights} />
      </div>
    </div>
  );
}
</file>

<file path="src/components/CarouselDots.jsx">
import { useRef } from 'react';

/**
 * CarouselDots - Reusable pagination indicator for horizontal carousels
 *
 * Features:
 * - WCAG 2.5.8 compliant touch targets (44x44px minimum)
 * - Full keyboard navigation (arrows, Home, End, Enter, Space)
 * - Screen reader accessible with proper ARIA
 * - Customizable appearance via variant prop
 *
 * @param {number} activeIndex - Currently active/visible item index
 * @param {number} totalItems - Total number of items in carousel
 * @param {function} onSelectItem - Callback when user selects a position
 * @param {string} variant - Visual style: 'default' | 'compact' | 'labeled'
 * @param {string[]} labels - Optional labels for each position (for screen readers)
 * @param {string} ariaLabel - Label for the overall control group
 */
export function CarouselDots({
  activeIndex,
  totalItems,
  onSelectItem,
  variant = 'default',
  labels = [],
  ariaLabel = 'Carousel position'
}) {
  const dotRefs = useRef([]);

  const focusDot = (index) => {
    const el = dotRefs.current[index];
    if (el && typeof el.focus === 'function') {
      el.focus();
    }
  };

  const goToIndex = (index) => {
    if (totalItems <= 0) return;
    const clamped = Math.min(totalItems - 1, Math.max(0, index));
    onSelectItem?.(clamped);
    // Schedule focus after state update
    const focusNext = () => focusDot(clamped);
    if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
      window.requestAnimationFrame(focusNext);
    } else {
      focusNext();
    }
  };

  const handleKeyDown = (event, idx) => {
    if (totalItems <= 0) return;

    // Handle activation with Enter or Space
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      goToIndex(idx);
      return;
    }

    let nextIndex = null;
    if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
      event.preventDefault();
      nextIndex = (idx + 1) % totalItems;
    } else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
      event.preventDefault();
      nextIndex = (idx - 1 + totalItems) % totalItems;
    } else if (event.key === 'Home') {
      event.preventDefault();
      nextIndex = 0;
    } else if (event.key === 'End') {
      event.preventDefault();
      nextIndex = totalItems - 1;
    }

    if (nextIndex !== null) {
      goToIndex(nextIndex);
    }
  };

  if (totalItems <= 1) return null;

  // Variant-specific styles
  const variantStyles = {
    default: {
      container: 'flex items-center justify-center gap-1',
      // 44px touch target with smaller visual dot inside
      button: 'relative flex items-center justify-center w-11 h-11 touch-manipulation',
      dotBase: 'w-2 h-2 rounded-full transition-all duration-200',
      dotActive: 'bg-primary w-4 shadow-md shadow-primary/40',
      dotInactive: 'bg-secondary/50 hover:bg-secondary/70'
    },
    compact: {
      container: 'flex items-center justify-center gap-0',
      button: 'relative flex items-center justify-center min-w-[44px] min-h-[44px] w-11 h-11 touch-manipulation',
      dotBase: 'w-1.5 h-1.5 rounded-full transition-all duration-200',
      dotActive: 'bg-primary w-3 shadow-sm shadow-primary/30',
      dotInactive: 'bg-secondary/40 hover:bg-secondary/60'
    },
    labeled: {
      container: 'flex items-center justify-center gap-2',
      button: 'relative flex items-center justify-center min-w-[44px] h-11 px-2 touch-manipulation',
      dotBase: 'text-xs font-medium transition-all duration-200 rounded-full px-2 py-1',
      dotActive: 'bg-primary/20 text-primary border border-primary/50',
      dotInactive: 'bg-secondary/10 text-muted border border-secondary/30 hover:bg-secondary/20'
    }
  };

  const styles = variantStyles[variant] || variantStyles.default;

  return (
    <div
      className={styles.container}
      role="tablist"
      aria-label={ariaLabel}
    >
      {Array.from({ length: totalItems }).map((_, idx) => {
        const isActive = idx === activeIndex;
        const label = labels[idx] || `Item ${idx + 1}`;

        return (
          <button
            key={idx}
            ref={el => { dotRefs.current[idx] = el; }}
            type="button"
            role="tab"
            aria-selected={isActive}
            aria-label={`${label}${isActive ? ' (current)' : ''}`}
            className={`${styles.button} focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/70 focus-visible:ring-offset-2 focus-visible:ring-offset-main rounded-full`}
            tabIndex={isActive ? 0 : -1}
            onClick={() => goToIndex(idx)}
            onKeyDown={(event) => handleKeyDown(event, idx)}
          >
            {variant === 'labeled' ? (
              <span className={`${styles.dotBase} ${isActive ? styles.dotActive : styles.dotInactive}`}>
                {idx + 1}
              </span>
            ) : (
              <span
                className={`${styles.dotBase} ${isActive ? styles.dotActive : styles.dotInactive}`}
                aria-hidden="true"
              />
            )}
          </button>
        );
      })}
    </div>
  );
}

/**
 * CarouselNav - Navigation buttons + dots for mobile carousels
 * Combines prev/next buttons with position indicators
 */
export function CarouselNav({
  activeIndex,
  totalItems,
  onSelectItem,
  labels = [],
  showButtons = true,
  ariaLabel = 'Carousel navigation'
}) {
  const canGoPrev = activeIndex > 0;
  const canGoNext = activeIndex < totalItems - 1;
  const currentLabel = labels[activeIndex] || `${activeIndex + 1} of ${totalItems}`;

  return (
    <div className="space-y-3">
      <CarouselDots
        activeIndex={activeIndex}
        totalItems={totalItems}
        onSelectItem={onSelectItem}
        labels={labels}
        ariaLabel={ariaLabel}
      />

      {showButtons && (
        <div className="flex items-center justify-between gap-2">
          <button
            type="button"
            onClick={() => onSelectItem?.(activeIndex - 1)}
            disabled={!canGoPrev}
            className="inline-flex items-center justify-center rounded-full border border-secondary/50 bg-surface px-3 py-2 min-w-[48px] min-h-[44px] text-xs font-semibold text-muted disabled:opacity-40 touch-manipulation"
            aria-label="Previous item"
          >
            Prev
          </button>
          <p className="text-xs text-muted" aria-live="polite">
            {currentLabel}
          </p>
          <button
            type="button"
            onClick={() => onSelectItem?.(activeIndex + 1)}
            disabled={!canGoNext}
            className="inline-flex items-center justify-center rounded-full border border-secondary/50 bg-surface px-3 py-2 min-w-[48px] min-h-[44px] text-xs font-semibold text-muted disabled:opacity-40 touch-manipulation"
            aria-label="Next item"
          >
            Next
          </button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/CoachSuggestion.jsx">
import { Sparkle, ArrowRight } from '@phosphor-icons/react';

/**
 * Get headline text from recommendation with proper fallback chain
 */
function getHeadline(recommendation) {
    return recommendation?.question
        ?? recommendation?.customFocus
        ?? recommendation?.spreadName
        ?? 'Suggested focus';
}

/**
 * Get journal-specific content
 */
function getJournalContent(recommendation) {
    if (!recommendation) return { subtitle: null, helper: null };

    return {
        subtitle: recommendation.spreadName ?? 'Three-Card Story',
        helper: recommendation.customFocus
            ? `Explore the theme of ${recommendation.customFocus}`
            : recommendation.question
                ? null
                : 'Reflect on your journey'
    };
}

export function CoachSuggestion({
    recommendation,
    onApply,
    onDismiss,
    className = "",
    showTitle = true,
    variant = 'default' // 'default' | 'journal'
}) {
    if (!recommendation) return null;

    const isJournalVariant = variant === 'journal';
    const headlineText = getHeadline(recommendation);
    const { subtitle: journalSubtitle, helper: journalHelper } = isJournalVariant
        ? getJournalContent(recommendation)
        : { subtitle: null, helper: null };

    // Styles that match the Journal Insights Panel design
    const containerClasses = isJournalVariant
        ? `rounded-3xl border border-secondary/20 bg-surface/40 p-5 ${className}`
        : `mt-3 rounded-xl border border-primary/30 bg-primary/5 p-4 ${className}`;

    const titleClasses = isJournalVariant
        ? "mb-4 flex items-center gap-2 text-xs font-bold uppercase tracking-wider text-accent/80"
        : "flex items-center gap-2 text-xs uppercase tracking-[0.3em] text-primary";

    const questionClasses = isJournalVariant
        ? "font-serif text-lg text-main"
        : "mt-2 font-serif text-base text-accent";

    const spreadClasses = isJournalVariant
        ? "mt-2 text-sm text-muted"
        : "text-xs text-muted mt-1";

    return (
        <div
            className={containerClasses}
            role="region"
            aria-labelledby={showTitle ? "coach-suggestion-title" : undefined}
        >
            {showTitle && (
                <h3 id="coach-suggestion-title" className={titleClasses}>
                    <Sparkle className="h-3 w-3" aria-hidden="true" />
                    Suggested Focus
                </h3>
            )}

            {headlineText && (
                <p className={questionClasses}>
                    {headlineText}
                </p>
            )}

            {isJournalVariant ? (
                <>
                    {journalSubtitle && (
                        <p className={spreadClasses}>{journalSubtitle}</p>
                    )}
                    {journalHelper && (
                        <p className="text-xs text-muted mt-1">{journalHelper}</p>
                    )}
                </>
            ) : (
                recommendation.spreadName && (
                    <p className={spreadClasses}>Suggested spread: {recommendation.spreadName}</p>
                )
            )}

            <div className="mt-4 flex flex-wrap gap-3">
                {isJournalVariant ? (
                    <button
                        type="button"
                        onClick={onApply}
                        className="min-h-[44px] inline-flex items-center gap-2 px-4 py-2 text-sm font-medium text-accent hover:text-main underline decoration-accent/30 underline-offset-4 transition-colors
                            focus:outline-none focus-visible:ring-2 focus-visible:ring-accent/50 focus-visible:ring-offset-2 touch-manipulation"
                    >
                        <span>Start with Intention Coach</span>
                        <ArrowRight className="h-4 w-4" aria-hidden="true" />
                    </button>
                ) : (
                    <>
                        <button
                            type="button"
                            onClick={onApply}
                            className="min-h-[44px] rounded-full border border-primary/50 px-4 py-2 text-sm text-main transition-colors
                                hover:bg-primary/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-primary/50 focus-visible:ring-offset-2 touch-manipulation"
                        >
                            Use this focus
                        </button>
                        {onDismiss && (
                            <button
                                type="button"
                                onClick={onDismiss}
                                className="min-h-[44px] rounded-full border border-secondary/40 px-4 py-2 text-sm text-muted transition-colors
                                    hover:bg-secondary/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/50 focus-visible:ring-offset-2 touch-manipulation"
                            >
                                Dismiss
                            </button>
                        )}
                    </>
                )}
            </div>
        </div>
    );
}
</file>

<file path="src/components/ConfirmModal.jsx">
import { useRef } from 'react';
import FocusTrap from 'focus-trap-react';
import { Warning, X } from '@phosphor-icons/react';
import { useModalA11y, createBackdropHandler } from '../hooks/useModalA11y';

/**
 * Confirmation Modal
 *
 * Replaces native browser confirm() dialogs with a styled modal
 * that matches the application's design system.
 */
export function ConfirmModal({
  isOpen,
  onClose,
  onConfirm,
  title = 'Confirm Action',
  message,
  confirmText = 'Confirm',
  cancelText = 'Cancel',
  variant = 'warning' // 'warning' | 'danger'
}) {
  const cancelButtonRef = useRef(null);
  const modalRef = useRef(null);

  // Use modal accessibility hook for scroll lock, escape key, and focus restoration
  // trapFocus: false because FocusTrap library handles focus trapping
  useModalA11y(isOpen, {
    onClose,
    containerRef: modalRef,
    trapFocus: false,
    initialFocusRef: cancelButtonRef,
  });

  if (!isOpen) return null;

  const handleConfirm = () => {
    onConfirm();
    onClose();
  };

  const variantStyles = {
    warning: 'border-accent/40 bg-surface/95',
    danger: 'border-error/40 bg-surface/95'
  };

  const buttonStyles = {
    warning: 'bg-accent/15 border-accent/40 text-accent hover:bg-accent/25',
    danger: 'bg-error/15 border-error/40 text-error hover:bg-error/25'
  };

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm animate-fade-in p-3 xs:p-4"
      onClick={createBackdropHandler(onClose)}
      style={{
        paddingTop: 'max(0.75rem, env(safe-area-inset-top))',
        paddingBottom: 'max(0.75rem, env(safe-area-inset-bottom))',
        paddingLeft: 'max(0.75rem, env(safe-area-inset-left))',
        paddingRight: 'max(0.75rem, env(safe-area-inset-right))'
      }}
    >
      <FocusTrap
        active={isOpen}
        focusTrapOptions={{
          initialFocus: () => cancelButtonRef.current,
          escapeDeactivates: false,
          clickOutsideDeactivates: false,
          returnFocusOnDeactivate: false,
          allowOutsideClick: true,
        }}
      >
        <div
          ref={modalRef}
          role="dialog"
          aria-modal="true"
          aria-labelledby="confirm-modal-title"
          className={`relative w-full max-w-md rounded-2xl border ${variantStyles[variant]} shadow-2xl animate-slide-up`}
        >
        <button
          onClick={onClose}
          className="absolute top-3 right-3 xs:top-4 xs:right-4 p-2 min-w-[44px] min-h-[44px] flex items-center justify-center text-muted hover:text-main hover:bg-surface-muted/50 rounded-full transition touch-manipulation"
          aria-label="Close"
        >
          <X className="w-5 h-5" />
        </button>

        <div className="p-5 xs:p-6">
          <div className="flex items-start gap-3 xs:gap-4 mb-4 pr-8">
            <div className={`p-2 rounded-full shrink-0 ${variant === 'danger' ? 'bg-error/10' : 'bg-accent/10'}`}>
              <Warning className={`w-5 h-5 xs:w-6 xs:h-6 ${variant === 'danger' ? 'text-error' : 'text-accent'}`} />
            </div>
            <div className="flex-1 min-w-0">
              <h2 id="confirm-modal-title" className="text-lg xs:text-xl font-serif text-main mb-2">
                {title}
              </h2>
              <p className="text-muted text-sm leading-relaxed">
                {message}
              </p>
            </div>
          </div>

          <div className="flex flex-col-reverse xs:flex-row gap-2 xs:gap-3 xs:justify-end mt-6">
            <button
              ref={cancelButtonRef}
              onClick={onClose}
              className="w-full xs:w-auto px-4 py-2.5 min-h-[44px] rounded-lg border border-secondary/40 text-muted hover:text-main hover:border-secondary/60 transition text-sm font-medium touch-manipulation"
            >
              {cancelText}
            </button>
            <button
              onClick={handleConfirm}
              className={`w-full xs:w-auto px-4 py-2.5 min-h-[44px] rounded-lg border ${buttonStyles[variant]} transition text-sm font-medium touch-manipulation`}
            >
              {confirmText}
            </button>
          </div>
        </div>
      </div>
      </FocusTrap>
    </div>
  );
}
</file>

<file path="src/components/DeckPile.jsx">
import { useState, useEffect, useRef } from 'react';
import { motion } from 'framer-motion';
import { TableuLogo } from './TableuLogo';
import { useReducedMotion } from '../hooks/useReducedMotion';

/**
 * Hook to compute responsive logo size with SSR safety, debounced resize handling
 * @param {number} baseSize - Maximum size in pixels
 * @param {number} factor - Viewport width multiplier
 * @param {number} debounceMs - Debounce delay in milliseconds
 */
function useDynamicLogoSize(baseSize = 120, factor = 0.15, debounceMs = 100) {
    const [size, setSize] = useState(baseSize);
    const timeoutRef = useRef(null);

    useEffect(() => {
        function updateSize() {
            setSize(Math.min(window.innerWidth * factor, baseSize));
        }

        function handleResize() {
            // Debounce resize events
            if (timeoutRef.current) {
                clearTimeout(timeoutRef.current);
            }
            timeoutRef.current = setTimeout(updateSize, debounceMs);
        }

        // Initial size calculation
        updateSize();

        window.addEventListener('resize', handleResize);
        return () => {
            window.removeEventListener('resize', handleResize);
            if (timeoutRef.current) {
                clearTimeout(timeoutRef.current);
            }
        };
    }, [baseSize, factor, debounceMs]);

    return size;
}

export function DeckPile({ cardsRemaining, onDraw, isShuffling, nextLabel }) {
    const rasterLogoSize = useDynamicLogoSize(120, 0.15);
    const shouldReduceMotion = useReducedMotion();

    if (cardsRemaining <= 0) return null;

    const hoverAnimation = shouldReduceMotion ? {} : { scale: 1.05, y: -5 };
    const tapAnimation = shouldReduceMotion ? {} : { scale: 0.97 };

    return (
        <div className="flex flex-col items-center justify-center py-6 sm:py-8 animate-fade-in relative z-20">
            <motion.button
                whileHover={hoverAnimation}
                whileTap={tapAnimation}
                transition={{ type: 'spring', stiffness: 400, damping: 25 }}
                onClick={onDraw}
                disabled={isShuffling}
                className="group relative w-[clamp(9rem,45vw,10rem)] h-[clamp(13.5rem,67.5vw,15rem)] sm:w-32 sm:h-48 md:w-40 md:h-60 focus:outline-none focus-visible:ring-2 focus-visible:ring-primary/50 focus-visible:ring-offset-2 rounded-2xl touch-manipulation"
                aria-label={nextLabel ? `Draw card for ${nextLabel}` : "Draw next card"}
            >
                {/* Stack effect layers - decorative, hidden when user prefers reduced motion */}
                {!shouldReduceMotion && (
                    <>
                        <div aria-hidden="true" className="pointer-events-none absolute inset-0 bg-surface-muted/60 rounded-2xl border border-primary/40 transform translate-x-2 translate-y-2 rotate-3 opacity-60" />
                        <div aria-hidden="true" className="pointer-events-none absolute inset-0 bg-surface-muted/70 rounded-2xl border border-primary/40 transform -translate-x-1 translate-y-1 -rotate-2 opacity-80" />
                    </>
                )}

                {/* Top Card with Tableu Logo */}
                <div className="absolute inset-0 bg-gradient-to-br from-surface/95 via-surface-muted/90 to-surface/95 rounded-2xl border-2 border-primary/30 shadow-2xl overflow-hidden">
                    {/* Subtle pattern overlay */}
                    <div className="absolute inset-0 opacity-10" style={{
                        backgroundImage: 'radial-gradient(circle at 50% 50%, var(--brand-secondary) 1px, transparent 1px)',
                        backgroundSize: '16px 16px'
                    }} />

                    {/* Tableu Logo */}
                    <div className="absolute inset-0 flex items-center justify-center p-4">
                        <TableuLogo
                            variant="icon"
                            size={rasterLogoSize}
                            className="opacity-90 group-hover:opacity-100 transition-opacity duration-300"
                            outline
                            glow
                            useRaster
                            ariaLabel="Tableu deck - tap to draw"
                        />
                    </div>
                </div>

                <div className="absolute -bottom-10 left-0 right-0 text-center">
                    <span className="inline-block px-3 py-1 rounded-full bg-primary/10 border border-primary/20 text-accent/90 text-xs font-semibold tracking-widest uppercase backdrop-blur-sm group-hover:bg-primary/20 transition-colors">
                        {nextLabel ? `Draw: ${nextLabel}` : 'Tap to Draw'}
                    </span>
                    <p className="text-primary/40 text-xs mt-2 font-medium">
                        {cardsRemaining} card{cardsRemaining !== 1 ? 's' : ''} remaining
                    </p>
                </div>
            </motion.button>
        </div>
    );
}
</file>

<file path="src/components/DeckRitual.jsx">
import { useState, useCallback, useRef, useEffect } from 'react';
import { motion, useAnimation, AnimatePresence } from 'framer-motion';
import { TableuLogo } from './TableuLogo';
import { Sparkle, Scissors, ArrowsClockwise, HandTap } from '@phosphor-icons/react';
import { useSmallScreen } from '../hooks/useSmallScreen';
import { useReducedMotion } from '../hooks/useReducedMotion';
import { useLandscape } from '../hooks/useLandscape';

const CARD_STACK_COUNT = 7; // Visual stack layers

// Haptic feedback helper
const vibrate = (pattern) => {
  if (typeof navigator !== 'undefined' && navigator.vibrate) {
    navigator.vibrate(pattern);
  }
};

/**
 * Unified deck + ritual interface combining DeckPile and RitualControls
 * Supports gesture-based interactions: tap to knock, long-press to cut, double-tap to shuffle
 */
export function DeckRitual({
  // Ritual state
  knockCount = 0,
  onKnock,
  hasCut = false,
  cutIndex = 0,
  onCutChange,
  onCutConfirm,
  deckSize = 78,

  // Deal state
  isShuffling = false,
  onShuffle,
  cardsRemaining,
  nextPosition,
  spreadPositions = [],
  revealedCount = 0,
  totalCards = 0,

  // Deal action
  onDeal
}) {
  const isSmallScreen = useSmallScreen();
  const prefersReducedMotion = useReducedMotion();
  const isLandscape = useLandscape();
  const deckControls = useAnimation();
  const [showCutSlider, setShowCutSlider] = useState(false);
  const [localCutIndex, setLocalCutIndex] = useState(cutIndex);
  const deckRef = useRef(null);
  const knockComplete = knockCount >= 3;

  // Sync local cut index with prop
  useEffect(() => {
    setLocalCutIndex(cutIndex);
  }, [cutIndex]);

  // Card stack visual offsets
  const stackCards = Array.from({ length: CARD_STACK_COUNT }, (_, i) => ({
    id: i,
    zIndex: CARD_STACK_COUNT - i,
    offset: i * 2,
    rotation: (i - Math.floor(CARD_STACK_COUNT / 2)) * 0.8,
    opacity: 1 - (i * 0.08)
  }));

  // Tap / double-tap handler (handles knock + shuffle within same flow to avoid browser dblclick delay)
  const lastTapRef = useRef(0);
  const handleDeckTap = useCallback(() => {
    if (showCutSlider) return;

    const now = Date.now();
    const sinceLast = now - lastTapRef.current;
    const withinDoubleTap = sinceLast > 0 && sinceLast < 320;

    if (withinDoubleTap) {
      lastTapRef.current = 0;
      onShuffle?.();
      vibrate([20, 50, 20, 50, 20]);
      return;
    }

    lastTapRef.current = now;

    if (knockCount < 3) {
      onKnock?.();
      vibrate([15, 30, 15]);

      // Visual pulse on knock
      if (!prefersReducedMotion) {
        deckControls.start({
          scale: [1, 0.96, 1.02, 1],
          transition: { duration: 0.25 }
        });
      }
    }
  }, [knockCount, onKnock, onShuffle, showCutSlider, prefersReducedMotion, deckControls]);

  // Long-press to reveal cut slider (disabled once cut is done to reduce accidental opens)
  const longPressTimerRef = useRef(null);
  const handleTouchStart = useCallback(() => {
    if (hasCut) return;
    longPressTimerRef.current = setTimeout(() => {
      setShowCutSlider(true);
      vibrate([30]);
    }, 420);
  }, [hasCut]);

  const handleTouchEnd = useCallback(() => {
    if (longPressTimerRef.current) {
      clearTimeout(longPressTimerRef.current);
    }
  }, []);

  // Shuffle animation
  useEffect(() => {
    if (isShuffling && !prefersReducedMotion) {
      deckControls.start({
        rotateY: [0, 180, 360, 180, 0],
        rotateZ: [0, 5, -5, 3, 0],
        transition: { duration: 1.2, ease: 'easeInOut' }
      });
    }
  }, [isShuffling, deckControls, prefersReducedMotion]);

  // Deal animation - card flies from deck
  const handleDealWithAnimation = useCallback(() => {
    if (cardsRemaining <= 0 || isShuffling) return;
    vibrate(10);
    onDeal?.();
  }, [cardsRemaining, isShuffling, onDeal]);

  // Handle local cut slider change
  const handleCutSliderChange = useCallback((e) => {
    const value = parseInt(e.target.value, 10);
    setLocalCutIndex(value);
    onCutChange?.(value);
  }, [onCutChange]);

  // Confirm cut
  const handleCutConfirm = useCallback(() => {
    onCutConfirm?.();
    setShowCutSlider(false);
    vibrate([20, 30, 20]);
  }, [onCutConfirm]);

  return (
    <div className={`deck-ritual-container relative ${isLandscape ? 'py-3' : 'py-4 xs:py-5 sm:py-8'}`}>
      {/* Ritual Status Indicator - more compact on very small screens */}
      <div className={`flex items-center justify-center ${isLandscape ? 'gap-2 mb-3' : 'gap-2 xs:gap-3 sm:gap-4 mb-3 xs:mb-4 sm:mb-6'}`}>
        <div className={`flex items-center gap-1.5 xs:gap-2 rounded-full border transition-all ${isLandscape ? 'px-2 py-1' : 'px-2.5 xs:px-3 py-1 xs:py-1.5'} ${
          knockComplete
            ? 'border-secondary/60 bg-secondary/15 text-secondary'
            : 'border-accent/30 bg-surface/60 text-muted'
        }`}>
          <Sparkle className={isLandscape ? 'w-3 h-3' : 'w-3.5 h-3.5 xs:w-4 xs:h-4'} weight={knockComplete ? 'fill' : 'regular'} />
          <span className={`font-semibold ${isLandscape ? 'text-[0.65rem]' : 'text-[0.7rem] xs:text-xs'}`}>{knockComplete ? (isLandscape ? '✓' : 'Cleared') : `${knockCount}/3`}</span>
        </div>

        <div className={`flex items-center gap-1.5 xs:gap-2 rounded-full border transition-all ${isLandscape ? 'px-2 py-1' : 'px-2.5 xs:px-3 py-1 xs:py-1.5'} ${
          hasCut
            ? 'border-secondary/60 bg-secondary/15 text-secondary'
            : 'border-accent/30 bg-surface/60 text-muted'
        }`}>
          <Scissors className={isLandscape ? 'w-3 h-3' : 'w-3.5 h-3.5 xs:w-4 xs:h-4'} weight={hasCut ? 'fill' : 'regular'} />
          <span className={`font-semibold ${isLandscape ? 'text-[0.65rem]' : 'text-[0.7rem] xs:text-xs'}`}>{hasCut ? `#${cutIndex}` : (isLandscape ? '—' : 'Uncut')}</span>
        </div>
      </div>

      {/* The Deck - responsive sizing for different screen sizes */}
      <div className="relative flex justify-center" style={{ perspective: '1200px' }}>
        <motion.div
          ref={deckRef}
          animate={deckControls}
          className="deck-stack relative cursor-pointer touch-manipulation"
          onClick={handleDeckTap}
          onTouchStart={handleTouchStart}
          onTouchEnd={handleTouchEnd}
          onMouseDown={handleTouchStart}
          onMouseUp={handleTouchEnd}
          role="button"
          aria-label={
            cardsRemaining > 0
              ? `Draw card for ${nextPosition || 'next position'}. Tap to knock (${knockCount}/3), double-tap to shuffle, long-press to cut.`
              : 'All cards dealt'
          }
          tabIndex={0}
          onKeyDown={(e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              if (e.shiftKey) {
                onShuffle?.();
              } else {
                handleDealWithAnimation();
              }
            }
            // 'k' to knock
            if (e.key === 'k' || e.key === 'K') {
              e.preventDefault();
              handleDeckTap();
            }
            // 'c' to toggle cut slider
            if (e.key === 'c' || e.key === 'C') {
              e.preventDefault();
              setShowCutSlider(prev => !prev);
            }
          }}
          style={{ transformStyle: 'preserve-3d' }}
        >
          {/* Stack of cards - optimized for very small screens (<375px) */}
          {stackCards.map((card) => (
            <motion.div
              key={card.id}
              className={`absolute rounded-xl border-2 border-primary/30 overflow-hidden ${isSmallScreen ? 'w-[clamp(5.5rem,32vw,7.5rem)] h-[clamp(8.25rem,48vw,11.25rem)]' : 'w-[clamp(7rem,35vw,8.5rem)] h-[clamp(10.5rem,52vw,12.75rem)]'}`}
              style={{
                zIndex: card.zIndex,
                opacity: card.opacity,
                transform: `translateX(${card.offset}px) translateY(${card.offset}px) rotate(${card.rotation}deg)`,
                background: 'linear-gradient(145deg, var(--bg-surface), var(--bg-surface-muted))'
              }}
              initial={false}
              animate={isShuffling && !prefersReducedMotion ? {
                x: [card.offset, card.offset + 10, card.offset - 5, card.offset],
                rotate: [card.rotation, card.rotation + 3, card.rotation - 2, card.rotation]
              } : {}}
              transition={{ duration: 0.4, delay: card.id * 0.05 }}
            >
              {/* Card back pattern */}
              <div className="absolute inset-0 opacity-10" style={{
                backgroundImage: 'radial-gradient(circle at 50% 50%, var(--brand-secondary) 1px, transparent 1px)',
                backgroundSize: '12px 12px'
              }} />
            </motion.div>
          ))}

          {/* Top card with logo - responsive sizing */}
          <motion.div
            className={`relative rounded-xl border-2 border-primary/40 shadow-2xl overflow-hidden ${isSmallScreen ? 'w-[clamp(5.5rem,32vw,7.5rem)] h-[clamp(8.25rem,48vw,11.25rem)]' : 'w-[clamp(7rem,35vw,8.5rem)] h-[clamp(10.5rem,52vw,12.75rem)]'}`}
            style={{
              background: 'linear-gradient(145deg, var(--bg-surface), var(--bg-surface-muted))',
              boxShadow: '0 20px 40px rgba(0,0,0,0.3), 0 0 30px color-mix(in srgb, var(--brand-primary) 10%, transparent)'
            }}
            whileHover={prefersReducedMotion ? {} : { y: -4, rotateX: 5 }}
            whileTap={prefersReducedMotion ? {} : { scale: 0.98 }}
          >
            <div className="absolute inset-0 flex items-center justify-center p-3 xs:p-4">
              <TableuLogo
                variant="icon"
                size={isSmallScreen ? 60 : 80}
                className="opacity-80 group-hover:opacity-100 transition-opacity"
                outline
                glow
                useRaster
              />
            </div>

            {/* Knock ripple effect */}
            <AnimatePresence>
              {knockCount > 0 && !knockComplete && (
                <motion.div
                  key={`knock-${knockCount}`}
                  className="absolute inset-0 rounded-xl border-2 border-secondary pointer-events-none"
                  initial={{ scale: 0.8, opacity: 0.8 }}
                  animate={{ scale: 1.3, opacity: 0 }}
                  exit={{ opacity: 0 }}
                  transition={{ duration: prefersReducedMotion ? 0.1 : 0.4 }}
                />
              )}
            </AnimatePresence>

            {/* Shuffle spinner overlay */}
            {isShuffling && (
              <div className="absolute inset-0 flex items-center justify-center bg-surface/50 backdrop-blur-sm rounded-xl">
                <ArrowsClockwise className="w-8 h-8 text-secondary animate-spin" />
              </div>
            )}
          </motion.div>
        </motion.div>
      </div>

      {/* Cut slider (appears on long-press) - mobile optimized */}
      <AnimatePresence>
        {showCutSlider && (
          <motion.div
            initial={prefersReducedMotion ? { opacity: 1, y: 0 } : { opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={prefersReducedMotion ? { opacity: 0, y: 0 } : { opacity: 0, y: 20 }}
            className="mt-4 xs:mt-5 sm:mt-6 max-w-xs mx-auto px-3 xs:px-4"
          >
            <div className="rounded-2xl border border-accent/30 bg-surface/80 backdrop-blur p-3 xs:p-4">
              <div className="flex items-center justify-between mb-2 xs:mb-3">
                <span className="text-[0.7rem] xs:text-xs text-muted">Cut position</span>
                <span className="text-sm font-bold text-secondary">#{localCutIndex}</span>
              </div>
              <input
                type="range"
                min={0}
                max={deckSize - 1}
                value={localCutIndex}
                onChange={handleCutSliderChange}
                className="w-full touch-manipulation"
                aria-label="Cut position in deck"
              />
              <div className="flex justify-between mt-2 xs:mt-3 gap-2">
                <button
                  onClick={() => setShowCutSlider(false)}
                  className="text-[0.7rem] xs:text-xs text-muted hover:text-main transition-colors px-3 py-2 rounded-full hover:bg-surface-muted/50 min-h-[44px] touch-manipulation"
                >
                  Cancel
                </button>
                <button
                  onClick={handleCutConfirm}
                  className="px-4 py-2 rounded-full bg-secondary/20 border border-secondary/50 text-secondary text-[0.7rem] xs:text-xs font-semibold hover:bg-secondary/30 transition-colors min-h-[44px] touch-manipulation"
                >
                  Confirm Cut
                </button>
              </div>
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {/* Quick draw CTA placed nearer to the deck on mobile */}
      {cardsRemaining > 0 && (
        <div className={`text-center px-3 xs:px-4 ${isLandscape ? 'mt-3' : 'mt-4 xs:mt-5'} sm:hidden`}>
          <motion.button
            onClick={handleDealWithAnimation}
            disabled={isShuffling}
            className="inline-flex items-center gap-2 px-4 py-2 rounded-full bg-primary text-main font-semibold shadow-lg disabled:opacity-50 disabled:cursor-not-allowed text-sm"
            style={{ boxShadow: '0 10px 30px color-mix(in srgb, var(--brand-primary) 30%, transparent)' }}
            whileHover={prefersReducedMotion ? {} : { scale: 1.03 }}
            whileTap={prefersReducedMotion ? {} : { scale: 0.98 }}
          >
            <span>Draw: {nextPosition || 'Next Card'}</span>
            <span className="opacity-70 text-[0.7rem]">({cardsRemaining})</span>
          </motion.button>
        </div>
      )}

      {/* Ritual action buttons - explicit alternatives to gestures for accessibility */}
      <div className={`flex flex-wrap items-center justify-center px-3 xs:px-4 ${isLandscape ? 'mt-3 gap-1.5' : 'mt-3 xs:mt-4 sm:mt-5 gap-1.5 xs:gap-2 sm:gap-3'}`}>
        {/* Knock button */}
        <button
          onClick={handleDeckTap}
          disabled={knockComplete || showCutSlider}
          className={`
            flex items-center rounded-full font-medium
            transition-all touch-manipulation min-h-[44px]
            ${isLandscape ? 'gap-1 px-2.5 py-1.5 text-[0.65rem]' : 'gap-1.5 px-2.5 xs:px-3 py-2 text-[0.7rem] xs:text-xs'}
            ${knockComplete
              ? 'bg-secondary/15 border border-secondary/40 text-secondary cursor-default'
              : 'bg-surface/60 border border-accent/30 text-muted hover:bg-surface hover:border-accent/50 hover:text-main active:scale-95'
            }
          `}
          aria-label={knockComplete ? 'Knocking complete' : `Knock on deck (${knockCount}/3)`}
        >
          <HandTap className={isLandscape ? 'w-3.5 h-3.5' : 'w-3.5 h-3.5 xs:w-4 xs:h-4'} aria-hidden="true" />
          <span>{knockComplete ? '✓' : (isLandscape ? knockCount : `Knock (${knockCount}/3)`)}</span>
        </button>

        {/* Cut button */}
        <button
          onClick={() => setShowCutSlider(prev => !prev)}
          className={`
            flex items-center rounded-full font-medium
            transition-all touch-manipulation min-h-[44px]
            ${isLandscape ? 'gap-1 px-2.5 py-1.5 text-[0.65rem]' : 'gap-1.5 px-2.5 xs:px-3 py-2 text-[0.7rem] xs:text-xs'}
            ${hasCut
              ? 'bg-secondary/15 border border-secondary/40 text-secondary'
              : showCutSlider
              ? 'bg-accent/20 border border-accent/50 text-main'
              : 'bg-surface/60 border border-accent/30 text-muted hover:bg-surface hover:border-accent/50 hover:text-main active:scale-95'
            }
          `}
          aria-label={hasCut ? `Deck cut at position ${cutIndex}` : showCutSlider ? 'Close cut slider' : 'Cut the deck'}
          aria-expanded={showCutSlider}
        >
          <Scissors className={isLandscape ? 'w-3.5 h-3.5' : 'w-3.5 h-3.5 xs:w-4 xs:h-4'} aria-hidden="true" />
          <span>{hasCut ? `#${cutIndex}` : (isLandscape ? 'Cut' : (showCutSlider ? 'Cutting...' : 'Cut Deck'))}</span>
        </button>

        {/* Shuffle button */}
        <button
          onClick={() => {
            onShuffle?.();
            vibrate([20, 50, 20, 50, 20]);
          }}
          disabled={isShuffling}
          className={`
            flex items-center rounded-full font-medium
            bg-surface/60 border border-accent/30 text-muted
            hover:bg-surface hover:border-accent/50 hover:text-main
            disabled:opacity-50 disabled:cursor-not-allowed
            transition-all touch-manipulation min-h-[44px] active:scale-95
            ${isLandscape ? 'gap-1 px-2.5 py-1.5 text-[0.65rem]' : 'gap-1.5 px-2.5 xs:px-3 py-2 text-[0.7rem] xs:text-xs'}
          `}
          aria-label={isShuffling ? 'Shuffling deck...' : 'Shuffle the deck'}
        >
          <ArrowsClockwise className={`${isLandscape ? 'w-3.5 h-3.5' : 'w-3.5 h-3.5 xs:w-4 xs:h-4'} ${isShuffling ? 'animate-spin' : ''}`} aria-hidden="true" />
          {!isLandscape && <span>{isShuffling ? 'Shuffling...' : 'Shuffle'}</span>}
        </button>
      </div>

      {/* Gesture hints (supplementary info for touch users) - hidden in landscape and on very small screens */}
      {!isLandscape && (
        <p className="hidden xs:block mt-2 xs:mt-3 text-center text-[0.65rem] xs:text-[0.7rem] text-muted/70 px-4">
          <span className="hidden sm:inline">Gestures: </span>
          Tap deck to knock · Hold to cut · Double-tap to shuffle
        </p>
      )}

      {/* Draw CTA - optimized for small screens */}
      {cardsRemaining > 0 && (
        <div className={`text-center px-3 xs:px-4 ${isLandscape ? 'mt-3' : 'mt-4 xs:mt-5 sm:mt-6 hidden sm:block'}`}>
          <motion.button
            onClick={handleDealWithAnimation}
            disabled={isShuffling}
            className={`inline-flex items-center rounded-full bg-primary text-main font-semibold shadow-lg disabled:opacity-50 disabled:cursor-not-allowed transition-colors hover:bg-primary/90 min-h-[44px] ${isLandscape ? 'gap-2 px-4 py-2 text-sm' : 'gap-2 xs:gap-3 px-4 xs:px-5 sm:px-6 py-2 xs:py-2.5 sm:py-3 text-sm xs:text-base'}`}
            style={{ boxShadow: '0 10px 30px color-mix(in srgb, var(--brand-primary) 30%, transparent)' }}
            whileHover={prefersReducedMotion ? {} : { scale: 1.03 }}
            whileTap={prefersReducedMotion ? {} : { scale: 0.98 }}
          >
            <span>{isLandscape ? nextPosition || 'Next' : `Draw: ${nextPosition || 'Next Card'}`}</span>
            <span className={`opacity-70 ${isLandscape ? 'text-[0.65rem]' : 'text-[0.7rem] xs:text-xs'}`}>({cardsRemaining})</span>
          </motion.button>
        </div>
      )}

      {/* Position preview minimap */}
      {spreadPositions && spreadPositions.length > 1 && (
        <div className={`flex justify-center px-3 xs:px-4 ${isLandscape ? 'mt-3' : 'mt-4 xs:mt-5 sm:mt-6'}`}>
          <SpreadMinimap
            positions={spreadPositions}
            revealedCount={revealedCount}
            nextIndex={totalCards - cardsRemaining}
          />
        </div>
      )}
    </div>
  );
}

// Minimap showing spread positions with current progress
function SpreadMinimap({ positions, revealedCount, nextIndex }) {
  return (
    <div
      className="flex items-center gap-1.5 sm:gap-2 px-3 sm:px-4 py-2 rounded-full bg-surface/60 border border-accent/20"
      role="list"
      aria-label="Spread position progress"
    >
      {positions.map((pos, i) => {
        const isRevealed = i < revealedCount;
        const isNext = i === nextIndex;
        const label = typeof pos === 'string' ? pos.split(' — ')[0] : `Position ${i + 1}`;

        return (
          <div
            key={i}
            className={`w-2.5 h-3.5 sm:w-3 sm:h-4 rounded-sm transition-all ${
              isRevealed
                ? 'bg-secondary shadow-sm'
                : isNext
                ? 'bg-primary animate-pulse'
                : 'bg-surface-muted border border-accent/30'
            }`}
            style={isRevealed ? { boxShadow: '0 0 6px color-mix(in srgb, var(--brand-secondary) 30%, transparent)' } : {}}
            title={label}
            role="listitem"
            aria-label={`${label}: ${isRevealed ? 'revealed' : isNext ? 'next to draw' : 'pending'}`}
          />
        );
      })}
    </div>
  );
}
</file>

<file path="src/components/DeckSelector.jsx">
import { useRef, useState, useEffect, useCallback } from 'react';
import { Check, CaretRight } from '@phosphor-icons/react';
import { CarouselDots } from './CarouselDots';
import rwsPreview from '../../selectorimages/rider.jpeg';
import thothPreview from '../../selectorimages/Thoth.jpeg';
import marseillePreview from '../../selectorimages/marseille.jpeg';
import { useReducedMotion } from '../hooks/useReducedMotion';

export const DECK_OPTIONS = [
  {
    id: 'rws-1909',
    label: 'Rider-Waite-Smith',
    subtitle: '1909 Edition',
    description: 'Classic Pamela Colman Smith watercolors with bold ink outlines and theatrical staging.',
    palette: [
      { label: 'Sunlit yellows', swatch: '#eac26d', textColor: '#1c1308' },
      { label: 'Lapis blues', swatch: '#1f3f78', textColor: '#e6ecf7' },
      { label: 'Crimson accents', swatch: '#8d1c33', textColor: '#f7e7ef' }
    ],
    preview: {
      src: rwsPreview,
      alt: 'Rider-Waite-Smith deck featuring The Magician card'
    },
    accent: '#e5c48e',
    border: 'rgba(220, 188, 141, 0.35)',
    borderActive: 'rgba(229, 196, 142, 0.9)',
    glow: 'rgba(229, 196, 142, 0.45)',
    background: 'linear-gradient(150deg, rgba(255, 209, 159, 0.12), rgba(17, 12, 21, 0.94)), radial-gradient(circle at 20% 18%, rgba(255, 225, 180, 0.12), transparent 52%), radial-gradient(circle at 80% -10%, rgba(63, 118, 192, 0.18), transparent 48)'
  },
  {
    id: 'thoth-a1',
    label: 'Thoth',
    subtitle: 'Crowley/Harris A1',
    description: 'Abstract, prismatic geometry with layered astrological sigils and Art Deco gradients.',
    palette: [
      { label: 'Electric teal', swatch: '#27cfc0', textColor: '#061412' },
      { label: 'Magenta', swatch: '#c1248b', textColor: '#fde7f4' },
      { label: 'Saffron gold', swatch: '#d9a441', textColor: '#120c05' }
    ],
    preview: {
      src: thothPreview,
      alt: 'Thoth deck featuring The Magus card with Art Deco styling'
    },
    accent: '#44e0d2',
    border: 'rgba(83, 216, 206, 0.25)',
    borderActive: 'rgba(83, 216, 206, 0.75)',
    glow: 'rgba(83, 216, 206, 0.35)',
    background: 'linear-gradient(165deg, rgba(26, 48, 63, 0.92), rgba(15, 12, 30, 0.96)), radial-gradient(circle at 12% 18%, rgba(68, 224, 210, 0.22), transparent 48%), radial-gradient(circle at 90% 0%, rgba(193, 36, 139, 0.18), transparent 50)',
    note: 'Uses Thoth card names (e.g., "The Magus", "Adjustment").'
  },
  {
    id: 'marseille-classic',
    label: 'Tarot de Marseille',
    subtitle: '18th Century Scans',
    description: 'Woodcut line work with flat primary colors and medieval heraldry.',
    palette: [
      { label: 'Carmine red', swatch: '#a32035', textColor: '#fde6ec' },
      { label: 'Cobalt blue', swatch: '#21489b', textColor: '#e7efff' },
      { label: 'Sunflower yellow', swatch: '#d8a300', textColor: '#140d02' }
    ],
    preview: {
      src: marseillePreview,
      alt: 'Tarot de Marseille deck featuring Le Bateleur card'
    },
    accent: '#d8a300',
    border: 'rgba(192, 146, 64, 0.28)',
    borderActive: 'rgba(216, 163, 0, 0.82)',
    glow: 'rgba(216, 163, 0, 0.35)',
    background: 'linear-gradient(170deg, rgba(34, 26, 28, 0.94), rgba(16, 18, 32, 0.96)), radial-gradient(circle at 12% 22%, rgba(216, 163, 0, 0.16), transparent 46%), radial-gradient(circle at 85% -8%, rgba(47, 86, 178, 0.18), transparent 48)',
    note: 'Uses Marseille numbering with French titles.'
  }
];

function DeckPreviewImage({ preview, deckLabel }) {
  if (!preview?.src) {
    return null;
  }

  return (
    <div className="relative overflow-hidden rounded-[14px] bg-[#0f0c14] mb-1">
      <img
        src={preview.src}
        alt={preview.alt || `${deckLabel} deck preview`}
        className="w-full h-auto object-cover"
        loading="lazy"
        decoding="async"
        onError={(e) => {
          e.currentTarget.style.display = 'none';
        }}
      />
      <div
        className="pointer-events-none absolute inset-0 rounded-[14px] border border-white/10 shadow-[0_0_0_1px_rgba(232,218,195,0.08)]"
        aria-hidden="true"
      />
    </div>
  );
}

function PaletteBadge({ label, swatch, textColor }) {
  return (
    <span
      className="deck-palette-badge"
      style={{
        backgroundColor: swatch,
        color: textColor,
        boxShadow: `0 10px 20px -14px rgba(0,0,0,0.8), 0 0 0 1px rgba(255,255,255,0.08), 0 0 0 1px ${swatch}33`
      }}
    >
      {label}
    </span>
  );
}

export function DeckSelector({ selectedDeck, onDeckChange }) {
  const deckRefs = useRef({});
  const carouselRef = useRef(null);
  const deckIds = DECK_OPTIONS.map(d => d.id);
  const [activeIndex, setActiveIndex] = useState(0);
  const [showLeftFade, setShowLeftFade] = useState(false);
  const [showRightFade, setShowRightFade] = useState(true);
  const prefersReducedMotion = useReducedMotion();

  // Update edge fade visibility based on scroll position
  const updateEdgeFades = useCallback((el) => {
    if (!el) return;
    const scrollLeft = el.scrollLeft;
    const scrollWidth = el.scrollWidth;
    const clientWidth = el.clientWidth;

    setShowLeftFade(scrollLeft > 10);
    setShowRightFade(scrollLeft < scrollWidth - clientWidth - 10);
  }, []);

  // Track scroll position for pagination dots using actual element positions
  useEffect(() => {
    const el = carouselRef.current;
    if (!el || deckIds.length <= 1) return undefined;

    const handleScroll = () => {
      const cards = Array.from(el.children);
      if (cards.length === 0) return;

      // Find the card whose center is closest to the viewport center
      const viewportCenter = el.scrollLeft + el.clientWidth / 2;
      let closestIndex = 0;
      let closestDistance = Infinity;

      cards.forEach((card, idx) => {
        const cardCenter = card.offsetLeft + card.offsetWidth / 2;
        const distance = Math.abs(viewportCenter - cardCenter);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestIndex = idx;
        }
      });

      setActiveIndex(closestIndex);
      updateEdgeFades(el);
    };

    handleScroll();
    el.addEventListener('scroll', handleScroll, { passive: true });
    return () => el.removeEventListener('scroll', handleScroll);
  }, [deckIds.length, updateEdgeFades]);

  const scrollToIndex = (index) => {
    const el = carouselRef.current;
    if (!el) return;
    const clamped = Math.min(deckIds.length - 1, Math.max(0, index));
    setActiveIndex(clamped);

    // Scroll to center the target card in the viewport
    const cards = Array.from(el.children);
    const targetCard = cards[clamped];
    if (targetCard) {
      const cardCenter = targetCard.offsetLeft + targetCard.offsetWidth / 2;
      const scrollTarget = cardCenter - el.clientWidth / 2;
      el.scrollTo({
        left: Math.max(0, scrollTarget),
        behavior: prefersReducedMotion ? 'auto' : 'smooth'
      });
    }
  };

  const handleKeyDown = (event, deckId) => {
    const deckIds = DECK_OPTIONS.map(d => d.id);
    const currentIndex = deckIds.indexOf(deckId);

    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      onDeckChange(deckId);
      return;
    }

    let nextIndex = -1;
    if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
      event.preventDefault();
      nextIndex = (currentIndex + 1) % deckIds.length;
    } else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
      event.preventDefault();
      nextIndex = (currentIndex - 1 + deckIds.length) % deckIds.length;
    } else if (event.key === 'Home') {
      event.preventDefault();
      nextIndex = 0;
    } else if (event.key === 'End') {
      event.preventDefault();
      nextIndex = deckIds.length - 1;
    }

    if (nextIndex !== -1) {
      const nextDeckId = deckIds[nextIndex];
      const nextElement = deckRefs.current[nextDeckId];
      if (nextElement && typeof nextElement.focus === 'function') {
        nextElement.focus();
        nextElement.scrollIntoView({
          behavior: prefersReducedMotion ? 'auto' : 'smooth',
          block: 'nearest',
          inline: 'center'
        });
      }
      // Note: Selection only happens on Enter/Space (handled above), not on arrow navigation
      // This follows the roving tabindex pattern where arrows move focus, not selection
    }
  };

  return (
    <div className="panel-mystic deck-selector-panel animate-fade-in">
      <div className="relative z-10 space-y-5">
        <header className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
          <div>
            <p className="text-[0.68rem] uppercase tracking-[0.22em] text-gold-soft">Choose Your Deck</p>
            <p className="text-xs text-muted max-w-2xl">
              Select the deck art for today&apos;s reading. Match it to your physical deck if you&apos;re contributing photos to the vision study.
            </p>
          </div>
          <div className="hidden sm:flex items-center gap-2 rounded-full border border-gold-soft/50 bg-black/30 px-3 py-1 text-[0.7rem] text-accent backdrop-blur">
            <span className="w-1.5 h-1.5 rounded-full bg-gold-soft animate-pulse" aria-hidden="true" />
            <span>Curated editions</span>
          </div>
        </header>

        {/* Carousel wrapper with edge fade indicators */}
        <div className="relative">
          {/* Left edge fade - indicates scrolled content behind */}
          <div
            className={`
              absolute left-0 top-0 bottom-3 w-8 z-10
              pointer-events-none
              bg-gradient-to-r from-[rgba(13,10,20,0.9)] to-transparent
              rounded-l-2xl
              transition-opacity duration-200
              sm:hidden
              ${showLeftFade ? 'opacity-100' : 'opacity-0'}
            `}
            aria-hidden="true"
          />

          {/* Right edge fade with scroll hint arrow */}
          <div
            className={`
              absolute right-0 top-0 bottom-3 w-12 z-10
              pointer-events-none
              bg-gradient-to-l from-[rgba(13,10,20,0.9)] via-[rgba(13,10,20,0.6)] to-transparent
              rounded-r-2xl
              transition-opacity duration-200
              sm:hidden
              flex items-center justify-end pr-1
              ${showRightFade ? 'opacity-100' : 'opacity-0'}
            `}
            aria-hidden="true"
          >
            <CaretRight
              className="w-5 h-5 text-accent/70 animate-pulse drop-shadow-md"
              weight="bold"
            />
          </div>

          <div
            ref={carouselRef}
            role="radiogroup"
            aria-label="Choose your deck style"
            className="deck-selector-grid flex gap-3 overflow-x-auto snap-x snap-mandatory pb-3 sm:overflow-visible sm:snap-none sm:grid sm:grid-cols-2 lg:grid-cols-3 sm:gap-4"
          >
          {DECK_OPTIONS.map((deck, index) => {
            const isSelected = selectedDeck === deck.id;
            const isFirstDeck = index === 0;
            const isTabbable = isSelected || (!selectedDeck && isFirstDeck);

            return (
              <button
                key={deck.id}
                ref={el => { deckRefs.current[deck.id] = el; }}
                type="button"
                role="radio"
                aria-checked={isSelected}
                tabIndex={isTabbable ? 0 : -1}
                onClick={() => onDeckChange(deck.id)}
                onKeyDown={(e) => handleKeyDown(e, deck.id)}
                className={`deck-card relative flex h-full flex-col gap-3 rounded-2xl px-4 py-4 sm:px-5 sm:py-5 text-left transition-all cursor-pointer select-none shrink-0 basis-[82%] xs:basis-[70%] snap-center sm:basis-auto sm:shrink focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--deck-ring)] focus-visible:ring-offset-2 focus-visible:ring-offset-[#0f0c13] ${isSelected ? 'deck-card--active' : ''}`}
                style={{
                  '--deck-accent': deck.accent,
                  '--deck-border': isSelected ? deck.borderActive : deck.border,
                  '--deck-background': deck.background,
                  '--deck-glow': deck.glow,
                  '--deck-ring': deck.accent
                }}
              >
                {isSelected && (
                  <div className="absolute top-3 right-3 z-20">
                    <div
                      className="w-7 h-7 rounded-full flex items-center justify-center border border-white/30"
                      style={{
                        backgroundColor: 'var(--deck-accent)',
                        boxShadow: `0 12px 26px -18px var(--deck-glow, rgba(212, 184, 150, 0.4))`
                      }}
                    >
                      <Check className="w-4 h-4 text-main" strokeWidth={3} />
                    </div>
                  </div>
                )}

                <DeckPreviewImage preview={deck.preview} deckLabel={deck.label} />

                <div className="pr-1">
                  <div className="font-serif text-accent text-base leading-tight">
                    {deck.label}
                  </div>
                  <div className="text-[0.7rem] uppercase tracking-[0.18em] text-gold-soft/90 mb-2">
                    {deck.subtitle}
                  </div>
                  <p className="text-xs text-muted leading-snug mb-3">
                    {deck.description}
                  </p>

                  <div className="flex flex-wrap gap-1.5 mb-2">
                    {deck.palette.map((tone) => (
                      <PaletteBadge key={`${deck.id}-${tone.label}`} {...tone} />
                    ))}
                  </div>

                  {deck.note && (
                    <p className="text-[0.68rem] text-accent/85 italic mt-2">
                      {deck.note}
                    </p>
                  )}
                </div>
              </button>
            );
          })}
          </div>
        </div>

        {/* Mobile pagination dots */}
        <div className="sm:hidden">
          <CarouselDots
            activeIndex={activeIndex}
            totalItems={deckIds.length}
            onSelectItem={scrollToIndex}
            labels={DECK_OPTIONS.map(d => d.label)}
            ariaLabel="Deck selection"
            variant="compact"
          />
        </div>

        <div className="deck-panel-footnote">
          <p className="text-xs leading-relaxed text-muted">
            <strong className="text-accent">For research participants:</strong> Choose the matching deck to help the vision model recognize suits and illustrations across art styles.
          </p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/ExperienceSettings.jsx">
import { useId } from 'react';
import { Sun, Moon, Stack, ArrowCounterClockwise, Info } from '@phosphor-icons/react';
import { Tooltip } from './Tooltip';
import { GlowToggle } from './GlowToggle';
import { HelperToggle } from './HelperToggle';
import { usePreferences } from '../contexts/PreferencesContext';

/**
 * ExperienceSettings - Non-audio reading preferences
 * Groups theme, deck size, and reversal framework controls
 */
export function ExperienceSettings({ className = '' }) {
  const {
    theme,
    setTheme,
    includeMinors,
    setIncludeMinors,
    reversalFramework,
    setReversalFramework
  } = usePreferences();

  const idPrefix = useId();
  const getId = suffix => `${idPrefix}-${suffix}`;

  const controlShellClass =
    'rounded-[1.75rem] border border-secondary/40 bg-surface/75 p-3 xs:p-4 shadow-lg shadow-secondary/20 backdrop-blur-xl';
  const tileBaseClass =
    'group flex items-center gap-2 xs:gap-3 rounded-2xl border border-secondary/10 bg-surface/65 px-3 py-2 xs:py-2.5 transition-colors duration-200 touch-manipulation min-h-[56px]';
  const activeTileClass =
    'border-secondary/70 bg-secondary/10 shadow-lg shadow-secondary/30';
  const inactiveTileClass = 'border-accent/20 hover:border-accent/40 hover:bg-surface/70';

  const iconWrapperBase =
    'flex h-8 w-8 xs:h-9 xs:w-9 flex-shrink-0 items-center justify-center rounded-xl border text-secondary transition-colors duration-200';
  const activeIconWrapper =
    'border-secondary/60 bg-secondary/20 text-secondary shadow-md shadow-secondary/20';
  const inactiveIconWrapper =
    'border-accent/20 bg-surface/80 text-muted group-hover:text-main';

  // Info button - subtle icon, 44px touch target but no visible border
  const infoButtonClass =
    'inline-flex min-w-[44px] min-h-[44px] items-center justify-center rounded-full text-muted/60 transition hover:text-accent focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60 touch-manipulation -ml-2 -mr-3';

  const reversalSelectClass =
    'w-full rounded-2xl border border-secondary/25 bg-surface/70 px-2 xs:px-3 py-2.5 min-h-[44px] text-[0.65rem] xs:text-[0.72rem] uppercase tracking-[0.06em] xs:tracking-[0.08em] text-main transition focus:outline-none focus:ring-2 focus:ring-accent/50';

  const LightIcon = theme === 'light' ? Sun : Moon;

  const experienceToggles = [
    {
      id: getId('theme-toggle'),
      label: 'Light mode',
      tooltipContent: 'High contrast theme',
      tooltipAria: 'About light mode',
      srDescription: 'Toggle between dark and light theme.',
      active: theme === 'light',
      Icon: LightIcon,
      onToggle: value => setTheme(value ? 'light' : 'dark')
    },
    {
      id: getId('deck-toggle'),
      label: 'Full deck',
      tooltipContent: 'Include Minor Arcana',
      tooltipAria: 'About deck size',
      srDescription: 'Toggle between the full 78-card deck and the Major Arcana-only deck.',
      active: includeMinors,
      Icon: Stack,
      onToggle: value => setIncludeMinors?.(value)
    }
  ];

  return (
    <div className={`${controlShellClass} ${className}`}>
      <div className="mb-3">
        <h3 className="text-xs sm:text-sm font-serif text-accent uppercase tracking-[0.12em] flex items-center gap-2">
          <Stack className="w-4 h-4" aria-hidden="true" />
          Experience Preferences
        </h3>
        <p className="text-[0.7rem] text-muted mt-1">Theme, deck scope, and interpretation lens</p>
      </div>

      <div className="space-y-2 sm:space-y-3">
        {/* Theme and Deck toggles */}
        <div
          className="grid grid-cols-1 gap-2 sm:grid-cols-2 sm:gap-3"
          role="group"
          aria-label="Theme and deck controls"
        >
          {experienceToggles.map(item => {
            const ItemIcon = item.Icon;
            const labelId = `${item.id}-label`;
            const descriptionId = `${item.id}-description`;

            return (
              <div
                key={item.id}
                className={`${tileBaseClass} ${item.active ? activeTileClass : inactiveTileClass}`}
              >
                <span
                  className={`${iconWrapperBase} ${
                    item.active ? activeIconWrapper : inactiveIconWrapper
                  }`}
                  aria-hidden="true"
                >
                  <ItemIcon className="h-4 w-4" />
                </span>

                <div className="min-w-0 flex-1">
                  <div className="flex items-center gap-1.5">
                    <span id={labelId} className="text-sm font-semibold text-main">
                      {item.label}
                    </span>
                    <Tooltip
                      content={item.tooltipContent}
                      position="top"
                      triggerClassName={infoButtonClass}
                      ariaLabel={item.tooltipAria}
                    >
                      <Info className="h-3.5 w-3.5" />
                    </Tooltip>
                  </div>
                  <span id={descriptionId} className="sr-only">
                    {item.srDescription}
                  </span>
                </div>

                <GlowToggle
                  checked={item.active}
                  onChange={item.onToggle}
                  labelId={labelId}
                  describedBy={descriptionId}
                />
              </div>
            );
          })}
        </div>

        {/* Reversal Framework */}
        <div className={`${tileBaseClass} ${activeTileClass}`}>
          <span className={`${iconWrapperBase} ${activeIconWrapper}`} aria-hidden="true">
            <ArrowCounterClockwise className="h-4 w-4" />
          </span>

          <div className="min-w-0 flex-1">
            <div className="flex items-center gap-1.5 mb-2">
              <span className="text-sm font-semibold text-main">Reversal lens</span>
              <Tooltip
                content="Reversal interpretation style"
                position="top"
                triggerClassName={infoButtonClass}
                ariaLabel="About reversal lens options"
              >
                <Info className="h-3.5 w-3.5" />
              </Tooltip>
            </div>
            <select
              id={getId('reversal-framework-select')}
              className={`${reversalSelectClass} w-full`}
              value={reversalFramework || 'auto'}
              onChange={event => {
                const value = event.target.value === 'auto' ? null : event.target.value;
                setReversalFramework(value);
              }}
              aria-describedby={getId('reversal-description')}
            >
              <option value="auto">Auto (recommended)</option>
              <option value="blocked">Blocked energy</option>
              <option value="delayed">Timing & delays</option>
              <option value="internalized">Internal process</option>
              <option value="contextual">Context-based</option>
              <option value="shadow">Shadow Integration (Jungian)</option>
              <option value="mirror">Mirror / reflection</option>
              <option value="potentialBlocked">Unrealized potential</option>
            </select>
          </div>
        </div>
      </div>

      <span id={getId('reversal-description')} className="sr-only">
        Choose how reversed cards are interpreted in AI-generated readings.
      </span>

      {reversalFramework && (
        <HelperToggle className="mt-2 max-w-xl">
          <div className="rounded-2xl border border-secondary/25 bg-secondary/5 px-3 py-2 text-[clamp(0.78rem,2vw,0.92rem)] leading-snug text-muted">
            {reversalFramework === 'blocked' && (
              <><span className="font-semibold text-secondary">Blocked</span> — themes face resistance or barriers</>
            )}
            {reversalFramework === 'delayed' && (
              <><span className="font-semibold text-secondary">Delayed</span> — timing not yet right</>
            )}
            {reversalFramework === 'internalized' && (
              <><span className="font-semibold text-secondary">Internal</span> — processing beneath the surface</>
            )}
            {reversalFramework === 'contextual' && (
              <><span className="font-semibold text-secondary">Contextual</span> — adapts to card and position</>
            )}
            {reversalFramework === 'shadow' && (
              <><span className="font-semibold text-secondary">Shadow</span> — surface hidden feelings and name a reintegration micro-practice</>
            )}
            {reversalFramework === 'mirror' && (
              <><span className="font-semibold text-secondary">Mirror</span> — examine what energy you might be projecting or attracting</>
            )}
            {reversalFramework === 'potentialBlocked' && (
              <><span className="font-semibold text-secondary">Potential</span> — treat reversals as dormant strengths awaiting activation</>
            )}
          </div>
        </HelperToggle>
      )}
    </div>
  );
}
</file>

<file path="src/components/FeedbackPanel.jsx">
import { useReducer, useMemo, useId } from 'react';

const RATING_FIELDS = [
  {
    key: 'overallAccuracy',
    label: 'Accuracy',
    helper: 'Did it match the cards?'
  },
  {
    key: 'narrativeCoherence',
    label: 'Coherence',
    helper: 'Did it flow naturally?'
  },
  {
    key: 'practicalValue',
    label: 'Actionability',
    helper: 'Can you use this?'
  }
];

const SCALE = [1, 2, 3, 4, 5];
const SCALE_LABELS = ['Poor', 'Fair', 'Good', 'Great', 'Excellent'];

// Use reducer for cleaner state management
const initialState = {
  ratings: {
    overallAccuracy: 0,
    narrativeCoherence: 0,
    practicalValue: 0
  },
  notes: '',
  status: 'idle', // 'idle' | 'submitting' | 'success' | 'error'
  error: null
};

function feedbackReducer(state, action) {
  switch (action.type) {
    case 'SET_RATING':
      return {
        ...state,
        ratings: { ...state.ratings, [action.key]: action.value }
      };
    case 'SET_NOTES':
      return { ...state, notes: action.value };
    case 'SUBMIT_START':
      return { ...state, status: 'submitting', error: null };
    case 'SUBMIT_SUCCESS':
      return { ...state, status: 'success' };
    case 'SUBMIT_ERROR':
      return { ...state, status: 'error', error: action.error };
    default:
      return state;
  }
}

export function FeedbackPanel({
  requestId,
  spreadKey,
  spreadName,
  deckStyle,
  provider,
  userQuestion,
  cards,
  visionSummary
}) {
  const [state, dispatch] = useReducer(feedbackReducer, initialState);
  const { ratings, notes, status, error } = state;
  const statusId = useId();
  const errorId = useId();

  const hasSubmitted = status === 'success';
  const isSubmitting = status === 'submitting';

  const canSubmit = useMemo(
    () =>
      requestId &&
      Object.values(ratings).every((value) => Number(value) >= 1) &&
      !isSubmitting,
    [ratings, requestId, isSubmitting]
  );

  if (!requestId) return null;

  const handleRating = (key, value) => {
    dispatch({ type: 'SET_RATING', key, value });
  };

  const handleSubmit = async (event) => {
    event.preventDefault();
    if (!canSubmit) return;

    dispatch({ type: 'SUBMIT_START' });

    try {
      const payload = {
        requestId,
        spreadKey,
        spreadName,
        deckStyle,
        provider,
        userQuestion,
        ratings,
        notes: notes.trim() || null,
        cards,
        visionSummary
      };
      const response = await fetch('/api/feedback', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        throw new Error('Unable to save feedback.');
      }
      dispatch({ type: 'SUBMIT_SUCCESS' });
    } catch (err) {
      dispatch({ type: 'SUBMIT_ERROR', error: err.message || 'Unable to save feedback.' });
    }
  };

  return (
    <form
      onSubmit={handleSubmit}
      className="modern-surface border border-secondary/30 w-full px-3 py-3 xs:px-4 xs:py-4 sm:px-5 sm:py-5 animate-fade-in"
      aria-describedby={error ? errorId : undefined}
    >
      <div className="flex items-center justify-between gap-2">
        <div className="min-w-0">
          <p className="text-sm font-semibold text-main">How did this reading land?</p>
          <p className="text-xs text-muted">
            Private ratings help tune quality.
          </p>
        </div>
        {hasSubmitted && (
          <span
            className="text-xs font-semibold text-secondary shrink-0"
            role="status"
            aria-live="polite"
          >
            Thank you ✦
          </span>
        )}
      </div>

      <div className="mt-3 xs:mt-4 space-y-3 xs:space-y-4">
        {RATING_FIELDS.map((field) => {
          const groupId = `rating-group-${field.key}`;
          return (
            <fieldset key={field.key} className="border-none p-0 m-0">
              <legend id={groupId} className="text-xs text-main/90 mb-2">
                <span className="font-medium">{field.label}</span>
                <span className="text-muted"> · {field.helper}</span>
              </legend>
              <div
                role="radiogroup"
                aria-labelledby={groupId}
                className="flex flex-wrap gap-1.5 xs:gap-2"
              >
                {SCALE.map((value, index) => {
                  const isSelected = ratings[field.key] === value;
                  return (
                    <button
                      type="button"
                      key={`${field.key}-${value}`}
                      role="radio"
                      aria-checked={isSelected}
                      aria-label={`${value} out of 5, ${SCALE_LABELS[index]}`}
                      onClick={() => handleRating(field.key, value)}
                      disabled={hasSubmitted}
                      className={`min-h-[44px] min-w-[44px] px-2.5 xs:px-3 py-2 rounded-full border text-sm font-medium transition-colors touch-manipulation
                        focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/70 focus-visible:ring-offset-2
                        ${isSelected
                          ? 'border-secondary/70 bg-secondary/20 text-secondary'
                          : 'border-accent/30 bg-surface-muted/70 text-muted hover:border-accent/60 hover:bg-surface-muted active:bg-surface-muted/90'
                        }
                        ${hasSubmitted ? 'cursor-not-allowed opacity-60' : ''}
                      `}
                    >
                      {value}
                    </button>
                  );
                })}
              </div>
            </fieldset>
          );
        })}
      </div>

      <div className="mt-4">
        <label htmlFor="feedback-notes" className="block text-xs text-muted mb-1">
          Additional notes (optional)
        </label>
        <textarea
          id="feedback-notes"
          value={notes}
          onChange={(event) => dispatch({ type: 'SET_NOTES', value: event.target.value })}
          rows={3}
          maxLength={750}
          disabled={hasSubmitted}
          className="w-full rounded-lg border border-accent/20 bg-surface/70 p-3 text-sm text-main placeholder:text-muted/60 focus:border-secondary/60 focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/70 disabled:opacity-60 disabled:cursor-not-allowed"
          placeholder="What resonated or felt off?"
        />
        <p className="mt-1 text-xs text-muted/70 text-right">
          {notes.length} / 750
        </p>
      </div>

      {/* Status announcements for screen readers */}
      <div
        id={statusId}
        role="status"
        aria-live="polite"
        className="sr-only"
      >
        {isSubmitting && 'Submitting feedback...'}
        {hasSubmitted && 'Feedback submitted successfully.'}
      </div>

      {error && (
        <p id={errorId} className="mt-2 text-xs text-error" role="alert">
          {error}
        </p>
      )}

      <div className="mt-4 flex items-center justify-between gap-4">
        <button
          type="submit"
          disabled={!canSubmit || hasSubmitted}
          className="min-h-[44px] px-5 py-2.5 rounded-full border border-secondary/40 bg-secondary/20 text-sm font-medium text-secondary transition-colors touch-manipulation
            hover:bg-secondary/30 focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/70 focus-visible:ring-offset-2
            disabled:opacity-40 disabled:cursor-not-allowed disabled:hover:bg-secondary/20"
        >
          {isSubmitting ? 'Sending…' : hasSubmitted ? 'Feedback saved' : 'Submit feedback'}
        </button>

        {/* Vision metrics - only shown when available, with clearer labels */}
        {(visionSummary?.avgConfidence > 0 || typeof visionSummary?.avgSymbolMatch === 'number') && (
          <div className="text-xs text-muted/80 text-right" aria-label="Reading quality metrics">
            {visionSummary?.avgConfidence > 0 && (
              <p title="How confident the system was in identifying the cards">
                Recognition: {(visionSummary.avgConfidence * 100).toFixed(0)}%
              </p>
            )}
            {typeof visionSummary?.avgSymbolMatch === 'number' && visionSummary.avgSymbolMatch > 0 && (
              <p title="How well the symbols matched the interpretation">
                Symbol accuracy: {(visionSummary.avgSymbolMatch * 100).toFixed(0)}%
              </p>
            )}
          </div>
        )}
      </div>
    </form>
  );
}
</file>

<file path="src/components/GlobalNav.jsx">
import { useLocation, useNavigate } from 'react-router-dom';
import { Sparkle, BookOpen } from './icons';
import { Icon, ICON_SIZES } from './Icon';
import { UserMenu } from './UserMenu';

export function GlobalNav({ condensed = false, withUserChip = false }) {
  const location = useLocation();
  const navigate = useNavigate();

  const isJournal = location.pathname.startsWith('/journal');
  const isReading = !isJournal;

  const baseButtonClasses = `
    inline-flex items-center justify-center gap-1.5
    rounded-full font-semibold
    transition-all touch-manipulation
    focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/80
    focus-visible:ring-offset-2 focus-visible:ring-offset-main
    active:scale-[0.97]
    min-h-[44px]
  `;

  const buttonPadding = condensed
    ? 'px-3 sm:px-3.5 py-2 text-xs-plus'
    : 'px-3.5 sm:px-5 py-2.5 text-sm';
  const buttonWidth = condensed
    ? 'flex-1 basis-[38%] min-w-[36%] sm:min-w-[9rem] sm:basis-auto'
    : 'flex-1 basis-[38%] min-w-[36%] sm:min-w-[10rem] sm:basis-auto';

  const activeClasses = 'bg-primary text-surface shadow shadow-primary/30 active:bg-primary/90';
  const inactiveClasses = `
    bg-surface text-main/85 border border-secondary/50
    hover:bg-surface-muted hover:text-main hover:border-secondary/60
    active:bg-surface-muted
  `;

  return (
    <nav
      aria-label="Primary navigation"
      className={`flex ${condensed ? 'justify-start mb-1.5' : 'justify-center mb-3'} animate-fade-in w-full`}
    >
      <div
        className={`
          inline-flex items-center flex-wrap sm:flex-nowrap w-full max-w-full
          ${condensed ? 'gap-1 sm:gap-1.5 px-1.5 py-1 shadow-inner shadow-main/20' : 'gap-1.5 sm:gap-2 px-1.5 py-1'}
          rounded-full sm:bg-surface/80 bg-surface/60 border border-transparent sm:border-accent/20
        `}
      >
        <button
          type="button"
          onClick={() => navigate('/')}
          className={`${baseButtonClasses} ${buttonPadding} ${buttonWidth} ${isReading ? activeClasses : inactiveClasses}`}
          aria-current={isReading ? 'page' : undefined}
        >
          <Icon icon={Sparkle} size={condensed ? ICON_SIZES.md : ICON_SIZES.lg} decorative />
          <span>Reading</span>
        </button>
        <button
          type="button"
          onClick={() => navigate('/journal')}
          className={`${baseButtonClasses} ${buttonPadding} ${buttonWidth} ${isJournal ? activeClasses : inactiveClasses}`}
          aria-current={isJournal ? 'page' : undefined}
        >
          <Icon icon={BookOpen} size={condensed ? ICON_SIZES.md : ICON_SIZES.lg} decorative />
          <span>Journal</span>
        </button>

        {withUserChip && (
          <div className="ml-auto flex-none sm:hidden">
            <UserMenu condensed />
          </div>
        )}
      </div>
    </nav>
  );
}
</file>

<file path="src/components/GlowToggle.jsx">
import { useState, useEffect, useRef } from 'react';

/**
 * GlowToggle - A clean toggle switch with subtle glow feedback on state change
 */
export function GlowToggle({
  checked,
  onChange,
  disabled = false,
  label,
  labelId,
  describedBy
}) {
  const [glowing, setGlowing] = useState(false);
  const isFirstRender = useRef(true);
  const prevChecked = useRef(checked);

  // Trigger glow animation on state change (not on initial render)
  useEffect(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      prevChecked.current = checked;
      return;
    }

    if (prevChecked.current !== checked) {
      prevChecked.current = checked;
    }
  }, [checked]);

  // Handle glow timeout separately
  useEffect(() => {
    if (!glowing) return;
    const timer = setTimeout(() => setGlowing(false), 400);
    return () => clearTimeout(timer);
  }, [glowing]);

  const handleToggle = () => {
    if (disabled) return;
    setGlowing(true);
    onChange(!checked);
  };

  // Track: 44x24 for good mobile touch target and visibility
  // Thumb: 20x20 centered vertically with 2px padding
  const trackWidth = 44;
  const trackHeight = 24;
  const thumbSize = 20;
  const thumbTravel = trackWidth - thumbSize - 4; // 4px total padding (2px each side)

  return (
    <button
      type="button"
      role="switch"
      aria-checked={checked}
      aria-label={labelId ? undefined : label}
      aria-labelledby={labelId}
      aria-describedby={describedBy}
      disabled={disabled}
      onClick={handleToggle}
      style={{
        position: 'relative',
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        width: trackWidth,
        height: trackHeight,
        padding: 0,
        border: 'none',
        background: 'none',
        cursor: disabled ? 'not-allowed' : 'pointer',
        opacity: disabled ? 0.5 : 1,
        WebkitTapHighlightColor: 'transparent',
        touchAction: 'manipulation',
      }}
    >
      {/* Track */}
      <span
        style={{
          position: 'absolute',
          inset: 0,
          borderRadius: trackHeight / 2,
          backgroundColor: checked ? 'rgba(168, 162, 158, 0.4)' : 'rgba(30, 28, 26, 0.8)',
          border: checked ? '1.5px solid rgba(168, 162, 158, 0.7)' : '1.5px solid rgba(168, 162, 158, 0.3)',
          transition: 'all 200ms ease-out',
          boxShadow: glowing
            ? checked
              ? '0 0 12px 3px rgba(212, 184, 150, 0.5)'
              : '0 0 8px 2px rgba(168, 162, 158, 0.3)'
            : 'none',
        }}
        aria-hidden="true"
      />
      {/* Thumb */}
      <span
        style={{
          position: 'absolute',
          left: 2,
          width: thumbSize,
          height: thumbSize,
          borderRadius: '50%',
          backgroundColor: checked ? '#d4b896' : 'rgba(168, 162, 158, 0.6)',
          transform: `translateX(${checked ? thumbTravel : 0}px) scale(${glowing ? 1.1 : 1})`,
          transition: 'all 200ms ease-out',
          boxShadow: checked
            ? '0 2px 8px rgba(212, 184, 150, 0.5)'
            : '0 1px 3px rgba(0, 0, 0, 0.3)',
        }}
        aria-hidden="true"
      />
    </button>
  );
}
</file>

<file path="src/components/GuidedIntentionCoach.jsx">
import { Fragment, useEffect, useLayoutEffect, useMemo, useRef, useState, useId } from 'react';
import FocusTrap from 'focus-trap-react';
import {
  ChartLine,
  ArrowLeft,
  ArrowRight,
  BookmarkSimple,
  ClockCounterClockwise,
  ArrowsClockwise,
  Sparkle,
  MagicWand,
  X
} from '@phosphor-icons/react';
import { useModalA11y, createBackdropHandler } from '../hooks/useModalA11y';
import { useSmallScreen } from '../hooks/useSmallScreen';
import { useLandscape } from '../hooks/useLandscape';
import { useReducedMotion } from '../hooks/useReducedMotion';
import { usePreferences } from '../contexts/PreferencesContext';
import {
  INTENTION_TOPIC_OPTIONS,
  INTENTION_TIMEFRAME_OPTIONS,
  INTENTION_DEPTH_OPTIONS,
  buildGuidedQuestion,
  buildCreativeQuestion,
  getCoachSummary
} from '../lib/intentionCoach';
import { scoreQuestion, getQualityLevel } from '../lib/questionQuality';
import { loadCoachRecommendation, loadStoredJournalInsights, loadCoachStatsSnapshot } from '../lib/journalInsights';
import {
  loadCoachTemplates,
  saveCoachTemplate,
  deleteCoachTemplate,
  loadCoachHistory,
  recordCoachQuestion,
  MAX_TEMPLATES
} from '../lib/coachStorage';
import { MOBILE_COACH_DIALOG_ID } from './MobileActionBar';
import { normalizeThemeLabel } from '../lib/themeText';

// ============================================================================
// Constants
// ============================================================================

const STEPS = [
  { id: 'topic', label: 'Topic' },
  { id: 'timeframe', label: 'Timeframe' },
  { id: 'depth', label: 'Depth' }
];

const COACH_PREFS_KEY = 'tarot-coach-preferences';
const SUGGESTIONS_PER_PAGE = 5;

// Timing constants (milliseconds)
const TIMING = {
  CREATIVE_DEBOUNCE: 800,
  STATUS_DISPLAY_SHORT: 1800,
  STATUS_DISPLAY_MEDIUM: 2600,
  STATUS_DISPLAY_LONG: 5000,
  PREFS_EXPIRY: 7 * 24 * 60 * 60 * 1000 // 1 week
};

const CONTEXT_HINTS = {
  love: {
    label: 'Relationship reciprocity',
    topic: 'relationships',
    timeframe: 'week',
    depth: 'guided',
    customFocus: 'my closest relationships and how I can nurture reciprocity'
  },
  career: {
    label: 'Purpose & vocation pulse',
    topic: 'career',
    timeframe: 'month',
    depth: 'guided',
    customFocus: 'my career direction and purpose'
  },
  self: {
    label: 'Inner growth focus',
    topic: 'growth',
    timeframe: 'open',
    depth: 'lesson',
    customFocus: 'my inner growth and healing'
  },
  spiritual: {
    label: 'Spiritual practice check-in',
    topic: 'growth',
    timeframe: 'season',
    depth: 'deep',
    customFocus: 'my spiritual practice and devotion'
  },
  wellbeing: {
    label: 'Energy & wellbeing tune-up',
    topic: 'wellbeing',
    timeframe: 'week',
    depth: 'guided',
    customFocus: 'my wellbeing and daily balance'
  },
  decision: {
    label: 'Navigating a decision',
    topic: 'decision',
    timeframe: 'week',
    depth: 'guided',
    customFocus: 'the decision currently on my mind'
  }
};

// Map spreads to suggested topics
const SPREAD_TO_TOPIC_MAP = {
  relationship: 'relationships',
  decision: 'decision',
  celtic: 'growth',
  fiveCard: 'wellbeing',
  threeCard: null,
  single: null
};

// Friendly spread names for hints
const SPREAD_NAMES = {
  relationship: 'Relationship Snapshot',
  decision: 'Decision',
  celtic: 'Celtic Cross',
  fiveCard: 'Five-Card Clarity',
  threeCard: 'Three-Card Story',
  single: 'One-Card Insight'
};

// Map onboarding focus areas to intention topics
const FOCUS_AREA_TO_TOPIC = {
  love: 'relationships',
  career: 'career',
  self_worth: 'growth',
  healing: 'wellbeing',
  creativity: 'career',
  spirituality: 'growth'
};

const baseOptionClass =
  'text-left rounded-2xl border bg-surface-muted/50 px-4 py-4 transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent focus-visible:ring-offset-2 focus-visible:ring-offset-main';

// ============================================================================
// Helper Functions
// ============================================================================

function describePrefillSource(source) {
  if (!source) return null;
  const label = typeof source.label === 'string' ? source.label.trim() : '';
  const normalizedSource = typeof source.source === 'string' ? source.source.toLowerCase() : '';

  if (normalizedSource === 'template') {
    return label ? `template "${label}"` : 'a saved template';
  }

  if (normalizedSource === 'suggestion') {
    return label ? `suggestion "${label}"` : 'a personalized suggestion';
  }

  if (normalizedSource === 'journal' || normalizedSource === 'insight' || normalizedSource === 'insights') {
    return label ? `journal insight "${label}"` : 'your journal insights';
  }

  if (normalizedSource && label) {
    return `${source.source} "${label}"`;
  }

  if (label) {
    return label;
  }

  if (normalizedSource) {
    return source.source;
  }

  return 'your journal insights';
}

function buildPersonalizedSuggestions(stats, history = []) {
  const suggestions = [];

  if (stats?.frequentCards?.length) {
    stats.frequentCards.slice(0, 2).forEach((card, idx) => {
      const label =
        idx === 0 ? `Recurring card: ${card.name}` : `${card.name} keeps showing up`;
      suggestions.push({
        id: `card-${card.name}-${idx}`,
        label,
        helper: `${card.count} pulls logged${card.reversed ? ` (${card.reversed} reversed)` : ''}`,
        question: `What is ${card.name} inviting me to embody next?`,
        topic: 'growth',
        timeframe: 'open',
        depth: 'lesson',
        customFocus: `${card.name} recurring energy`
      });
    });
  }

  if (Array.isArray(stats?.recentThemes)) {
    stats.recentThemes.slice(0, 2).forEach((theme, idx) => {
      const label = normalizeThemeLabel(theme);
      if (!label) return;
      suggestions.push({
        id: `theme-${idx}`,
        label: `Lean into: ${label}`,
        helper: 'Recent journal theme',
        topic: 'growth',
        timeframe: 'month',
        depth: 'guided',
        customFocus: label
      });
    });
  }

  if (Array.isArray(stats?.contextBreakdown) && stats.contextBreakdown.length > 0) {
    const primary = stats.contextBreakdown.slice().sort((a, b) => b.count - a.count)[0];
    const hint = CONTEXT_HINTS[primary.name];
    if (hint) {
      suggestions.push({
        id: `context-${primary.name}`,
        label: hint.label,
        helper: `Most logged context (${primary.count})`,
        topic: hint.topic,
        timeframe: hint.timeframe,
        depth: hint.depth,
        customFocus: hint.customFocus
      });
    }
  }

  if (Array.isArray(history) && history.length > 0) {
    const last = history[0];
    suggestions.push({
      id: `history-${last.id}`,
      label: 'Revisit your last question',
      helper: last.question,
      question: last.question
    });
  }

  return suggestions;
}

function getTopicLabel(value) {
  return INTENTION_TOPIC_OPTIONS.find(option => option.value === value)?.label || null;
}

function getTimeframeLabel(value) {
  return INTENTION_TIMEFRAME_OPTIONS.find(option => option.value === value)?.label || null;
}

function getDepthLabel(value) {
  return INTENTION_DEPTH_OPTIONS.find(option => option.value === value)?.label || null;
}

// ============================================================================
// Component
// ============================================================================

export function GuidedIntentionCoach({ isOpen, selectedSpread, onClose, onApply, prefillRecommendation = null }) {
  const isLandscape = useLandscape();
  const _isSmallScreen = useSmallScreen();
  const prefersReducedMotion = useReducedMotion();
  const { personalization } = usePreferences();
  const [step, setStep] = useState(0);

  // Determine suggested topic from focus areas, falling back to spread
  const focusAreaSuggestedTopic = useMemo(() => {
    if (!Array.isArray(personalization?.focusAreas)) return null;
    for (const area of personalization.focusAreas) {
      const mapped = FOCUS_AREA_TO_TOPIC[area];
      if (mapped) return mapped;
    }
    return null;
  }, [personalization?.focusAreas]);

  const spreadSuggestedTopic = useMemo(() => {
    return SPREAD_TO_TOPIC_MAP[selectedSpread] || null;
  }, [selectedSpread]);

  const suggestedTopic = useMemo(() => {
    return focusAreaSuggestedTopic || spreadSuggestedTopic || INTENTION_TOPIC_OPTIONS[0].value;
  }, [focusAreaSuggestedTopic, spreadSuggestedTopic]);

  const [topic, setTopic] = useState(suggestedTopic);
  const [timeframe, setTimeframe] = useState(INTENTION_TIMEFRAME_OPTIONS[1].value);
  const [depth, setDepth] = useState(INTENTION_DEPTH_OPTIONS[1].value);
  const [customFocus, setCustomFocus] = useState('');
  const [useCreative, setUseCreative] = useState(false);
  const [questionText, setQuestionText] = useState('');
  const [questionLoading, setQuestionLoading] = useState(false);
  const [questionError, setQuestionError] = useState('');
  const [historyStatus, setHistoryStatus] = useState('');
  const [autoQuestionEnabled, setAutoQuestionEnabled] = useState(true);
  const [prefillSource, setPrefillSource] = useState(null);
  const [templates, setTemplates] = useState([]);
  const [newTemplateLabel, setNewTemplateLabel] = useState('');
  const [templateStatus, setTemplateStatus] = useState('');
  const [questionHistory, setQuestionHistory] = useState([]);
  const [coachStats, setCoachStats] = useState(null);
  const [_coachStatsMeta, setCoachStatsMeta] = useState(null);
  const [personalizedSuggestions, setPersonalizedSuggestions] = useState([]);
  const [suggestionsPage, setSuggestionsPage] = useState(0);
  const [isTemplatePanelOpen, setTemplatePanelOpen] = useState(false);
  const [remixCount, setRemixCount] = useState(0);
  const [astroHighlights, setAstroHighlights] = useState([]);
  const [astroWindowDays, setAstroWindowDays] = useState(null);
  const [astroSource, setAstroSource] = useState(null);

  // Refs
  const modalRef = useRef(null);
  const closeButtonRef = useRef(null);
  const depthSectionRef = useRef(null);
  const customFocusRef = useRef(null);
  const stepButtonRefs = useRef([]);
  const titleId = useId();
  const timeoutRefs = useRef([]);
  const hasInitializedRef = useRef(false);

  // Use modal accessibility hook for scroll lock, escape key, and focus restoration
  // trapFocus: false because FocusTrap library handles focus trapping
  useModalA11y(isOpen, {
    onClose,
    containerRef: modalRef,
    trapFocus: false,
    initialFocusRef: closeButtonRef,
  });

  // Clear step button refs on each render to prevent stale references
  useLayoutEffect(() => {
    stepButtonRefs.current = [];
  });

  // ============================================================================
  // Utility Functions
  // ============================================================================

  const releasePrefill = () => {
    if (prefillSource) {
      setPrefillSource(null);
      setAutoQuestionEnabled(true);
    }
  };

  const scheduleTimeout = (callback, delay) => {
    const id = setTimeout(() => {
      timeoutRefs.current = timeoutRefs.current.filter(timeoutId => timeoutId !== id);
      callback();
    }, delay);
    timeoutRefs.current.push(id);
    return id;
  };

  const clearAllTimeouts = () => {
    timeoutRefs.current.forEach(id => clearTimeout(id));
    timeoutRefs.current = [];
  };

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      clearAllTimeouts();
    };
  }, []);

  const prefillSourceDescription = useMemo(
    () => describePrefillSource(prefillSource),
    [prefillSource]
  );

  const _refreshSuggestions = () => {
    setPersonalizedSuggestions(buildPersonalizedSuggestions(coachStats, questionHistory));
    setSuggestionsPage(0);
  };

  // ============================================================================
  // Derived State
  // ============================================================================

  // Generate deterministic seed from user selections
  const questionSeed = useMemo(() => {
    return `${topic}|${timeframe}|${depth}|${customFocus}|${remixCount}`;
  }, [topic, timeframe, depth, customFocus, remixCount]);

  const guidedQuestion = useMemo(
    () => buildGuidedQuestion({ topic, timeframe, depth, customFocus, seed: questionSeed }),
    [topic, timeframe, depth, customFocus, questionSeed]
  );

  const questionQuality = useMemo(
    () => scoreQuestion(questionText || guidedQuestion || ''),
    [questionText, guidedQuestion]
  );

  const qualityLevel = useMemo(
    () => getQualityLevel(questionQuality.score),
    [questionQuality.score]
  );

  const summary = getCoachSummary({ topic, timeframe, depth });

  const questionContextChips = useMemo(() => {
    const chips = [];
    if (summary.topicLabel) {
      chips.push({ label: summary.topicLabel, type: 'Topic', step: 0 });
    }
    if (summary.timeframeLabel) {
      chips.push({ label: summary.timeframeLabel, type: 'Timing', step: 1 });
    }
    if (summary.depthLabel) {
      chips.push({ label: summary.depthLabel, type: 'Depth', step: 2 });
    }
    if (customFocus?.trim()) {
      chips.push({ label: customFocus.trim(), type: 'Detail', action: 'focus' });
    }
    return chips;
  }, [summary.topicLabel, summary.timeframeLabel, summary.depthLabel, customFocus]);

  const qualityHelperText = useMemo(() => {
    if (questionQuality.score >= 85) return 'Ready to anchor into your spread.';
    if (questionQuality.score >= 65) return 'Add one more detail for extra clarity.';
    if (questionQuality.score >= 40) return 'Sharpen the focus to strengthen it.';
    return 'Try reframing it from a curious, open-ended angle.';
  }, [questionQuality.score]);

  const normalizedQualityScore = Math.min(Math.max(questionQuality.score, 0), 100);

  const _suggestionPageCount = useMemo(() => {
    if (personalizedSuggestions.length === 0) return 0;
    return Math.ceil(personalizedSuggestions.length / SUGGESTIONS_PER_PAGE);
  }, [personalizedSuggestions.length]);

  const _visibleSuggestions = useMemo(() => {
    if (personalizedSuggestions.length === 0) return [];
    const start = suggestionsPage * SUGGESTIONS_PER_PAGE;
    return personalizedSuggestions.slice(start, start + SUGGESTIONS_PER_PAGE);
  }, [personalizedSuggestions, suggestionsPage]);

  // ============================================================================
  // Event Handlers
  // ============================================================================

  const handleSaveTemplate = () => {
    const label = newTemplateLabel.trim();
    if (!label) {
      setTemplateStatus('Add a template name first.');
      return;
    }
    const trimmedQuestion = (questionText || guidedQuestion || '').trim();
    if (!trimmedQuestion) {
      setTemplateStatus('Add or generate a question before saving.');
      return;
    }
    const normalizedLabel = label.toLowerCase();
    const previousTemplateCount = templates.length;
    const replacedExisting = templates.some(template => template.label?.toLowerCase() === normalizedLabel);
    const payload = {
      label,
      topic,
      timeframe,
      depth,
      customFocus,
      useCreative,
      savedQuestion: trimmedQuestion
    };
    const result = saveCoachTemplate(payload);
    if (result.success) {
      setTemplates(result.templates);
      const archivedOldest =
        !replacedExisting &&
        previousTemplateCount >= MAX_TEMPLATES &&
        (result.templates?.length || 0) >= MAX_TEMPLATES;
      const status = archivedOldest
        ? 'Template saved (oldest archived to keep 8 max).'
        : replacedExisting
          ? 'Template updated'
          : 'Template saved';
      setTemplateStatus(status);
      setNewTemplateLabel('');
      scheduleTimeout(() => setTemplateStatus(''), TIMING.STATUS_DISPLAY_MEDIUM);
    } else if (result.error) {
      setTemplateStatus(result.error);
      scheduleTimeout(() => setTemplateStatus(''), TIMING.STATUS_DISPLAY_MEDIUM);
    }
  };

  const handleApplyTemplate = (template) => {
    if (!template) return;
    if (template.topic && template.topic !== topic) {
      releasePrefill();
      setTopic(template.topic);
    }
    if (template.timeframe && template.timeframe !== timeframe) {
      setTimeframe(template.timeframe);
    }
    if (template.depth && template.depth !== depth) {
      setDepth(template.depth);
    }
    setCustomFocus(template.customFocus || '');
    setUseCreative(Boolean(template.useCreative));
    if (template.savedQuestion) {
      setQuestionText(template.savedQuestion);
      setAutoQuestionEnabled(false);
    } else {
      setAutoQuestionEnabled(true);
    }
    setQuestionError('');
    setQuestionLoading(false);
    setPrefillSource({
      source: 'template',
      label: template.label
    });
  };

  const handleDeleteTemplate = (templateId) => {
    const result = deleteCoachTemplate(templateId);
    if (result.success) {
      setTemplates(result.templates);
      setTemplateStatus('Template removed');
      scheduleTimeout(() => setTemplateStatus(''), TIMING.STATUS_DISPLAY_SHORT);
    } else if (result.error) {
      setTemplateStatus(result.error);
      scheduleTimeout(() => setTemplateStatus(''), TIMING.STATUS_DISPLAY_MEDIUM);
    }
  };

  const handleApplySuggestion = (suggestion) => {
    if (!suggestion) return;
    if (suggestion.topic && suggestion.topic !== topic) {
      releasePrefill();
      setTopic(suggestion.topic);
    }
    if (suggestion.timeframe && suggestion.timeframe !== timeframe) {
      setTimeframe(suggestion.timeframe);
    }
    if (suggestion.depth && suggestion.depth !== depth) {
      setDepth(suggestion.depth);
    }
    if (typeof suggestion.customFocus === 'string') {
      setCustomFocus(suggestion.customFocus);
    }
    if (typeof suggestion.useCreative === 'boolean') {
      setUseCreative(suggestion.useCreative);
    }
    if (suggestion.question) {
      setQuestionText(suggestion.question);
      setAutoQuestionEnabled(false);
    } else {
      setAutoQuestionEnabled(true);
    }
    setQuestionError('');
    setQuestionLoading(false);
    setPrefillSource({
      source: 'suggestion',
      label: suggestion.label
    });
  };

  const handleApplyHistoryQuestion = (historyItem) => {
    if (!historyItem) return;
    handleApplySuggestion({
      label: 'Recent question',
      question: historyItem.question
    });
  };

  const canGoNext = () => {
    if (step === 0) return Boolean(topic);
    if (step === 1) return Boolean(timeframe);
    if (step === 2) return Boolean(depth);
    return false;
  };

  const goNext = () => {
    if (step < STEPS.length - 1 && canGoNext()) {
      setStep(step + 1);
    }
  };

  const goBack = () => {
    if (step > 0) setStep(step - 1);
  };

  // Keyboard navigation for step indicators (roving tabindex pattern)
  const handleStepKeyDown = (event, currentIndex) => {
    let nextIndex = null;

    if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
      event.preventDefault();
      nextIndex = (currentIndex + 1) % STEPS.length;
    } else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
      event.preventDefault();
      nextIndex = (currentIndex - 1 + STEPS.length) % STEPS.length;
    } else if (event.key === 'Home') {
      event.preventDefault();
      nextIndex = 0;
    } else if (event.key === 'End') {
      event.preventDefault();
      nextIndex = STEPS.length - 1;
    } else if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      setStep(currentIndex);
      return;
    }

    if (nextIndex !== null) {
      setStep(nextIndex);
      // Focus the new step button after state update
      requestAnimationFrame(() => {
        stepButtonRefs.current[nextIndex]?.focus();
      });
    }
  };

  const handleApply = async () => {
    const finalQuestion = questionText || guidedQuestion;
    if (!finalQuestion) return;

    // Record question, but don't block apply if storage fails
    const historyResult = recordCoachQuestion(finalQuestion);

    // Update history state with the new list
    if (historyResult?.history) {
      setQuestionHistory(historyResult.history);
      // Refresh suggestions with the NEW history immediately
      setPersonalizedSuggestions(buildPersonalizedSuggestions(coachStats, historyResult.history));
      setSuggestionsPage(0);
    }

    // Save preferences for next time
    try {
      const prefs = {
        lastTopic: topic,
        lastTimeframe: timeframe,
        lastDepth: depth,
        timestamp: Date.now()
      };
      localStorage.setItem(COACH_PREFS_KEY, JSON.stringify(prefs));
    } catch (error) {
      console.warn('Could not save coach preferences:', error);
    }

    // Clear any status messages on success
    if (historyResult?.success) {
      setHistoryStatus('');
    } else {
      const message =
        historyResult?.error ||
        'Your question was used, but we could not save it to recent history. Check storage permissions and try again.';
      setHistoryStatus(message);
    }

    // Apply the question regardless of storage outcome
    onApply?.(finalQuestion);

    if (historyResult?.success) {
      onClose?.();
    }
  };

  // ============================================================================
  // Effects
  // ============================================================================

  // Initialize state when modal opens
  useEffect(() => {
    if (!isOpen) {
      hasInitializedRef.current = false;
      return;
    }

    if (hasInitializedRef.current) {
      return;
    }

    hasInitializedRef.current = true;

    try {
      const saved = JSON.parse(localStorage.getItem(COACH_PREFS_KEY) || '{}');
      const now = Date.now();
      const isRecent = saved.timestamp && (now - saved.timestamp) < TIMING.PREFS_EXPIRY;

      setStep(0);
      setTopic(isRecent && saved.lastTopic ? saved.lastTopic : suggestedTopic);
      setTimeframe(isRecent && saved.lastTimeframe ? saved.lastTimeframe : INTENTION_TIMEFRAME_OPTIONS[1].value);
      setDepth(isRecent && saved.lastDepth ? saved.lastDepth : INTENTION_DEPTH_OPTIONS[1].value);
      setCustomFocus('');
      setUseCreative(false);
      setQuestionText('');
      setQuestionError('');
      setQuestionLoading(false);
      setAutoQuestionEnabled(true);
      setPrefillSource(null);
    } catch (error) {
      console.warn('Could not load coach preferences:', error);
      setStep(0);
      setTopic(suggestedTopic);
      setTimeframe(INTENTION_TIMEFRAME_OPTIONS[1].value);
      setDepth(INTENTION_DEPTH_OPTIONS[1].value);
      setCustomFocus('');
      setUseCreative(false);
      setQuestionText('');
      setQuestionError('');
      setQuestionLoading(false);
      setAutoQuestionEnabled(true);
      setPrefillSource(null);
    }

    const recommendation = prefillRecommendation?.question ? prefillRecommendation : loadCoachRecommendation();
    if (recommendation?.question) {
      if (recommendation.topicValue) {
        setTopic(recommendation.topicValue);
      }
      if (recommendation.timeframeValue) {
        setTimeframe(recommendation.timeframeValue);
      }
      if (recommendation.depthValue) {
        setDepth(recommendation.depthValue);
      }
      setUseCreative(false);
      setQuestionLoading(false);
      setQuestionError('');
      setQuestionText(recommendation.question);
      setPrefillSource(recommendation);
      setAutoQuestionEnabled(false);
    }
  }, [isOpen, suggestedTopic, prefillRecommendation]);

  // Load templates and history when modal opens
  useEffect(() => {
    if (!isOpen) return;
    setTemplates(loadCoachTemplates());
    const history = loadCoachHistory();
    setQuestionHistory(history);
    const insights = loadStoredJournalInsights();
    const snapshot = loadCoachStatsSnapshot();
    if (snapshot?.stats) {
      setCoachStats(snapshot.stats);
      setCoachStatsMeta(snapshot.meta || null);
    } else {
      setCoachStats(insights?.stats || null);
      setCoachStatsMeta(null);
    }
  }, [isOpen]);

  // Build personalized suggestions when stats/history change
  useEffect(() => {
    if (!isOpen) return;
    setPersonalizedSuggestions(buildPersonalizedSuggestions(coachStats, questionHistory));
    setSuggestionsPage(0);
  }, [coachStats, questionHistory, isOpen]);

  // Keep pagination in range when suggestion count changes
  useEffect(() => {
    const totalPages = Math.max(0, Math.ceil(personalizedSuggestions.length / SUGGESTIONS_PER_PAGE) - 1);
    setSuggestionsPage(prev => Math.min(prev, totalPages));
  }, [personalizedSuggestions]);

  // Reset transient state when modal closes
  useEffect(() => {
    if (!isOpen) {
      setTemplateStatus('');
      setNewTemplateLabel('');
      setTemplatePanelOpen(false);
      setHistoryStatus('');
      setSuggestionsPage(0);
      clearAllTimeouts();
    }
  }, [isOpen]);

  // Clear history status after timeout (using scheduleTimeout for consistency)
  useEffect(() => {
    if (!historyStatus) return;
    const timeoutId = scheduleTimeout(() => setHistoryStatus(''), TIMING.STATUS_DISPLAY_LONG);
    return () => clearTimeout(timeoutId);
  }, [historyStatus]);


  // Creative question generation with proper race condition handling
  useEffect(() => {
    const controller = new AbortController();
    let timerId = null;
    let isCancelled = false;

    const safeSetState = (setter, value) => {
      if (!isCancelled) setter(value);
    };

    if (!isOpen) {
      setQuestionText('');
      setAstroHighlights([]);
      setAstroWindowDays(null);
      setAstroSource(null);
      return () => { isCancelled = true; };
    }

    if (!autoQuestionEnabled) {
      return () => { isCancelled = true; };
    }

    // If not in creative mode, update immediately
    if (!useCreative) {
      setQuestionLoading(false);
      setQuestionError('');
      setQuestionText(guidedQuestion);
      setAstroHighlights([]);
      setAstroWindowDays(null);
      setAstroSource(null);
      return () => { isCancelled = true; };
    }

    setQuestionLoading(true);
    setQuestionError('');

    timerId = setTimeout(async () => {
      try {
        const { question: creative, source, forecast } = await buildCreativeQuestion({
          topic,
          timeframe,
          depth,
          customFocus,
          seed: questionSeed,
          focusAreas: personalization?.focusAreas
        }, { signal: controller.signal });

        if (isCancelled || controller.signal.aborted) {
          return;
        }

        if (creative) {
          safeSetState(setQuestionText, creative);
          const isLocalFallback = source === 'local' || source === 'local-fallback' || source === 'api-fallback';
          safeSetState(setQuestionError, isLocalFallback ? 'Using on-device generator for now.' : '');

          if (forecast?.highlights?.length) {
            safeSetState(setAstroHighlights, forecast.highlights);
            safeSetState(setAstroWindowDays, forecast.days || (timeframe === 'season' ? 90 : 30));
            safeSetState(setAstroSource, forecast.source || null);
          } else {
            safeSetState(setAstroHighlights, []);
            safeSetState(setAstroWindowDays, null);
            safeSetState(setAstroSource, null);
          }
        } else {
          safeSetState(setQuestionText, guidedQuestion);
          safeSetState(setQuestionError, 'Personalized mode is temporarily unavailable. Showing guided version.');
          safeSetState(setAstroHighlights, []);
          safeSetState(setAstroWindowDays, null);
          safeSetState(setAstroSource, null);
        }
      } catch (error) {
        if (error?.name === 'AbortError' || isCancelled) {
          return;
        }
        safeSetState(setQuestionText, guidedQuestion);
        safeSetState(setQuestionError, 'Personalized mode is temporarily unavailable. Showing guided version.');
        safeSetState(setAstroHighlights, []);
        safeSetState(setAstroWindowDays, null);
        safeSetState(setAstroSource, null);
      } finally {
        if (!isCancelled && !controller.signal.aborted) {
          safeSetState(setQuestionLoading, false);
        }
      }
    }, TIMING.CREATIVE_DEBOUNCE);

    return () => {
      isCancelled = true;
      if (timerId) clearTimeout(timerId);
      controller.abort();
    };
  }, [guidedQuestion, useCreative, isOpen, autoQuestionEnabled, questionSeed, topic, timeframe, depth, customFocus, personalization?.focusAreas]);

  // ============================================================================
  // Render Helpers
  // ============================================================================

  const renderStepPanelContent = (panelId) => {
    if (panelId === 'topic') {
      return (
        <div className="space-y-4">
          <p className="text-sm text-muted">What area do you want to explore?</p>
          {SPREAD_TO_TOPIC_MAP[selectedSpread] && (
            <div className="rounded-lg bg-accent/10 border border-accent/30 px-3 py-2">
              <div className="flex items-center gap-2 mb-1">
                <Sparkle className="h-3 w-3 text-accent" />
                <span className="text-xs font-bold uppercase tracking-wider text-accent">Suggested Focus</span>
              </div>
              <p className="text-xs text-secondary">
                Based on your <span className="font-medium">{SPREAD_NAMES[selectedSpread]}</span> spread, we suggest exploring{' '}
                <span className="font-medium text-main">
                  {INTENTION_TOPIC_OPTIONS.find(opt => opt.value === SPREAD_TO_TOPIC_MAP[selectedSpread])?.label}
                </span>
                . Feel free to choose any topic.
              </p>
            </div>
          )}
          <div className="grid gap-3 md:grid-cols-2">
            {INTENTION_TOPIC_OPTIONS.map(option => (
              <button
                key={option.value}
                type="button"
                className={`${baseOptionClass} ${option.value === topic ? 'border-accent bg-accent/10 shadow-lg shadow-accent/20' : 'border-secondary/30 hover:border-accent/50 hover:bg-accent/5'}`}
                onClick={() => {
                  if (option.value !== topic) {
                    releasePrefill();
                  }
                  setTopic(option.value);
                }}
              >
                <p className="font-medium text-main">{option.label}</p>
                <p className="text-sm text-muted">{option.description}</p>
                {focusAreaSuggestedTopic && option.value === focusAreaSuggestedTopic && (
                  <span className="mt-3 inline-flex items-center gap-1 rounded-full bg-accent/15 px-3 py-1 text-[0.65rem] font-semibold uppercase tracking-[0.2em] text-accent">
                    Based on your interests
                  </span>
                )}
              </button>
            ))}
          </div>
        </div>
      );
    }

    if (panelId === 'timeframe') {
      return (
        <div className="space-y-4">
          <p className="text-sm text-muted">When do you need guidance for?</p>
          <div className="grid gap-3 sm:grid-cols-2">
            {INTENTION_TIMEFRAME_OPTIONS.map(option => (
              <button
                key={option.value}
                type="button"
                className={`${baseOptionClass} ${option.value === timeframe ? 'border-accent bg-accent/10 shadow-lg shadow-accent/20' : 'border-secondary/30 hover:border-accent/50 hover:bg-accent/5'}`}
                onClick={() => {
                  if (option.value !== timeframe) {
                    releasePrefill();
                  }
                  setTimeframe(option.value);
                }}
              >
                <p className="font-medium text-main">{option.label}</p>
                <p className="text-sm text-muted">{option.description}</p>
              </button>
            ))}
          </div>
        </div>
      );
    }

    if (panelId === 'depth') {
      return (
        <div className="space-y-6">
          <div ref={depthSectionRef} className="space-y-4">
            <p className="text-sm text-muted">How deep do you want to go?</p>
            <div className="grid gap-3 md:grid-cols-2">
              {INTENTION_DEPTH_OPTIONS.map(option => (
                <button
                  key={option.value}
                  type="button"
                  className={`${baseOptionClass} ${option.value === depth ? 'border-accent bg-accent/10 shadow-lg shadow-accent/20' : 'border-secondary/30 hover:border-accent/50 hover:bg-accent/5'}`}
                  onClick={() => {
                    if (option.value !== depth) {
                      releasePrefill();
                    }
                    setDepth(option.value);
                  }}
                >
                  <p className="font-medium text-main">{option.label}</p>
                  <p className="text-sm text-muted">{option.description}</p>
                </button>
              ))}
            </div>
          </div>

          <div className="space-y-2">
            <label htmlFor="custom-focus" className="text-sm font-medium text-accent">
              Add a detail (optional)
            </label>
            <input
              ref={customFocusRef}
              id="custom-focus"
              type="text"
              value={customFocus}
              onChange={event => {
                releasePrefill();
                setCustomFocus(event.target.value);
              }}
              placeholder="e.g. a potential move, a creative launch, a new relationship"
              className="w-full rounded-xl border border-secondary/40 bg-surface/80 px-4 py-3 text-main placeholder:text-secondary/40 focus:border-secondary focus:outline-none focus:ring-1 focus:ring-secondary/60"
            />
          </div>

          <div className="rounded-2xl border border-accent/30 bg-accent/5 p-4 space-y-4">
            <div className="flex flex-col gap-2">
              <div>
                <p className="flex items-center gap-2 text-xs uppercase tracking-[0.3em] text-secondary">
                  <Sparkle className="h-3.5 w-3.5 text-secondary" aria-hidden="true" />
                  Review & Refine
                </p>
                <p className="text-xs text-secondary/80 mt-1">
                  Tap a tag to adjust that setting or toggle AI for a creative spin.
                </p>
              </div>

              {questionContextChips.length > 0 && (
                <div className="flex flex-wrap gap-2 py-2">
                  {questionContextChips.map((chip, idx) => (
                    <button
                      key={`${chip.label}-${idx}`}
                      onClick={() => {
                        if (typeof chip.step === 'number') {
                          setStep(chip.step);
                          if (chip.step === step && chip.type === 'Depth') {
                            depthSectionRef.current?.scrollIntoView({ behavior: 'smooth', block: 'center' });
                          }
                        }
                        if (chip.action === 'focus') {
                          customFocusRef.current?.focus();
                        }
                      }}
                      className="rounded-full border border-secondary/40 bg-surface/50 px-3 py-1 text-[0.65rem] uppercase tracking-[0.2em] text-secondary/80 hover:bg-secondary/10 hover:border-secondary transition"
                    >
                      <span className="font-bold opacity-50 mr-1">{chip.type}:</span>
                      {chip.label}
                    </button>
                  ))}
                </div>
              )}

              <div className="flex flex-wrap items-center gap-2 pt-1">
                <label className="inline-flex items-center gap-2 rounded-full border border-secondary/40 bg-surface/50 px-3 py-1.5 text-[0.7rem] text-secondary cursor-pointer select-none hover:bg-secondary/5 transition">
                  <input
                    type="checkbox"
                    className="h-4 w-4 rounded border-secondary/60 bg-transparent text-secondary focus:ring-secondary"
                    checked={useCreative}
                    onChange={event => {
                      releasePrefill();
                      setUseCreative(event.target.checked);
                      setAutoQuestionEnabled(true);
                    }}
                  />
                  <span className="inline-flex items-center gap-1 font-medium">
                    <MagicWand className="h-3.5 w-3.5 text-secondary" aria-hidden="true" />
                    Personalize with AI
                  </span>
                </label>
                <button
                  type="button"
                  onClick={() => {
                    setPrefillSource(null);
                    setAutoQuestionEnabled(true);
                    setQuestionError('');
                    setRemixCount(c => c + 1);
                  }}
                  className="inline-flex items-center gap-1 rounded-full border border-secondary/60 bg-transparent px-3 py-1.5 text-[0.7rem] font-semibold text-secondary hover:bg-secondary/10 transition"
                >
                  <ArrowsClockwise className="h-3.5 w-3.5" aria-hidden="true" />
                  Remix
                </button>
              </div>
            </div>

            {prefillSource && prefillSourceDescription && (
              <p className="text-xs text-secondary/80">
                <span className="font-semibold text-secondary">Auto-filled</span> from {prefillSourceDescription}.
              </p>
            )}
            {questionLoading && (
              <p className={`text-xs text-accent/80 ${prefersReducedMotion ? '' : 'animate-pulse'}`}>Weaving a personalized prompt…</p>
            )}
            {questionError && (
              <p className="text-xs text-accent/80">{questionError}</p>
            )}

            <div className="rounded-2xl border border-secondary/30 bg-surface/60 p-5 space-y-3 text-center">
              <div className="flex items-center justify-center gap-2 text-[0.65rem] uppercase tracking-[0.3em] text-secondary/80">
                <Sparkle className="h-4 w-4 text-secondary" aria-hidden="true" />
                Your Question
              </div>
              <p className="font-serif text-xl sm:text-2xl text-main leading-relaxed">
                {questionText || guidedQuestion}
              </p>
            </div>

            {astroHighlights.length > 0 && (
              <div className="rounded-2xl border border-secondary/30 bg-surface/50 p-4 space-y-2">
                <div className="flex items-center justify-between text-xs text-secondary/80">
                  <span className="inline-flex items-center gap-2 uppercase tracking-[0.2em]">
                    <MagicWand className="h-3.5 w-3.5 text-secondary" aria-hidden="true" />
                    Astro window{astroWindowDays ? ` · ${astroWindowDays} days` : ''}
                  </span>
                  {astroSource && <span className="text-[0.65rem] text-secondary/60">{astroSource}</span>}
                </div>
                <ul className="grid gap-1 text-sm text-main text-left">
                  {astroHighlights.map((item, idx) => (
                    <li key={`astro-${idx}`} className="flex items-start gap-2">
                      <span className="mt-[5px] h-1.5 w-1.5 rounded-full bg-secondary/70" aria-hidden="true" />
                      <span className="leading-snug text-secondary/90">{item}</span>
                    </li>
                  ))}
                </ul>
              </div>
            )}

            {/* Question Quality Indicator */}
            <div className="rounded-2xl border border-secondary/30 bg-surface/40 p-3 space-y-2">
              <div className="flex items-center justify-between text-xs text-secondary">
                <span className="inline-flex items-center gap-1">
                  <ChartLine className="h-4 w-4 text-secondary" aria-hidden="true" />
                  Question quality
                </span>
                <span className="text-xs font-semibold text-secondary">
                  {qualityLevel.emoji} {qualityLevel.label}
                </span>
              </div>
              <div className="h-2 w-full rounded-full bg-surface-muted/80 overflow-hidden">
                <div
                  className={`h-full ${prefersReducedMotion ? '' : 'transition-all duration-500'} ${
                    normalizedQualityScore >= 85
                      ? 'bg-accent'
                      : normalizedQualityScore >= 65
                        ? 'bg-secondary'
                        : 'bg-secondary/50'
                  }`}
                  style={{ width: `${normalizedQualityScore}%` }}
                />
              </div>
              <p className="text-[0.7rem] text-secondary/80">{qualityHelperText}</p>
            </div>
          </div>
        </div>
      );
    }

    return null;
  };

  // ============================================================================
  // Early Return
  // ============================================================================

  if (!isOpen) {
    return null;
  }

  // ============================================================================
  // Main Render
  // ============================================================================

  return (
    <div
      className={`fixed inset-0 z-[100] flex items-center justify-center bg-main/90 backdrop-blur ${prefersReducedMotion ? '' : 'animate-fade-in'}`}
      onClick={createBackdropHandler(onClose)}
    >
      <FocusTrap
        active={isOpen}
        focusTrapOptions={{
          initialFocus: () => closeButtonRef.current,
          escapeDeactivates: false,
          clickOutsideDeactivates: false,
          returnFocusOnDeactivate: false,
          allowOutsideClick: true,
        }}
      >
        <div
          ref={modalRef}
          id={MOBILE_COACH_DIALOG_ID}
          role="dialog"
          aria-modal="true"
          aria-labelledby={titleId}
          className={`relative w-full h-full sm:h-auto ${isLandscape ? 'max-h-[98vh]' : 'sm:max-h-[90vh]'} sm:max-w-3xl sm:mx-4 sm:rounded-3xl border-0 sm:border border-accent/30 bg-surface shadow-2xl focus:outline-none flex flex-col ${prefersReducedMotion ? '' : 'animate-pop-in'}`}
        >
          {/* Close Button */}
          <button
            ref={closeButtonRef}
            type="button"
            onClick={onClose}
            className="absolute right-3 top-3 min-h-[44px] min-w-[44px] flex items-center justify-center rounded-full text-accent/80 hover:text-main hover:bg-surface-muted/50 z-10 touch-manipulation transition-colors"
            aria-label="Close intention coach"
          >
            <X className="h-5 w-5" />
          </button>

          {/* Scrollable content area */}
          <div className="flex-1 overflow-y-auto">
            <div className={`flex flex-col gap-6 px-4 pb-6 sm:px-10 sm:pb-6 ${isLandscape ? 'pt-10 gap-4' : 'pt-16 sm:pt-8'}`}>
              {/* Header */}
              <div>
                <div className="flex items-center gap-2 text-secondary">
                  <Sparkle className="h-4 w-4" />
                  <span className="text-xs uppercase tracking-[0.2em]">Guided Intention Coach</span>
                </div>
                <h2 id={titleId} className={`mt-2 font-serif text-main ${isLandscape ? 'text-xl' : 'text-2xl'}`}>Shape a question with clarity</h2>
                {!isLandscape && (
                  <p className="mt-1 text-sm text-muted">
                    Answer three quick prompts and we&apos;ll craft an open-ended question you can drop
                    directly into your reading.
                  </p>
                )}
              </div>

              {/* Step Navigation & Content */}
              <div className="flex flex-col gap-3">
                {/* Step Progress Indicator */}
                <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                  <div
                    className="flex items-center gap-2 text-xs font-semibold uppercase tracking-widest text-accent flex-wrap"
                    role="tablist"
                    aria-label="Coach wizard steps"
                  >
                    {STEPS.map((entry, index) => (
                      <Fragment key={entry.id}>
                        <button
                          ref={el => {
                            if (el) stepButtonRefs.current[index] = el;
                          }}
                          type="button"
                          id={`step-tab-${entry.id}`}
                          role="tab"
                          aria-selected={index === step}
                          aria-controls={`step-panel-${entry.id}`}
                          tabIndex={index === step ? 0 : -1}
                          className={`rounded-full px-3 py-1 min-h-[44px] min-w-[44px] touch-manipulation transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/70 focus-visible:ring-offset-2 focus-visible:ring-offset-surface ${
                            index === step
                              ? 'bg-accent text-main shadow-lg shadow-accent/20'
                              : 'bg-surface-muted text-muted hover:bg-surface-muted/80 hover:text-accent'
                          }`}
                          onClick={() => setStep(index)}
                          onKeyDown={(e) => handleStepKeyDown(e, index)}
                        >
                          <span className="hidden sm:inline">{entry.label}</span>
                          <span className="sm:hidden">{index + 1}</span>
                        </button>
                        {index < STEPS.length - 1 && <span className="text-accent/30" aria-hidden="true">·</span>}
                      </Fragment>
                    ))}
                  </div>
                  <div className="flex flex-col gap-2 sm:flex-row sm:items-center sm:gap-3">
                    <p className="text-xs text-secondary font-medium">
                      Step {step + 1} of {STEPS.length}
                    </p>
                    <button
                      type="button"
                      onClick={() => setTemplatePanelOpen(true)}
                      className="inline-flex items-center justify-center gap-1 rounded-full border border-secondary/40 px-3 py-1.5 text-[0.65rem] uppercase tracking-[0.2em] text-secondary hover:bg-secondary/10 transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/60"
                    >
                      <BookmarkSimple className="h-3.5 w-3.5 text-secondary" aria-hidden="true" />
                      Templates
                    </button>
                  </div>
                </div>

                {/* Step Panels */}
                <div className={`rounded-2xl border border-accent/30 bg-surface-muted/40 ${isLandscape ? 'p-3' : 'p-4 sm:p-5'}`}>
                  {STEPS.map((entry, index) => (
                    <div
                      key={entry.id}
                      id={`step-panel-${entry.id}`}
                      role="tabpanel"
                      aria-labelledby={`step-tab-${entry.id}`}
                      hidden={step !== index}
                      aria-hidden={step !== index}
                      tabIndex={step === index ? 0 : -1}
                    >
                      {renderStepPanelContent(entry.id)}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>

          {/* Footer - OUTSIDE scrollable area for proper sticky behavior */}
          <div className={`flex-shrink-0 bg-surface border-t border-accent/20 sm:border-t-0 px-4 sm:px-10 pb-safe sm:pb-6 ${isLandscape ? 'pt-2' : 'pt-4 sm:pt-0'}`}>
            {historyStatus && (
              <p className="text-xs text-error text-center sm:text-left mb-2">
                {historyStatus}
              </p>
            )}
            <div className={`flex sm:flex-row sm:items-center sm:justify-between ${isLandscape ? 'flex-row items-center gap-2' : 'flex-col gap-3'}`}>
              <div className={`text-xs text-muted ${isLandscape ? 'block' : 'hidden sm:block'}`}>
                <p>
                  {isLandscape
                    ? `${summary.topicLabel} · ${summary.timeframeLabel}`
                    : `${summary.topicLabel} · ${summary.timeframeLabel} · ${summary.depthLabel}`}
                </p>
              </div>
              <div className={`flex items-center w-full sm:w-auto ${isLandscape ? 'gap-2 flex-1 justify-end' : 'gap-3'}`}>
                <button
                  type="button"
                  onClick={goBack}
                  disabled={step === 0}
                  className={`inline-flex items-center justify-center gap-1 rounded-full border border-accent/20 text-sm text-main transition disabled:opacity-40 min-h-[44px] sm:min-h-0 touch-manipulation ${isLandscape ? 'px-3 py-2 flex-none' : 'px-4 py-2.5 sm:py-2 flex-1 sm:flex-none'}`}
                >
                  <ArrowLeft className="h-4 w-4" />
                  {!isLandscape && <span>Back</span>}
                </button>
                {step < STEPS.length - 1 ? (
                  <button
                    type="button"
                    onClick={goNext}
                    disabled={!canGoNext()}
                    className={`inline-flex items-center justify-center gap-2 rounded-full border border-secondary/60 bg-secondary/20 text-sm font-medium text-secondary transition disabled:opacity-50 min-h-[44px] sm:min-h-0 touch-manipulation ${isLandscape ? 'px-4 py-2 flex-none' : 'px-5 py-2.5 sm:py-2 flex-1 sm:flex-none'}`}
                  >
                    <span>Next</span>
                    <ArrowRight className="h-4 w-4" />
                  </button>
                ) : (
                  <button
                    type="button"
                    onClick={handleApply}
                    disabled={(!questionText && !guidedQuestion) || questionLoading}
                    className={`inline-flex items-center justify-center gap-2 rounded-full border border-secondary/60 bg-secondary/80 text-sm font-semibold text-white transition disabled:opacity-50 min-h-[44px] sm:min-h-0 touch-manipulation ${isLandscape ? 'px-4 py-2 flex-none' : 'px-5 py-2.5 sm:py-2 flex-1 sm:flex-none'}`}
                  >
                    <span>{isLandscape ? 'Use' : 'Use question'}</span>
                    <Sparkle className="h-4 w-4" />
                  </button>
                )}
              </div>
            </div>
          </div>

          {/* Template Panel Overlay */}
          {isTemplatePanelOpen && (
            <div
              className={`absolute inset-0 z-40 flex items-stretch bg-surface/70 backdrop-blur-sm ${prefersReducedMotion ? '' : 'animate-fade-in'}`}
              onClick={() => setTemplatePanelOpen(false)}
              onKeyDown={(e) => {
                if (e.key === 'Escape') {
                  setTemplatePanelOpen(false);
                }
              }}
              aria-label="Close template panel backdrop"
            >
              <div
                role="dialog"
                aria-modal="false"
                aria-label="Template library"
                className={`ml-auto h-full w-full sm:w-[26rem] bg-surface border-l border-accent/30 p-5 sm:p-6 overflow-y-auto shadow-[0_0_45px_rgba(0,0,0,0.6)] ${prefersReducedMotion ? '' : 'animate-slide-in-right'}`}
                onClick={event => event.stopPropagation()}
              >
                {/* Panel Header */}
                <div className="flex items-center justify-between gap-2">
                  <div>
                    <p className="flex items-center gap-2 text-xs uppercase tracking-[0.3em] text-secondary">
                      <BookmarkSimple className="h-4 w-4 text-secondary" aria-hidden="true" />
                      Template library
                    </p>
                    <p className="text-sm text-muted">
                      Save this configuration or reapply a favorite blend anytime.
                    </p>
                  </div>
                  <button
                    type="button"
                    onClick={() => setTemplatePanelOpen(false)}
                    className="inline-flex items-center justify-center rounded-full border border-secondary/40 p-1 text-secondary hover:bg-secondary/10"
                    aria-label="Close template panel"
                  >
                    <X className="h-4 w-4" />
                  </button>
                </div>

                {/* Panel Content */}
                <div className="mt-5 space-y-6">
                  {/* Save Current Setup Section */}
                  <section className="space-y-3">
                    <div className="flex flex-col gap-2">
                      <p className="text-xs uppercase tracking-[0.3em] text-accent/80">Save current setup</p>
                      <div className="flex flex-col gap-2 sm:flex-row">
                        <input
                          type="text"
                          value={newTemplateLabel}
                          onChange={event => setNewTemplateLabel(event.target.value)}
                          placeholder="Template name"
                          className="flex-1 rounded-full border border-accent/20 bg-surface/70 px-3 py-2 text-sm text-main focus:outline-none focus:ring-1 focus:ring-secondary/60"
                        />
                        <button
                          type="button"
                          onClick={handleSaveTemplate}
                          className="inline-flex items-center justify-center gap-1 rounded-full border border-secondary/60 bg-secondary/10 px-4 py-2 text-xs font-semibold text-secondary hover:bg-secondary/20 transition"
                        >
                          <Sparkle className="h-3.5 w-3.5 text-secondary" aria-hidden="true" />
                          Save
                        </button>
                      </div>
                      <p className="text-[0.65rem] text-secondary/70">
                        {templates.length}/{MAX_TEMPLATES} templates saved · oldest entry is replaced when you add more than {MAX_TEMPLATES}.
                      </p>
                    </div>
                    {templateStatus && (
                      <p className="text-xs text-secondary/80">{templateStatus}</p>
                    )}
                  </section>

                  {/* Saved Templates Section */}
                  <section className="space-y-3">
                    <p className="text-xs uppercase tracking-[0.3em] text-accent/80">Saved templates</p>
                    {templates.length === 0 ? (
                      <p className="text-xs text-muted">
                        Nothing saved yet. Create a label above to store this blend for later.
                      </p>
                    ) : (
                      <div className="space-y-3">
                        {templates.map(template => (
                          <div
                            key={template.id}
                            className="rounded-2xl border border-accent/20 bg-surface-muted/70 p-3 flex flex-col gap-2"
                          >
                            <button
                              type="button"
                              onClick={() => handleApplyTemplate(template)}
                              className="text-left"
                            >
                              <p className="text-sm font-semibold text-main">{template.label}</p>
                              <p className="text-xs text-muted">
                                {[
                                  getTopicLabel(template.topic),
                                  getTimeframeLabel(template.timeframe),
                                  getDepthLabel(template.depth)
                                ]
                                  .filter(Boolean)
                                  .join(' · ') || 'Custom mix'}
                              </p>
                              {template.customFocus && (
                                <p className="mt-1 text-xs text-secondary/80">{template.customFocus}</p>
                              )}
                              {template.savedQuestion && (
                                <p className="mt-2 text-xs text-muted">{template.savedQuestion}</p>
                              )}
                            </button>
                            <button
                              type="button"
                              onClick={() => handleDeleteTemplate(template.id)}
                              className="self-start text-xs text-error hover:text-error/80 underline decoration-dotted"
                            >
                              Remove
                            </button>
                          </div>
                        ))}
                      </div>
                    )}
                  </section>

                  {/* Recent Questions Section */}
                  <section className="space-y-3">
                    <p className="flex items-center gap-2 text-xs uppercase tracking-[0.3em] text-accent/80">
                      <ClockCounterClockwise className="h-4 w-4 text-secondary" aria-hidden="true" />
                      Recent questions
                    </p>
                    {questionHistory.length === 0 ? (
                      <p className="text-xs text-muted">No recent pulls yet—log a question to see it here.</p>
                    ) : (
                      <div className="space-y-2">
                        {questionHistory.slice(0, 6).map(item => (
                          <button
                            key={item.id}
                            type="button"
                            onClick={() => handleApplyHistoryQuestion(item)}
                            className="w-full text-left rounded-2xl border border-accent/20 bg-surface-muted/70 px-4 py-2 text-sm text-muted hover:border-secondary/50 transition"
                          >
                            {item.question}
                          </button>
                        ))}
                      </div>
                    )}
                  </section>
                </div>
              </div>
            </div>
          )}
        </div>
      </FocusTrap>
    </div>
  );
}
</file>

<file path="src/components/Header.jsx">
import { useState, useEffect, useRef, useCallback } from 'react';
import { ArrowCounterClockwise } from '@phosphor-icons/react';
import { GlobalNav } from './GlobalNav';
import { UserMenu } from './UserMenu';
import { StepProgress } from './StepProgress';
import { useReducedMotion } from '../hooks/useReducedMotion';
import { useSmallScreen } from '../hooks/useSmallScreen';
import { usePreferences } from '../contexts/PreferencesContext';

// Scroll thresholds - using viewport-relative values for mobile
const COMPACT_THRESHOLD = 32;
const HIDE_THRESHOLD_MIN = 180; // Minimum for small screens
const HIDE_THRESHOLD_RATIO = 0.2; // 20% of viewport height

export function Header({ steps, activeStep, onStepSelect, isShuffling }) {
  const prefersReducedMotion = useReducedMotion();
  const isMobile = useSmallScreen(768);
  const { personalization } = usePreferences();
  const displayName = personalization?.displayName?.trim();
  const [headerState, setHeaderState] = useState(() => ({
    isCompact: false,
    isHidden: false,
  }));
  const lastScrollYRef = useRef(0);
  const scrollRafRef = useRef(null);
  const isCleanedUpRef = useRef(false);
  const { isCompact, isHidden } = headerState;
  // Disable auto-hide for reduced motion users and on small screens to prevent unexpected movement
  const shouldHideHeader = isHidden && !isShuffling && !prefersReducedMotion && !isMobile;

  // Calculate viewport-aware hide threshold
  const getHideThreshold = useCallback(() => {
    if (typeof window === 'undefined') return HIDE_THRESHOLD_MIN;
    // Use the larger of: minimum threshold OR 20% of viewport height
    const viewportThreshold = Math.round(window.innerHeight * HIDE_THRESHOLD_RATIO);
    return Math.max(HIDE_THRESHOLD_MIN, viewportThreshold);
  }, []);

  // Header collapse / auto-hide based on scroll
  useEffect(() => {
    if (typeof window === 'undefined') return;

    isCleanedUpRef.current = false;

    const updateHeaderState = () => {
      if (isCleanedUpRef.current) return;

      const currentY = window.scrollY || 0;
      const isScrollingDown = currentY > lastScrollYRef.current;
      const hideThreshold = getHideThreshold();

      const shouldCompact = currentY > COMPACT_THRESHOLD;
      // Only hide when scrolling down AND past threshold
      // Reveal immediately when scrolling up
      const shouldHide = !isMobile && isScrollingDown && currentY > hideThreshold;

      setHeaderState((prev) => {
        if (prev.isCompact === shouldCompact && prev.isHidden === shouldHide) {
          return prev;
        }
        return {
          isCompact: shouldCompact,
          isHidden: shouldHide,
        };
      });
      lastScrollYRef.current = currentY;
    };

    const handleScroll = () => {
      if (scrollRafRef.current || isCleanedUpRef.current) return;
      scrollRafRef.current = window.requestAnimationFrame(() => {
        if (!isCleanedUpRef.current) {
          updateHeaderState();
        }
        scrollRafRef.current = null;
      });
    };

    // Reset scroll tracking on resize/orientation change
    const handleResize = () => {
      lastScrollYRef.current = window.scrollY || 0;
      // Force re-evaluation after resize
      updateHeaderState();
    };

    window.addEventListener('scroll', handleScroll, { passive: true });
    window.addEventListener('resize', handleResize, { passive: true });
    updateHeaderState();

    return () => {
      isCleanedUpRef.current = true;
      window.removeEventListener('scroll', handleScroll);
      window.removeEventListener('resize', handleResize);
      if (scrollRafRef.current) {
        window.cancelAnimationFrame(scrollRafRef.current);
        scrollRafRef.current = null;
      }
    };
  }, [getHideThreshold, isMobile]);

  // Logo height based on compact state and screen size
  // Mobile (< 640px) uses smaller logo to reduce header height
  const logoHeight = isCompact ? (isMobile ? 36 : 40) : (isMobile ? 50 : 56);

  return (
    <>
      {/* Main Header */}
      <header aria-labelledby="tableau-heading" className={isCompact ? 'header-condensed' : ''}>
        <div className="text-center mb-2 sm:mb-6 md:mb-8 mystic-heading-wrap flex flex-col items-center">
          <div
            className="transition-all duration-200 ease-out"
            style={{
              // Use margin adjustment for smooth visual transition instead of scale
              marginTop: isCompact ? '-8px' : '0',
              marginBottom: isCompact ? '-8px' : '0',
            }}
          >
            <img
              src="/images/tableu-logo-new.png"
              alt="Tableu - Tarot Reading Application"
              className="mb-2 opacity-90 hover:opacity-100 transition-opacity"
              style={{ height: logoHeight, width: 'auto' }}
            />
          </div>
          <h1 id="tableau-heading" className="sr-only">
            Tableu
          </h1>
          <p
            className={`
              mt-1 text-muted leading-relaxed max-w-2xl
              transition-all duration-200
              hidden sm:block
              ${isCompact
                ? 'text-xs opacity-0 h-0 overflow-hidden'
                : 'text-xs-plus sm:text-sm md:text-base opacity-100'
              }
            `}
            aria-hidden={isCompact}
          >
            Authentic tarot, thoughtfully interpreted.
          </p>
        </div>
      </header>

      {/* Sticky Navigation Bar */}
      <div
        className={`
          full-bleed sticky top-0 z-30 mb-5
          bg-surface/95 backdrop-blur
          border-y border-accent/20
          px-4 sm:px-5 md:px-6
          pr-[max(1rem,env(safe-area-inset-right))]
          pl-[max(1rem,env(safe-area-inset-left))]
          shadow-lg shadow-primary/20
          header-sticky
          ${isCompact ? 'header-sticky--compact' : ''}
        `}
        style={{
          transform: shouldHideHeader ? 'translateY(-110%)' : 'translateY(0)',
          transition: 'transform 200ms ease',
        }}
      >
        <div className="header-sticky__row flex flex-wrap items-center gap-2 sm:gap-3 justify-between">
          <div className="header-sticky__nav flex-1 w-full sm:w-auto">
            <GlobalNav condensed={isCompact} withUserChip />
          </div>
          {/* Fallback placement if user chip overflows (desktop still shows) */}
          <div className="header-sticky__user hidden sm:block">
            <UserMenu condensed={isCompact} />
          </div>
        </div>
        <div className="mt-2 sm:mt-1">
          {displayName && (
            <p className="text-[0.75rem] sm:text-xs text-muted mb-1">
              Welcome back, {displayName}.
            </p>
          )}
          <StepProgress
            steps={steps}
            activeStep={activeStep}
            onSelect={onStepSelect}
            condensed={isCompact}
          />
        </div>
        {isShuffling && (
          <div
            className="mt-2 pb-1 flex items-center gap-2 text-muted text-[clamp(0.85rem,2.4vw,0.95rem)] leading-snug"
            role="status"
            aria-live="polite"
          >
            <ArrowCounterClockwise className="w-4 h-4 animate-spin text-accent" aria-hidden="true" />
            <span>Shuffling the deck...</span>
          </div>
        )}
      </div>
    </>
  );
}
</file>

<file path="src/components/HelperToggle.jsx">
import { useId, useState, useRef, useEffect } from 'react';
import { CaretDown } from '@phosphor-icons/react';

export function HelperToggle({ children, label = 'More information', className = '', defaultOpen = false }) {
  const [isOpen, setIsOpen] = useState(defaultOpen);
  const contentId = useId();
  const contentRef = useRef(null);
  const [contentHeight, setContentHeight] = useState(0);
  // Use state instead of ref since we need to read it during render for state adjustment
  const [hasToggled, setHasToggled] = useState(false);

  // Track previous defaultOpen for render-time state adjustment
  const [prevDefaultOpen, setPrevDefaultOpen] = useState(defaultOpen);

  // Sync isOpen with defaultOpen changes if user hasn't manually toggled
  // This pattern (adjusting state during render) is React-recommended over useEffect
  if (defaultOpen !== prevDefaultOpen) {
    setPrevDefaultOpen(defaultOpen);
    if (defaultOpen && !hasToggled) {
      setIsOpen(true);
    }
  }

  // Measure content height for smooth animation
  // Schedule via RAF to avoid synchronous setState in effect
  useEffect(() => {
    if (contentRef.current) {
      requestAnimationFrame(() => {
        if (contentRef.current) {
          const height = contentRef.current.scrollHeight;
          setContentHeight(height);
        }
      });
    }
  }, [children, isOpen]);

  const handleToggle = () => {
    setHasToggled(true);
    setIsOpen(prev => !prev);
  };

  return (
    <div className={className}>
      <button
        type="button"
        onClick={handleToggle}
        className="inline-flex items-center gap-1.5 px-3 py-1.5 min-h-[44px] text-xs text-muted/80 transition-all duration-200
          hover:text-secondary
          focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/50 focus-visible:ring-offset-2 focus-visible:ring-offset-main
          touch-manipulation"
        aria-expanded={isOpen}
        aria-controls={contentId}
        aria-label={isOpen ? `Hide ${label.toLowerCase()}` : label}
      >
        <span className="font-medium tracking-wide">{isOpen ? 'Less' : 'Learn more'}</span>
        <CaretDown
          className={`w-3.5 h-3.5 transition-transform duration-200 ${isOpen ? 'rotate-180' : ''}`}
          aria-hidden="true"
        />
      </button>

      {/* Animated content container */}
      <div
        id={contentId}
        ref={contentRef}
        className="overflow-hidden transition-all duration-300 ease-out"
        style={{
          maxHeight: isOpen ? `${contentHeight + 24}px` : '0px', // +24 for padding
          opacity: isOpen ? 1 : 0,
          marginTop: isOpen ? '0.5rem' : '0',
        }}
        aria-hidden={!isOpen}
      >
        <div className="text-[clamp(0.85rem,2.4vw,0.95rem)] leading-snug text-muted bg-surface/70 border border-secondary/25 rounded-lg p-3">
          {children}
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/components/HumeAudioControls.jsx">
import { useState, useEffect } from 'react';
import { 
  SpeakerHigh, 
  SpeakerSlash, 
  Play, 
  Pause, 
  Stop 
} from '@phosphor-icons/react';
import { 
  speakWithHume, 
  stopHumeAudio, 
  isHumeTTSAvailable,
  HUME_VOICES 
} from '../lib/audioHume';

/**
 * HumeAudioControls Component
 * 
 * Provides UI controls for Hume AI Octave TTS functionality in tarot readings.
 * Allows users to select voices, adjust speed, and control playback.
 */
export default function HumeAudioControls({ 
  readingText, 
  context = 'full-reading',
  onPlaybackStart,
  onPlaybackEnd,
  className = ''
}) {
  const [availability, setAvailability] = useState({ checked: false, ok: false });
  const [isPlaying, setIsPlaying] = useState(false);
  const [selectedVoice, setSelectedVoice] = useState('ITO');
  const [speed, setSpeed] = useState(1.0);
  const [currentAudio, setCurrentAudio] = useState(null);
  const [error, setError] = useState(null);

  // Check if Hume TTS is available on mount
  useEffect(() => {
    let isMounted = true;
    isHumeTTSAvailable()
      .then(ok => { if (isMounted) setAvailability({ checked: true, ok }); })
      .catch(() => { if (isMounted) setAvailability({ checked: true, ok: false }); });
    return () => { isMounted = false; };
  }, []);

  const handlePlay = async () => {
    if (!readingText) {
      setError('No text to read');
      return;
    }

    try {
      setError(null);
      setIsPlaying(true);
      
      if (onPlaybackStart) {
        onPlaybackStart();
      }

      const result = await speakWithHume(readingText, {
        context,
        voiceName: selectedVoice,
        speed
      });

      setCurrentAudio(result);

      // Play the audio
      await result.play();

      // Handle audio end
      result.audio.onended = () => {
        setIsPlaying(false);
        if (onPlaybackEnd) {
          onPlaybackEnd();
        }
      };

      // Handle audio errors
      result.audio.onerror = (e) => {
        console.error('Audio playback error:', e);
        setError('Audio playback failed');
        setIsPlaying(false);
      };

    } catch (err) {
      console.error('Hume TTS error:', err);
      setError(err.message || 'Failed to generate speech');
      setIsPlaying(false);
    }
  };

  const handlePause = () => {
    if (currentAudio) {
      currentAudio.pause();
      setIsPlaying(false);
    }
  };

  const handleStop = () => {
    stopHumeAudio();
    setCurrentAudio(null);
    setIsPlaying(false);
  };

  if (!availability.checked) {
    return (
      <div className={`text-sm text-gray-500 ${className}`}>
        Checking Hume voice…
      </div>
    );
  }

  if (!availability.ok) {
    return (
      <div className={`text-sm text-gray-500 ${className}`}>
        <SpeakerSlash className="inline mr-2" size={16} />
        Hume AI voice not configured
      </div>
    );
  }

  return (
    <div className={`bg-white dark:bg-gray-800 rounded-lg p-4 shadow-sm border border-gray-200 dark:border-gray-700 ${className}`}>
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-semibold text-gray-900 dark:text-gray-100 flex items-center">
          <SpeakerHigh className="mr-2" size={20} />
          Mystical Voice Reading
        </h3>
      </div>

      {error && (
        <div className="mb-3 p-2 bg-red-50 dark:bg-red-900/20 text-red-700 dark:text-red-400 text-sm rounded">
          {error}
        </div>
      )}

      {/* Voice Selection */}
      <div className="mb-3">
        <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
          Voice
        </label>
        <select
          value={selectedVoice}
          onChange={(e) => setSelectedVoice(e.target.value)}
          disabled={isPlaying}
          className="w-full px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-md 
                   bg-white dark:bg-gray-700 text-gray-900 dark:text-gray-100
                   focus:ring-2 focus:ring-purple-500 focus:border-transparent
                   disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <optgroup label="Mystical (Recommended)">
            {HUME_VOICES.mystical.map(voice => (
              <option key={voice} value={voice}>{voice}</option>
            ))}
          </optgroup>
          <optgroup label="Narrators">
            {HUME_VOICES.narrators.map(voice => (
              <option key={voice} value={voice}>{voice}</option>
            ))}
          </optgroup>
          <optgroup label="Conversational">
            {HUME_VOICES.conversational.map(voice => (
              <option key={voice} value={voice}>{voice}</option>
            ))}
          </optgroup>
          <optgroup label="Dramatic">
            {HUME_VOICES.dramatic.map(voice => (
              <option key={voice} value={voice}>{voice}</option>
            ))}
          </optgroup>
        </select>
      </div>

      {/* Speed Control */}
      <div className="mb-4">
        <label className="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">
          Speed: {speed.toFixed(1)}x
        </label>
        <input
          type="range"
          min="0.5"
          max="2.0"
          step="0.1"
          value={speed}
          onChange={(e) => setSpeed(parseFloat(e.target.value))}
          disabled={isPlaying}
          className="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer
                   disabled:opacity-50 disabled:cursor-not-allowed"
        />
        <div className="flex justify-between text-xs text-gray-500 dark:text-gray-400 mt-1">
          <span>Slower</span>
          <span>Faster</span>
        </div>
      </div>

      {/* Playback Controls */}
      <div className="flex gap-2">
        {!isPlaying ? (
          <button
            onClick={handlePlay}
            disabled={!readingText}
            className="flex-1 flex items-center justify-center gap-2 px-4 py-2 
                     bg-purple-600 hover:bg-purple-700 text-white rounded-md
                     disabled:opacity-50 disabled:cursor-not-allowed
                     transition-colors duration-200"
          >
            <Play size={16} weight="fill" />
            <span className="text-sm font-medium">Listen to Reading</span>
          </button>
        ) : (
          <>
            <button
              onClick={handlePause}
              className="flex-1 flex items-center justify-center gap-2 px-4 py-2 
                       bg-amber-600 hover:bg-amber-700 text-white rounded-md
                       transition-colors duration-200"
            >
              <Pause size={16} weight="fill" />
              <span className="text-sm font-medium">Pause</span>
            </button>
            <button
              onClick={handleStop}
              className="flex items-center justify-center gap-2 px-4 py-2 
                       bg-gray-600 hover:bg-gray-700 text-white rounded-md
                       transition-colors duration-200"
            >
              <Stop size={16} weight="fill" />
            </button>
          </>
        )}
      </div>

      {/* Info Text */}
      <p className="mt-3 text-xs text-gray-600 dark:text-gray-400 text-center">
        Powered by Hume AI&apos;s Octave TTS
      </p>
    </div>
  );
}
</file>

<file path="src/components/Icon.jsx">
import PropTypes from 'prop-types';

/**
 * Standardized Icon Wrapper for Phosphor Icons
 *
 * Provides consistent sizing, weights, and accessibility across the application.
 * Wraps Phosphor icon components with semantic size scales and proper ARIA attributes.
 *
 * @example
 * import { Sparkle } from '@phosphor-icons/react';
 * import { Icon } from './Icon';
 *
 * // Standard usage
 * <Icon icon={Sparkle} size="md" />
 *
 * // With custom props
 * <Icon icon={Sparkle} size="lg" weight="bold" label="Generate reading" />
 *
 * // Decorative icon (hidden from screen readers)
 * <Icon icon={Sparkle} size="sm" decorative />
 *
 * // Responsive size - larger on mobile for better touch targets
 * <Icon icon={Sparkle} size="md-touch" decorative />
 */

// Semantic size scale mapping to Tailwind classes
const SIZE_MAP = {
  // Fixed sizes
  xs: 'w-3 h-3',           // 12px - tiny inline icons
  sm: 'w-3.5 h-3.5',       // 14px - small inline icons
  md: 'w-4 h-4',           // 16px - standard icons (default)
  lg: 'w-5 h-5',           // 20px - prominent icons
  xl: 'w-6 h-6',           // 24px - large interactive icons
  '2xl': 'w-8 h-8',        // 32px - hero/feature icons

  // Responsive sizes - larger on mobile, smaller on desktop
  // Use these for interactive elements that need bigger touch targets
  'xs-touch': 'w-3.5 h-3.5 sm:w-3 sm:h-3',       // 14px mobile, 12px desktop
  'sm-touch': 'w-4 h-4 sm:w-3.5 sm:h-3.5',       // 16px mobile, 14px desktop
  'md-touch': 'w-5 h-5 sm:w-4 sm:h-4',           // 20px mobile, 16px desktop
  'lg-touch': 'w-6 h-6 sm:w-5 sm:h-5',           // 24px mobile, 20px desktop
  'xl-touch': 'w-7 h-7 sm:w-6 sm:h-6',           // 28px mobile, 24px desktop

  // Responsive sizes - smaller on mobile, larger on desktop
  // Use these for decorative icons that can be smaller on constrained screens
  'sm-responsive': 'w-3 h-3 sm:w-3.5 sm:h-3.5',  // 12px mobile, 14px desktop
  'md-responsive': 'w-3.5 h-3.5 sm:w-4 sm:h-4',  // 14px mobile, 16px desktop
  'lg-responsive': 'w-4 h-4 sm:w-5 sm:h-5',      // 16px mobile, 20px desktop
  'xl-responsive': 'w-5 h-5 sm:w-6 sm:h-6',      // 20px mobile, 24px desktop
};

// Phosphor icon weight variants
// See: https://phosphoricons.com/
const WEIGHTS = ['thin', 'light', 'regular', 'bold', 'fill', 'duotone'];

// All valid size keys for PropTypes
const VALID_SIZES = Object.keys(SIZE_MAP);

export function Icon({
  icon: IconComponent,
  size = 'md',
  weight = 'regular',
  className = '',
  label,
  decorative = false,
  color,
  mirrored = false,
  ...props
}) {
  // Validate size
  const sizeClass = SIZE_MAP[size] || SIZE_MAP.md;

  // Build className
  const classes = [
    sizeClass,
    mirrored && 'scale-x-[-1]',
    className
  ].filter(Boolean).join(' ');

  // Accessibility attributes
  const a11yProps = decorative
    ? { 'aria-hidden': 'true' }
    : label
    ? { 'aria-label': label, role: 'img' }
    : {};

  return (
    <IconComponent
      className={classes}
      weight={weight}
      color={color}
      mirrored={mirrored}
      {...a11yProps}
      {...props}
    />
  );
}

Icon.propTypes = {
  /** The Phosphor icon component to render */
  icon: PropTypes.elementType.isRequired,

  /** Semantic size scale - use -touch variants for interactive elements on mobile */
  size: PropTypes.oneOf(VALID_SIZES),

  /** Icon weight variant */
  weight: PropTypes.oneOf(WEIGHTS),

  /** Additional CSS classes */
  className: PropTypes.string,

  /** Accessible label (required unless decorative=true) */
  label: PropTypes.string,

  /** If true, icon is decorative and hidden from screen readers */
  decorative: PropTypes.bool,

  /** Icon color (CSS color value) */
  color: PropTypes.string,

  /** If true, flip icon horizontally */
  mirrored: PropTypes.bool,
};

/**
 * Icon Size Constants
 * Use these for consistent sizing throughout the app
 *
 * Fixed sizes: xs, sm, md, lg, xl, xxl
 * Touch-friendly (larger on mobile): xsTouch, smTouch, mdTouch, lgTouch, xlTouch
 * Responsive (smaller on mobile): smResponsive, mdResponsive, lgResponsive, xlResponsive
 */
export const ICON_SIZES = {
  // Fixed sizes
  xs: 'xs',     // 12px - tiny inline
  sm: 'sm',     // 14px - small inline
  md: 'md',     // 16px - standard (default)
  lg: 'lg',     // 20px - prominent
  xl: 'xl',     // 24px - large interactive
  xxl: '2xl',   // 32px - hero/feature

  // Touch-friendly responsive (larger on mobile)
  xsTouch: 'xs-touch',   // 14px mobile → 12px desktop
  smTouch: 'sm-touch',   // 16px mobile → 14px desktop
  mdTouch: 'md-touch',   // 20px mobile → 16px desktop
  lgTouch: 'lg-touch',   // 24px mobile → 20px desktop
  xlTouch: 'xl-touch',   // 28px mobile → 24px desktop

  // Space-saving responsive (smaller on mobile)
  smResponsive: 'sm-responsive',  // 12px mobile → 14px desktop
  mdResponsive: 'md-responsive',  // 14px mobile → 16px desktop
  lgResponsive: 'lg-responsive',  // 16px mobile → 20px desktop
  xlResponsive: 'xl-responsive',  // 20px mobile → 24px desktop
};

/**
 * Icon Weight Constants
 * Use these for semantic visual hierarchy
 */
export const ICON_WEIGHTS = {
  thin: 'thin',       // Delicate, minimal
  light: 'light',     // Subtle, secondary
  regular: 'regular', // Standard (default)
  bold: 'bold',       // Emphasis, primary actions
  fill: 'fill',       // Filled solid
  duotone: 'duotone', // Two-tone style
};
</file>

<file path="src/components/icons.js">
/**
 * Centralized Icon Registry
 *
 * Import commonly used Phosphor icons once here, then re-export for use throughout the app.
 * This provides a single source of truth for which icons are used and makes it easier to
 * swap icons or track usage.
 *
 * Usage:
 * import { Sparkle, Check, Info } from './components/icons';
 * import { Icon, ICON_SIZES } from './components/Icon';
 *
 * <Icon icon={Sparkle} size={ICON_SIZES.md} label="Generate" />
 */

// Navigation & Actions
export {
  ArrowLeft,
  ArrowRight,
  ArrowCounterClockwise,
  ArrowsClockwise,
  ArrowsOut,
  CaretLeft,
  CaretRight,
  CaretDown,
  CaretUp,
  X,
} from '@phosphor-icons/react';

// UI Elements
export {
  Check,
  Info,
  Question,
  Gear,
  UploadSimple,
  DownloadSimple,
} from '@phosphor-icons/react';

// Content & Features
export {
  Sparkle,
  Star,
  Eye,
  Path,
  Heart,
  Compass,
  Lightning,
  BookOpen,
  BookmarkSimple,
  ClipboardText,
  FileText,
  ChartBar,
  ChartLine,
} from '@phosphor-icons/react';

// Media & Audio
export {
  SpeakerHigh,
  SpeakerSlash,
  MusicNotes,
  Sun,
  Moon,
} from '@phosphor-icons/react';

// Layout & Organization
export {
  GridFour,
  Stack,
} from '@phosphor-icons/react';

// Social & Sharing
export {
  ShareNetwork,
  Copy,
} from '@phosphor-icons/react';

// User & Auth
export {
  SignIn,
  SignOut,
  User,
} from '@phosphor-icons/react';

// Actions & Operations
export {
  Trash,
  Scissors,
  MagicWand,
  ClockCounterClockwise,
} from '@phosphor-icons/react';

// Data & Charts
export {
  TrendUp,
  Medal,
  Fire,
} from '@phosphor-icons/react';

/**
 * Icon Usage Patterns by Context
 *
 * Standard patterns to follow for consistency:
 *
 * 1. DECORATIVE ICONS (inline with text)
 *    <Icon icon={Sparkle} size="sm" decorative />
 *
 * 2. INTERACTIVE ICONS (buttons, clickable)
 *    <Icon icon={Check} size="md" label="Confirm selection" />
 *
 * 3. STATUS ICONS (indicate state)
 *    <Icon icon={Check} size="md" weight="bold" decorative />
 *
 * 4. NAVIGATION ICONS
 *    <Icon icon={ArrowLeft} size="lg" label="Go back" />
 *
 * 5. FEATURE ICONS (section headers)
 *    <Icon icon={Sparkle} size="xl" weight="bold" decorative />
 */
</file>

<file path="src/components/ImagePreview.jsx">
import { useEffect, useMemo, useRef, useCallback } from 'react';

export function ImagePreview({ image, onConfirm, onRetake }) {
  const previousTriggerRef = useRef(null);
  const confirmButtonRef = useRef(null);

  // Compute imageUrl synchronously via useMemo to avoid setState in effect
  const imageUrl = useMemo(() => {
    if (image instanceof File) {
      return URL.createObjectURL(image);
    }
    return image || null;
  }, [image]);

  // Cleanup object URLs to prevent memory leaks (no setState, only cleanup side effect)
  useEffect(() => {
    if (image instanceof File && imageUrl) {
      return () => URL.revokeObjectURL(imageUrl);
    }
  }, [image, imageUrl]);

  // Store reference to previously focused element for focus restoration
  useEffect(() => {
    if (imageUrl) {
      previousTriggerRef.current = document.activeElement;
      // Focus the confirm button when modal opens
      requestAnimationFrame(() => {
        confirmButtonRef.current?.focus();
      });
    }
    return () => {
      // Restore focus when modal closes
      if (previousTriggerRef.current && typeof previousTriggerRef.current.focus === 'function') {
        previousTriggerRef.current.focus();
      }
    };
  }, [imageUrl]);

  // Handle keyboard events for accessibility
  const handleKeyDown = useCallback((event) => {
    if (event.key === 'Escape') {
      event.preventDefault();
      onRetake?.();
    }
    // Trap focus within the modal
    if (event.key === 'Tab') {
      const focusableElements = event.currentTarget.querySelectorAll(
        'button:not([disabled]), [tabindex]:not([tabindex="-1"])'
      );
      const firstElement = focusableElements[0];
      const lastElement = focusableElements[focusableElements.length - 1];

      if (event.shiftKey && document.activeElement === firstElement) {
        event.preventDefault();
        lastElement?.focus();
      } else if (!event.shiftKey && document.activeElement === lastElement) {
        event.preventDefault();
        firstElement?.focus();
      }
    }
  }, [onRetake]);

  // Lock body scroll when modal is open
  useEffect(() => {
    if (imageUrl) {
      const originalOverflow = document.body.style.overflow;
      document.body.style.overflow = 'hidden';
      return () => {
        document.body.style.overflow = originalOverflow;
      };
    }
  }, [imageUrl]);

  if (!imageUrl) return null;

  return (
    <div
      role="dialog"
      aria-modal="true"
      aria-label="Image preview"
      className="fixed inset-0 z-50 flex flex-col bg-black animate-fade-in"
      onKeyDown={handleKeyDown}
    >
      {/* Image container */}
      <div className="flex-1 flex items-center justify-center p-4 min-h-0">
        <img
          src={imageUrl}
          alt="Preview of your captured photo for the tarot reading"
          className="max-w-full max-h-full object-contain"
        />
      </div>

      {/* Action buttons with safe area padding for notched devices */}
      <div className="bg-black/70 backdrop-blur-sm p-4 pb-[max(1rem,env(safe-area-inset-bottom))] flex justify-center gap-6">
        <button
          type="button"
          onClick={onRetake}
          className="min-h-[48px] min-w-[100px] px-6 py-3 text-lg text-white font-semibold rounded-lg border border-white/30 hover:bg-white/10 focus:outline-none focus-visible:ring-2 focus-visible:ring-white/50 focus-visible:ring-offset-2 focus-visible:ring-offset-black transition-colors touch-manipulation"
        >
          Retake
        </button>
        <button
          ref={confirmButtonRef}
          type="button"
          onClick={onConfirm}
          className="min-h-[48px] min-w-[120px] px-6 py-3 text-lg text-white font-semibold bg-secondary hover:bg-secondary/90 rounded-lg focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/50 focus-visible:ring-offset-2 focus-visible:ring-offset-black transition-colors touch-manipulation"
        >
          Use Photo
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/InlineStatus.jsx">
import { CheckCircle, WarningCircle, XCircle, Info } from '@phosphor-icons/react';

const TONE_STYLES = {
  success: {
    icon: CheckCircle,
    className: 'text-accent'
  },
  warning: {
    icon: WarningCircle,
    className: 'text-amber-400'
  },
  error: {
    icon: XCircle,
    className: 'text-error'
  },
  info: {
    icon: Info,
    className: 'text-secondary'
  },
  pending: {
    icon: Info,
    className: 'text-secondary'
  }
};

/**
 * Determine the appropriate aria-live value based on tone.
 * Errors and warnings use 'assertive' for immediate announcement.
 * Other tones use 'polite' to avoid interrupting the user.
 */
function getDefaultLive(tone) {
  return tone === 'error' || tone === 'warning' ? 'assertive' : 'polite';
}

export function InlineStatus({ tone = 'info', message, live, className = '' }) {
  if (!message) return null;

  const toneConfig = TONE_STYLES[tone] || TONE_STYLES.info;
  const Icon = toneConfig.icon || Info;
  // Use provided live prop, or auto-select based on tone
  const ariaLive = live ?? getDefaultLive(tone);

  return (
    <div
      role="status"
      aria-live={ariaLive}
      className={`flex items-center gap-2 text-xs font-semibold ${toneConfig.className} ${className}`}
    >
      <Icon className="h-4 w-4" aria-hidden="true" />
      <span>{message}</span>
    </div>
  );
}
</file>

<file path="src/components/InsightsErrorBoundary.jsx">
import React from 'react';

/**
 * Catches rendering errors inside JournalInsightsPanel so the whole
 * Journal page does not blank out when an unexpected issue occurs.
 */
export class InsightsErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }

  componentDidCatch(error, info) {
    // Surface to console for debugging; production stays graceful.
    console.error('Journal insights crashed:', error, info);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="rounded-3xl border border-error/30 bg-error/5 p-4 text-sm text-error">
          Insights are temporarily unavailable. You can continue browsing your journal.
        </div>
      );
    }
    return this.props.children;
  }
}
</file>

<file path="src/components/InteractiveCardOverlay.jsx">
import { useCallback, useEffect, useState } from 'react';
import { createPortal } from 'react-dom';
import { SYMBOL_COORDINATES } from '../data/symbolCoordinates';
import { useReducedMotion } from '../hooks/useReducedMotion';
import { titleCase } from '../lib/textUtils';

// Estimated tooltip dimensions for collision detection
const TOOLTIP_WIDTH = 220;
const TOOLTIP_HEIGHT = 120;
const VIEWPORT_PADDING = 16;

/**
 * Calculate tooltip position with viewport collision detection
 */
function calculateTooltipPosition(rect) {
  let x = rect.left + rect.width / 2;
  let y = rect.bottom + 8;
  let placement = 'below';

  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;

  // Check if tooltip would overflow right edge
  if (x + TOOLTIP_WIDTH / 2 > viewportWidth - VIEWPORT_PADDING) {
    x = viewportWidth - TOOLTIP_WIDTH / 2 - VIEWPORT_PADDING;
  }

  // Check if tooltip would overflow left edge
  if (x - TOOLTIP_WIDTH / 2 < VIEWPORT_PADDING) {
    x = TOOLTIP_WIDTH / 2 + VIEWPORT_PADDING;
  }

  // Check if tooltip would overflow bottom - flip to top
  if (y + TOOLTIP_HEIGHT > viewportHeight - VIEWPORT_PADDING) {
    y = rect.top - TOOLTIP_HEIGHT - 8;
    placement = 'above';

    // If flipped tooltip would also overflow top, center it vertically
    if (y < VIEWPORT_PADDING) {
      y = Math.max(VIEWPORT_PADDING, (viewportHeight - TOOLTIP_HEIGHT) / 2);
      placement = 'center';
    }
  }

  return { x, y, placement };
}

/**
 * InteractiveCardOverlay - SVG overlay for card images with clickable symbol regions
 * Optimized for mobile with large touch targets and tap-based tooltips.
 * Uses React Portals to render tooltips above all card boundaries.
 */
export function InteractiveCardOverlay({ card }) {
  const [activeSymbol, setActiveSymbol] = useState(null);
  const [tooltipPosition, setTooltipPosition] = useState({ x: 0, y: 0, placement: 'below' });
  const prefersReducedMotion = useReducedMotion();

  // Get card number for coordinate lookup
  const cardNumber = card.number ?? null;
  const coordinates = SYMBOL_COORDINATES[cardNumber];

  // Close tooltip on scroll, resize, or clicking outside
  useEffect(() => {
    if (!activeSymbol || typeof window === 'undefined') return undefined;

    const handleScroll = () => setActiveSymbol(null);
    const handleResize = () => setActiveSymbol(null);
    const handleClickOutside = () => setActiveSymbol(null);

    window.addEventListener('scroll', handleScroll, { passive: true });
    window.addEventListener('resize', handleResize, { passive: true });

    // Delay adding click listener to avoid closing from the click that opened it
    const clickTimeoutId = setTimeout(() => {
      document.addEventListener('click', handleClickOutside);
    }, 0);

    return () => {
      window.removeEventListener('scroll', handleScroll);
      window.removeEventListener('resize', handleResize);
      clearTimeout(clickTimeoutId);
      document.removeEventListener('click', handleClickOutside);
    };
  }, [activeSymbol]);

  // Close tooltip on Escape key
  useEffect(() => {
    if (!activeSymbol) return undefined;

    const handleKeyDown = (event) => {
      if (event.key === 'Escape') {
        setActiveSymbol(null);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [activeSymbol]);

  const handleSymbolActivate = useCallback((symbol, event) => {
    // Prevent default browser behavior for proper handling
    if (event.type === 'keydown' && event.key === ' ') {
      event.preventDefault(); // Prevent page scroll on Space
    }
    event.stopPropagation();

    // Toggle tooltip - close if clicking same symbol, open if different
    if (activeSymbol?.object === symbol.object) {
      setActiveSymbol(null);
    } else {
      // Calculate position with collision detection
      const rect = event.currentTarget.getBoundingClientRect();
      const position = calculateTooltipPosition(rect);
      setTooltipPosition(position);
      setActiveSymbol(symbol);
    }
  }, [activeSymbol]);

  const handleKeyDown = useCallback((symbol, event) => {
    if (event.key === 'Enter' || event.key === ' ') {
      handleSymbolActivate(symbol, event);
    }
  }, [handleSymbolActivate]);

  // Only render for cards with mapped coordinates
  if (!coordinates) {
    return null;
  }

  return (
    <>
      <svg
        viewBox="0 0 820 1430"
        className="absolute inset-0 w-full h-full pointer-events-none"
        style={{ zIndex: 10 }}
        aria-hidden="true"
      >
        {/* Render symbol regions */}
        {coordinates.symbols.map((symbolCoord, index) => {
          const isActive = activeSymbol?.object === symbolCoord.symbol.object;
          const commonProps = {
            fill: isActive ? 'rgba(255, 215, 0, 0.3)' : 'transparent',
            stroke: isActive ? 'rgba(255, 215, 0, 0.8)' : 'rgba(255, 255, 255, 0.2)',
            strokeWidth: "3",
            className: "cursor-pointer transition-all duration-200 hover:fill-yellow-400/20 hover:stroke-yellow-400/60 focus:outline-none focus:stroke-yellow-400 focus:stroke-[6px]",
            onClick: (e) => handleSymbolActivate(symbolCoord.symbol, e),
            onKeyDown: (e) => handleKeyDown(symbolCoord.symbol, e),
            style: { pointerEvents: 'all' },
            tabIndex: 0,
            role: "button",
            "aria-label": `${symbolCoord.symbol.object}: ${symbolCoord.symbol.meaning}`,
            "aria-expanded": isActive,
            "aria-haspopup": "true"
          };

          return (
            <g key={`symbol-${index}`}>
              {/* Clickable region */}
              {symbolCoord.shape === 'circle' && (
                <circle
                  cx={symbolCoord.cx}
                  cy={symbolCoord.cy}
                  r={symbolCoord.r}
                  {...commonProps}
                />
              )}

              {symbolCoord.shape === 'rect' && (
                <rect
                  x={symbolCoord.x}
                  y={symbolCoord.y}
                  width={symbolCoord.width}
                  height={symbolCoord.height}
                  rx="8"
                  {...commonProps}
                />
              )}

              {symbolCoord.shape === 'polygon' && (
                <polygon
                  points={symbolCoord.points}
                  {...commonProps}
                />
              )}

              {/* Pulsing indicator dot to show symbol is interactive - respects reduced motion */}
              {!isActive && symbolCoord.indicatorCx && (
                <circle
                  cx={symbolCoord.indicatorCx}
                  cy={symbolCoord.indicatorCy}
                  r="8"
                  fill="rgba(255, 215, 0, 0.8)"
                  className={`${prefersReducedMotion ? '' : 'animate-pulse'} pointer-events-none`}
                  aria-hidden="true"
                />
              )}
            </g>
          );
        })}
      </svg>

      {/* Tooltip Portal */}
      {activeSymbol && typeof document !== 'undefined' && createPortal(
        <div
          className="fixed z-[9999] pointer-events-none"
          style={{
            left: tooltipPosition.x,
            top: tooltipPosition.y,
            transform: 'translate(-50%, 0)',
            maxWidth: '90vw',
            width: 'max-content'
          }}
          role="tooltip"
          aria-live="polite"
        >
          {/* Inner content with visual styling */}
          <div
            className={`bg-surface/95 backdrop-blur-md rounded-lg border-2 border-accent/60 p-3 shadow-2xl pointer-events-auto ${
              prefersReducedMotion ? '' : 'animate-in fade-in zoom-in-95 duration-150'
            }`}
            style={{ maxWidth: `${TOOLTIP_WIDTH}px` }}
          >
            <p className="text-sm font-semibold text-accent mb-1">
              {titleCase(activeSymbol.object)}
            </p>
            {activeSymbol.color && (
              <p className="text-xs text-secondary/80 mb-1">
                Color: {activeSymbol.color}
              </p>
            )}
            <p className="text-xs text-main/90 leading-relaxed whitespace-normal">
              {activeSymbol.meaning}
            </p>

            {/* Visual arrow indicator based on placement */}
            <div
              className={`absolute w-3 h-3 bg-surface/95 border-accent/60 transform rotate-45 ${
                tooltipPosition.placement === 'above'
                  ? 'bottom-[-6px] left-1/2 -translate-x-1/2 border-r-2 border-b-2'
                  : tooltipPosition.placement === 'below'
                  ? 'top-[-6px] left-1/2 -translate-x-1/2 border-l-2 border-t-2'
                  : 'hidden'
              }`}
              aria-hidden="true"
            />
          </div>
        </div>,
        document.body
      )}
    </>
  );
}
</file>

<file path="src/components/Journal.jsx">
import { useDeferredValue, useCallback, useEffect, useMemo, useState } from 'react';
import { CaretLeft, UploadSimple, Notebook, ChartLine, Sparkle, BookOpen, CaretDown, CaretUp } from '@phosphor-icons/react';
import { useNavigate } from 'react-router-dom';
import { GlobalNav } from './GlobalNav';
import { UserMenu } from './UserMenu';
import { ConfirmModal } from './ConfirmModal';
import { useAuth } from '../contexts/AuthContext';
import { useJournal } from '../hooks/useJournal';
import { JournalFilters } from './JournalFilters.jsx';
import { JournalInsightsPanel } from './JournalInsightsPanel.jsx';
import { InsightsErrorBoundary } from './InsightsErrorBoundary.jsx';
import { JournalEntryCard } from './JournalEntryCard.jsx';
import { SavedIntentionsList } from './SavedIntentionsList.jsx';
import { ArchetypeJourneySection } from './ArchetypeJourneySection.jsx';
import { computeJournalStats, formatContextName } from '../lib/journalInsights';
import { SPREADS } from '../data/spreads';
import { DECK_OPTIONS } from './DeckSelector';
import { useSmallScreen } from '../hooks/useSmallScreen';
import { useToast } from '../contexts/ToastContext.jsx';

const CONTEXT_FILTERS = [
  { value: 'love', label: 'Love' },
  { value: 'career', label: 'Career' },
  { value: 'self', label: 'Self' },
  { value: 'spiritual', label: 'Spiritual' },
  { value: 'wellbeing', label: 'Wellbeing' },
  { value: 'decision', label: 'Decision' }
];

const SPREAD_FILTERS = Object.entries(SPREADS || {}).map(([value, config]) => ({
  value,
  label: config?.name || value
}));

const DECK_FILTERS = DECK_OPTIONS.map(d => ({ value: d.id, label: d.label }));

const VISIBLE_ENTRY_BATCH = 10;
const MOBILE_LAYOUT_MAX = 1023;

function getEntryTimestamp(entry) {
  if (!entry) return null;
  if (typeof entry.ts === 'number') return entry.ts;
  if (entry?.created_at) return entry.created_at * 1000;
  if (entry?.updated_at) return entry.updated_at * 1000;
  return null;
}

function getMonthHeader(timestamp) {
  if (!timestamp) return 'Undated';
  const date = new Date(timestamp);
  if (Number.isNaN(date.getTime())) return 'Undated';
  return date.toLocaleString(undefined, { month: 'long', year: 'numeric' });
}

function formatSummaryDate(timestamp) {
  if (!timestamp) return 'No entries yet';
  const date = new Date(timestamp);
  if (Number.isNaN(date.getTime())) return 'No entries yet';
  return date.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' });
}

function getTopContext(stats) {
  if (!stats?.contextBreakdown?.length) return null;
  return stats.contextBreakdown.slice().sort((a, b) => b.count - a.count)[0];
}

export default function Journal() {
  const { isAuthenticated, user } = useAuth();
  const { entries, loading, deleteEntry, migrateToCloud, error: journalError } = useJournal();
  const [migrating, setMigrating] = useState(false);
  const [deleteConfirmModal, setDeleteConfirmModal] = useState({ isOpen: false, entryId: null });
  const [filters, setFilters] = useState({ query: '', contexts: [], spreads: [], decks: [], timeframe: 'all', onlyReversals: false });
  const deferredQuery = useDeferredValue(filters.query);
  const filterSignature = useMemo(
    () =>
      JSON.stringify({
        query: filters.query.trim().toLowerCase(),
        contexts: [...filters.contexts].sort(),
        spreads: [...filters.spreads].sort(),
        decks: [...filters.decks].sort(),
        timeframe: filters.timeframe,
        onlyReversals: filters.onlyReversals
      }),
    [filters]
  );
  const [shareLinks, setShareLinks] = useState([]);
  const [shareLoading, setShareLoading] = useState(false);
  const [shareError, setShareError] = useState('');
  const [compactList, setCompactList] = useState(false);
  const [mobilePanelsOpen, setMobilePanelsOpen] = useState({ filters: true, insights: false, archetype: false });
  const navigate = useNavigate();
  const isMobileLayout = useSmallScreen(MOBILE_LAYOUT_MAX);
  const { publish: showToast } = useToast();

  const handleStartReading = () => {
    navigate('/', { state: { focusSpread: true } });
  };

  const filteredEntries = useMemo(() => {
    if (!entries || entries.length === 0) {
      return [];
    }
    const query = deferredQuery.trim().toLowerCase();
    const contextSet = new Set(filters.contexts);
    const spreadSet = new Set(filters.spreads);
    const deckSet = new Set(filters.decks);
    const timeframeCutoff = (() => {
      const now = Date.now();
      switch (filters.timeframe) {
        case '30d':
          return now - 30 * 24 * 60 * 60 * 1000;
        case '90d':
          return now - 90 * 24 * 60 * 60 * 1000;
        case 'ytd': {
          const yearStart = new Date(new Date().getFullYear(), 0, 1).getTime();
          return yearStart;
        }
        default:
          return null;
      }
    })();

    return entries.filter((entry) => {
      if (contextSet.size > 0 && !contextSet.has(entry?.context)) {
        return false;
      }
      if (spreadSet.size > 0 && !spreadSet.has(entry?.spreadKey)) {
        return false;
      }
      if (deckSet.size > 0 && !deckSet.has(entry?.deckId)) {
        return false;
      }
      const entryTs = entry?.ts || (entry?.created_at ? entry.created_at * 1000 : null);
      if (timeframeCutoff && entryTs && entryTs < timeframeCutoff) {
        return false;
      }
      if (filters.onlyReversals) {
        const hasReversal = (entry?.cards || []).some((card) => (card?.orientation || '').toLowerCase().includes('reversed'));
        if (!hasReversal) {
          return false;
        }
      }
      if (query) {
        const reflections = entry?.reflections ? Object.values(entry.reflections).join(' ') : '';
        const cards = (entry?.cards || [])
          .map((card) => `${card.position || ''} ${card.name} ${card.orientation || ''}`)
          .join(' ');
        const haystack = [
          entry?.question,
          entry?.spread,
          entry?.context,
          entry?.personalReading,
          reflections,
          cards
        ]
          .filter(Boolean)
          .join(' ')
          .toLowerCase();
        if (!haystack.includes(query)) {
          return false;
        }
      }
      return true;
    });
  }, [entries, deferredQuery, filters.contexts, filters.spreads, filters.decks, filters.timeframe, filters.onlyReversals]);

  const [visibleCount, setVisibleCount] = useState(VISIBLE_ENTRY_BATCH);

  useEffect(() => {
    setVisibleCount(VISIBLE_ENTRY_BATCH);
  }, [filterSignature, filteredEntries.length]);

  const visibleEntries = useMemo(() => filteredEntries.slice(0, visibleCount), [filteredEntries, visibleCount]);
  const hasMoreEntries = filteredEntries.length > visibleCount;

  // Compute stats for both full journal and filtered view
  const allStats = useMemo(() => computeJournalStats(entries), [entries]);
  const filteredStats = useMemo(() => computeJournalStats(filteredEntries), [filteredEntries]);
  const filtersActive = Boolean(filters.query.trim()) || filters.contexts.length > 0 || filters.spreads.length > 0 || filters.decks.length > 0 || filters.timeframe !== 'all' || filters.onlyReversals;
  const hasEntries = entries.length > 0;
  const toggleMobilePanel = (panelId) => {
    setMobilePanelsOpen((prev) => ({ ...prev, [panelId]: !prev[panelId] }));
  };
  const renderMobileAccordionSection = (id, label, content, helperText) => (
    <div className="rounded-2xl border border-secondary/30 bg-surface/70">
      <button
        type="button"
        onClick={() => toggleMobilePanel(id)}
        aria-expanded={Boolean(mobilePanelsOpen[id])}
        className="flex w-full items-center justify-between px-4 py-3 text-left focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/40"
      >
        <div>
          <p className="text-[11px] uppercase tracking-[0.25em] text-secondary/70">{label}</p>
          {helperText && <p className="text-xs text-secondary/60">{helperText}</p>}
        </div>
        {mobilePanelsOpen[id] ? <CaretUp className="h-4 w-4 text-secondary/70" aria-hidden /> : <CaretDown className="h-4 w-4 text-secondary/70" aria-hidden />}
      </button>
      {mobilePanelsOpen[id] && (
        <div className="border-t border-secondary/15 p-4">
          {content}
        </div>
      )}
    </div>
  );

  const latestAllEntryTs = useMemo(() => {
    if (!entries || entries.length === 0) return null;
    return entries.reduce((latest, entry) => {
      const ts = getEntryTimestamp(entry);
      if (!ts) return latest;
      if (!latest || ts > latest) return ts;
      return latest;
    }, null);
  }, [entries]);

  const latestFilteredEntryTs = useMemo(() => {
    if (!filteredEntries || filteredEntries.length === 0) return null;
    return filteredEntries.reduce((latest, entry) => {
      const ts = getEntryTimestamp(entry);
      if (!ts) return latest;
      if (!latest || ts > latest) return ts;
      return latest;
    }, null);
  }, [filteredEntries]);

  const topContextAll = useMemo(() => getTopContext(allStats), [allStats]);
  const topContextFiltered = useMemo(() => getTopContext(filteredStats), [filteredStats]);
  const primaryEntryCount = filtersActive ? filteredEntries.length : entries.length;
  const entrySecondaryLabel = filtersActive ? `of ${entries.length} entries` : 'All time';
  const primaryReversalRate = filtersActive
    ? (filteredStats ? filteredStats.reversalRate : 0)
    : (allStats?.reversalRate ?? 0);
  const reversalSecondary = filtersActive
    ? `Journal avg ${allStats?.reversalRate ?? 0}%`
    : allStats?.totalCards
      ? `${allStats.totalCards} cards logged`
      : 'Log cards to see insights';
  const summaryTopContext = filtersActive && topContextFiltered ? topContextFiltered : topContextAll;
  const topContextLabel = summaryTopContext
    ? formatContextName(summaryTopContext.name)
    : filtersActive
      ? 'No match'
      : 'No context yet';
  const topContextSecondary = filtersActive
    ? summaryTopContext
      ? 'Filtered view'
      : 'Adjust filters to resurface contexts'
    : hasEntries
      ? `${entries.length} entries`
      : 'Log a reading';
  const summaryLastEntryTs = filtersActive && filteredEntries.length > 0 ? latestFilteredEntryTs : latestAllEntryTs;
  const summaryLastEntryLabel = filtersActive && filteredEntries.length === 0
    ? 'No matches'
    : formatSummaryDate(summaryLastEntryTs);
  const summaryLastEntrySecondary = filtersActive
    ? (filteredEntries.length === 0 ? 'Showing whole journal' : `Journal: ${formatSummaryDate(latestAllEntryTs)}`)
    : 'Latest journal update';
  const summaryCardData = [
    {
      id: 'entries',
      label: 'Entries logged',
      value: primaryEntryCount,
      hint: entrySecondaryLabel
    },
    {
      id: 'reversal',
      label: 'Reversal rate',
      value: `${primaryReversalRate}%`,
      hint: reversalSecondary
    },
    {
      id: 'context',
      label: 'Top context',
      value: topContextLabel,
      hint: topContextSecondary
    },
    {
      id: 'last-entry',
      label: 'Last entry',
      value: summaryLastEntryLabel,
      hint: summaryLastEntrySecondary
    }
  ];
  const showSummaryBand = !loading && hasEntries;

  const fetchShareLinks = useCallback(async () => {
    if (!isAuthenticated) return;
    setShareLoading(true);
    setShareError('');
    try {
      const response = await fetch('/api/share', { credentials: 'include' });
      if (!response.ok) {
        const payload = await response.json().catch(() => ({}));
        throw new Error(payload.error || 'Unable to load share links');
      }
      const payload = await response.json();
      setShareLinks(payload.shares || []);
    } catch (error) {
      setShareError(error.message || 'Unable to load share links');
    } finally {
      setShareLoading(false);
    }
  }, [isAuthenticated]);

  useEffect(() => {
    if (isAuthenticated) {
      fetchShareLinks();
    } else {
      setShareLinks([]);
      setShareError('');
    }
  }, [isAuthenticated, fetchShareLinks]);

  const createShareLink = useCallback(
    async ({ scope = 'journal', entryId, entryIds, title, limit, expiresInHours } = {}) => {
      if (!isAuthenticated) {
        throw new Error('Sign in to create share links');
      }
      const payload = { scope };
      const parsedLimit = Number.parseInt(limit, 10);
      const sanitizedLimit = Number.isFinite(parsedLimit)
        ? Math.max(1, Math.min(10, parsedLimit))
        : undefined;
      const parsedExpiry = Number.parseInt(expiresInHours, 10);
      const sanitizedExpiry = Number.isFinite(parsedExpiry) && parsedExpiry > 0
        ? Math.floor(parsedExpiry)
        : undefined;
      const normalizedEntryIds = Array.isArray(entryIds)
        ? entryIds
          .map((value) => (typeof value === 'string' ? value.trim() : ''))
          .filter(Boolean)
          .slice(0, 10)
        : [];

      if (scope === 'entry') {
        if (entryId) {
          payload.entryIds = [entryId];
        } else if (normalizedEntryIds.length === 1) {
          payload.entryIds = normalizedEntryIds;
        }
      } else if (normalizedEntryIds.length > 0) {
        payload.entryIds = normalizedEntryIds;
      } else if (sanitizedLimit) {
        payload.limit = sanitizedLimit;
      }
      if (title) {
        payload.title = title;
      }
      if (sanitizedExpiry) {
        payload.expiresInHours = sanitizedExpiry;
      }
      const response = await fetch('/api/share', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        const body = await response.json().catch(() => ({}));
        throw new Error(body.error || 'Unable to create share link');
      }
      const data = await response.json();
      await fetchShareLinks();
      return data;
    },
    [isAuthenticated, fetchShareLinks]
  );

  const deleteShareLink = useCallback(
    async (shareToken) => {
      if (!isAuthenticated) return;
      const response = await fetch(`/api/share/${shareToken}`, {
        method: 'DELETE',
        credentials: 'include'
      });
      if (!response.ok) {
        const payload = await response.json().catch(() => ({}));
        throw new Error(payload.error || 'Unable to delete share link');
      }
      await fetchShareLinks();
    },
    [isAuthenticated, fetchShareLinks]
  );

  const handleMigrate = async () => {
    setMigrating(true);

    const result = await migrateToCloud();

    if (result.success) {
      const parts = [`Migrated ${result.migrated} entries`];
      if (typeof result.skipped === 'number' && result.skipped > 0) {
        parts.push(`${result.skipped} already existed`);
      }
      showToast({
        type: 'success',
        title: 'Migration complete',
        description: parts.join(', ')
      });
    } else {
      showToast({
        type: 'error',
        title: 'Migration failed',
        description: result.error || 'We could not sync your local entries.'
      });
    }

    setMigrating(false);
  };

  const handleDeleteRequest = (entryId) => {
    setDeleteConfirmModal({ isOpen: true, entryId });
  };

  const handleDeleteConfirm = async () => {
    const entryId = deleteConfirmModal.entryId;
    if (!entryId) return;

    // Close modal immediately to provide responsive feedback
    setDeleteConfirmModal({ isOpen: false, entryId: null });

    const result = await deleteEntry(entryId);

    if (result.success) {
      showToast({
        type: 'success',
        title: 'Entry deleted',
        description: 'Removed from your journal history.'
      });
    } else {
      showToast({
        type: 'error',
        title: 'Delete failed',
        description: result.error || 'Please try again in a moment.'
      });
    }
  };

  const handleDeleteCancel = () => {
    setDeleteConfirmModal({ isOpen: false, entryId: null });
  };

  const handleLoadMoreEntries = () => {
    setVisibleCount((prev) => Math.min(filteredEntries.length, prev + VISIBLE_ENTRY_BATCH));
  };

  // Check if we have localStorage entries that can be migrated
  const hasLocalStorageEntries = () => {
    if (typeof localStorage === 'undefined') return false;
    const stored = localStorage.getItem('tarot_journal');
    if (!stored) return false;
    try {
      const parsed = JSON.parse(stored);
      return Array.isArray(parsed) && parsed.length > 0;
    } catch {
      return false;
    }
  };

  const desktopRailContent = (!loading && hasEntries && !isMobileLayout) ? (
    <div className="space-y-6 lg:space-y-8">
      <JournalFilters
        filters={filters}
        onChange={setFilters}
        contexts={CONTEXT_FILTERS}
        spreads={SPREAD_FILTERS}
        decks={DECK_FILTERS}
      />
      {(allStats || filteredStats) && (
        <InsightsErrorBoundary>
          <JournalInsightsPanel
            stats={filteredStats}
            allStats={allStats}
            entries={filteredEntries}
            allEntries={entries}
            isAuthenticated={isAuthenticated}
            filtersActive={filtersActive}
            shareLinks={shareLinks}
            shareLoading={shareLoading}
            shareError={shareError}
            onCreateShareLink={isAuthenticated ? createShareLink : null}
            onDeleteShareLink={isAuthenticated ? deleteShareLink : null}
          />
        </InsightsErrorBoundary>
      )}
      {isAuthenticated && (
        <ArchetypeJourneySection isAuthenticated={isAuthenticated} userId={user?.id} showEmptyState />
      )}
    </div>
  ) : null;
  const hasRailContent = !loading && hasEntries;
  const entryStackSpacingClass = compactList ? 'space-y-3.5' : 'space-y-5';
  let lastMonthLabel = null;
  const renderedHistoryEntries = visibleEntries.map((entry, index) => {
    const timestamp = getEntryTimestamp(entry);
    const monthLabel = getMonthHeader(timestamp);
    const showDivider = monthLabel !== lastMonthLabel;
    lastMonthLabel = monthLabel;
    const key = entry.id || `${timestamp || 'entry'}-${index}`;
    return (
      <div key={key} className="space-y-2">
        {showDivider && (
          <p className="text-[11px] uppercase tracking-[0.3em] text-secondary/60">{monthLabel}</p>
        )}
        <JournalEntryCard
          entry={entry}
          isAuthenticated={isAuthenticated}
          onCreateShareLink={isAuthenticated ? createShareLink : null}
          onDelete={handleDeleteRequest}
          compact={compactList}
        />
      </div>
    );
  });

  const mobileRailContent = (!loading && hasEntries && isMobileLayout) ? (
    <section className="mb-6 space-y-3 lg:hidden" aria-label="Journal filters and insights">
      {renderMobileAccordionSection('filters', 'Filters', (
        <JournalFilters
          filters={filters}
          onChange={setFilters}
          contexts={CONTEXT_FILTERS}
          spreads={SPREAD_FILTERS}
          decks={DECK_FILTERS}
        />
      ), 'Search and narrow your journal')}

      {(allStats || filteredStats) && renderMobileAccordionSection('insights', 'Insights', (
        <InsightsErrorBoundary>
          <JournalInsightsPanel
            stats={filteredStats}
            allStats={allStats}
            entries={filteredEntries}
            allEntries={entries}
            isAuthenticated={isAuthenticated}
            filtersActive={filtersActive}
            shareLinks={shareLinks}
            shareLoading={shareLoading}
            shareError={shareError}
            onCreateShareLink={isAuthenticated ? createShareLink : null}
            onDeleteShareLink={isAuthenticated ? deleteShareLink : null}
          />
        </InsightsErrorBoundary>
      ), 'Share, export, and view analytics')}

      {isAuthenticated && renderMobileAccordionSection('archetype', 'Archetype journey', (
        <ArchetypeJourneySection isAuthenticated={isAuthenticated} userId={user?.id} showEmptyState />
      ), 'Track recurring cards in your readings')}
    </section>
  ) : null;

  return (
    <>
      <div className="min-h-screen bg-main text-main animate-fade-in">
        <div className="skip-links">
          <a href="#journal-content" className="skip-link">Skip to journal content</a>
        </div>
        <main id="journal-content" tabIndex={-1} className="journal-page max-w-5xl mx-auto px-4 sm:px-6 py-8">
          <GlobalNav />

          <div className="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between mb-6">
            <button
              onClick={() => navigate('/')}
              className="flex items-center text-accent hover:text-main self-start"
            >
              <CaretLeft className="w-5 h-5 mr-2" />
              Back to Reading
            </button>

            <div className="flex items-center gap-4">
              <UserMenu />
            </div>
          </div>

          <h1 className="text-3xl font-serif text-accent mb-4">Your Tarot Journal</h1>

          {isAuthenticated ? (
            <div className="mb-6 rounded-2xl border border-secondary/40 bg-secondary/10 p-4">
              <p className="journal-prose text-secondary">✓ Signed in — Your journal is synced across devices</p>
              {hasLocalStorageEntries() && !migrating && (
                <button
                  onClick={handleMigrate}
                  className="mt-2 inline-flex items-center gap-2 text-sm text-secondary hover:text-secondary/80 underline"
                >
                  <UploadSimple className="w-4 h-4" />
                  Migrate localStorage entries to cloud
                </button>
              )}
              {migrating && (
                <p className="mt-2 text-sm text-secondary">Migrating...</p>
              )}
            </div>
          ) : (
            <div className="mb-6 rounded-2xl border border-primary/40 bg-primary/10 p-4 text-sm text-accent journal-prose">
              Your journal is currently stored locally in this browser only. Use the Sign In button in the header to sync across devices.
            </div>
          )}

          {journalError && (
            <div className="mb-4 rounded-lg border border-error/40 bg-error/10 p-3 text-sm text-error">
              {journalError}
            </div>
          )}

          {showSummaryBand && (
            <section className="mb-6 rounded-3xl border border-secondary/30 bg-surface/80 p-6 shadow-lg">
              <div className="flex flex-col gap-6">
                <div className="flex flex-col gap-3 lg:flex-row lg:items-center lg:justify-between">
                  <div>
                    <p className="journal-eyebrow text-secondary/70">Journal pulse</p>
                    <h2 className="text-2xl font-serif text-main">Where your readings stand</h2>
                  </div>
                  <div className="flex flex-col gap-3 sm:flex-row sm:items-center">
                    <button
                      type="button"
                      onClick={handleStartReading}
                      className="inline-flex items-center justify-center rounded-full bg-accent px-5 py-2 text-sm font-semibold text-surface shadow-lg shadow-accent/30 hover:opacity-95"
                    >
                      New entry
                    </button>
                      <label className="journal-prose flex items-center gap-2 text-sm text-secondary">
                      <input
                        type="checkbox"
                        className="h-4 w-4 rounded border-secondary/40 bg-surface text-accent focus:ring-secondary"
                        checked={compactList}
                        onChange={(event) => setCompactList(event.target.checked)}
                      />
                      Compact list
                    </label>
                  </div>
                </div>
                <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-4">
                  {summaryCardData.map((card) => (
                    <div key={card.id} className="rounded-2xl border border-secondary/20 bg-surface/40 p-4">
                      <p className="journal-eyebrow text-secondary/60">{card.label}</p>
                      <p className="mt-2 text-2xl font-serif text-main">{card.value}</p>
                      {card.hint && (
                        <p className="journal-prose text-secondary/70">{card.hint}</p>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            </section>
          )}

          {mobileRailContent}

          {loading ? (
            <div className="py-12 text-center">
              <div className="inline-block h-8 w-8 animate-spin rounded-full border-b-2 border-accent" />
              <p className="mt-4 text-muted">Loading journal...</p>
            </div>
          ) : (
              <div className={hasEntries && hasRailContent ? 'lg:grid lg:grid-cols-[minmax(0,1fr)_360px] lg:gap-6' : ''}>
                <div className="space-y-8">
                <section id="today" className="rounded-3xl border border-secondary/30 bg-surface/70 p-5 shadow-lg">
                  <div className="mb-4">
                    <p className="journal-eyebrow text-secondary/70">Today</p>
                    <h2 className="text-xl font-serif text-main">Keep today&rsquo;s focus handy</h2>
                  </div>
                  <SavedIntentionsList />
                </section>

                    {hasEntries ? (
                      <section id="history" className="space-y-5">
                      <div className="flex flex-col gap-1 sm:flex-row sm:items-center sm:justify-between">
                        <div className="flex items-center gap-2">
                          <h2 className="text-xl font-serif text-main">Journal history</h2>
                          <span className="inline-flex items-center rounded-full border border-secondary/25 bg-surface/60 px-2.5 py-1 text-[10px] font-semibold uppercase tracking-[0.18em] text-secondary/70">
                            History
                          </span>
                        </div>
                        <span className="inline-flex items-center gap-2 rounded-full border border-secondary/25 bg-surface/60 px-3 py-1 text-[11px] text-secondary/70">
                          Showing {visibleEntries.length} of {filteredEntries.length}
                        </span>
                      </div>

                    {filteredEntries.length === 0 ? (
                      <div className="rounded-2xl border border-secondary/30 bg-surface/60 p-6 text-sm text-secondary">
                          <p className="journal-prose">No entries match your filters.</p>
                          <p className="journal-prose mt-2 text-secondary/70">Try adjusting the filters or reset to see the full journal.</p>
                      </div>
                    ) : (
                      <>
                        <div className={entryStackSpacingClass}>
                          {renderedHistoryEntries}
                        </div>
                        {hasMoreEntries && (
                          <div className="flex justify-center">
                            <button
                              type="button"
                              onClick={handleLoadMoreEntries}
                              className="inline-flex items-center rounded-full border border-secondary/30 bg-surface/70 px-3.5 py-1.5 text-xs font-semibold text-secondary hover:bg-secondary/10"
                            >
                              Load {Math.min(VISIBLE_ENTRY_BATCH, filteredEntries.length - visibleEntries.length)} more
                            </button>
                          </div>
                        )}
                      </>
                    )}
                  </section>
                ) : (
                  <div className="modern-surface animate-fade-in space-y-4 rounded-3xl p-6 text-center text-main">
                    <div className="flex justify-center">
                      <Notebook className="h-10 w-10 text-accent" aria-hidden="true" />
                    </div>
                    <div>
                      <h2 className="text-2xl font-serif text-accent">Start your tarot journal</h2>
                      <p className="journal-prose mt-1 text-sm text-muted sm:text-base">
                        Track patterns across readings, revisit past insights, and watch your understanding deepen over time.
                      </p>
                    </div>
                    <div className="grid gap-3 text-left text-sm text-muted sm:grid-cols-3">
                      <div className="flex items-start gap-2">
                        <Sparkle className="mt-0.5 h-4 w-4 text-accent" />
                        <div className="journal-prose">
                          <p className="text-main font-semibold">Spot recurring themes</p>
                          <p>Surface repeaters and spreads that resonate most.</p>
                        </div>
                      </div>
                      <div className="flex items-start gap-2">
                        <ChartLine className="mt-0.5 h-4 w-4 text-accent" />
                        <div className="journal-prose">
                          <p className="text-main font-semibold">Measure your growth</p>
                          <p>See how questions evolve and which cards guide you.</p>
                        </div>
                      </div>
                      <div className="flex items-start gap-2">
                        <BookOpen className="mt-0.5 h-4 w-4 text-accent" />
                        <div className="journal-prose">
                          <p className="text-main font-semibold">Capture reflections</p>
                          <p>Keep notes beside each position to revisit later.</p>
                        </div>
                      </div>
                    </div>
                    <div className="rounded-xl border border-secondary/50 bg-surface p-4 text-left shadow-sm">
                      <p className="text-[0.78rem] uppercase tracking-[0.12em] text-secondary/80 mb-1">Example entry</p>
                      <div className="journal-prose flex flex-col gap-1 text-sm text-muted">
                        <p className="text-main font-semibold">Three-Card Story · Daily check-in</p>
                        <p>Question: &ldquo;What pattern is emerging for me this week?&rdquo;</p>
                        <p>Pull: The Star (upright), Six of Cups, Two of Wands</p>
                        <p className="italic text-secondary">Reflection: Hope is back. Remember the plan from Tuesday and take the next step.</p>
                      </div>
                    </div>
                    <div className="flex flex-wrap items-center justify-center gap-3 pt-1">
                      <button
                        type="button"
                        onClick={handleStartReading}
                        className="inline-flex items-center gap-2 rounded-full bg-accent px-5 py-2.5 text-sm font-semibold text-surface shadow-lg shadow-accent/25 hover:opacity-95 transition"
                      >
                        Start a reading
                      </button>
                      <button
                        type="button"
                        onClick={() => navigate('/', { state: { focusSpread: true, initialQuestion: 'What pattern is emerging for me this week?' } })}
                        className="inline-flex items-center gap-2 rounded-full border border-secondary/60 px-5 py-2.5 text-sm font-semibold text-secondary hover:bg-secondary/10 transition"
                      >
                        Try a guided draw
                      </button>
                    </div>
                  </div>
                )}
              </div>

              {hasEntries && hasRailContent && desktopRailContent && (
                <aside className="hidden lg:block">
                  <div className="lg:sticky lg:top-6">
                    {desktopRailContent}
                  </div>
                </aside>
              )}
            </div>
          )}
        </main>
      </div>

      <ConfirmModal
        isOpen={deleteConfirmModal.isOpen}
        onClose={handleDeleteCancel}
        onConfirm={handleDeleteConfirm}
        title="Delete Journal Entry"
        message="Are you sure you want to delete this journal entry? This action cannot be undone."
        confirmText="Delete"
        cancelText="Keep Entry"
        variant="danger"
      />
    </>
  );
}
</file>

<file path="src/components/JournalEntryCard.jsx">
import { useState, memo, useId } from 'react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import remarkBreaks from 'remark-breaks';
import { ShareNetwork, DownloadSimple, Trash, CaretDown, CaretUp, BookOpen, ClipboardText, Sparkle, CircleNotch } from '@phosphor-icons/react';
import { CardSymbolInsights } from './CardSymbolInsights';
import { buildCardInsightPayload, exportJournalEntriesToCsv, copyJournalEntrySummary, copyJournalEntriesToClipboard, REVERSED_PATTERN, formatContextName } from '../lib/journalInsights';
import { useSmallScreen } from '../hooks/useSmallScreen';
import { InlineStatus } from './InlineStatus.jsx';
import { useInlineStatus } from '../hooks/useInlineStatus';

const ICON_BUTTON_CLASS = 'inline-flex items-center justify-center h-9 w-9 rounded-full border border-secondary/25 bg-surface/40 text-secondary/70 hover:border-secondary/50 hover:text-secondary focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/40 disabled:opacity-50 disabled:cursor-not-allowed active:bg-secondary/15';
const ICON_BUTTON_DANGER_CLASS = 'inline-flex items-center justify-center h-9 w-9 rounded-full border border-error/25 bg-surface/40 text-error/80 hover:border-error/60 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-error/40 disabled:opacity-50 disabled:cursor-not-allowed active:bg-error/10';

const CONTEXT_SUMMARIES = {
    love: 'Relationship lens — center relational reciprocity and communication.',
    career: 'Career lens — focus on vocation, impact, and material pathways.',
    self: 'Self lens — emphasize personal growth and inner landscape.',
    spiritual: 'Spiritual lens — frame insights through devotion, meaning, and practice.',
    decision: 'Decision lens — weigh the tradeoffs and clarify what aligns before choosing a path.'
};

const TIMING_SUMMARIES = {
  'near-term-tilt': 'Timing: energy is likely to shift in the near-term if you engage with it.',
  'longer-arc-tilt': 'Timing: this pattern stretches over a longer arc demanding patience.',
  'developing-arc': 'Timing: expect this to develop as an unfolding chapter, not a single moment.'
};

function normalizeTimestamp(value) {
  if (!Number.isFinite(value)) return null;
  return value < 1e12 ? value * 1000 : value;
}

function deriveTimestamp(entry) {
  const tsCandidates = [entry?.ts, entry?.created_at, entry?.updated_at].map(normalizeTimestamp);
  return tsCandidates.find(Boolean) || null;
}

function buildThemeInsights(entry) {
    const lines = [];
    const themes = entry?.themes;
    if (entry?.context) {
        lines.push(CONTEXT_SUMMARIES[entry.context] || `Context lens: ${entry.context}`);
    }

    if (!themes || typeof themes !== 'object') {
        return lines;
    }

    if (themes.suitFocus) {
        lines.push(themes.suitFocus);
    } else if (themes.dominantSuit) {
        lines.push(`Suit focus: ${themes.dominantSuit} themes stand out in this spread.`);
    }

    if (themes.elementalBalance) {
        lines.push(themes.elementalBalance);
    }

    if (themes.archetypeDescription) {
        lines.push(themes.archetypeDescription);
    }

    if (themes.reversalDescription?.name) {
        const desc = themes.reversalDescription.description
            ? ` — ${themes.reversalDescription.description}`
            : '';
        lines.push(`Reversal lens: ${themes.reversalDescription.name}${desc}`);
    }

    if (themes.timingProfile && TIMING_SUMMARIES[themes.timingProfile]) {
        lines.push(TIMING_SUMMARIES[themes.timingProfile]);
    }

    return lines.filter(Boolean);
}

const JournalCardListItem = memo(function JournalCardListItem({ card }) {
  const insightCard = buildCardInsightPayload(card);
  const isReversed = REVERSED_PATTERN.test(card?.orientation || '');

  return (
    <li className="group relative flex flex-col gap-2 rounded-xl border border-secondary/20 bg-surface-muted/40 p-3 transition-colors hover:bg-surface-muted/60 sm:flex-row sm:items-center sm:justify-between">
      <div className="flex items-center gap-3 min-w-0 flex-1">
        {/* Position indicator bar */}
        <div className="flex-shrink-0 w-1 self-stretch rounded-full bg-secondary/30 hidden sm:block" />

        <div className="flex-1 min-w-0">
          {/* Position label */}
          <span className="text-[10px] font-bold uppercase tracking-wider text-secondary/70 leading-tight">
            {card.position}
          </span>
          {/* Card name + orientation */}
          <div className="flex items-center gap-2 mt-0.5">
            <p className="text-sm font-medium text-main truncate">
              {card.name}
            </p>
            <span className={`flex-shrink-0 text-[10px] ${isReversed ? 'font-semibold text-error/80 bg-error/10' : 'text-secondary/50'} px-1.5 py-0.5 rounded`}>
              {isReversed ? 'Rev' : 'Up'}
            </span>
          </div>
        </div>
      </div>

      {/* Symbol insights - visible on mobile, hover-reveal on desktop */}
      {insightCard && (
        <div className="transition-opacity sm:opacity-0 sm:group-hover:opacity-100 shrink-0">
          <CardSymbolInsights card={insightCard} position={card.position} />
        </div>
      )}
    </li>
  );
});

export const JournalEntryCard = memo(function JournalEntryCard({ entry, onCreateShareLink, isAuthenticated, onDelete, defaultExpanded = false, compact = false }) {
  const insights = buildThemeInsights(entry);
  const [isExpanded, setIsExpanded] = useState(defaultExpanded);
  const [showNarrative, setShowNarrative] = useState(false);
  const [showCards, setShowCards] = useState(false); // Collapsed by default on mobile
  const [pendingAction, setPendingAction] = useState(null);
  const entryContentId = useId();
  const narrativeId = useId();
  const cardsId = useId();
  const isSmallScreen = useSmallScreen(640); // < sm breakpoint
  const { status: inlineStatus, showStatus, clearStatus } = useInlineStatus();

  const runAction = async (actionKey, task) => {
    setPendingAction(actionKey);
    clearStatus();
    try {
      return await task();
    } finally {
      setPendingAction(null);
    }
  };

  const handleEntryExport = () => runAction('export', async () => {
    const filename = `tarot-entry-${entry.id || entry.ts || 'reading'}.csv`;
    const success = exportJournalEntriesToCsv([entry], filename);
    showStatus({
      tone: success ? 'success' : 'error',
      message: success ? `Saved ${filename}` : 'Unable to download this entry right now.'
    });
    return success;
  });

  const handleEntryCopy = async () => runAction('copy', async () => {
    const success = await copyJournalEntriesToClipboard([entry]);
    showStatus({
      tone: success ? 'success' : 'error',
      message: success ? 'Reading details copied to your clipboard.' : 'Copying was blocked by the browser.'
    });
    return success;
  });

  const handleEntryShare = async () => runAction('share', async () => {
    if (isAuthenticated && onCreateShareLink) {
      try {
        const data = await onCreateShareLink({ scope: 'entry', entryId: entry.id });
        const shareUrl = data?.url && typeof window !== 'undefined'
          ? `${window.location.origin}${data.url}`
          : null;
        if (shareUrl && navigator?.clipboard?.writeText) {
          await navigator.clipboard.writeText(shareUrl);
          showStatus({ tone: 'success', message: 'Share link copied to clipboard.' });
        } else {
          showStatus({ tone: 'info', message: 'Share link ready—copy from your browser address bar.' });
        }
        return true;
      } catch (error) {
        showStatus({ tone: 'error', message: error.message || 'Unable to create a share link right now.' });
        return false;
      }
    }

    const success = await copyJournalEntrySummary(entry);
    showStatus({
      tone: success ? 'success' : 'error',
      message: success ? 'Entry summary copied to your clipboard.' : 'Unable to copy this entry right now.'
    });
    return success;
  });

  const timestamp = deriveTimestamp(entry);
  const formattedTimestamp = timestamp
    ? new Date(timestamp).toLocaleString(undefined, {
      weekday: 'short',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    })
    : 'Date unavailable';
  const cards = Array.isArray(entry?.cards) ? entry.cards : [];
  const reflections = entry?.reflections && typeof entry.reflections === 'object'
    ? Object.entries(entry.reflections).filter(([, note]) => typeof note === 'string' && note.trim())
    : [];
  const hasReflections = reflections.length > 0;
  const contextLabel = entry?.context ? formatContextName(entry.context) : '';
  const headerPadding = compact ? 'p-3.5 sm:p-4' : 'p-4';
  const contentPadding = compact ? 'px-4 py-4 sm:p-5' : 'p-5';
  const cardPreview = cards.slice(0, 3).map((card, index) => ({
    key: `${card?.position || card?.name || 'card'}-${index}`,
    name: card?.name || 'Card',
    isReversed: REVERSED_PATTERN.test(card?.orientation || (card?.isReversed ? 'reversed' : ''))
  }));

  return (
    <article className="group relative rounded-2xl border border-secondary/20 bg-surface/40 transition-all hover:border-secondary/40 hover:bg-surface/60 animate-fade-in">
      <div className={`${headerPadding} ${isExpanded ? 'border-b border-secondary/10' : ''}`}>
        <button
          onClick={() => setIsExpanded(prev => !prev)}
          aria-expanded={isExpanded}
          aria-controls={entryContentId}
          className="w-full text-left rounded-lg focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/50 -m-1 p-1"
        >
          <div className="flex items-start gap-3">
            <span className="mt-0.5 flex h-8 w-8 items-center justify-center rounded-full bg-surface-muted/70 text-secondary/70 ring-1 ring-secondary/25">
              {isExpanded ? (
                <CaretUp className="h-4 w-4" aria-hidden="true" />
              ) : (
                <CaretDown className="h-4 w-4" aria-hidden="true" />
              )}
            </span>

            <div className="min-w-0 flex-1 space-y-1">
              <div className="flex items-center gap-2 min-w-0">
                <h3 className={`font-serif ${compact ? 'text-base' : 'text-lg'} text-main truncate`}>
                  {entry.spread || 'Tarot Reading'}
                </h3>
                {contextLabel && (
                  <span className="inline-flex items-center rounded-full bg-secondary/10 px-2 py-0.5 text-[10px] font-semibold uppercase tracking-[0.12em] text-secondary/80">
                    {contextLabel}
                  </span>
                )}
                {hasReflections && (
                  <span className="inline-flex items-center gap-1 rounded-full bg-accent/10 border border-accent/20 px-2 py-0.5 text-[10px] font-semibold text-accent/90">
                    <Sparkle className="h-2.5 w-2.5" aria-hidden="true" />
                    {reflections.length}
                  </span>
                )}
              </div>

              <div className="flex flex-wrap items-center gap-x-2 gap-y-1 text-[11px] text-secondary/70">
                <span>{formattedTimestamp}</span>
                {cards.length > 0 && (
                  <span className="inline-flex items-center gap-1 rounded-full bg-surface-muted/60 px-2 py-0.5 text-[11px] text-secondary/70">
                    {cards.length} cards
                  </span>
                )}
              </div>

              {entry.question && (
                <p className="text-sm text-secondary/80 line-clamp-1">
                  &ldquo;{entry.question}&rdquo;
                </p>
              )}
            </div>
          </div>
        </button>

        {!isExpanded && cardPreview.length > 0 && (
          <div className="mt-3 flex flex-wrap items-center gap-1.5 sm:gap-2">
            {cardPreview.map((card) => (
              <span
                key={card.key}
                className="inline-flex items-center rounded-full border border-secondary/20 bg-surface-muted/80 px-2.5 py-1 text-[11px] font-medium text-main/80 shadow-sm"
              >
                <span className="truncate max-w-[8rem]">{card.name}</span>
                {card.isReversed && (
                  <span className="ml-1 inline-flex h-4 w-4 items-center justify-center rounded-full bg-error/10 text-[10px] text-error/90 ring-1 ring-error/20">
                    <CaretDown className="h-3 w-3 rotate-180" aria-hidden="true" />
                  </span>
                )}
              </span>
            ))}
            {cards.length > 3 && (
              <span className="text-[11px] font-semibold text-secondary/60">+{cards.length - 3}</span>
            )}
          </div>
        )}
      </div>

      {/* Collapsible content */}
      {isExpanded && (
        <div id={entryContentId} className={`${contentPadding} animate-slide-down`}>
          {/* Question */}
          {entry.question && (
            <div className="mb-4">
              <p className="journal-eyebrow mb-1 text-secondary/80">Question</p>
              <p className="journal-quote text-main/90">
                &ldquo;{entry.question}&rdquo;
              </p>
            </div>
          )}

          {/* Cards Grid - collapsible on mobile */}
          <div className="mb-5">
            {/* Mobile: collapsible toggle */}
            {isSmallScreen && cards.length > 0 ? (
              <div className="rounded-xl border border-secondary/15 bg-surface/30 overflow-hidden">
                <button
                  onClick={() => setShowCards(prev => !prev)}
                  aria-expanded={showCards}
                  aria-controls={cardsId}
                  className="w-full flex items-center justify-between px-3 py-2.5 text-left active:bg-secondary/10"
                >
                  <span className="text-[11px] font-semibold uppercase tracking-wider text-secondary/80">
                    Cards Drawn
                    <span className="ml-1.5 text-secondary/60">({cards.length})</span>
                  </span>
                  <div className="flex items-center gap-2">
                    {!showCards && (
                      <span className="text-xs text-secondary/50 truncate max-w-[140px]">
                        {cards.slice(0, 2).map(c => {
                          // Abbreviate long names: "The High Priestess" → "High Priestess", "Ace of Wands" → "Ace Wands"
                          const name = c.name || '';
                          return name.replace(/^The\s+/i, '').replace(/\s+of\s+/i, ' ');
                        }).join(', ')}
                        {cards.length > 2 && '…'}
                      </span>
                    )}
                    {showCards ? (
                      <CaretUp className="h-4 w-4 text-secondary/60 flex-shrink-0" aria-hidden="true" />
                    ) : (
                      <CaretDown className="h-4 w-4 text-secondary/60 flex-shrink-0" aria-hidden="true" />
                    )}
                  </div>
                </button>
                {showCards && (
                  <div id={cardsId} className="px-3 pb-3 animate-slide-down">
                    <ul className="grid gap-2">
                      {cards.map((card, idx) => (
                        <JournalCardListItem key={idx} card={card} />
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            ) : (
              <>
                {/* Desktop: always expanded */}
                <p className="journal-eyebrow mb-2 text-secondary/80">Cards Drawn</p>
                {cards.length > 0 ? (
                  <ul className="grid gap-2 sm:grid-cols-2">
                    {cards.map((card, idx) => (
                      <JournalCardListItem key={idx} card={card} />
                    ))}
                  </ul>
                ) : (
                  <p className="journal-prose text-sm text-secondary/70">No cards recorded for this entry.</p>
                )}
              </>
            )}
          </div>

          {hasReflections && (
            <div className="mb-5">
              <p className="journal-eyebrow mb-2 text-secondary/80">Reflections</p>
              <ul className="journal-prose space-y-1.5 text-secondary/80">
                {reflections.map(([position, note], index) => (
                  <li key={`${position || 'reflection'}-${index}`} className="flex items-start gap-2">
                    <span className="font-medium text-main">{position || `Note ${index + 1}`}</span>
                    <span className="text-secondary/70">{note}</span>
                  </li>
                ))}
              </ul>
            </div>
          )}

          {/* Insights & Narrative */}
          <div className="space-y-4">
            {insights.length > 0 && (
              <div className="rounded-xl bg-secondary/10 p-4">
                <h4 className="mb-2 flex items-center gap-2 text-xs font-bold uppercase tracking-wider text-secondary">
                  <BookOpen className="h-3 w-3" />
                  Key Themes
                </h4>
                <ul className="space-y-1.5">
                  {insights.map((line, idx) => (
                    <li key={idx} className="text-sm leading-relaxed text-secondary/80">
                      • {line}
                    </li>
                  ))}
                </ul>
              </div>
            )}

            {entry.personalReading && (
              <div>
                <button
                  onClick={() => setShowNarrative(!showNarrative)}
                  aria-expanded={showNarrative}
                  aria-controls={narrativeId}
                  className="flex w-full items-center justify-between rounded-xl border border-secondary/20 bg-surface/30 px-4 py-3 text-sm font-medium text-main transition-colors hover:bg-surface/50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/50"
                >
                  <span>Reading Narrative</span>
                  {showNarrative ? <CaretUp className="h-4 w-4" aria-hidden="true" /> : <CaretDown className="h-4 w-4" aria-hidden="true" />}
                </button>

                {showNarrative && (
                  <div id={narrativeId} className="mt-2 animate-slide-down rounded-xl border border-secondary/10 bg-surface/20 p-4">
                    <div className="prose prose-invert prose-sm max-w-prose font-serif leading-relaxed text-muted">
                      <ReactMarkdown remarkPlugins={[remarkGfm, remarkBreaks]} skipHtml>
                        {entry.personalReading}
                      </ReactMarkdown>
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        </div>
      )}

      {/* Footer actions */}
      <div className="border-t border-secondary/10 bg-surface/30 px-3.5 py-2.5 flex items-center justify-between">
        <div className="hidden sm:block text-[11px] text-secondary/70">
          {hasReflections ? `${reflections.length} reflection${reflections.length === 1 ? '' : 's'}` : formattedTimestamp}
        </div>

        <div className="flex items-center gap-1.5">
          <button
            onClick={handleEntryCopy}
            className={ICON_BUTTON_CLASS}
            aria-label="Copy reading details to clipboard"
            title="Copy entry"
            disabled={pendingAction === 'copy'}
          >
            {pendingAction === 'copy' ? <CircleNotch className="h-4 w-4 animate-spin" /> : <ClipboardText className="h-4 w-4" />}
            <span className="sr-only">Copy entry</span>
          </button>
          <button
            onClick={handleEntryShare}
            className={ICON_BUTTON_CLASS}
            aria-label="Share reading"
            title="Share"
            disabled={pendingAction === 'share'}
          >
            {pendingAction === 'share' ? <CircleNotch className="h-4 w-4 animate-spin" /> : <ShareNetwork className="h-4 w-4" />}
            <span className="sr-only">Share</span>
          </button>
          <button
            onClick={handleEntryExport}
            className={ICON_BUTTON_CLASS}
            aria-label="Export reading as CSV file"
            title="Export CSV"
            disabled={pendingAction === 'export'}
          >
            {pendingAction === 'export' ? <CircleNotch className="h-4 w-4 animate-spin" /> : <DownloadSimple className="h-4 w-4" />}
            <span className="sr-only">Export CSV</span>
          </button>
          {isAuthenticated && onDelete && (
            <button
              onClick={() => onDelete(entry.id)}
              className={ICON_BUTTON_DANGER_CLASS}
              aria-label="Delete reading permanently"
              title="Delete entry"
            >
              <Trash className="h-4 w-4" />
              <span className="sr-only">Delete</span>
            </button>
          )}
        </div>
      </div>
      <div className="px-4 pb-3">
        <InlineStatus tone={inlineStatus.tone} message={inlineStatus.message} />
      </div>
    </article>
  );
});
</file>

<file path="src/components/JournalFilters.jsx">
import { useState, useRef, useEffect, useId } from 'react';
import { CaretDown, Check, BookmarkSimple } from '@phosphor-icons/react';

const TIMEFRAME_OPTIONS = [
  { value: 'all', label: 'All time' },
  { value: '30d', label: '30 days' },
  { value: '90d', label: '90 days' },
  { value: 'ytd', label: 'This year' }
];

const DEFAULT_FILTERS = { query: '', contexts: [], spreads: [], decks: [], timeframe: 'all', onlyReversals: false };
const SAVED_FILTERS_KEY = 'journal_saved_filters_v1';
const OUTLINE_FILTER_BASE = 'flex items-center gap-2 rounded-xl border px-3 py-2 text-sm font-medium transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/40';
const OUTLINE_FILTER_IDLE = 'border-secondary/40 text-secondary/80 hover:border-secondary/60';
const OUTLINE_FILTER_ACTIVE = 'border-secondary/60 bg-secondary/10 text-secondary';

function FilterDropdown({ label, options, value, onChange, multiple = false }) {
  const [isOpen, setIsOpen] = useState(false);
  const containerRef = useRef(null);
  const buttonRef = useRef(null);
  const menuId = useId();

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (containerRef.current && !containerRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const focusFirstOption = () => {
    if (typeof window === 'undefined') return;
    const schedule = typeof window.requestAnimationFrame === 'function'
      ? window.requestAnimationFrame
      : (cb) => setTimeout(cb, 0);
    schedule(() => {
      const firstOption = containerRef.current?.querySelector('[data-dropdown-option="true"]');
      if (firstOption instanceof HTMLElement) {
        firstOption.focus();
      }
    });
  };

  const handleButtonKeyDown = (event) => {
    if (event.key === 'ArrowDown' || event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      if (!isOpen) {
        setIsOpen(true);
        focusFirstOption();
      }
    }
  };

  const handleMenuKeyDown = (event) => {
    if (event.key === 'Escape') {
      event.preventDefault();
      setIsOpen(false);
      buttonRef.current?.focus();
    }
  };

  const handleSelect = (optionValue) => {
    if (multiple) {
      const current = value || [];
      const next = current.includes(optionValue)
        ? current.filter(v => v !== optionValue)
        : [...current, optionValue];
      onChange(next);
    } else {
      onChange(optionValue);
      setIsOpen(false);
      buttonRef.current?.focus();
    }
  };

  const isSelected = (optionValue) => {
    if (multiple) return (value || []).includes(optionValue);
    return value === optionValue;
  };

  const activeCount = multiple ? (value || []).length : (value && value !== 'all' ? 1 : 0);

  let displayLabel = label;
  if (!multiple && value && value !== 'all') {
    const selectedOption = options.find(o => o.value === value);
    if (selectedOption) displayLabel = selectedOption.label;
  }

  return (
    <div className="relative" ref={containerRef}>
      <button
        ref={buttonRef}
        type="button"
        onClick={() => {
          const next = !isOpen;
          setIsOpen(next);
          if (next) {
            focusFirstOption();
          }
        }}
        onKeyDown={handleButtonKeyDown}
        className={`${OUTLINE_FILTER_BASE} ${activeCount > 0 ? OUTLINE_FILTER_ACTIVE : OUTLINE_FILTER_IDLE}`}
        aria-haspopup="listbox"
        aria-expanded={isOpen}
        aria-controls={isOpen ? menuId : undefined}
      >
        {multiple && <span>{label}</span>}
        {!multiple && <span className={value !== 'all' ? 'text-secondary' : ''}>{displayLabel}</span>}

        {multiple && activeCount > 0 && (
          <span className="flex h-4 min-w-[1rem] items-center justify-center rounded-full bg-secondary/20 px-1 text-[10px]">
            {activeCount}
          </span>
        )}
        <CaretDown className={`h-3 w-3 transition-transform ${isOpen ? 'rotate-180' : ''}`} />
      </button>

      {isOpen && (
        <div
          id={menuId}
          role="listbox"
          aria-multiselectable={multiple || undefined}
          className="absolute left-0 top-full z-50 mt-2 w-64 origin-top-left rounded-xl border border-secondary/30 bg-main p-1.5 shadow-xl backdrop-blur-xl animate-in fade-in zoom-in-95 duration-100"
          onKeyDown={handleMenuKeyDown}
        >
          <div className="max-h-64 overflow-y-auto py-1">
            {options.map((option) => (
              <button
                key={option.value}
                onClick={() => handleSelect(option.value)}
                type="button"
                data-dropdown-option="true"
                role="option"
                aria-selected={isSelected(option.value)}
                className="flex w-full items-center justify-between rounded-lg px-3 py-2 text-left text-sm text-muted hover:bg-secondary/10 hover:text-secondary transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-secondary/40"
              >
                <span>{option.label}</span>
                {isSelected(option.value) && <Check className="h-3.5 w-3.5 text-secondary" />}
              </button>
            ))}
          </div>
        </div>
      )}
    </div>
  );
}

export function JournalFilters({ filters, onChange, contexts = [], spreads = [], decks = [] }) {
  const [savedFilters, setSavedFilters] = useState([]);
  const [newFilterName, setNewFilterName] = useState('');

  useEffect(() => {
    if (typeof window === 'undefined') return;
    try {
      const stored = JSON.parse(localStorage.getItem(SAVED_FILTERS_KEY) || '[]');
      if (Array.isArray(stored)) {
        setSavedFilters(stored);
      }
    } catch (error) {
      console.warn('Failed to load saved filters', error);
    }
  }, []);

  const persistSavedFilters = (next) => {
    setSavedFilters(next);
    if (typeof window === 'undefined') return;
    try {
      localStorage.setItem(SAVED_FILTERS_KEY, JSON.stringify(next));
    } catch (error) {
      console.warn('Unable to persist saved filters', error);
    }
  };

  const normalizedFilters = () => ({
    ...DEFAULT_FILTERS,
    query: filters.query || '',
    contexts: Array.isArray(filters.contexts) ? [...filters.contexts] : [],
    spreads: Array.isArray(filters.spreads) ? [...filters.spreads] : [],
    decks: Array.isArray(filters.decks) ? [...filters.decks] : [],
    timeframe: filters.timeframe || 'all',
    onlyReversals: Boolean(filters.onlyReversals)
  });

  const hasActiveFilters = () => {
    const snapshot = normalizedFilters();
    return Boolean(snapshot.query.trim())
      || snapshot.contexts.length > 0
      || snapshot.spreads.length > 0
      || snapshot.decks.length > 0
      || snapshot.timeframe !== 'all'
      || snapshot.onlyReversals;
  };

  const handleSaveCurrent = () => {
    const name = newFilterName.trim();
    if (!name || !hasActiveFilters()) return;
    const snapshot = normalizedFilters();
    const existingIndex = savedFilters.findIndex(item => item.name.toLowerCase() === name.toLowerCase());
    const entry = {
      id: existingIndex >= 0 ? savedFilters[existingIndex].id : `saved-${Date.now()}`,
      name,
      values: snapshot
    };

    const next = existingIndex >= 0
      ? savedFilters.map((item, idx) => (idx === existingIndex ? entry : item))
      : [entry, ...savedFilters].slice(0, 6);

    persistSavedFilters(next);
    setNewFilterName('');
  };

  const handleApplySaved = (saved) => {
    if (!saved?.values) return;
    onChange({ ...DEFAULT_FILTERS, ...saved.values });
  };

  const handleDeleteSaved = (id) => {
    const next = savedFilters.filter(item => item.id !== id);
    persistSavedFilters(next);
  };

  const handleQueryChange = (event) => {
    onChange({ ...filters, query: event.target.value });
  };

  const clearFilters = () => {
    onChange(DEFAULT_FILTERS);
  };

  return (
    <section className="rounded-3xl border border-secondary/30 bg-surface/80 p-5 shadow-lg animate-fade-in">
      <div className="mb-6 space-y-4">
        <div>
          <p className="text-[11px] uppercase tracking-[0.3em] text-secondary/80">Filters</p>
          <h2 className="text-xl font-serif text-main">Focus your journal</h2>
        </div>
        <div className="flex flex-wrap items-center gap-3">
          <div className="relative flex-1 min-w-[200px]">
            <input
              type="search"
              value={filters.query}
              onChange={handleQueryChange}
              placeholder="Search readings..."
              className="w-full rounded-xl border border-secondary/30 bg-surface/60 px-4 py-2 text-sm text-main focus:outline-none focus:ring-2 focus:ring-secondary/40 placeholder:text-secondary/40"
            />
          </div>
          <button
            type="button"
            onClick={clearFilters}
            className="text-xs font-semibold text-secondary/70 underline decoration-dotted decoration-secondary/40 hover:text-secondary"
          >
            Clear filters
          </button>
        </div>
        <div className="rounded-xl border border-secondary/20 bg-surface/60 p-3">
          <div className="flex items-center gap-2 text-[11px] uppercase tracking-[0.25em] text-secondary/80">
            <BookmarkSimple className="h-4 w-4" />
            <span>Saved filters</span>
          </div>
          <div className="mt-2 flex flex-wrap items-center gap-2">
            {savedFilters.length > 0 ? (
              savedFilters.map((saved) => (
                <div
                  key={saved.id}
                  className="inline-flex items-center gap-2 rounded-full border border-secondary/30 bg-surface/70 px-3 py-1 text-xs text-secondary"
                >
                  <button
                    type="button"
                    onClick={() => handleApplySaved(saved)}
                    className="flex items-center gap-1 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/40"
                  >
                    <span className="font-semibold text-main">{saved.name}</span>
                  </button>
                  <button
                    type="button"
                    onClick={() => handleDeleteSaved(saved.id)}
                    className="rounded-full px-1 text-secondary/60 hover:text-error focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/40"
                    aria-label={`Delete saved filter ${saved.name}`}
                  >
                    <span aria-hidden="true">×</span>
                  </button>
                </div>
              ))
            ) : (
              <p className="text-xs text-secondary/60">No saved filters yet—name a view to reuse it.</p>
            )}
          </div>
          <div className="mt-3 flex flex-col gap-2 sm:flex-row sm:items-center sm:gap-3">
            <input
              type="text"
              value={newFilterName}
              onChange={(event) => setNewFilterName(event.target.value)}
              placeholder="Name this view"
              className="flex-1 rounded-xl border border-secondary/30 bg-surface/60 px-4 py-2 text-sm text-main focus:outline-none focus:ring-2 focus:ring-secondary/40 placeholder:text-secondary/40"
            />
            <div className="flex items-center gap-2">
              <button
                type="button"
                onClick={handleSaveCurrent}
                className={`${OUTLINE_FILTER_BASE} ${OUTLINE_FILTER_ACTIVE}`}
                disabled={!newFilterName.trim() || !hasActiveFilters()}
              >
                Save current
              </button>
              <button
                type="button"
                onClick={clearFilters}
                className={`${OUTLINE_FILTER_BASE} ${OUTLINE_FILTER_IDLE}`}
              >
                Reset
              </button>
            </div>
          </div>
        </div>
      </div>

      <div className="flex flex-wrap items-center gap-3">
        <FilterDropdown
          label="Timeframe"
          options={TIMEFRAME_OPTIONS}
          value={filters.timeframe}
          onChange={(val) => onChange({ ...filters, timeframe: val })}
          multiple={false}
        />

        {contexts.length > 0 && (
          <FilterDropdown
            label="Context"
            options={contexts}
            value={filters.contexts}
            onChange={(val) => onChange({ ...filters, contexts: val })}
            multiple={true}
          />
        )}

        {spreads.length > 0 && (
          <FilterDropdown
            label="Spread"
            options={spreads}
            value={filters.spreads}
            onChange={(val) => onChange({ ...filters, spreads: val })}
            multiple={true}
          />
        )}

        {decks.length > 0 && (
          <FilterDropdown
            label="Deck"
            options={decks}
            value={filters.decks}
            onChange={(val) => onChange({ ...filters, decks: val })}
            multiple={true}
          />
        )}

        <div className="h-6 w-px bg-surface-muted/50 mx-1" />

        <button
          type="button"
          onClick={() => onChange({ ...filters, onlyReversals: !filters.onlyReversals })}
          className={`${OUTLINE_FILTER_BASE} ${filters.onlyReversals ? OUTLINE_FILTER_ACTIVE : OUTLINE_FILTER_IDLE}`}
        >
          <span>Reversals</span>
          {filters.onlyReversals && <Check className="h-3 w-3" />}
        </button>
      </div>
    </section>
  );
}
</file>

<file path="src/components/JournalInsightsPanel.jsx">
import { useState, useMemo, useEffect, useRef, memo } from 'react';
import { FileText, Copy, ArrowsClockwise, ChartBar, Sparkle, ShareNetwork, DownloadSimple, Trash, BookOpen, CircleNotch } from '@phosphor-icons/react';
import { useSmallScreen } from '../hooks/useSmallScreen';
import { useLandscape } from '../hooks/useLandscape';
import { useReducedMotion } from '../hooks/useReducedMotion';
import { CoachSuggestion } from './CoachSuggestion';
import {
    downloadInsightsSvg,
    exportJournalInsightsToPdf
} from '../lib/pdfExport';
import {
    exportJournalEntriesToCsv,
    copyJournalShareSummary,
    saveCoachRecommendation,
    persistCoachStatsSnapshot,
    computePreferenceDrift,
    formatContextName
} from '../lib/journalInsights';
import { usePreferences } from '../contexts/PreferencesContext';
import { buildThemePolishPrompt, buildThemeQuestion, ensureQuestionMark, normalizeThemeLabel } from '../lib/themeText';
import { callLlmApi } from '../lib/intentionCoach';
import { InlineStatus } from './InlineStatus.jsx';
import { useInlineStatus } from '../hooks/useInlineStatus';

const OUTLINE_BUTTON_CLASS = 'inline-flex items-center gap-2 rounded-full border border-secondary/40 px-3 py-1.5 text-xs font-semibold text-secondary hover:border-secondary/70 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/50 disabled:opacity-50 disabled:cursor-not-allowed';

const CONTEXT_TO_SPREAD = {
    love: {
        spread: 'Relationship Snapshot',
        spreadKey: 'relationship',
        question: 'How can I nurture reciprocity in my closest connection right now?'
    },
    career: {
        spread: 'Decision / Two-Path',
        spreadKey: 'decision',
        question: 'What would help me choose the path that aligns with my purpose?'
    },
    self: {
        spread: 'Three-Card Story',
        spreadKey: 'threeCard',
        question: 'What inner story is ready to evolve this season?'
    },
    spiritual: {
        spread: 'Celtic Cross',
        spreadKey: 'celtic',
        question: 'How can I deepen trust with my spiritual practice now?'
    },
    wellbeing: {
        spread: 'Five-Card Clarity',
        spreadKey: 'fiveCard',
        question: 'Where can I rebalance my energy in the days ahead?'
    },
    decision: {
        spread: 'Decision / Two-Path',
        spreadKey: 'decision',
        question: 'What do I need to understand about the paths before me?'
    }
};

function scheduleDeferred(callback) {
    if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
        const frameId = window.requestAnimationFrame(callback);
        return () => window.cancelAnimationFrame(frameId);
    }
    const timeoutId = setTimeout(callback, 0);
    return () => clearTimeout(timeoutId);
}

function mapContextToTopic(context) {
    switch (context) {
        case 'love': return 'relationships';
        case 'career': return 'career';
        case 'self': return 'growth';
        case 'spiritual': return 'growth';
        case 'wellbeing': return 'wellbeing';
        case 'decision': return 'decision';
        default: return null;
    }
}

function formatEntryOptionLabel(entry) {
    const spreadLabel = entry?.spread || 'Reading';
    const timestamp = getEntryTimestamp(entry);
    const dateLabel = timestamp ? new Date(timestamp).toLocaleDateString() : 'Undated';
    const contextLabel = entry?.context ? ` · ${entry.context}` : '';
    return `${spreadLabel} · ${dateLabel}${contextLabel}`;
}

function normalizeEntryTimestamp(value) {
    if (!Number.isFinite(value)) return null;
    return value < 1e12 ? value * 1000 : value;
}

function getEntryTimestamp(entry) {
    const candidates = [entry?.ts, entry?.created_at, entry?.updated_at].map(normalizeEntryTimestamp);
    return candidates.find(Boolean) || null;
}

export const JournalInsightsPanel = memo(function JournalInsightsPanel({
    stats,
    allStats,
    entries,
    allEntries,
    isAuthenticated,
    filtersActive,
    shareLinks = [],
    shareLoading: _shareLoading,
    shareError: _shareError,
    onCreateShareLink,
    onDeleteShareLink
}) {
    const isSmallScreen = useSmallScreen();
    const isLandscape = useLandscape();
    const prefersReducedMotion = useReducedMotion();
    const { personalization } = usePreferences();
    const primaryStats = stats || allStats;
    const frequentCards = primaryStats?.frequentCards || [];
    const contextBreakdown = primaryStats?.contextBreakdown || [];
    const _monthlyCadence = primaryStats?.monthlyCadence || [];
    const recentThemes = primaryStats?.recentThemes || [];
    const isFilteredView = Boolean(filtersActive && stats);

    const [shareComposerOpen, setShareComposerOpen] = useState(false);
    const [shareComposer, setShareComposer] = useState({ scope: 'journal', entryId: '', title: '', limit: '5', expiresInHours: '72' });
    const [composerErrors, setComposerErrors] = useState({});
    const [shareLinkFeedback, setShareLinkFeedback] = useState({ token: null, message: '' });
    const [pendingAction, setPendingAction] = useState(null);
    const { status: inlineStatus, showStatus, clearStatus } = useInlineStatus();
    const shareFeedbackTimeout = useRef(null);

    const showLinkFeedback = (token, message, delay = 2500) => {
        setShareLinkFeedback({ token, message });
        if (shareFeedbackTimeout.current) {
            clearTimeout(shareFeedbackTimeout.current);
        }
        shareFeedbackTimeout.current = setTimeout(() => {
            setShareLinkFeedback({ token: null, message: '' });
            shareFeedbackTimeout.current = null;
        }, delay);
    };

    const runToolbarAction = async (actionKey, task) => {
        setPendingAction(actionKey);
        clearStatus();
        try {
            return await task();
        } finally {
            setPendingAction(null);
        }
    };

    useEffect(() => () => {
        if (shareFeedbackTimeout.current) {
            clearTimeout(shareFeedbackTimeout.current);
        }
    }, []);

    const summaryEntries = useMemo(() => {
        if (filtersActive) {
            return Array.isArray(entries) ? entries : [];
        }
        if (Array.isArray(allEntries) && allEntries.length > 0) {
            return allEntries;
        }
        return Array.isArray(entries) ? entries : [];
    }, [allEntries, entries, filtersActive]);

    const summaryStats = useMemo(() => {
        if (isFilteredView) {
            return stats;
        }
        return allStats || stats || null;
    }, [allStats, isFilteredView, stats]);

    const usingFilteredEntries = filtersActive && Array.isArray(entries) && entries.length > 0;
    const svgStats = stats || allStats;
    const baseEntries = Array.isArray(summaryEntries) ? summaryEntries : [];
    const isFilteredAndEmpty =
        filtersActive &&
        baseEntries.length === 0 &&
        Array.isArray(allEntries) &&
        allEntries.length > 0;

    // Compute preference drift for "Emerging Interests" insight (Phase 5.4)
    const preferenceDrift = useMemo(
        () => computePreferenceDrift(
            filtersActive ? allEntries : summaryEntries,
            personalization?.focusAreas
        ),
        [allEntries, summaryEntries, filtersActive, personalization?.focusAreas]
    );

    useEffect(() => {
        if (!summaryStats) return;
        const baseEntryCount = baseEntries.length;
        const totalEntriesCount = Array.isArray(allEntries) ? allEntries.length : null;
        persistCoachStatsSnapshot(summaryStats, {
            filtersActive: isFilteredView,
            filterLabel: isFilteredView ? 'Filtered journal view' : 'Entire journal',
            entryCount: baseEntryCount,
            totalEntries: totalEntriesCount
        });
    }, [summaryStats, isFilteredView, baseEntries.length, allEntries]);

    useEffect(() => {
        if (shareComposerOpen) {
            return undefined;
        }
        return scheduleDeferred(() => setComposerErrors({}));
    }, [shareComposerOpen]);

    useEffect(() => {
        if (!isAuthenticated && shareComposerOpen) {
            setShareComposerOpen(false);
        }
    }, [isAuthenticated, shareComposerOpen]);

    useEffect(() => {
        if (!shareLinkFeedback.token) return;
        const stillExists = shareLinks.some(link => link.token === shareLinkFeedback.token);
        if (!stillExists) {
            setShareLinkFeedback({ token: null, message: '' });
        }
    }, [shareLinks, shareLinkFeedback.token]);

    const handleExport = () => runToolbarAction('export', async () => {
        const exportEntries = isFilteredAndEmpty && Array.isArray(allEntries) ? allEntries : summaryEntries;
        const result = exportJournalEntriesToCsv(exportEntries);
        showStatus({
            tone: result ? 'success' : 'error',
            message: result ? 'Export started—CSV download is on its way.' : 'Unable to export this view right now.'
        });
        return result;
    });

    const handlePdfDownload = () => runToolbarAction('pdf', async () => {
        const pdfStats = isFilteredAndEmpty && allStats ? allStats : summaryStats;
        const pdfEntries = isFilteredAndEmpty && Array.isArray(allEntries) ? allEntries : summaryEntries;
        try {
            exportJournalInsightsToPdf(pdfStats, pdfEntries);
            showStatus({ tone: 'success', message: 'PDF download started.' });
            return true;
        } catch {
            showStatus({ tone: 'error', message: 'PDF generation failed. Please try again.' });
            return false;
        }
    });

    const handleVisualCardDownload = () => runToolbarAction('visual-card', async () => {
        if (!svgStats) {
            showStatus({ tone: 'warning', message: 'Add more readings to unlock the visual card.' });
            return false;
        }
        try {
            downloadInsightsSvg(svgStats);
            showStatus({ tone: 'success', message: 'Visual card downloaded.' });
            return true;
        } catch {
            showStatus({ tone: 'error', message: 'Unable to download the visual card.' });
            return false;
        }
    });

    const handleShare = async () => runToolbarAction('share', async () => {
        const noEntriesAvailable =
            (!isFilteredAndEmpty && baseEntries.length === 0) ||
            (isFilteredAndEmpty && (!allEntries || allEntries.length === 0));

        if (noEntriesAvailable) {
            showStatus({ tone: 'info', message: 'Log a reading or clear filters to share.' });
            return false;
        }

        if (isAuthenticated && onCreateShareLink) {
            try {
                const shareFromFilteredView = usingFilteredEntries && !isFilteredAndEmpty;
                const payload = { scope: 'journal' };
                if (shareFromFilteredView) {
                    const entryIds = baseEntries
                        .slice(0, 10)
                        .map((entry) => entry?.id)
                        .filter(Boolean);
                    if (entryIds.length === 0) {
                        showStatus({ tone: 'warning', message: 'Filtered entries need IDs before they can be shared.' });
                        return false;
                    }
                    payload.entryIds = entryIds;
                    payload.limit = entryIds.length;
                }
                const data = await onCreateShareLink(payload);
                const shareUrl = data?.url && typeof window !== 'undefined'
                    ? `${window.location.origin}${data.url}`
                    : null;
                if (shareUrl && navigator?.clipboard?.writeText) {
                    try {
                        await navigator.clipboard.writeText(shareUrl);
                        showStatus({
                            tone: 'success',
                            message: isFilteredAndEmpty ? 'Shared full journal link copied.' : 'Share link copied to clipboard.'
                        });
                    } catch (error) {
                        console.warn('Clipboard write failed for quick share link', error);
                        showStatus({ tone: 'warning', message: 'Link ready—copy from your browser if clipboard was blocked.' });
                    }
                } else {
                    showStatus({
                        tone: 'info',
                        message: isFilteredAndEmpty ? 'Full journal link ready in the address bar.' : 'Share link ready—copy from your browser.'
                    });
                }
                return true;
            } catch (error) {
                console.warn('Share link creation failed, falling back to snapshot', error);
                const shareStats = isFilteredAndEmpty ? allStats : (summaryStats || allStats || primaryStats);
                const success = await copyJournalShareSummary(shareStats);
                showStatus({
                    tone: success ? 'warning' : 'error',
                    message: success
                        ? 'Link unavailable; copied a journal snapshot instead.'
                        : 'Unable to create a share link right now.'
                });
                return success;
            }
        }

        const shareStats = isFilteredAndEmpty ? allStats : (summaryStats || allStats || primaryStats);
        const success = await copyJournalShareSummary(shareStats);
        showStatus({
            tone: success ? 'success' : 'error',
            message: success
                ? (isFilteredAndEmpty ? 'Copied a full journal summary.' : 'Snapshot copied—paste to share these insights.')
                : 'Clipboard copy failed in this browser.'
        });
        return success;
    });

    const topContext = contextBreakdown.slice().sort((a, b) => b.count - a.count)[0];
    const contextSuggestion = topContext && CONTEXT_TO_SPREAD[topContext.name];
    const topCard = frequentCards[0];
    const topTheme = recentThemes[0];
    const normalizedTopTheme = normalizeThemeLabel(topTheme);
    const [polishedThemeQuestion, setPolishedThemeQuestion] = useState(null);

    // Automatically polish the theme-based suggestion via LLM for smoother default wording
    useEffect(() => {
        let isCancelled = false;
        const controller = new AbortController();

        const run = async () => {
            // Reset when there is no theme or insights are hidden
            if (!normalizedTopTheme) {
                setPolishedThemeQuestion(null);
                return;
            }

            const fallbackQuestion = buildThemeQuestion(normalizedTopTheme);

            try {
                if (typeof callLlmApi !== 'function') {
                    setPolishedThemeQuestion(fallbackQuestion);
                    return;
                }

                const { prompt, metadata } = buildThemePolishPrompt(normalizedTopTheme, {
                    draftQuestion: fallbackQuestion,
                    spreadName: 'Three-Card Story',
                    topic: 'growth',
                    timeframe: 'month',
                    contextHint: topContext?.name || null,
                    entryCount: primaryStats?.totalReadings
                });

                const result = await callLlmApi(prompt, metadata, { signal: controller.signal });
                const refined = typeof result === 'string' ? result : result?.question;

                if (!isCancelled && refined) {
                    setPolishedThemeQuestion(ensureQuestionMark(refined));
                } else if (!isCancelled) {
                    setPolishedThemeQuestion(fallbackQuestion);
                }
            } catch (error) {
                if (!isCancelled) {
                    console.warn('Theme polish failed; using fallback', error);
                    setPolishedThemeQuestion(fallbackQuestion);
                }
            }
        };

        try {
            run();
        } catch (err) {
            console.error('Theme polish unexpected error; disabling polish', err);
            if (!isCancelled) {
                setPolishedThemeQuestion(null);
            }
        }

        return () => {
            isCancelled = true;
            controller.abort();
        };
    }, [normalizedTopTheme, topContext?.name, primaryStats?.totalReadings]);

    const coachRecommendation = (() => {
        if (contextSuggestion) {
            return {
                question: contextSuggestion.question,
                spreadName: contextSuggestion.spread,
                spreadKey: contextSuggestion.spreadKey,
                topicValue: mapContextToTopic(topContext?.name),
                timeframeValue: 'week',
                depthValue: 'guided',
                source: topContext?.name ? `context:${topContext.name}` : 'context'
            };
        }
        if (normalizedTopTheme) {
            return {
                question: polishedThemeQuestion || buildThemeQuestion(normalizedTopTheme),
                spreadName: 'Three-Card Story',
                spreadKey: 'threeCard',
                topicValue: 'growth',
                timeframeValue: 'month',
                depthValue: 'guided',
                source: `theme:${normalizedTopTheme}`,
                customFocus: normalizedTopTheme
            };
        }
        if (topCard) {
            return {
                question: `What is ${topCard.name} inviting me to embody next?`,
                spreadName: 'Three-Card Story',
                spreadKey: 'threeCard',
                topicValue: 'growth',
                timeframeValue: 'open',
                depthValue: 'lesson',
                source: `card:${topCard.name}`,
                cardName: topCard.name
            };
        }
        return null;
    })();

    const prevCoachRecRef = useRef(null);
    useEffect(() => {
        if (!coachRecommendation) return;
        if (filtersActive) return;
        const current = JSON.stringify(coachRecommendation);
        if (prevCoachRecRef.current === current) return;
        saveCoachRecommendation(coachRecommendation);
        prevCoachRecRef.current = current;
    }, [coachRecommendation, filtersActive]);

    const handleCoachPrefill = async () => {
        if (!coachRecommendation) return;
        if (filtersActive) {
            showStatus({ tone: 'info', message: 'Clear filters to sync this coach recommendation.' });
            return;
        }
        try {
            await Promise.resolve(saveCoachRecommendation(coachRecommendation));
            showStatus({ tone: 'success', message: 'Sent to Intention Coach.' });
        } catch (error) {
            console.warn('Unable to persist coach recommendation', error);
            showStatus({ tone: 'error', message: 'Unable to sync suggestion. Please try again.' });
        }
    };

    const entryOptions = useMemo(() => {
        const filteredList = Array.isArray(entries) ? entries : [];
        const filteredOptions = filteredList
            .filter((entry) => entry?.id)
            .map((entry) => ({ id: entry.id, entry, source: 'filtered', label: formatEntryOptionLabel(entry) }));

        if (!Array.isArray(allEntries) || allEntries.length === 0) {
            return { filtered: filteredOptions, journal: [], all: filteredOptions };
        }

        const seen = new Set(filteredOptions.map((option) => option.id));
        const journalOptions = [];
        allEntries.forEach((entry) => {
            if (!entry?.id || seen.has(entry.id)) return;
            journalOptions.push({ id: entry.id, entry, source: 'journal', label: formatEntryOptionLabel(entry) });
        });

        return { filtered: filteredOptions, journal: journalOptions, all: [...filteredOptions, ...journalOptions] };
    }, [allEntries, entries]);

    const insightsGridLayout = useMemo(() => {
        if (isSmallScreen) {
            return 'grid-cols-1 gap-4';
        }
        if (isLandscape) {
            return 'grid-cols-2 gap-3';
        }
        return 'sm:grid-cols-2 gap-6';
    }, [isLandscape, isSmallScreen]);

    const composerPreviewEntries = useMemo(() => {
        if (!filtersActive || shareComposer.scope !== 'journal') return [];
        const filteredList = Array.isArray(entries) ? entries : [];
        if (filteredList.length === 0) return [];
        const parsedLimit = Number.parseInt(shareComposer.limit, 10);
        const limit = Number.isFinite(parsedLimit)
            ? Math.min(10, Math.max(1, parsedLimit))
            : Math.min(10, filteredList.length);
        return filteredList.slice(0, limit);
    }, [entries, filtersActive, shareComposer.limit, shareComposer.scope]);

    const handleComposerSubmit = async (event) => {
        event.preventDefault();
        if (!onCreateShareLink) return;
        const scope = shareComposer.scope;
        const trimmedTitle = shareComposer.title.trim();
        const parsedLimit = scope === 'journal' ? Number.parseInt(shareComposer.limit, 10) : undefined;
        const normalizedLimit = Number.isFinite(parsedLimit)
            ? Math.min(10, Math.max(1, parsedLimit))
            : undefined;
        const expiresParsed = shareComposer.expiresInHours ? Number.parseInt(shareComposer.expiresInHours, 10) : undefined;
        const expiresInHours = Number.isFinite(expiresParsed) && expiresParsed > 0
            ? Math.floor(expiresParsed)
            : undefined;

        const selectedEntryValid = entryOptions.all.some((option) => option.id === shareComposer.entryId);

        const errors = {};

        if (scope === 'journal') {
            if (!Number.isFinite(normalizedLimit) || normalizedLimit < 1 || normalizedLimit > 10) {
                errors.limit = 'Choose 1-10 entries for a journal link';
            }
        } else {
            if (!shareComposer.entryId) {
                errors.entryId = 'Pick a journal entry to share';
            }
            if (!selectedEntryValid) {
                errors.entryId = 'Select an entry from your journal';
            }
        }

        let entryIdsForJournal;
        if (scope === 'journal' && filtersActive) {
            const filteredIds = (Array.isArray(entries) ? entries : [])
                .map((entry) => entry?.id)
                .filter(Boolean);
            if (filteredIds.length === 0) {
                errors.limit = 'No entries match your filters';
            }
            const limitForFilteredShare = normalizedLimit ?? Math.min(filteredIds.length, 10);
            entryIdsForJournal = filteredIds.slice(0, limitForFilteredShare);
        }

        if (Object.values(errors).some(Boolean)) {
            setComposerErrors(errors);
            return;
        }

        setComposerErrors({});

        try {
            const data = await onCreateShareLink({
                scope,
                entryId: scope === 'entry' ? shareComposer.entryId : undefined,
                title: trimmedTitle,
                limit: scope === 'journal' ? normalizedLimit : undefined,
                entryIds: scope === 'journal' ? entryIdsForJournal : undefined,
                expiresInHours
            });
            const shareUrl = data?.url && typeof window !== 'undefined'
                ? `${window.location.origin}${data.url}`
                : null;
            if (shareUrl && navigator?.clipboard?.writeText) {
                try {
                    await navigator.clipboard.writeText(shareUrl);
                    showStatus({ tone: 'success', message: 'Custom link copied to clipboard.' });
                } catch (error) {
                    console.warn('Clipboard write failed for custom link', error);
                    showStatus({ tone: 'warning', message: 'Link ready—copy manually if clipboard was blocked.' });
                }
            } else {
                showStatus({ tone: 'info', message: 'Custom link ready—copy from your browser to share.' });
            }
            setShareComposerOpen(false);
        } catch (error) {
            const message = error.message || 'Unable to create custom link';
            setComposerErrors({ general: message });
            showStatus({ tone: 'error', message });
        }
    };

    const copyShareUrl = async (token) => {
        if (typeof window === 'undefined') return;
        const url = `${window.location.origin}/share/${token}`;
        if (navigator?.clipboard?.writeText) {
            try {
                await navigator.clipboard.writeText(url);
                showLinkFeedback(token, 'Link copied');
                showStatus({ tone: 'success', message: 'Link copied.' });
                return;
            } catch (error) {
                console.warn('Clipboard write failed for saved link', error);
                showLinkFeedback(token, 'Copy blocked—use tap-and-hold to copy');
                showStatus({ tone: 'warning', message: 'Copy blocked—open the link and copy manually.' });
            }
        } else {
            showLinkFeedback(token, 'Copy not supported in this browser');
            showStatus({ tone: 'error', message: 'Copy not supported—open the link to share it.' });
        }
    };

    if (!primaryStats) {
        return null;
    }

    return (
        <div className={prefersReducedMotion ? '' : 'animate-fade-in'}>
            <div className="space-y-6 rounded-3xl border border-secondary/30 bg-surface/70 p-6">
                <div>
                    <h2 className="text-2xl font-serif text-main">Journal Insights</h2>
                    <p className="mt-1 text-sm text-secondary/70">
                        {isFilteredView && allStats ? (
                            <>
                                <span className="font-medium text-secondary">Filtered:</span> {stats.totalReadings} of {allStats.totalReadings} entries · {stats.reversalRate}% reversed
                            </>
                        ) : (
                            <>
                                {primaryStats.totalReadings} entries · {primaryStats.totalCards} cards · {primaryStats.reversalRate}% reversed
                            </>
                        )}
                    </p>
                    {isFilteredAndEmpty && (
                        <p className="mt-1 text-xs text-secondary/70">Filters returned no entries, showing full journal insights.</p>
                    )}
                </div>

                <div className="rounded-2xl border border-secondary/30 bg-surface/60 p-3 lg:sticky lg:top-0 lg:z-10">
                    <div className="flex flex-wrap gap-2">
                        <button
                            type="button"
                            onClick={handleShare}
                            className={OUTLINE_BUTTON_CLASS}
                            disabled={pendingAction === 'share'}
                        >
                            {pendingAction === 'share' ? <CircleNotch className="h-4 w-4 animate-spin" /> : <ShareNetwork className="h-4 w-4" />}
                            Share link
                        </button>
                        <button
                            type="button"
                            onClick={handleExport}
                            className={OUTLINE_BUTTON_CLASS}
                            disabled={pendingAction === 'export'}
                        >
                            {pendingAction === 'export' ? <CircleNotch className="h-4 w-4 animate-spin" /> : <FileText className="h-4 w-4" />}
                            Export CSV
                        </button>
                        <button
                            type="button"
                            onClick={handlePdfDownload}
                            className={OUTLINE_BUTTON_CLASS}
                            disabled={pendingAction === 'pdf'}
                        >
                            {pendingAction === 'pdf' ? <CircleNotch className="h-4 w-4 animate-spin" /> : <DownloadSimple className="h-4 w-4" />}
                            PDF
                        </button>
                        <button
                            type="button"
                            onClick={handleVisualCardDownload}
                            disabled={!svgStats}
                            className={`${OUTLINE_BUTTON_CLASS} ${svgStats ? '' : 'border-secondary/20 text-secondary/40'}`}
                        >
                            {pendingAction === 'visual-card' ? <CircleNotch className="h-4 w-4 animate-spin" /> : <Sparkle className="h-4 w-4" />}
                            Visual card
                        </button>
                    {isAuthenticated && onCreateShareLink && (
                        <button
                            type="button"
                            onClick={() => setShareComposerOpen(prev => !prev)}
                            className={`${OUTLINE_BUTTON_CLASS} ${shareComposerOpen ? 'border-secondary text-secondary bg-secondary/10' : ''}`}
                            >
                                <ArrowsClockwise className="h-4 w-4" />
                                {shareComposerOpen ? 'Close custom link' : 'Custom link'}
                            </button>
                        )}
                    </div>
                    <div className="mt-2">
                        <InlineStatus tone={inlineStatus.tone} message={inlineStatus.message} />
                    </div>
                </div>

                {shareComposerOpen && (
                    <form onSubmit={handleComposerSubmit} className={`rounded-2xl border border-secondary/30 bg-surface-muted/50 ${isSmallScreen ? 'p-4' : 'p-6'} ${prefersReducedMotion ? '' : 'animate-slide-down'}`}>
                        <div className="grid gap-4 sm:grid-cols-2">
                            <label className="block">
                                <span className="text-xs uppercase tracking-wider text-secondary/80">Link Title</span>
                            <input
                                type="text"
                                value={shareComposer.title}
                                onChange={(e) => setShareComposer(p => ({ ...p, title: e.target.value }))}
                                placeholder="Optional title"
                                className="mt-2 w-full rounded-xl border border-secondary/30 bg-surface/50 px-3 py-2 text-sm text-main focus:ring-2 focus:ring-secondary/50"
                            />
                        </label>
                        <label className="block">
                            <span className="text-xs uppercase tracking-wider text-secondary/80">Expires In</span>
                            <select
                                value={shareComposer.expiresInHours ?? ''}
                                onChange={(e) => setShareComposer(p => ({ ...p, expiresInHours: e.target.value || undefined }))}
                                className="mt-2 w-full rounded-xl border border-secondary/30 bg-surface/50 px-3 py-2 text-sm text-main focus:ring-2 focus:ring-secondary/50"
                            >
                                <option value="24">24 hours</option>
                                <option value="72">3 days</option>
                                <option value="168">1 week</option>
                                <option value="">No expiry</option>
                            </select>
                        </label>
                        <label className="block">
                            <span className="text-xs uppercase tracking-wider text-secondary/80">Scope</span>
                            <select
                                value={shareComposer.scope}
                                onChange={(e) => {
                                    const nextScope = e.target.value;
                                    setShareComposer(p => ({ ...p, scope: nextScope }));
                                    setComposerErrors(prev => ({ ...prev, limit: '', entryId: '', general: '' }));
                                }}
                                className="mt-2 w-full rounded-xl border border-secondary/30 bg-surface/50 px-3 py-2 text-sm text-main focus:ring-2 focus:ring-secondary/50"
                            >
                                <option value="journal">Recent entries</option>
                                <option value="entry">Single entry</option>
                            </select>
                        </label>
                        {shareComposer.scope === 'journal' ? (
                            <label className="block">
                                <span className="text-xs uppercase tracking-wider text-secondary/80">How many entries to share (1–10)</span>
                                <input
                                    type="number"
                                    min="1"
                                    max="10"
                                    value={shareComposer.limit}
                                    onChange={(e) => {
                                        setShareComposer(p => ({ ...p, limit: e.target.value }));
                                        setComposerErrors(prev => ({ ...prev, limit: '', general: '' }));
                                    }}
                                    className="mt-2 w-full rounded-xl border border-secondary/30 bg-surface/50 px-3 py-2 text-sm text-main focus:ring-2 focus:ring-secondary/50"
                                />
                                <p className="mt-1 text-xs text-secondary/70">Defaults to your latest entries{filtersActive ? ' in this filtered view' : ''}.</p>
                                {composerErrors.limit && (
                                    <p className="mt-1 text-xs text-error">{composerErrors.limit}</p>
                                )}
                            </label>
                        ) : (
                            <label className="block">
                                <span className="text-xs uppercase tracking-wider text-secondary/80">Pick an entry to share</span>
                                <select
                                    value={shareComposer.entryId || ''}
                                    onChange={(e) => {
                                        setShareComposer(p => ({ ...p, entryId: e.target.value }));
                                        setComposerErrors(prev => ({ ...prev, entryId: '', general: '' }));
                                    }}
                                    className="mt-2 w-full rounded-xl border border-secondary/30 bg-surface/50 px-3 py-2 text-sm text-main focus:ring-2 focus:ring-secondary/50"
                                >
                                    {entryOptions.all.map(opt => (
                                        <option key={opt.id} value={opt.id}>{opt.label}</option>
                                    ))}
                                </select>
                                {composerErrors.entryId && (
                                    <p className="mt-1 text-xs text-error">{composerErrors.entryId}</p>
                                )}
                            </label>
                        )}
                        {filtersActive && shareComposer.scope === 'journal' && composerPreviewEntries.length > 0 && (
                            <div className="sm:col-span-2 rounded-xl border border-secondary/20 bg-surface/40 p-4">
                                <p className="text-xs uppercase tracking-[0.2em] text-secondary/80">
                                    Sharing {composerPreviewEntries.length} filtered entr{composerPreviewEntries.length === 1 ? 'y' : 'ies'}
                                </p>
                                <ul className="mt-2 space-y-1 text-sm text-muted">
                                    {composerPreviewEntries.map((entry, idx) => (
                                        <li key={entry?.id || idx} className="flex items-center gap-2">
                                            <span className="h-1.5 w-1.5 rounded-full bg-secondary/40" />
                                            <span className="truncate">{formatEntryOptionLabel(entry)}</span>
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        )}
                    </div>
                    <div className="mt-4 flex justify-end">
                        {composerErrors.general && (
                            <p className="mr-4 text-sm text-error">{composerErrors.general}</p>
                        )}
                        <button type="submit" className="rounded-full bg-secondary/20 px-6 py-2 text-sm font-medium text-secondary hover:bg-secondary/30">
                            Create Link
                        </button>
                    </div>
                </form>
            )}

                <div className={`grid ${insightsGridLayout} lg:grid-cols-1 lg:gap-4`}>
                    {/* Frequent Cards */}
                    {frequentCards.length > 0 && (
                        <div className={`rounded-3xl border border-secondary/20 bg-surface/40 ${isLandscape ? 'p-3' : 'p-5'}`}>
                            <h3 className={`flex items-center gap-2 text-xs font-bold uppercase tracking-wider text-accent/80 ${isLandscape ? 'mb-2' : 'mb-4'}`}>
                                <ChartBar className="h-3 w-3" /> Frequent Cards
                            </h3>
                            <ul className={isLandscape ? 'space-y-1' : 'space-y-2'}>
                                {frequentCards.slice(0, isLandscape ? 3 : 5).map((card) => (
                                    <li key={card.name} className={`flex items-center justify-between text-muted ${isLandscape ? 'text-xs' : 'text-sm'}`}>
                                        <span>{card.name}</span>
                                        <span className="text-secondary/60">{card.count}×</span>
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}

                    {/* Context Mix */}
                    {contextBreakdown.length > 0 && (
                        <div className={`rounded-3xl border border-secondary/20 bg-surface/40 ${isLandscape ? 'p-3' : 'p-5'}`}>
                            <h3 className={`text-xs font-bold uppercase tracking-wider text-accent/80 ${isLandscape ? 'mb-2' : 'mb-4'}`}>Context Mix</h3>
                            <div className={`flex flex-wrap ${isLandscape ? 'gap-1' : 'gap-2'}`}>
                                {contextBreakdown.map((ctx) => (
                                    <span key={ctx.name} className={`rounded-full border border-secondary/20 bg-secondary/5 text-secondary ${isLandscape ? 'px-2 py-0.5 text-[0.65rem]' : 'px-3 py-1 text-xs'}`}>
                                        {ctx.name} <span className="opacity-50">({ctx.count})</span>
                                    </span>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* Recent Themes */}
                    {recentThemes.length > 0 && (
                        <div className={`rounded-3xl border border-secondary/20 bg-surface/40 ${isLandscape ? 'p-3' : 'p-5'}`}>
                            <h3 className={`flex items-center gap-2 text-xs font-bold uppercase tracking-wider text-accent/80 ${isLandscape ? 'mb-2' : 'mb-4'}`}>
                                <Sparkle className="h-3 w-3" /> Recent Themes
                            </h3>
                            <ul className={isLandscape ? 'space-y-1' : 'space-y-2'}>
                                {recentThemes.slice(0, isLandscape ? 3 : 5).map((theme, idx) => (
                                    <li key={idx} className={`flex items-center gap-2 text-muted ${isLandscape ? 'text-xs' : 'text-sm'}`}>
                                        <span className="h-1.5 w-1.5 rounded-full bg-secondary/40" />
                                        <span>{theme}</span>
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}

                    {/* Emerging Interests (Preference Drift) - Phase 5.4 */}
                    {preferenceDrift?.hasDrift && (
                        <div className={`rounded-3xl border border-amber-500/30 bg-amber-500/5 ${isLandscape ? 'p-3' : 'p-5'}`}>
                            <h3 className={`flex items-center gap-2 text-xs font-bold uppercase tracking-wider text-amber-400/90 ${isLandscape ? 'mb-2' : 'mb-4'}`}>
                                <BookOpen className="h-3 w-3" /> Emerging Interests
                            </h3>
                            <p className={`text-muted leading-relaxed ${isLandscape ? 'text-xs' : 'text-sm'}`}>
                                You&apos;ve been exploring{' '}
                                <span className="font-medium text-amber-300">
                                    {preferenceDrift.driftContexts
                                        .slice(0, 2)
                                        .map(d => formatContextName(d.context))
                                        .join(' and ')}
                                </span>{' '}
                                themes beyond your selected focus areas.
                            </p>
                            <p className={`mt-2 text-secondary/60 ${isLandscape ? 'text-[0.65rem]' : 'text-xs'}`}>
                                Consider updating your focus areas in Settings to personalize future readings.
                            </p>
                        </div>
                    )}

                    {/* Next Steps / Coach */}
                    {(contextSuggestion || topTheme || topCard) && coachRecommendation && (
                        <CoachSuggestion
                            recommendation={coachRecommendation}
                            onApply={handleCoachPrefill}
                            variant="journal"
                            className={filtersActive ? "opacity-50 pointer-events-none" : ""}
                        />
                    )}
                </div>

                {isAuthenticated && shareLinks.length > 0 && (
                    <div className="rounded-3xl border border-secondary/20 bg-surface/40 p-5">
                        <h3 className="mb-4 text-xs font-bold uppercase tracking-wider text-accent/80">
                            Active Share Links
                        </h3>
                        <div className="grid gap-3 sm:grid-cols-2 lg:grid-cols-3">
                            {shareLinks.slice(0, 6).map((link) => (
                                <div key={link.token} className="rounded-xl border border-secondary/10 bg-surface-muted/40 p-3">
                                    <div className="flex items-center justify-between gap-3">
                                        <div className="overflow-hidden">
                                            <p className="truncate text-sm font-medium text-secondary">{link.title || 'Untitled Link'}</p>
                                            <p className="text-xs text-secondary/50">{link.viewCount || 0} views</p>
                                        </div>
                                        <div className="flex flex-wrap gap-2">
                                            <button
                                                onClick={() => copyShareUrl(link.token)}
                                                className="inline-flex items-center gap-1.5 rounded-full border border-secondary/40 px-2.5 py-1 text-xs font-semibold text-secondary hover:border-secondary/70 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/50"
                                                aria-label="Copy share link"
                                            >
                                                <Copy className="h-3.5 w-3.5" />
                                                <span>Copy</span>
                                            </button>
                                            <button
                                                onClick={() => onDeleteShareLink?.(link.token)}
                                                className="inline-flex items-center gap-1.5 rounded-full border border-error/40 px-2.5 py-1 text-xs font-semibold text-error hover:border-error/60 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-error/50"
                                                aria-label="Delete share link"
                                            >
                                                <Trash className="h-3.5 w-3.5" />
                                                <span>Delete</span>
                                            </button>
                                        </div>
                                    </div>
                                    {shareLinkFeedback.token === link.token && shareLinkFeedback.message && (
                                        <p className="mt-2 text-[11px] text-secondary/70" aria-live="polite">
                                            {shareLinkFeedback.message}
                                        </p>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>
                )}
            </div>
        </div>
    );
});
</file>

<file path="src/components/MarkdownRenderer.jsx">
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';

// Mobile-optimized typography: 65-75 character line length, good paragraph spacing
// Using 16px (text-base) as minimum for accessibility and iOS zoom prevention
const paragraphClass = 'text-base md:text-lg leading-relaxed xs:leading-7 md:leading-loose';
const headingClass = 'font-serif text-lg sm:text-xl text-secondary mt-5 xs:mt-6 mb-2 xs:mb-3';
const listClass = 'list-disc pl-4 sm:pl-5 space-y-1.5 xs:space-y-2';

export function MarkdownRenderer({ content }) {
  if (!content || typeof content !== 'string') {
    return null;
  }

  return (
    // max-w-prose ensures 65-75 character line length for optimal readability
    // Using calc for very small screens to prevent text touching edges
    <div className="text-main space-y-4 xs:space-y-5 md:space-y-6 max-w-[calc(100vw-1.5rem)] xs:max-w-sm sm:max-w-prose mx-auto text-left px-1 xs:px-2 sm:px-4 lg:px-6">
      <ReactMarkdown
        remarkPlugins={[remarkGfm]}
        skipHtml
        className="space-y-3 xs:space-y-4"
        components={{
          h1: ({ node: _node, ...props }) => (
            <h1 {...props} className={`${headingClass} text-xl xs:text-2xl`} />
          ),
          h2: ({ node: _node, ...props }) => (
            <h2 {...props} className={`${headingClass} text-lg xs:text-xl`} />
          ),
          h3: ({ node: _node, ...props }) => (
            <h3 {...props} className={`${headingClass} text-base xs:text-lg`} />
          ),
          p: ({ node: _node, ...props }) => (
            <p {...props} className={paragraphClass} />
          ),
          strong: ({ node: _node, ...props }) => (
            <strong {...props} className="text-main font-semibold" />
          ),
          em: ({ node: _node, ...props }) => (
            <em {...props} className="italic text-main/90" />
          ),
          ul: ({ node: _node, ...props }) => (
            <ul {...props} className={`${listClass} ${paragraphClass}`} />
          ),
          ol: ({ node: _node, ...props }) => (
            <ol {...props} className={`list-decimal pl-5 space-y-1.5 xs:space-y-2 ${paragraphClass}`} />
          ),
          li: ({ node: _node, ...props }) => (
            <li {...props} className="marker:text-secondary pl-1" />
          ),
          blockquote: ({ node: _node, ...props }) => (
            <blockquote
              {...props}
              className={`${paragraphClass} border-l-2 border-secondary/40 pl-4 xs:pl-5 italic text-accent/85 my-4 xs:my-5`}
            />
          ),
          a: ({ node: _node, ...props }) => (
            <a
              {...props}
              className="text-secondary underline decoration-dotted underline-offset-4 hover:text-secondary break-words overflow-wrap-anywhere"
              target="_blank"
              rel="noopener noreferrer"
            />
          ),
          // Inline code (backticks)
          code: ({ node: _node, inline, className, children, ...props }) => {
            if (inline) {
              return (
                <code
                  {...props}
                  className="bg-surface-muted/70 text-accent px-1.5 py-0.5 rounded text-[0.85rem] xs:text-sm font-mono break-words"
                >
                  {children}
                </code>
              );
            }
            // Code blocks (triple backticks) - pre handles container styling
            return (
              <code
                {...props}
                className={`block p-3 text-[0.8rem] xs:text-sm font-mono whitespace-pre-wrap break-words ${className || ''}`}
              >
                {children}
              </code>
            );
          },
          // Pre wrapper for code blocks - handles scrolling with mobile overflow fix
          pre: ({ node: _node, ...props }) => (
            <pre
              {...props}
              className="bg-surface-muted/50 rounded-lg overflow-x-auto my-3 xs:my-4 border border-secondary/20 max-w-full"
            />
          ),
          // Horizontal rule - section break
          hr: ({ node: _node, ...props }) => (
            <hr {...props} className="border-secondary/30 my-6 xs:my-8" />
          ),
          // Tables (from GFM) - scrollable container with keyboard support
          table: ({ node: _node, ...props }) => (
            <div
              className="overflow-x-auto my-4 xs:my-5 -mx-1 px-1"
              role="region"
              aria-label="Data table"
              tabIndex={0}
            >
              <table {...props} className="w-full border-collapse text-[0.8rem] xs:text-sm" />
            </div>
          ),
          thead: ({ node: _node, ...props }) => (
            <thead {...props} className="bg-surface-muted/50" />
          ),
          th: ({ node: _node, ...props }) => (
            <th {...props} className="border border-secondary/30 px-2 xs:px-3 py-1.5 xs:py-2 text-left font-semibold text-accent" />
          ),
          td: ({ node: _node, ...props }) => (
            <td {...props} className="border border-secondary/30 px-2 xs:px-3 py-1.5 xs:py-2" />
          )
        }}
      >
        {content}
      </ReactMarkdown>
    </div>
  );
}
</file>

<file path="src/components/MobileActionBar.jsx">
import { useMemo, useSyncExternalStore } from 'react';
import { Gear, Sparkle, ArrowsClockwise } from '@phosphor-icons/react';
import { useLandscape } from '../hooks/useLandscape';

// Subscribe to visualViewport changes for keyboard avoidance
function subscribeToViewport(callback) {
  if (typeof window === 'undefined' || !window.visualViewport) {
    return () => {};
  }
  window.visualViewport.addEventListener('resize', callback);
  window.visualViewport.addEventListener('scroll', callback);
  return () => {
    window.visualViewport.removeEventListener('resize', callback);
    window.visualViewport.removeEventListener('scroll', callback);
  };
}

function getViewportOffset() {
  if (typeof window === 'undefined' || !window.visualViewport) {
    return 0;
  }
  const offset = window.innerHeight - window.visualViewport.height;
  return offset > 50 ? offset : 0;
}

function getServerViewportOffset() {
  return 0;
}

export const MOBILE_SETTINGS_DIALOG_ID = 'mobile-settings-drawer';
export const MOBILE_COACH_DIALOG_ID = 'guided-intention-coach';

// Shared button styles - reduced height in landscape while maintaining touch target
const BTN_BASE = 'inline-flex items-center justify-center rounded-xl font-semibold transition touch-manipulation';
const BTN_PRIMARY = `${BTN_BASE} bg-accent text-surface shadow-lg hover:opacity-90`;
const BTN_SECONDARY = `${BTN_BASE} bg-surface-muted text-accent border border-accent/30 hover:bg-surface`;
const BTN_TERTIARY = `${BTN_BASE} bg-primary/20 text-primary border border-primary/40 hover:bg-primary/30`;
const BTN_COACH = `${BTN_BASE} bg-secondary/20 text-secondary border border-secondary/40 hover:bg-secondary/30`;

const STEP_BADGES = {
  spread: 'Step 1',
  intention: 'Step 2',
  ritual: 'Step 3',
  reading: 'Step 4'
};

/**
 * Determines which action mode the mobile bar should display
 */
export function getActionMode({ isShuffling, reading, revealedCount: _revealedCount, allRevealed, needsNarrative, hasNarrative, isGenerating, isError }) {
  if (isShuffling) return 'shuffling';
  if (!reading) return 'preparation';
  if (!allRevealed) return 'revealing';
  if (needsNarrative && isGenerating) return 'generating';
  if (needsNarrative && isError) return 'error';
  if (needsNarrative) return 'ready-for-narrative';
  if (hasNarrative) return 'completed';
  return 'completed';
}

function ActionButton({
  onClick,
  disabled,
  variant = 'primary',
  stepLabel,
  children,
  ariaLabel,
  ariaControls,
  ariaExpanded,
  icon: Icon,
  className = '',
  isLandscape = false
}) {
  const variantClass = {
    primary: BTN_PRIMARY,
    secondary: BTN_SECONDARY,
    tertiary: BTN_TERTIARY,
    coach: BTN_COACH
  }[variant] || BTN_PRIMARY;

  // In landscape: hide step labels but keep touch target size consistent
  const showStepLabel = Boolean(stepLabel) && !isLandscape;
  const heightClass = 'min-h-[44px]';
  const textSize = isLandscape ? 'text-xs' : 'text-sm';

  return (
    <button
      type="button"
      onClick={onClick}
      disabled={disabled}
      aria-label={ariaLabel}
      aria-controls={ariaControls}
      aria-expanded={typeof ariaExpanded === 'boolean' ? ariaExpanded : undefined}
      className={`
        ${variantClass}
        ${heightClass}
        ${showStepLabel ? 'flex-col gap-0.5' : 'gap-1.5'}
        ${disabled ? 'opacity-50 cursor-not-allowed' : ''}
        ${className}
      `}
    >
      {Icon && !showStepLabel && <Icon className={isLandscape ? 'w-3.5 h-3.5' : 'w-4 h-4'} weight="fill" aria-hidden="true" />}
      {showStepLabel && (
        <span className="text-xs uppercase tracking-wider opacity-70">{stepLabel}</span>
      )}
      <span className={`${textSize} font-semibold`}>{children}</span>
    </button>
  );
}

function MobileActionContents({
  isShuffling,
  reading,
  revealedCards,
  dealIndex = 0,
  isGenerating,
  personalReading,
  needsNarrativeGeneration,
  stepIndicatorLabel,
  activeStep = 'spread',
  onOpenSettings,
  onOpenCoach,
  onShuffle,
  onDealNext,
  onRevealAll,
  onGenerateNarrative,
  onSaveReading,
  onNewReading,
  variant = 'fixed',
  showUtilityButtons = true,
  isSettingsOpen = false,
  isCoachOpen = false,
  settingsDialogId = MOBILE_SETTINGS_DIALOG_ID,
  coachDialogId = MOBILE_COACH_DIALOG_ID
}) {
  const isLandscape = useLandscape();
  const readingLength = reading?.length || 0;
  const revealedCount = revealedCards?.size || 0;
  const allRevealed = readingLength > 0 && revealedCount === readingLength;
  const hasNarrative = Boolean(personalReading && !personalReading.isError);
  const isError = Boolean(personalReading?.isError);
  // Preserve the ability to retry even if upstream flags temporarily clear needsNarrativeGeneration
  const needsNarrative = needsNarrativeGeneration || isError;
  const stepBadge = STEP_BADGES[activeStep] || 'Step';

  const mode = useMemo(() => getActionMode({
    isShuffling,
    reading,
    revealedCount,
    allRevealed,
    needsNarrative,
    hasNarrative,
    isGenerating,
    isError
  }), [isShuffling, reading, revealedCount, allRevealed, needsNarrative, hasNarrative, isGenerating, isError]);

  // In landscape: tighter layout with smaller gaps
  const layoutClass = variant === 'inline'
    ? 'flex flex-col gap-2 w-full'
    : isLandscape
      ? 'flex flex-wrap gap-1.5'
      : 'flex flex-wrap gap-2';

  return (
    <div className={layoutClass}>
      {renderActions(mode, {
        variant,
        showUtilityButtons,
        readingLength,
        dealIndex,
        stepBadge,
        stepIndicatorLabel,
        hasNarrative,
        isLandscape,
        isSettingsOpen,
        isCoachOpen,
        settingsDialogId,
        coachDialogId,
        onOpenSettings,
        onOpenCoach,
        onShuffle,
        onDealNext,
        onRevealAll,
        onGenerateNarrative,
        onSaveReading,
        onNewReading
      })}
    </div>
  );
}

function withStepContext(label, stepIndicatorLabel) {
  if (!stepIndicatorLabel) return label;
  return `${label} — ${stepIndicatorLabel}`;
}

function renderActions(mode, options) {
  const {
    variant,
    showUtilityButtons,
    readingLength,
    dealIndex,
    stepBadge,
    stepIndicatorLabel,
    hasNarrative,
    isLandscape,
    isSettingsOpen,
    isCoachOpen,
    settingsDialogId,
    coachDialogId,
    onOpenSettings,
    onOpenCoach,
    onShuffle,
    onDealNext,
    onRevealAll,
    onGenerateNarrative,
    onSaveReading,
    onNewReading
  } = options;

  // In landscape: smaller minimum widths to fit more buttons
  const widthClasses = {
    primary: variant === 'inline' ? 'w-full' : isLandscape ? 'flex-1 min-w-[4rem]' : 'flex-1 min-w-[7.5rem]',
    prepPrimary: variant === 'inline' ? 'w-full' : isLandscape ? 'flex-1 min-w-[3.5rem]' : 'flex-1 min-w-[6rem]',
    secondary: variant === 'inline' ? 'w-full' : isLandscape ? 'flex-1 min-w-[4rem]' : 'flex-1 min-w-[7.5rem]',
    tertiary: variant === 'inline' ? 'w-full' : isLandscape ? 'flex-1 min-w-[3rem]' : 'flex-1 min-w-[7.5rem]',
    icon: variant === 'inline' ? 'w-full' : isLandscape ? 'flex-none w-[2.25rem]' : 'flex-none w-[3rem]',
    coach: variant === 'inline' ? 'w-full' : 'flex-none'
  };

  // Padding classes: smaller in landscape
  const px = isLandscape ? 'px-2' : 'px-3';

  switch (mode) {
    case 'shuffling': {
      const label = isLandscape ? 'Shuffling' : 'Shuffling';
      return (
        <ActionButton
          variant="primary"
          disabled
          stepLabel={stepBadge}
          ariaLabel={withStepContext(label, stepIndicatorLabel)}
          className={`${widthClasses.primary} ${px}`}
          isLandscape={isLandscape}
        >
          <span className="flex items-center gap-1.5">
            <ArrowsClockwise className={isLandscape ? 'w-3.5 h-3.5 animate-spin' : 'w-4 h-4 animate-spin'} aria-hidden="true" />
            {label}...
          </span>
        </ActionButton>
      );
    }

    case 'preparation': {
      const drawLabel = isLandscape ? 'Draw' : 'Draw cards';
      return (
        <>
          {showUtilityButtons && (
            <ActionButton
              variant="secondary"
              onClick={onOpenSettings}
              ariaLabel="Open settings"
              ariaControls={settingsDialogId}
              ariaExpanded={isSettingsOpen}
              className={`${widthClasses.icon} ${variant === 'inline' ? px : 'px-0'}`}
              isLandscape={isLandscape}
            >
              <Gear className={isLandscape ? 'w-4 h-4' : 'w-5 h-5'} />
            </ActionButton>
          )}
          {showUtilityButtons && (
            <ActionButton
              variant="coach"
              onClick={onOpenCoach}
              icon={Sparkle}
              ariaLabel="Open guided intention coach"
              ariaControls={coachDialogId}
              ariaExpanded={isCoachOpen}
              className={`${widthClasses.coach} ${px}`}
              isLandscape={isLandscape}
            >
              {isLandscape ? 'Coach' : 'Coach'}
            </ActionButton>
          )}
          <ActionButton
            variant="primary"
            onClick={onShuffle}
            stepLabel={stepBadge}
            ariaLabel={withStepContext(drawLabel, stepIndicatorLabel)}
            className={`${widthClasses.prepPrimary} ${px}`}
            isLandscape={isLandscape}
          >
            {drawLabel}
          </ActionButton>
        </>
      );
    }

    case 'revealing': {
      const nextLabel = isLandscape
        ? `${Math.min(dealIndex + 1, readingLength)}/${readingLength}`
        : `Reveal next (${Math.min(dealIndex + 1, readingLength)}/${readingLength})`;
      const revealAllLabel = isLandscape ? 'All' : 'Reveal all';
      return (
        <>
          <ActionButton
            variant="primary"
            onClick={onDealNext}
            stepLabel={stepBadge}
            ariaLabel={withStepContext(nextLabel, stepIndicatorLabel)}
            className={`${widthClasses.primary} ${px}`}
            isLandscape={isLandscape}
          >
            {nextLabel}
          </ActionButton>
          {readingLength > 1 && (
            <ActionButton
              variant="tertiary"
              onClick={onRevealAll}
              ariaLabel={withStepContext('Reveal all cards', stepIndicatorLabel)}
              className={`${widthClasses.tertiary} ${px}`}
              isLandscape={isLandscape}
            >
              {revealAllLabel}
            </ActionButton>
          )}
        </>
      );
    }

    case 'generating':
      return (
        <>
          <ActionButton
            variant="primary"
            disabled
            stepLabel={stepBadge}
            ariaLabel={withStepContext('Narrative in progress', stepIndicatorLabel)}
            className={`${widthClasses.primary} ${px}`}
            isLandscape={isLandscape}
          >
            <span className="flex items-center gap-1.5">
              <ArrowsClockwise className={isLandscape ? 'w-3.5 h-3.5 animate-spin' : 'w-4 h-4 animate-spin'} aria-hidden="true" />
              {isLandscape ? 'Weaving' : 'Weaving...'}
            </span>
          </ActionButton>
          <ActionButton
            variant="secondary"
            onClick={onNewReading}
            ariaLabel="Start a new reading (resets the current spread)"
            className={`${widthClasses.secondary} ${px}`}
            isLandscape={isLandscape}
          >
            {isLandscape ? 'New' : 'New reading'}
          </ActionButton>
        </>
      );

    case 'error':
      return (
        <>
          <ActionButton
            variant="primary"
            onClick={onGenerateNarrative}
            stepLabel={stepBadge}
            icon={ArrowsClockwise}
            ariaLabel={withStepContext('Retry narrative generation', stepIndicatorLabel)}
            className={`${widthClasses.primary} ${px}`}
            isLandscape={isLandscape}
          >
            {isLandscape ? 'Retry' : 'Retry narrative'}
          </ActionButton>
          <ActionButton
            variant="secondary"
            onClick={onNewReading}
            ariaLabel="Start a new reading (resets the current spread)"
            className={`${widthClasses.secondary} ${px}`}
            isLandscape={isLandscape}
          >
            {isLandscape ? 'New' : 'New reading'}
          </ActionButton>
        </>
      );

    case 'ready-for-narrative':
      return (
        <>
          <ActionButton
            variant="primary"
            onClick={onGenerateNarrative}
            stepLabel={stepBadge}
            ariaLabel={withStepContext('Create narrative', stepIndicatorLabel)}
            className={`${widthClasses.primary} ${px}`}
            isLandscape={isLandscape}
          >
            {isLandscape ? 'Create' : 'Create narrative'}
          </ActionButton>
          <ActionButton
            variant="secondary"
            onClick={onNewReading}
            ariaLabel="Start a new reading (resets the current spread)"
            className={`${widthClasses.secondary} ${px}`}
            isLandscape={isLandscape}
          >
            {isLandscape ? 'New' : 'New reading'}
          </ActionButton>
        </>
      );

    case 'completed':
      return (
        <>
          {hasNarrative && (
            <ActionButton
              variant="primary"
              onClick={onSaveReading}
              stepLabel={stepBadge}
              ariaLabel={withStepContext('Save reading to journal', stepIndicatorLabel)}
              className={`${widthClasses.primary} ${px}`}
              isLandscape={isLandscape}
            >
              {isLandscape ? 'Save' : 'Save reading'}
            </ActionButton>
          )}
          <ActionButton
            variant="secondary"
            onClick={onNewReading}
            ariaLabel="Start a new reading (resets the current spread)"
            className={`${widthClasses.secondary} ${px}`}
            isLandscape={isLandscape}
          >
            {isLandscape ? 'New' : 'New reading'}
          </ActionButton>
        </>
      );

    default:
      return null;
  }
}

export function MobileActionBar({ keyboardOffset = 0, isOverlayActive = false, ...props }) {
  // Use useSyncExternalStore for visualViewport subscription (React-recommended pattern for browser APIs)
  const viewportOffset = useSyncExternalStore(
    subscribeToViewport,
    getViewportOffset,
    getServerViewportOffset
  );

  const effectiveOffset = Math.max(keyboardOffset, viewportOffset);

  return (
    <nav
      className={`mobile-action-bar sm:hidden transition-opacity duration-200 ${isOverlayActive ? 'opacity-0 pointer-events-none' : 'opacity-100'}`}
      aria-label="Primary mobile actions"
      style={effectiveOffset > 0 ? { bottom: effectiveOffset } : undefined}
      data-overlay-active={isOverlayActive ? 'true' : undefined}
    >
      <MobileActionContents {...props} />
    </nav>
  );
}

export function MobileActionGroup({ showUtilityButtons = false, ...props }) {
  return (
    <div className="mobile-action-group sm:hidden" aria-label="Inline mobile actions">
      <MobileActionContents variant="inline" showUtilityButtons={showUtilityButtons} {...props} />
    </div>
  );
}
</file>

<file path="src/components/MobileInfoSection.jsx">
import { useState, useId } from 'react';
import { CaretDown, CaretUp, Info } from '@phosphor-icons/react';

/**
 * MobileInfoSection - A mobile-friendly alternative to tooltips
 *
 * Instead of tiny info icons that are hard to tap, this component provides:
 * - A clearly visible, tap-friendly expand/collapse trigger
 * - Smooth content reveal animation
 * - Proper accessibility with ARIA attributes
 * - Respects prefers-reduced-motion
 *
 * Use this in mobile contexts where Tooltip would require a small tap target.
 *
 * @param {Object} props
 * @param {string} props.title - Brief label for the info section
 * @param {React.ReactNode} props.children - Info content to display when expanded
 * @param {string} [props.variant='inline'] - 'inline' for compact, 'block' for full-width
 * @param {boolean} [props.defaultOpen=false] - Whether to start expanded
 * @param {string} [props.className] - Additional CSS classes
 */
export function MobileInfoSection({
  title,
  children,
  variant = 'inline',
  defaultOpen = false,
  className = ''
}) {
  const [isOpen, setIsOpen] = useState(defaultOpen);
  const contentId = useId();

  const isInline = variant === 'inline';

  const baseButtonClass = `
    inline-flex items-center gap-1.5
    min-h-[44px] px-3 py-2
    rounded-xl border border-secondary/30
    bg-surface/60
    text-xs text-secondary
    transition-colors duration-150
    hover:border-accent/50 hover:bg-surface/80
    focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60 focus-visible:ring-offset-2 focus-visible:ring-offset-main
    touch-manipulation
    active:scale-[0.98]
  `;

  const blockButtonClass = `
    w-full flex items-center justify-between gap-2
    min-h-[48px] px-4 py-3
    rounded-xl border border-secondary/25
    bg-surface/50
    text-sm text-main
    transition-colors duration-150
    hover:border-accent/40 hover:bg-surface/70
    focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60
    touch-manipulation
    active:scale-[0.99]
  `;

  const contentClass = isOpen
    ? 'opacity-100 max-h-[500px] mt-2'
    : 'opacity-0 max-h-0 overflow-hidden';

  return (
    <div className={`${className}`}>
      <button
        type="button"
        onClick={() => setIsOpen(prev => !prev)}
        className={isInline ? baseButtonClass : blockButtonClass}
        aria-expanded={isOpen}
        aria-controls={contentId}
      >
        {isInline ? (
          <>
            <Info className="w-4 h-4 flex-shrink-0" aria-hidden="true" />
            <span className="font-medium">{title}</span>
            {isOpen
              ? <CaretUp className="w-3.5 h-3.5 flex-shrink-0" aria-hidden="true" />
              : <CaretDown className="w-3.5 h-3.5 flex-shrink-0" aria-hidden="true" />
            }
          </>
        ) : (
          <>
            <div className="flex items-center gap-2">
              <Info className="w-5 h-5 text-secondary flex-shrink-0" aria-hidden="true" />
              <span className="font-semibold">{title}</span>
            </div>
            <span className="w-8 h-8 flex items-center justify-center rounded-full bg-secondary/10 border border-secondary/20">
              {isOpen
                ? <CaretUp className="w-4 h-4 text-accent" aria-hidden="true" />
                : <CaretDown className="w-4 h-4 text-accent" aria-hidden="true" />
              }
            </span>
          </>
        )}
      </button>

      <div
        id={contentId}
        className={`transition-all duration-200 ease-out ${contentClass}`}
        aria-hidden={!isOpen}
      >
        <div className={`
          rounded-xl border border-secondary/20 bg-surface/70
          px-3 py-2.5
          text-sm text-muted leading-relaxed
          ${isInline ? '' : 'ml-7'}
        `}>
          {children}
        </div>
      </div>
    </div>
  );
}

/**
 * InfoText - A simpler inline info display without expand/collapse
 * Use when you want to show helpful text inline without interaction.
 */
export function InfoText({ children, className = '' }) {
  return (
    <div className={`flex items-start gap-2 text-xs text-muted ${className}`}>
      <Info className="w-4 h-4 flex-shrink-0 text-secondary/70 mt-0.5" aria-hidden="true" />
      <span className="leading-relaxed">{children}</span>
    </div>
  );
}
</file>

<file path="src/components/MobileSettingsDrawer.jsx">
import { useRef, useCallback, useState, useEffect } from 'react';
import { Sparkle, X } from '@phosphor-icons/react';
import { useModalA11y } from '../hooks/useModalA11y';
import { MOBILE_SETTINGS_DIALOG_ID } from './MobileActionBar';

export function MobileSettingsDrawer({ isOpen, onClose, children, footer = null }) {
  const drawerRef = useRef(null);
  const closeButtonRef = useRef(null);

  // Shared modal accessibility: scroll lock, escape key, focus trap, focus restoration
  useModalA11y(isOpen, {
    onClose,
    containerRef: drawerRef,
    initialFocusRef: closeButtonRef,
    scrollLockStrategy: 'simple', // Simple strategy for drawers
  });

  // Handle swipe-to-dismiss with velocity and visual feedback
  const touchStartY = useRef(null);
  const touchStartTime = useRef(null);
  const [dragOffset, setDragOffset] = useState(0);
  const [isDragging, setIsDragging] = useState(false);

  // Reset drag state when drawer opens/closes
  // Using refs for previous state to avoid cascading renders
  const prevIsOpenRef = useRef(isOpen);
  useEffect(() => {
    // Only reset when isOpen actually changes
    if (prevIsOpenRef.current !== isOpen) {
      prevIsOpenRef.current = isOpen;
      // Reset all drag-related state and refs when drawer state changes
      touchStartY.current = null;
      touchStartTime.current = null;
      // Defer state updates to avoid cascading renders
      queueMicrotask(() => {
        setDragOffset(0);
        setIsDragging(false);
      });
    }
  }, [isOpen]);

  const handleTouchStart = useCallback((event) => {
    // Only track touches that start on the handle area or header
    const target = event.target;
    const isHandleOrHeader = target.closest('.mobile-drawer__handle') ||
      target.closest('.mobile-drawer__header');

    // Allow anywhere if at scroll top, or specifically on handle/header
    const scrollContainer = drawerRef.current?.querySelector('.mobile-drawer__body');
    const isAtScrollTop = !scrollContainer || scrollContainer.scrollTop <= 0;

    if (isHandleOrHeader || isAtScrollTop) {
      touchStartY.current = event.touches[0].clientY;
      touchStartTime.current = Date.now();
      setIsDragging(true);
    }
  }, []);

  const handleTouchMove = useCallback((event) => {
    if (touchStartY.current === null) return;

    const currentY = event.touches[0].clientY;
    const deltaY = currentY - touchStartY.current;

    // Only allow dragging downward (positive delta)
    if (deltaY > 0) {
      // Apply resistance as drag increases (feels more natural)
      const resistance = 0.6;
      const dampedDelta = deltaY * resistance;
      setDragOffset(dampedDelta);
    }
  }, []);

  const handleTouchEnd = useCallback((event) => {
    if (touchStartY.current === null) {
      setIsDragging(false);
      setDragOffset(0);
      return;
    }

    const touchEndY = event.changedTouches[0].clientY;
    const deltaY = touchEndY - touchStartY.current;
    const elapsed = Date.now() - (touchStartTime.current || Date.now());

    // Calculate velocity (pixels per millisecond)
    const velocity = deltaY / Math.max(elapsed, 1);

    // Dismiss conditions (increased thresholds to prevent accidental dismissal):
    // 1. Dragged far enough (200px+)
    // 2. Fast swipe (velocity > 0.6 px/ms) with substantial distance (80px+)
    const shouldDismiss = deltaY > 200 || (deltaY > 80 && velocity > 0.6);

    if (shouldDismiss) {
      // Animate out with current momentum
      setDragOffset(window.innerHeight);
      setTimeout(onClose, 150);
    } else {
      // Snap back
      setDragOffset(0);
    }

    touchStartY.current = null;
    touchStartTime.current = null;
    setIsDragging(false);
  }, [onClose]);

  const handleTouchCancel = useCallback(() => {
    touchStartY.current = null;
    touchStartTime.current = null;
    setIsDragging(false);
    setDragOffset(0);
  }, []);

  if (!isOpen) return null;

  return (
    <div
      className="fixed inset-0 z-[70] flex items-end justify-center sm:hidden"
      style={{ paddingTop: 'max(16px, env(safe-area-inset-top, 16px))' }}
    >
      <div
        className="mobile-drawer-overlay absolute inset-0 animate-fade-in"
        onClick={onClose}
        aria-hidden="true"
      />

      <div
        ref={drawerRef}
        className="mobile-drawer relative w-full flex flex-col animate-slide-up"
        id={MOBILE_SETTINGS_DIALOG_ID}
        role="dialog"
        aria-modal="true"
        aria-labelledby="mobile-drawer-title"
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
        onTouchCancel={handleTouchCancel}
        style={{
          maxHeight: 'calc(100% - 8px)',
          transform: dragOffset > 0 ? `translateY(${dragOffset}px)` : undefined,
          transition: isDragging ? 'none' : 'transform 0.2s ease-out'
        }}
      >
        <div className="mobile-drawer__handle" aria-hidden="true" />

        <div className="mobile-drawer__header px-4 pt-3 pb-3">
          <div className="flex items-start justify-between gap-3">
            <div className="space-y-1">
              <p className="mobile-drawer__eyebrow">
                <Sparkle className="w-3.5 h-3.5" aria-hidden="true" />
                Guided setup
              </p>
              <h2 id="mobile-drawer-title" className="text-lg font-serif text-accent">Prepare Reading</h2>
              <p className="text-[0.78rem] text-muted/90 leading-snug max-w-[22rem]">
                Align your spread, deck, and ritual steps before you draw cards.
              </p>
            </div>

            <button
              ref={closeButtonRef}
              onClick={onClose}
              className="mobile-drawer__close"
              aria-label="Close settings drawer"
            >
              <X className="w-5 h-5" />
            </button>
          </div>

        </div>

        <div className="mobile-drawer__body p-4 space-y-8 overflow-y-auto overscroll-contain pb-safe-bottom">
          {children}
        </div>
        {footer && (
          <div className="mobile-drawer__footer">
            {footer}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/PersonalizationBanner.jsx">
export function PersonalizationBanner({ onDismiss, onPersonalize }) {
  return (
    <div className="bg-accent/10 border border-accent/30 rounded-lg p-4 mb-4 flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
      <div>
        <p className="text-sm text-main">
          <strong>New:</strong> Personalize your readings with tone, style, and focus preferences.
        </p>
        <p className="text-xs text-muted mt-1">
          Skip ritual steps, set your ideal spread depth, and tailor the narrative tone whenever you like.
        </p>
      </div>
      <div className="flex gap-2">
        <button
          type="button"
          onClick={onPersonalize}
          className="btn-primary text-xs sm:text-sm min-h-[38px]"
        >
          Set Preferences
        </button>
        <button
          type="button"
          onClick={onDismiss}
          className="btn-secondary text-xs sm:text-sm min-h-[38px]"
        >
          Maybe Later
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/PhotoInputModal.jsx">
import { useRef, useMemo } from 'react';
import { Camera, Images, X } from '@phosphor-icons/react';
import { useModalA11y, createBackdropHandler } from '../hooks/useModalA11y';

export function PhotoInputModal({ onTakePhoto, onChooseFromLibrary, onCancel }) {
  const modalRef = useRef(null);
  const titleId = 'photo-input-modal-title';

  // Shared modal accessibility: scroll lock, escape key, focus trap, focus restoration
  // This modal is always open when rendered, so isOpen is always true
  useModalA11y(true, {
    onClose: onCancel,
    containerRef: modalRef,
    scrollLockStrategy: 'fixed',
  });

  // Handle backdrop click using shared helper
  // useMemo is appropriate here since createBackdropHandler returns a function
  const handleBackdropClick = useMemo(() => createBackdropHandler(onCancel), [onCancel]);

  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-main/90 backdrop-blur-sm animate-fade-in p-3 xs:p-4"
      onClick={handleBackdropClick}
      role="dialog"
      aria-modal="true"
      aria-labelledby={titleId}
      style={{
        paddingTop: 'max(0.75rem, env(safe-area-inset-top))',
        paddingBottom: 'max(0.75rem, env(safe-area-inset-bottom))',
        paddingLeft: 'max(0.75rem, env(safe-area-inset-left))',
        paddingRight: 'max(0.75rem, env(safe-area-inset-right))'
      }}
    >
      <div
        ref={modalRef}
        tabIndex={-1}
        className="bg-surface rounded-xl shadow-2xl p-5 xs:p-6 w-full max-w-sm animate-pop-in border border-secondary/30 focus:outline-none"
      >
        <div className="flex items-center justify-between mb-4">
          <h3 id={titleId} className="text-base xs:text-lg font-semibold text-main">
            Add a Photo
          </h3>
          <button
            type="button"
            onClick={onCancel}
            className="p-2 -mr-2 min-w-[44px] min-h-[44px] flex items-center justify-center text-muted hover:text-main hover:bg-surface-muted rounded-full transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary touch-manipulation"
            aria-label="Close"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        <div className="space-y-3">
          <button
            type="button"
            onClick={onTakePhoto}
            className="w-full flex items-center gap-3 px-4 py-3 min-h-[48px] text-white bg-secondary hover:bg-secondary/90 active:bg-secondary/80 rounded-lg transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2 focus-visible:ring-offset-surface touch-manipulation"
          >
            <Camera className="w-5 h-5" aria-hidden="true" />
            <span className="font-medium">Take Photo</span>
          </button>

          <button
            type="button"
            onClick={onChooseFromLibrary}
            className="w-full flex items-center gap-3 px-4 py-3 min-h-[48px] text-white bg-primary hover:bg-primary/90 active:bg-primary/80 rounded-lg transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 focus-visible:ring-offset-surface touch-manipulation"
          >
            <Images className="w-5 h-5" aria-hidden="true" />
            <span className="font-medium">Choose from Library</span>
          </button>
        </div>

        <button
          type="button"
          onClick={onCancel}
          className="w-full mt-4 px-4 py-2.5 min-h-[44px] text-muted hover:text-main border border-secondary/30 hover:border-secondary/50 rounded-lg transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary touch-manipulation"
        >
          Cancel
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/components/QuestionInput.jsx">
import { useEffect, useId, useRef, useState } from 'react';
import { ArrowsClockwise, Sparkle } from '@phosphor-icons/react';
import { EXAMPLE_QUESTIONS } from '../data/exampleQuestions';
import { recordCoachQuestion } from '../lib/coachStorage';
import { usePreferences } from '../contexts/PreferencesContext';

export function QuestionInput({
  userQuestion,
  setUserQuestion,
  placeholderIndex,
  onFocus,
  onBlur,
  onPlaceholderRefresh,
  onLaunchCoach
}) {
  const optionalId = useId();
  const [savedNotice, setSavedNotice] = useState(false);
  const [saveError, setSaveError] = useState('');
  const timeoutRefs = useRef([]);
  const { personalization } = usePreferences();
  const isExperienced = personalization?.tarotExperience === 'experienced';
  const isNewbie = personalization?.tarotExperience === 'newbie';
  const displayName = personalization?.displayName?.trim();

  const clearAllTimeouts = () => {
    timeoutRefs.current.forEach(timeoutId => clearTimeout(timeoutId));
    timeoutRefs.current = [];
  };

  const registerTimeout = (callback, delay) => {
    const id = setTimeout(() => {
      callback();
      timeoutRefs.current = timeoutRefs.current.filter(timeoutId => timeoutId !== id);
    }, delay);
    timeoutRefs.current = [...timeoutRefs.current, id];
    return id;
  };

  useEffect(() => clearAllTimeouts, []);

  const handleRefreshExamples = () => {
    onPlaceholderRefresh?.();
  };

  const handleSaveIntention = () => {
    const trimmed = userQuestion.trim();
    if (!trimmed) return;
    const result = recordCoachQuestion(trimmed);
    if (result.success) {
      setSavedNotice(true);
      setSaveError('');
      registerTimeout(() => setSavedNotice(false), 1800);
    } else {
      setSavedNotice(false);
      setSaveError(result.error || 'Unable to save this question. Check browser storage settings.');
      registerTimeout(() => setSaveError(''), 3000);
    }
  };

  const handleLaunchCoach = () => {
    if (typeof onLaunchCoach === 'function') {
      onLaunchCoach();
    }
  };

  return (
    <div className="space-y-3 animate-fade-in">
      <div className="flex flex-col gap-2 xs:flex-row xs:items-center xs:justify-between">
        <div className="text-accent font-serif text-sm sm:text-base">
          <label htmlFor="question-input">
            Step 2 · {displayName ? `${displayName}'s intention` : 'Your question or intention'}
          </label>
        </div>
        {typeof onLaunchCoach === 'function' && (
          <button
            type="button"
            onClick={handleLaunchCoach}
            className="inline-flex items-center gap-1.5 rounded-full border border-primary/50 px-3 py-1.5 min-h-[44px] text-xs text-main transition hover:bg-primary/10 active:bg-primary/15 touch-manipulation self-start xs:self-auto"
            title="Shortcut: Shift+G"
            aria-label="Open guided coach (Shift+G)"
          >
            <Sparkle className="h-3.5 w-3.5" aria-hidden="true" />
            {isExperienced ? 'Coach' : 'Guided coach'}
          </button>
        )}
        <span id={optionalId} className="sr-only">
          Optional field
        </span>
      </div>
      {isNewbie && (
        <p className="text-xs text-muted mt-1">
          Unsure what to ask? Tap Guided coach or cycle the example prompt to get inspired.
        </p>
      )}
      <div className="relative">
        <input
          id="question-input"
          type="text"
          value={userQuestion}
          onChange={event => setUserQuestion(event.target.value)}
          placeholder={EXAMPLE_QUESTIONS[placeholderIndex]}
          className="w-full bg-surface border border-primary/40 rounded-lg px-3 xs:px-4 py-3 pr-12 text-base text-main placeholder-muted focus:outline-none focus:border-primary focus:ring-1 focus:ring-primary/70 transition-all"
          // text-base (16px) prevents iOS zoom on focus
          onFocus={onFocus}
          onBlur={onBlur}
          aria-describedby={optionalId}
        />
        <button
          type="button"
          onClick={handleRefreshExamples}
          className="absolute inset-y-0 right-1 flex items-center justify-center min-w-[44px] min-h-[44px] text-muted hover:text-main focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary focus-visible:ring-offset-2 focus-visible:ring-offset-surface rounded-full touch-manipulation"
          aria-label="Cycle example intention prompts"
        >
          <ArrowsClockwise className="w-4 h-4" aria-hidden="true" />
        </button>
      </div>
      <div className="flex flex-wrap items-center gap-2 xs:gap-3">
        <button
          type="button"
          className="px-3 py-1.5 min-h-[36px] rounded-lg border border-primary/40 text-xs text-main hover:bg-primary/10 active:bg-primary/15 transition disabled:opacity-50 touch-manipulation"
          onClick={handleSaveIntention}
          disabled={!userQuestion.trim()}
        >
          Save intention
        </button>
        <span role="status" aria-live="polite" className="text-xs min-h-[1.25rem]">
          {savedNotice && <span className="text-primary">Saved ✓</span>}
          {saveError && <span className="text-error">{saveError}</span>}
        </span>
      </div>
    </div>
  );
}
</file>

<file path="src/components/ReadingDisplay.jsx">
import { useCallback, useMemo, useState } from 'react';
import { AnimatePresence } from 'framer-motion';
import { Sparkle, ArrowCounterClockwise, Star, CheckCircle, BookmarkSimple } from '@phosphor-icons/react';
import { useNavigate } from 'react-router-dom';
import { getSpreadInfo, normalizeSpreadKey } from '../data/spreads';
import { ReadingGrid } from './ReadingGrid';
import { StreamingNarrative } from './StreamingNarrative';
import { HelperToggle } from './HelperToggle';
import { Tooltip } from './Tooltip';
import { SpreadPatterns } from './SpreadPatterns';
import { VisionValidationPanel } from './VisionValidationPanel';
import { FeedbackPanel } from './FeedbackPanel';
import { CardModal } from './CardModal';
import { DeckPile } from './DeckPile';
import { DeckRitual } from './DeckRitual';
import { useReading } from '../contexts/ReadingContext';
import { usePreferences } from '../contexts/PreferencesContext';
import { useSaveReading } from '../hooks/useSaveReading';
import { useFeatureFlags } from '../hooks/useFeatureFlags';
import { useAuth } from '../contexts/AuthContext';
import { useSmallScreen } from '../hooks/useSmallScreen';
import { useLandscape } from '../hooks/useLandscape';
import { useReducedMotion } from '../hooks/useReducedMotion';

export function ReadingDisplay({ sectionRef }) {
    const navigate = useNavigate();
    const { saveReading, isSaving } = useSaveReading();

    // --- Contexts ---
    const {
        // Audio
        ttsState,
        showVoicePrompt,
        setShowVoicePrompt,
        handleNarrationButtonClick,
        handleNarrationStop,
        handleVoicePromptEnable,

        // Tarot State
        selectedSpread,
        reading,
        isShuffling,
        revealedCards,
        setRevealedCards,
        dealIndex: _dealIndex,
        setDealIndex,
        sessionSeed,
        userQuestion,
        shuffle,
        dealNext,
        revealCard,
        revealAll,

        // Ritual State (for DeckRitual)
        knockCount,
        hasKnocked: _hasKnocked,
        hasCut,
        cutIndex,
        setCutIndex,
        handleKnock,
        applyCut,

        // Vision
        visionResults,
        visionConflicts,
        isVisionReady,
        hasVisionData,
        handleVisionResults,
        handleRemoveVisionResult,
        handleClearVisionResults,
        feedbackVisionSummary,

        // Reading Generation & UI
        personalReading,
        isGenerating,
        narrativePhase,
        themes,
        emotionalTone,
        readingMeta,
        journalStatus,
        setJournalStatus: _setJournalStatus,
        reflections,
        setReflections,
        lastCardsForFeedback,
        generatePersonalReading,
        highlightItems
    } = useReading();

    const readingIdentity = useMemo(() => {
        const spreadKey = selectedSpread || 'unset-spread';
        const seed = sessionSeed || 'no-seed';
        const length = reading?.length ?? 0;
        return `${spreadKey}:${seed}:${length}`;
    }, [selectedSpread, sessionSeed, reading]);

    const [selectionState, setSelectionState] = useState({ key: readingIdentity, value: null });
    const [isNarrativeFocus, setIsNarrativeFocus] = useState(false);
    const selectedCardData = selectionState.key === readingIdentity ? selectionState.value : null;
    const setSelectedCardData = useCallback((value) => {
        setSelectionState({ key: readingIdentity, value });
    }, [readingIdentity]);

    const {
        voiceOn,
        autoNarrate,
        deckStyleId,
        personalization
    } = usePreferences();
    const displayName = personalization?.displayName?.trim();
    const _isExperienced = personalization?.tarotExperience === 'experienced';
    const isNewbie = personalization?.tarotExperience === 'newbie';
    const readingTone = personalization?.readingTone || 'balanced';
    const spiritualFrame = personalization?.spiritualFrame || 'mixed';
    const { isAuthenticated } = useAuth();

    // Labels for tooltip display
    const TONE_LABELS = { gentle: 'Gentle', balanced: 'Balanced', blunt: 'Direct' };
    const FRAME_LABELS = { psychological: 'Psychological', spiritual: 'Spiritual', mixed: 'Balanced', playful: 'Playful' };
    const narrativeStyleTooltip = `Your style: ${TONE_LABELS[readingTone] || 'Balanced'} tone, ${FRAME_LABELS[spiritualFrame] || 'Balanced'} frame`;

    const { visionResearch: visionResearchEnabled, newDeckInterface } = useFeatureFlags();
    const isCompactScreen = useSmallScreen(768);
    const isLandscape = useLandscape();
    const prefersReducedMotion = useReducedMotion();
    const safeSpreadKey = normalizeSpreadKey(selectedSpread);
    const spreadInfo = getSpreadInfo(safeSpreadKey);
    const canShowVisionPanel = visionResearchEnabled && isAuthenticated;

    // --- Derived State ---
    const isPersonalReadingError = Boolean(personalReading?.isError);
    const fullReadingText = !isPersonalReadingError ? personalReading?.raw || personalReading?.normalized || '' : '';
    const narrativeText = useMemo(() => {
        if (!personalReading) return '';
        if (personalReading.hasMarkdown) return personalReading.raw || personalReading.normalized || '';
        if (Array.isArray(personalReading.paragraphs) && personalReading.paragraphs.length > 0) {
            return personalReading.paragraphs.join('\n\n');
        }
        return personalReading.normalized || personalReading.raw || '';
    }, [personalReading]);
    const shouldStreamNarrative = Boolean(personalReading && !personalReading.isError);
    const hasPatternHighlights = Boolean(!isPersonalReadingError && themes?.knowledgeGraph?.narrativeHighlights?.length);
    const hasTraditionalInsights = Boolean(readingMeta?.graphContext?.retrievedPassages?.length);
    const hasHighlightPanel = Boolean(highlightItems?.length && revealedCards.size === reading?.length);
    const hasInsightPanels = hasPatternHighlights || hasTraditionalInsights || hasHighlightPanel || canShowVisionPanel;
    const focusToggleAvailable = hasInsightPanels && (isCompactScreen || isNarrativeFocus);
    const shouldShowSpreadInsights = !isNarrativeFocus && (hasPatternHighlights || hasHighlightPanel || hasTraditionalInsights);

    // Track previous hasInsightPanels for render-time state adjustment
    const [prevHasInsightPanels, setPrevHasInsightPanels] = useState(hasInsightPanels);

    // Reset narrative focus when insight panels become unavailable.
    // This pattern (adjusting state during render) is React-recommended over useEffect
    // for syncing derived state. See: https://react.dev/learn/you-might-not-need-an-effect
    if (hasInsightPanels !== prevHasInsightPanels) {
        setPrevHasInsightPanels(hasInsightPanels);
        if (!hasInsightPanels && isNarrativeFocus) {
            setIsNarrativeFocus(false);
        }
    }


    // --- Handlers ---
    const handleNarrationWrapper = useCallback(() => {
        // Extract emotion from GraphRAG-derived emotional tone for TTS acting instructions
        const emotion = emotionalTone?.emotion || null;
        handleNarrationButtonClick(fullReadingText, isPersonalReadingError, emotion);
    }, [handleNarrationButtonClick, fullReadingText, isPersonalReadingError, emotionalTone]);

    const handleVoicePromptWrapper = useCallback(() => {
        const emotion = emotionalTone?.emotion || null;
        handleVoicePromptEnable(fullReadingText, emotion);
    }, [handleVoicePromptEnable, fullReadingText, emotionalTone]);

    const handleRevealAllWithScroll = useCallback(() => {
        revealAll();
        sectionRef.current?.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }, [revealAll, sectionRef]);

    const handleResetReveals = useCallback(() => {
        setRevealedCards(new Set());
        setDealIndex(0);
    }, [setRevealedCards, setDealIndex]);

    const handleCardClick = useCallback((card, position, index) => {
        setSelectedCardData({ card, position, index });
    }, [setSelectedCardData]);

    // Memoize next label computation to avoid IIFE in render
    const nextLabel = useMemo(() => {
        if (!reading) return null;
        const nextIndex = reading.findIndex((_, i) => !revealedCards.has(i));
        if (nextIndex === -1) return null;
        const pos = spreadInfo?.positions?.[nextIndex];
        return pos ? pos.split('—')[0].trim() : `Card ${nextIndex + 1}`;
    }, [reading, revealedCards, spreadInfo]);

    return (
        <section ref={sectionRef} id="step-reading" tabIndex={-1} className="scroll-mt-[6.5rem] sm:scroll-mt-[7.5rem]" aria-label="Draw and explore your reading">
            <div className={isLandscape ? 'mb-2' : 'mb-4 sm:mb-5'}>
                <p className="text-xs-plus sm:text-sm uppercase tracking-[0.12em] text-accent">
                    {displayName ? `Reading for ${displayName}` : 'Reading'}
                </p>
                {!isLandscape && (
                    <p className="mt-1 text-muted-high text-xs sm:text-sm">
                        {displayName ? `${displayName}, draw and reveal your cards, explore the spread, and weave your narrative.` : 'Draw and reveal your cards, explore the spread, and weave your narrative.'}
                    </p>
                )}
            </div>
            {/* Primary CTA */}
            {!reading && (
                <div className="hidden sm:block text-center mb-8 sm:mb-10">
                    <button onClick={shuffle} disabled={isShuffling} className="bg-primary hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed text-surface font-semibold px-6 sm:px-8 py-3 sm:py-4 rounded-lg shadow-lg transition-all inline-flex items-center gap-2 sm:gap-3 text-base sm:text-lg">
                        <ArrowCounterClockwise className={`w-4 h-4 sm:w-5 sm:h-5 ${isShuffling ? 'motion-safe:animate-spin' : ''}`} />
                        <span>{isShuffling ? 'Shuffling the cards...' : 'Draw cards'}</span>
                    </button>
                </div>
            )}

            {canShowVisionPanel && !isNarrativeFocus && (
                <div className="mb-6">
                    <VisionValidationPanel
                        deckStyle={deckStyleId}
                        onResults={handleVisionResults}
                        onRemoveResult={handleRemoveVisionResult}
                        onClearResults={handleClearVisionResults}
                        conflicts={visionConflicts}
                        results={visionResults}
                    />
                </div>
            )}

            {/* Reading Display */}
            {reading && (
                <div className={isLandscape ? 'space-y-4' : 'space-y-8'}>
                    {userQuestion && !isLandscape && (<div className="text-center"><p className="text-muted text-sm italic">Intention: {userQuestion}</p></div>)}
                    <div className={`text-center text-accent font-serif mb-2 ${isLandscape ? 'text-lg' : 'text-2xl'}`}>{spreadInfo?.name || 'Tarot Spread'}</div>
                    {reading.length > 1 && !isLandscape && (<p className="text-center text-muted text-xs-plus sm:text-sm mb-4">Reveal in order for a narrative flow, or follow your intuition and reveal randomly.</p>)}

                    {revealedCards.size < reading.length && (
                        <div className="hidden sm:block text-center">
                            <button type="button" onClick={handleRevealAllWithScroll} className="bg-primary hover:bg-primary/90 text-surface font-semibold px-4 sm:px-6 py-2.5 sm:py-3 rounded-full shadow-lg shadow-primary/30 transition-all flex items-center gap-2 sm:gap-3 mx-auto text-sm sm:text-base">
                                <Star className="w-4 h-4 sm:w-5 sm:h-5" /><span>Reveal All Cards</span>
                            </button>
                            <p className="text-accent/80 text-xs sm:text-sm mt-2 sm:mt-3">{revealedCards.size} of {reading.length} cards revealed</p>
                        </div>
                    )}
                    {revealedCards.size > 0 && (
                        <div className="text-center mt-3 sm:mt-4">
                            <button type="button" onClick={handleResetReveals} className="inline-flex items-center justify-center px-4 py-2 rounded-full border border-accent/50 text-muted text-xs sm:text-sm hover:text-main hover:border-accent/70 transition">
                                <span className="hidden xs:inline">Reset reveals (keep this spread)</span><span className="xs:hidden">Reset reveals</span>
                            </button>
                        </div>
                    )}
                    {reading && revealedCards.size < reading.length && (
                        newDeckInterface ? (
                            <DeckRitual
                                // Ritual state
                                knockCount={knockCount}
                                onKnock={handleKnock}
                                hasCut={hasCut}
                                cutIndex={cutIndex}
                                onCutChange={setCutIndex}
                                onCutConfirm={applyCut}
                                deckSize={78}
                                // Deal state
                                isShuffling={isShuffling}
                                onShuffle={shuffle}
                                cardsRemaining={reading.length - revealedCards.size}
                                nextPosition={nextLabel}
                                spreadPositions={spreadInfo?.positions || []}
                                revealedCount={revealedCards.size}
                                totalCards={reading.length}
                                // Deal action
                                onDeal={dealNext}
                            />
                        ) : (
                            <DeckPile
                                cardsRemaining={reading.length - revealedCards.size}
                                onDraw={dealNext}
                                isShuffling={isShuffling}
                                nextLabel={nextLabel}
                            />
                        )
                    )}

                    <ReadingGrid
                        selectedSpread={selectedSpread}
                        reading={reading}
                        revealedCards={revealedCards}
                        revealCard={revealCard}
                        reflections={reflections}
                        setReflections={setReflections}
                        onCardClick={handleCardClick}
                    />

                    {!personalReading && revealedCards.size === reading.length && (
                        <div className="text-center">
                            <Tooltip content={narrativeStyleTooltip} position="top" asChild enableClick={false}>
                                <button onClick={generatePersonalReading} disabled={isGenerating} className="bg-accent hover:bg-accent/90 disabled:opacity-50 disabled:cursor-not-allowed text-surface font-semibold px-5 sm:px-8 py-3 sm:py-4 rounded-xl shadow-xl shadow-accent/20 transition-all flex items-center gap-2 sm:gap-3 mx-auto text-sm sm:text-base md:text-lg">
                                    <Sparkle className={`w-4 h-4 sm:w-5 sm:h-5 ${isGenerating ? 'motion-safe:animate-pulse' : ''}`} />
                                    {isGenerating ? <span className="text-sm sm:text-base">Weaving your personalized reflection from this spread...</span> : <span>Create Personal Narrative</span>}
                                </button>
                            </Tooltip>
                            {hasVisionData && !isVisionReady && <p className="mt-3 text-sm text-muted">⚠️ Vision data has conflicts - research telemetry may be incomplete.</p>}
                            <HelperToggle className="mt-3 max-w-xl mx-auto" defaultOpen={isNewbie}><p>Reveal all cards to unlock a tailored reflection that weaves positions, meanings, and your notes into one coherent story.</p></HelperToggle>
                        </div>
                    )}


                    {personalReading && (
                        <div className={`bg-surface/95 backdrop-blur-xl rounded-2xl border border-secondary/40 shadow-2xl shadow-secondary/40 max-w-full sm:max-w-5xl mx-auto ${isLandscape ? 'p-3' : 'px-3 xxs:px-4 py-4 xs:px-5 sm:p-6 md:p-8'}`}>
                            {/* Narrative completion banner - shown when complete */}
                            {narrativePhase === 'complete' && !isPersonalReadingError && (
                                <div className={`mb-5 p-4 bg-gradient-to-r from-primary/20 via-secondary/15 to-accent/20 border border-primary/30 rounded-xl ${prefersReducedMotion ? '' : 'animate-fade-in'}`} role="status" aria-live="polite">
                                    <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3">
                                        <div className="flex items-center gap-2.5">
                                            <CheckCircle className="w-5 h-5 text-primary flex-shrink-0" weight="fill" />
                                            <div>
                                                <p className="text-sm font-semibold text-main">Your narrative is ready</p>
                                                <p className="text-xs text-muted">Save to your journal. Use controls below for narration.</p>
                                            </div>
                                        </div>
                                        <button
                                            type="button"
                                            onClick={saveReading}
                                            disabled={isSaving}
                                            className="inline-flex items-center gap-1.5 px-3 py-1.5 rounded-full bg-accent/20 border border-accent/40 text-accent text-xs font-semibold hover:bg-accent/30 transition touch-manipulation disabled:opacity-50 disabled:cursor-not-allowed"
                                        >
                                            <BookmarkSimple className="w-3.5 h-3.5" weight="fill" />
                                            <span>{isSaving ? 'Saving...' : 'Save to Journal'}</span>
                                        </button>
                                    </div>
                                </div>
                            )}
                            <h3 className="text-base xxs:text-lg xs:text-xl sm:text-2xl font-serif text-accent mb-2 flex items-center gap-2 leading-tight"><Sparkle className="w-5 h-5 sm:w-6 sm:h-6 text-secondary" />Your Personalized Narrative</h3>
                            <HelperToggle className="mt-3 max-w-2xl mx-auto" defaultOpen={isNewbie}>
                                <p>This narrative braids together your spread positions, card meanings, and reflections into a single through-line. Read slowly, notice what resonates, and treat it as a mirror—not a script. Let your own sense of meaning carry as much weight as any description.</p>
                            </HelperToggle>
                            {userQuestion && (
                                <div className="bg-surface/85 rounded-lg px-3 xxs:px-4 py-3 mb-4 border border-secondary/40">
                                    <p className="text-accent/85 text-xs sm:text-sm italic">Anchor: {userQuestion}</p>
                                </div>
                            )}
                            {focusToggleAvailable && (
                                <div className="mt-4 flex justify-end">
                                    <button
                                        type="button"
                                        aria-pressed={isNarrativeFocus}
                                        onClick={() => setIsNarrativeFocus(prev => !prev)}
                                        className="inline-flex items-center gap-2 rounded-full border border-secondary/50 px-3 xxs:px-4 py-1.5 text-[0.7rem] xxs:text-xs font-semibold text-muted hover:text-main hover:border-secondary/70 transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary/60"
                                    >
                                        {isNarrativeFocus ? 'Show insight panels' : 'Focus on narrative'}
                                    </button>
                                </div>
                            )}
                            <StreamingNarrative
                                className="max-w-3xl mx-auto"
                                text={narrativeText}
                                useMarkdown={Boolean(personalReading?.hasMarkdown)}
                                isStreamingEnabled={shouldStreamNarrative}
                                autoNarrate={voiceOn && autoNarrate}
                                onNarrationStart={handleNarrationWrapper}
                                displayName={displayName}
                            />
                            <div className="flex flex-col items-center justify-center gap-2 sm:gap-3 mt-3 sm:mt-4">
                                {reading && personalReading && !isPersonalReadingError && (
                                    <div className="flex flex-wrap items-center justify-center gap-2 sm:gap-3">
                                        <button type="button" onClick={handleNarrationWrapper} className="px-3 sm:px-4 py-2 rounded-lg border border-secondary/40 bg-surface/85 hover:bg-surface/80 disabled:opacity-40 disabled:cursor-not-allowed transition focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2 focus-visible:ring-offset-main text-xs sm:text-sm" disabled={!fullReadingText || ttsState.status === 'loading'}>
                                            <span className="hidden xs:inline">{ttsState.status === 'loading' ? 'Preparing narration...' : ttsState.status === 'playing' ? 'Pause narration' : ttsState.status === 'paused' ? 'Resume narration' : 'Read this aloud'}</span>
                                            <span className="xs:hidden">{ttsState.status === 'loading' ? 'Loading...' : ttsState.status === 'playing' ? 'Pause' : ttsState.status === 'paused' ? 'Resume' : 'Play'}</span>
                                        </button>
                                        {(voiceOn && fullReadingText && (ttsState.status === 'playing' || ttsState.status === 'paused' || ttsState.status === 'loading')) && (
                                            <button type="button" onClick={handleNarrationStop} className="px-2 sm:px-3 py-2 rounded-lg border border-secondary/40 bg-surface/70 hover:bg-surface/80 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2 focus-visible:ring-offset-main transition disabled:opacity-40 disabled:cursor-not-allowed text-xs sm:text-sm">Stop</button>
                                        )}
                                        <button type="button" onClick={() => navigate('/journal')} className="px-3 sm:px-4 py-2 rounded-lg bg-primary/15 border border-primary/40 text-primary text-xs sm:text-sm hover:bg-primary/25 hover:text-primary transition">View Journal</button>
                                    </div>
                                )}
                                {showVoicePrompt && (
                                    <div className="text-xs text-muted bg-surface/70 border border-accent/30 rounded-lg px-3 py-2 text-center space-y-2" aria-live="polite">
                                        <p>Voice narration is disabled. Turn it on?</p>
                                        <div className="flex flex-wrap items-center justify-center gap-2">
                                            <button type="button" onClick={handleVoicePromptWrapper} className="px-3 py-1.5 rounded-full bg-primary/15 border border-primary/40 text-primary hover:bg-primary/30 text-xs">Enable voice & play</button>
                                            <button type="button" onClick={() => setShowVoicePrompt(false)} className="px-3 py-1.5 rounded-full border border-accent/50 text-muted hover:text-main text-xs">Maybe later</button>
                                        </div>
                                    </div>
                                )}
                                {journalStatus && <p role="status" aria-live="polite" className={`text-xs text-center max-w-sm ${journalStatus.type === 'success' ? 'text-success' : 'text-error'}`}>{journalStatus.message}</p>}
                            </div>
                        </div>
                    )}

                    {!personalReading && !isGenerating && (
                        <div className="bg-surface/95 backdrop-blur-xl rounded-2xl p-4 sm:p-6 border border-secondary/40 max-w-2xl mx-auto">
                            <h3 className="text-lg sm:text-xl font-serif text-accent mb-2 sm:mb-3 flex items-center gap-2"><Star className="w-4 h-4 sm:w-5 sm:h-5" />Interpretation Guidance</h3>
                            <HelperToggle className="mt-2" defaultOpen={isNewbie}>
                                <p>Notice how the cards speak to one another. Consider themes, repetitions, contrasts, and where your attention is drawn. Give as much weight to your own felt sense as you do to any written description.</p>
                                <p className="mt-2">This reading offers reflective guidance only. It is not a substitute for medical, mental health, legal, financial, or safety advice. If your situation involves health, legal risk, abuse, or crisis, consider reaching out to qualified professionals or trusted support services.</p>
                            </HelperToggle>
                        </div>
                    )}

                    {shouldShowSpreadInsights && (
                        <div className="w-full max-w-5xl mx-auto">
                            <SpreadPatterns
                                themes={themes}
                                spreadHighlights={highlightItems}
                                passages={readingMeta?.graphContext?.retrievedPassages}
                            />
                        </div>
                    )}

                    {personalReading && (
                        <div className="w-full max-w-2xl mx-auto">
                            <FeedbackPanel
                                requestId={readingMeta.requestId}
                                spreadKey={readingMeta.spreadKey || selectedSpread}
                                spreadName={readingMeta.spreadName || spreadInfo?.name}
                                deckStyle={readingMeta.deckStyle || deckStyleId}
                                provider={readingMeta.provider}
                                userQuestion={readingMeta.userQuestion || userQuestion}
                                cards={lastCardsForFeedback}
                                visionSummary={feedbackVisionSummary}
                            />
                        </div>
                    )}

                    <div className="hidden sm:block text-center mt-6 sm:mt-8">
                        <button
                            onClick={shuffle}
                            disabled={isShuffling}
                            aria-label={isShuffling ? 'Shuffling a new reading' : 'Start a new reading and reset this spread'}
                            className="bg-primary hover:bg-primary/90 disabled:opacity-50 disabled:cursor-not-allowed text-surface font-semibold px-6 sm:px-8 py-3 sm:py-4 rounded-lg shadow-lg transition-all inline-flex items-center gap-2 sm:gap-3 text-base sm:text-lg"
                        >
                            <ArrowCounterClockwise className={`w-4 h-4 sm:w-5 sm:h-5 ${isShuffling ? 'motion-safe:animate-spin' : ''}`} />
                            <span className="hidden xs:inline">{isShuffling ? 'Shuffling the cards...' : 'Draw new reading'}</span>
                            <span className="xs:hidden">{isShuffling ? 'Shuffling...' : 'Reset spread'}</span>
                        </button>
                    </div>
                </div>
            )}

            {!reading && !isShuffling && (
                <div className="text-center py-16 px-4">
                    <p className="text-muted text-lg font-serif">Focus on your question, then draw your cards when you&apos;re ready.</p>
                </div>
            )}

            <AnimatePresence>
                {selectedCardData && (
                    <CardModal
                        card={selectedCardData.card}
                        position={selectedCardData.position}
                        isOpen={!!selectedCardData}
                        onClose={() => setSelectedCardData(null)}
                        layoutId={`card-${selectedCardData.index}`}
                    />
                )}
            </AnimatePresence>
        </section>
    );
}
</file>

<file path="src/components/ReadingGrid.jsx">
import { useCallback, useEffect, useRef, useState } from 'react';
import { getSpreadInfo } from '../data/spreads';
import { getOrientationMeaning } from '../lib/cardLookup';
import { Card } from './Card';
import { Tooltip } from './Tooltip';
import { CarouselDots } from './CarouselDots';
import { SpreadTableCompact } from './SpreadTable';
import { useSmallScreen } from '../hooks/useSmallScreen';
import { useReducedMotion } from '../hooks/useReducedMotion';
import { useLandscape } from '../hooks/useLandscape';

/**
 * Celtic Cross position short labels for mobile context.
 * These are abbreviated versions of the full position names from spreads.js,
 * optimized for display in constrained mobile UI elements.
 */
// Celtic Cross position short labels for mobile context
const CELTIC_POSITION_LABELS = [
  'Present',
  'Challenge',
  'Past',
  'Future',
  'Above',
  'Below',
  'Advice',
  'External',
  'Hopes/Fears',
  'Outcome'
];

// Celtic Cross area class mapping by index (more reliable than string matching)
const CELTIC_AREA_CLASSES = [
  'cc-present',
  'cc-challenge',
  'cc-past',
  'cc-future',
  'cc-above',
  'cc-below',
  'cc-advice',
  'cc-external',
  'cc-hopesfears',
  'cc-outcome'
];

// Mini-map grid positions for Celtic Cross visualization
const CELTIC_MINIMAP_POSITIONS = [
  { x: 1, y: 1, label: '1' },   // Present (center)
  { x: 1, y: 1, label: '2', overlay: true }, // Challenge (crossing)
  { x: 0, y: 1, label: '3' },   // Past (left)
  { x: 2, y: 1, label: '4' },   // Future (right)
  { x: 1, y: 0, label: '5' },   // Above
  { x: 1, y: 2, label: '6' },   // Below
  { x: 3, y: 2, label: '7' },   // Advice (staff bottom)
  { x: 3, y: 1.5, label: '8' }, // External
  { x: 3, y: 1, label: '9' },   // Hopes/Fears
  { x: 3, y: 0.5, label: '10' } // Outcome (staff top)
];

// Grid dimensions for mini-map positioning
const MINIMAP_GRID_WIDTH = 3.5;
const MINIMAP_GRID_HEIGHT = 2.5;

// Mini-map showing Celtic Cross layout with current position highlighted
function CelticCrossMiniMap({ activeIndex, totalCards }) {
  return (
    <div className="flex items-center gap-3 px-4 py-2 bg-surface/80 backdrop-blur rounded-xl border border-secondary/30">
      {/* Mini grid visualization */}
      <div className="relative w-16 h-12 flex-shrink-0" aria-hidden="true">
        {CELTIC_MINIMAP_POSITIONS.slice(0, totalCards).map((pos, idx) => {
          // Build transform string - avoid compounding from className
          const transforms = ['translate(-50%, -50%)'];
          if (pos.overlay) {
            transforms.push('rotate(90deg)', 'scale(0.75)');
          } else if (idx === activeIndex) {
            transforms.push('scale(1.25)');
          }

          return (
            <div
              key={`minimap-pos-${idx}`}
              className={`absolute w-2.5 h-3.5 rounded-sm transition-all duration-200 ${
                idx === activeIndex
                  ? 'bg-primary shadow-md shadow-primary/50'
                  : 'bg-secondary/40'
              }`}
              style={{
                left: `${(pos.x / MINIMAP_GRID_WIDTH) * 100}%`,
                top: `${(pos.y / MINIMAP_GRID_HEIGHT) * 100}%`,
                transform: transforms.join(' ')
              }}
            />
          );
        })}
      </div>

      {/* Current position label */}
      <div className="flex-1 min-w-0">
        <p className="text-xs text-muted truncate">Position {activeIndex + 1} of {totalCards}</p>
        <p className="text-sm font-semibold text-accent truncate">
          {CELTIC_POSITION_LABELS[activeIndex] || `Card ${activeIndex + 1}`}
        </p>
      </div>
    </div>
  );
}

// Position dots wrapper that provides Celtic Cross position labels
function PositionDotsWrapper({ activeIndex, totalCards, spreadKey, onSelectPosition }) {
  const isCeltic = spreadKey === 'celtic';
  const labels = isCeltic
    ? CELTIC_POSITION_LABELS.slice(0, totalCards)
    : Array.from({ length: totalCards }, (_, i) => `Position ${i + 1}`);

  return (
    <CarouselDots
      activeIndex={activeIndex}
      totalItems={totalCards}
      onSelectItem={onSelectPosition}
      labels={labels}
      ariaLabel="Card positions"
    />
  );
}

function getAreaClass(index, selectedSpread) {
  if (selectedSpread !== 'celtic') return '';
  return CELTIC_AREA_CLASSES[index] || 'cc-present';
}

export function ReadingGrid({
  selectedSpread,
  reading,
  revealedCards,
  revealCard,
  reflections,
  setReflections,
  onCardClick
}) {
  const carouselRef = useRef(null);
  const cardsRef = useRef([]);
  const rafIdRef = useRef(null);
  const [activeIndex, setActiveIndex] = useState(0);
  const [showSwipeHint, setShowSwipeHint] = useState(true);
  const [mobileLayoutMode, setMobileLayoutMode] = useState('carousel');
  // User's preferred layout mode (persists when switching between mobile/desktop)
  const [layoutPreference, setLayoutPreference] = useState('carousel');
  const isCompactScreen = useSmallScreen();
  const isVerySmallScreen = useSmallScreen(480);
  const prefersReducedMotion = useReducedMotion();
  const isLandscape = useLandscape();
  const isListView = mobileLayoutMode === 'list';
  const shouldUseGridOnMobile = Boolean(
    isCompactScreen &&
    !isListView &&
    selectedSpread !== 'celtic' &&
    reading?.length &&
    reading.length <= 3
  );

  // Track previous isCompactScreen for render-time state adjustment
  const [prevIsCompactScreen, setPrevIsCompactScreen] = useState(isCompactScreen);

  // In landscape mobile: use smaller card widths to fit more cards visible
  const carouselCardWidthClass = isLandscape
    ? 'min-w-[44vw] max-w-[11.5rem]'
    : isVerySmallScreen
      ? 'min-w-[82vw] max-w-[17.5rem]'
      : 'min-w-[72vw] xxs:min-w-[66vw] xs:min-w-[60vw] max-w-[18.5rem]';
  const mobileCarouselPadding = isLandscape ? 'px-2' : 'px-3 xxs:px-4';

  // Hide swipe hint after 4 seconds or when user interacts
  useEffect(() => {
    if (!reading || reading.length <= 1 || isListView) return undefined;

    const timer = setTimeout(() => {
      setShowSwipeHint(false);
    }, 4000);

    return () => clearTimeout(timer);
  }, [reading, isListView]);

  // Sync mobile layout mode with screen size changes.
  // This pattern (adjusting state during render) is React-recommended over useEffect
  // for syncing state with prop/hook changes. See: https://react.dev/learn/you-might-not-need-an-effect
  if (isCompactScreen !== prevIsCompactScreen) {
    setPrevIsCompactScreen(isCompactScreen);
    if (!isCompactScreen) {
      // Desktop: always use carousel
      if (mobileLayoutMode !== 'carousel') {
        setMobileLayoutMode('carousel');
      }
    } else {
      // Mobile: restore user's preferred layout
      if (layoutPreference !== mobileLayoutMode) {
        setMobileLayoutMode(layoutPreference);
      }
    }
  }

  useEffect(() => {
    if (!isCompactScreen) return;
    const manyCards = reading?.length > 4;
    if ((isVerySmallScreen || manyCards) && layoutPreference === 'carousel' && mobileLayoutMode === 'carousel') {
      setLayoutPreference('list');
      setMobileLayoutMode('list');
    }
  }, [isCompactScreen, isVerySmallScreen, reading?.length, layoutPreference, mobileLayoutMode]);

  // Celtic Cross uses a fixed CSS grid layout that doesn't scroll horizontally,
  // so carousel navigation (swipe, dots, prev/next) should be disabled for it
  const enableCarousel = reading?.length > 1 && !isListView && selectedSpread !== 'celtic' && !shouldUseGridOnMobile;

  // Hide hint when user scrolls
  const hideHintOnInteraction = useCallback(() => {
    setShowSwipeHint(false);
  }, []);

  // Optimized scroll handler with RAF throttling and cached elements
  const updateActiveIndex = useCallback(() => {
    const el = carouselRef.current;
    if (!el) return;

    const cards = cardsRef.current;
    if (cards.length === 0) return;

    // Find the card whose center is closest to the viewport center
    const viewportCenter = el.scrollLeft + el.clientWidth / 2;
    let closestIndex = 0;
    let closestDistance = Infinity;

    for (let idx = 0; idx < cards.length; idx++) {
      const card = cards[idx];
      if (!card) continue;
      const cardCenter = card.offsetLeft + card.offsetWidth / 2;
      const distance = Math.abs(viewportCenter - cardCenter);
      if (distance < closestDistance) {
        closestDistance = distance;
        closestIndex = idx;
      }
    }

    // Only update if index changed to prevent unnecessary re-renders
    setActiveIndex(prev => prev === closestIndex ? prev : closestIndex);
  }, []);

  useEffect(() => {
    if (!enableCarousel) return undefined;
    const el = carouselRef.current;
    if (!el) return undefined;

    // Cache card elements
    cardsRef.current = Array.from(el.children);

    const handleScroll = () => {
      // Hide swipe hint on first scroll interaction
      hideHintOnInteraction();

      // Throttle with RAF
      if (rafIdRef.current) return;
      rafIdRef.current = requestAnimationFrame(() => {
        rafIdRef.current = null;
        updateActiveIndex();
      });
    };

    // Initial calculation - schedule via RAF to avoid synchronous setState in effect
    rafIdRef.current = requestAnimationFrame(() => {
      rafIdRef.current = null;
      updateActiveIndex();
    });

    el.addEventListener('scroll', handleScroll, { passive: true });

    return () => {
      el.removeEventListener('scroll', handleScroll);
      if (rafIdRef.current) {
        cancelAnimationFrame(rafIdRef.current);
        rafIdRef.current = null;
      }
    };
  }, [enableCarousel, reading?.length, updateActiveIndex, hideHintOnInteraction]);

  const scrollToIndex = useCallback((index) => {
    if (!enableCarousel || !reading) return;
    const el = carouselRef.current;
    if (!el) return;

    const clamped = Math.min(reading.length - 1, Math.max(0, index));
    setActiveIndex(clamped);

    // Scroll to center the target card in the viewport
    const cards = cardsRef.current;
    const targetCard = cards[clamped];
    if (targetCard) {
      const cardCenter = targetCard.offsetLeft + targetCard.offsetWidth / 2;
      const scrollTarget = cardCenter - el.clientWidth / 2;
      el.scrollTo({
        left: Math.max(0, scrollTarget),
        behavior: prefersReducedMotion ? 'auto' : 'smooth'
      });
    }
  }, [enableCarousel, reading, prefersReducedMotion]);

  const handleLayoutToggle = useCallback((mode) => {
    setLayoutPreference(mode);
    setMobileLayoutMode(mode);
    if (mode === 'list') {
      setShowSwipeHint(false);
    } else if (reading?.length > 1) {
      setShowSwipeHint(true);
    }
  }, [reading?.length]);

  const getCardTakeaway = useCallback((card) => {
    const meaning = getOrientationMeaning(card);
    if (!meaning) return '';
    const firstClause = meaning.split(/[.;]| — | – | - /)[0];
    const text = firstClause.trim();
    if (text.length <= 72) return text;
    return `${text.slice(0, 72).trimEnd()}…`;
  }, []);

  // Memoize tooltip content generator
  const getTooltipContent = useCallback((card, position, isRevealed) => {
    if (!isRevealed) return null;
    const takeaway = getCardTakeaway(card);
    return (
      <div className="space-y-1 text-left leading-snug">
        <strong className="block text-accent text-sm">{position}</strong>
        <p className="text-xs-plus text-muted">
          {card.name}{card.isReversed ? ' (Reversed)' : ''}
        </p>
        <p className="text-xs-plus text-main/90">{takeaway || 'Card revealed'}</p>
      </div>
    );
  }, [getCardTakeaway]);

  // Early return after all hooks to satisfy Rules of Hooks
  if (!reading) return null;

  const spreadInfo = getSpreadInfo(selectedSpread);
  const isBatchReveal = reading.length > 1 && revealedCards.size === reading.length;

  const responsiveGridFallback = reading.length <= 4
    ? 'sm:grid sm:gap-8 sm:overflow-visible sm:snap-none sm:pb-0 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-4'
    : 'sm:grid sm:gap-8 sm:overflow-visible sm:snap-none sm:pb-0 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-3';

  const multiCardLayoutClass = isListView
    ? 'flex flex-col gap-4 pb-6 sm:pb-4'
    : `flex overflow-x-auto snap-x snap-mandatory scrollbar-none ${isLandscape ? 'gap-2 pb-5' : 'gap-3 pb-8'} ${mobileCarouselPadding}`;

  const shouldApplyCarouselPadding = enableCarousel && !isListView && selectedSpread !== 'celtic';
  const shouldShowCompactMap = Boolean(isCompactScreen && reading && reading.length > 2);
  const carouselInlineStyles = shouldApplyCarouselPadding
    ? {
        scrollPaddingLeft: 'max(1.25rem, env(safe-area-inset-left, 1rem))',
        scrollPaddingRight: 'max(1.25rem, env(safe-area-inset-right, 1rem))',
        scrollbarGutter: 'stable both-edges'
      }
    : undefined;

  return (
    <>
      {enableCarousel && showSwipeHint && (
        <p className="sm:hidden text-center text-xs text-primary/70 mb-2 animate-pulse">
          Swipe to explore cards &rarr;
        </p>
      )}
      <div
        className={
          selectedSpread === 'celtic'
            ? 'cc-grid animate-fade-in'
            : shouldUseGridOnMobile
              ? 'animate-fade-in grid grid-cols-1 xxs:grid-cols-2 gap-3 xs:gap-4'
              : `animate-fade-in ${reading.length === 1
                ? 'grid grid-cols-1 max-w-md mx-auto'
                : `${multiCardLayoutClass} ${responsiveGridFallback}`
              }`
        }
        style={selectedSpread === 'celtic' ? undefined : carouselInlineStyles}
        ref={enableCarousel ? carouselRef : null}
      >
        {reading.map((card, index) => {
          const position = spreadInfo?.positions?.[index] || `Position ${index + 1}`;
          const isRevealed = revealedCards.has(index);
          const tooltipContent = getTooltipContent(card, position, isRevealed);

          const cardElement = (
            <Card
              card={card}
              index={index}
              isRevealed={isRevealed}
              onReveal={revealCard}
              position={position}
              reflections={reflections}
              setReflections={setReflections}
              onCardClick={onCardClick}
              staggerDelay={isBatchReveal ? index * 0.15 : 0}
            />
          );

          return (
            <div
              key={`${card.name}-${index}`}
              className={`${selectedSpread === 'celtic'
                ? getAreaClass(index, selectedSpread)
                : reading.length > 1 ? (isListView ? 'w-full sm:min-w-0' : `${carouselCardWidthClass} snap-center sm:min-w-0`) : ''
                }`}
            >
              <Tooltip
                content={tooltipContent}
                position="top"
                asChild
                enableClick={false}
                autoHideMs={null}
                triggerClassName="block h-full"
              >
                {cardElement}
              </Tooltip>
            </div>
          );
        })}
      </div>
      {reading.length > 1 && (
        <div className={`sm:hidden ${isLandscape ? 'mt-2 space-y-2' : 'mt-3 space-y-3'}`}>
          {/* Layout toggle - hide in landscape to save space */}
          {!isLandscape && (
            <div className="flex items-center justify-center gap-2" role="group" aria-label="Change mobile layout">
              <button
                type="button"
                aria-pressed={!isListView}
                onClick={() => handleLayoutToggle('carousel')}
                className={`flex-1 rounded-full border px-3 py-2 text-xs font-semibold ${isListView ? 'border-secondary/40 text-muted' : 'border-primary/60 bg-primary/10 text-primary'}`}
              >
                Swipe view
              </button>
              <button
                type="button"
                aria-pressed={isListView}
                onClick={() => handleLayoutToggle('list')}
                className={`flex-1 rounded-full border px-3 py-2 text-xs font-semibold ${isListView ? 'border-primary/60 bg-primary/10 text-primary' : 'border-secondary/40 text-muted'}`}
              >
                List view
              </button>
            </div>
          )}

          {shouldShowCompactMap && (
            <SpreadTableCompact
              spreadKey={selectedSpread}
              cards={reading}
              revealedIndices={revealedCards}
            />
          )}

          {enableCarousel && (
            <>
              {/* Celtic Cross mini-map - more compact in landscape */}
              {selectedSpread === 'celtic' && !isLandscape && (
                <CelticCrossMiniMap activeIndex={activeIndex} totalCards={reading.length} />
              )}

              <PositionDotsWrapper
                activeIndex={activeIndex}
                totalCards={reading.length}
                spreadKey={selectedSpread}
                onSelectPosition={scrollToIndex}
              />

              <div className="flex items-center justify-between gap-2">
                <button
                  type="button"
                  onClick={() => scrollToIndex(activeIndex - 1)}
                  disabled={activeIndex === 0}
                  className={`inline-flex items-center justify-center rounded-full border border-secondary/50 bg-surface ${isLandscape ? 'px-2 py-1 min-w-[44px] min-h-[44px]' : 'px-3 py-2 min-w-[48px] min-h-[44px]'} text-xs font-semibold text-muted disabled:opacity-40 touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary`}
                  aria-label="Show previous card"
                >
                  {isLandscape ? '←' : 'Prev'}
                </button>
                <p className="text-xs text-muted" aria-live="polite">
                  {selectedSpread === 'celtic'
                    ? CELTIC_POSITION_LABELS[activeIndex]
                    : `${activeIndex + 1}/${reading.length}`}
                </p>
                <button
                  type="button"
                  onClick={() => scrollToIndex(activeIndex + 1)}
                  disabled={activeIndex >= reading.length - 1}
                  className={`inline-flex items-center justify-center rounded-full border border-secondary/50 bg-surface ${isLandscape ? 'px-2 py-1 min-w-[44px] min-h-[44px]' : 'px-3 py-2 min-w-[48px] min-h-[44px]'} text-xs font-semibold text-muted disabled:opacity-40 touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary`}
                  aria-label="Show next card"
                >
                  {isLandscape ? '→' : 'Next'}
                </button>
              </div>
            </>
          )}
        </div>
      )}
    </>
  );
}
</file>

<file path="src/components/ReadingPreparation.jsx">
import { useState, useCallback, useRef } from 'react';
import { CaretDown, CaretUp, TextAlignLeft, SpeakerHigh, Palette, Sparkle } from '@phosphor-icons/react';
import { QuestionInput } from './QuestionInput';
import { AudioControls } from './AudioControls';
import { ExperienceSettings } from './ExperienceSettings';
import { CoachSuggestion } from './CoachSuggestion';
import { RitualControls } from './RitualControls';

// Mobile tab configuration
const MOBILE_TABS = [
    { id: 'intention', label: 'Intent', icon: TextAlignLeft },
    { id: 'audio', label: 'Audio', icon: SpeakerHigh },
    { id: 'experience', label: 'Theme', icon: Palette },
    { id: 'ritual', label: 'Ritual', icon: Sparkle }
];

export function ReadingPreparation({
    variant = 'desktop',
    // State & Setters
    userQuestion,
    setUserQuestion,
    placeholderIndex,
    onPlaceholderRefresh,

    // Coach
    coachRecommendation,
    applyCoachRecommendation,
    dismissCoachRecommendation,
    onLaunchCoach,

    // UI State
    prepareSectionsOpen,
    togglePrepareSection,
    prepareSummaries,
    prepareSectionLabels,

    // Ritual Props
    hasKnocked,
    handleKnock,
    cutIndex,
    setCutIndex,
    hasCut,
    applyCut,
    knockCount,
    onSkipRitual,
    deckAnnouncement,
    sectionRef,
    shouldSkipRitual = false
}) {
    const mobileTabs = shouldSkipRitual
        ? MOBILE_TABS.filter(tab => tab.id !== 'ritual')
        : MOBILE_TABS;
    const sectionOrder = shouldSkipRitual
        ? ['audio', 'experience']
        : ['audio', 'experience', 'ritual'];

    const renderSectionContent = (section) => {
        if (section === 'intention') {
            return (
                <>
                    <QuestionInput
                        userQuestion={userQuestion}
                        setUserQuestion={setUserQuestion}
                        placeholderIndex={placeholderIndex}
                        onPlaceholderRefresh={onPlaceholderRefresh}
                        onLaunchCoach={onLaunchCoach}
                    />
                    <CoachSuggestion
                        recommendation={coachRecommendation}
                        onApply={applyCoachRecommendation}
                        onDismiss={dismissCoachRecommendation}
                        showTitle={false}
                    />
                </>
            );
        }
        if (section === 'audio') {
            return <AudioControls />;
        }
        if (section === 'experience') {
            return <ExperienceSettings />;
        }
        if (section === 'ritual') {
            if (shouldSkipRitual) {
                return (
                    <p className="text-sm text-muted">
                        Ritual steps are hidden based on your personalization preferences.
                    </p>
                );
            }
            return (
                <RitualControls
                    hasKnocked={hasKnocked}
                    handleKnock={handleKnock}
                    cutIndex={cutIndex}
                    setCutIndex={setCutIndex}
                    hasCut={hasCut}
                    applyCut={applyCut}
                    knockCount={knockCount}
                    onSkip={onSkipRitual}
                    deckAnnouncement={deckAnnouncement}
                />
            );
        }
        return null;
    };

    // Mobile tabbed navigation state
    const [activeTabRaw, setActiveTabRaw] = useState('intention');
    const tabRefs = useRef({});

    // Derive the effective active tab - if ritual is skipped and ritual was selected, fall back to intention
    const activeTab = (shouldSkipRitual && activeTabRaw === 'ritual') ? 'intention' : activeTabRaw;

    const handleTabChange = useCallback((tabId) => {
        setActiveTabRaw(tabId);
    }, []);

    // Keyboard navigation for tabs (roving tabindex pattern)
    const handleTabKeyDown = useCallback((event, currentIndex) => {
        const tabIds = mobileTabs.map(t => t.id);
        let nextIndex = currentIndex;

        switch (event.key) {
            case 'ArrowLeft':
                event.preventDefault();
                nextIndex = currentIndex === 0 ? tabIds.length - 1 : currentIndex - 1;
                break;
            case 'ArrowRight':
                event.preventDefault();
                nextIndex = currentIndex === tabIds.length - 1 ? 0 : currentIndex + 1;
                break;
            case 'Home':
                event.preventDefault();
                nextIndex = 0;
                break;
            case 'End':
                event.preventDefault();
                nextIndex = tabIds.length - 1;
                break;
            default:
                return;
        }

        const nextTabId = tabIds[nextIndex];
        setActiveTabRaw(nextTabId);
        tabRefs.current[nextTabId]?.focus();
    }, [mobileTabs]);

    if (variant === 'mobile') {
        return (
            <div className="space-y-4">
                {/* Segmented tab control */}
                <div
                    className="flex bg-surface-muted/60 rounded-xl p-1 border border-secondary/20"
                    role="tablist"
                    aria-label="Preparation settings"
                >
                    {mobileTabs.map((tab, index) => {
                        const Icon = tab.icon;
                        const isActive = activeTab === tab.id;
                        return (
                            <button
                                key={tab.id}
                                ref={(el) => { tabRefs.current[tab.id] = el; }}
                                type="button"
                                role="tab"
                                id={`mobile-tab-${tab.id}`}
                                aria-selected={isActive}
                                aria-controls={`mobile-panel-${tab.id}`}
                                tabIndex={isActive ? 0 : -1}
                                onClick={() => handleTabChange(tab.id)}
                                onKeyDown={(e) => handleTabKeyDown(e, index)}
                                className={`
                                    flex-1 flex flex-col items-center justify-center gap-1 py-2.5 px-1 rounded-lg
                                    text-xs font-semibold transition-all touch-manipulation
                                    focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/70
                                    ${isActive
                                        ? 'bg-surface shadow-sm border border-secondary/30 text-accent'
                                        : 'text-muted hover:text-main'
                                    }
                                `}
                            >
                                <Icon className={`w-4 h-4 ${isActive ? 'text-secondary' : ''}`} weight={isActive ? 'fill' : 'regular'} />
                                <span className="truncate">{tab.label}</span>
                            </button>
                        );
                    })}
                </div>

                {/* Tab panel content */}
                {mobileTabs.map((tab) => (
                    <div
                        key={tab.id}
                        id={`mobile-panel-${tab.id}`}
                        role="tabpanel"
                        aria-labelledby={`mobile-tab-${tab.id}`}
                        hidden={activeTab !== tab.id}
                        className={activeTab === tab.id ? 'animate-fade-in' : ''}
                    >
                        {activeTab === tab.id && (
                            <div className="rounded-2xl border border-secondary/20 bg-surface/40 p-4">
                                {renderSectionContent(tab.id)}
                            </div>
                        )}
                    </div>
                ))}
            </div>
        );
    }

    return (
        <section
            ref={sectionRef}
            aria-label="Prepare your reading"
            id="step-intention"
            className="hidden sm:block prepare-reading-panel deck-selector-panel animate-fade-in scroll-mt-[6.5rem] sm:scroll-mt-[7.5rem]"
        >
            <div className="relative z-10 space-y-5">
                <header className="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
                    <div>
                        <p className="text-[0.68rem] uppercase tracking-[0.22em] text-gold-soft">Prepare Your Reading</p>
                        <p className="text-xs text-muted max-w-2xl">
                            Capture an intention, tune experience controls, and complete the ritual setup inside one textured command center.
                        </p>
                    </div>
                    <div className="hidden sm:flex items-center gap-2 rounded-full border border-gold-soft/50 bg-black/30 px-3 py-1 text-[0.7rem] text-accent backdrop-blur">
                        <span className="w-1.5 h-1.5 rounded-full bg-gold-soft animate-pulse" aria-hidden="true" />
                        <span>All-in-one prep</span>
                    </div>
                </header>

                <div className="prepare-summary-chip">
                    <span>{prepareSummaries.intention}</span>
                    <span aria-hidden="true">·</span>
                    <span>{prepareSummaries.experience}</span>
                    {!shouldSkipRitual && (
                        <>
                            <span aria-hidden="true">·</span>
                            <span>{prepareSummaries.ritual}</span>
                        </>
                    )}
                </div>

                <div className="space-y-4">
                    <div className="prepare-card">
                        <div className="prepare-card__header">
                            <div>
                                <p className="font-serif text-accent text-base leading-tight">Intention</p>
                                <p className="text-xs text-muted">Set your guiding prompt before you draw — always available without expanding a panel.</p>
                            </div>
                            <span className="prepare-card__badge">Inline</span>
                        </div>
                        <div className="prepare-card__body">
                            {renderSectionContent('intention')}
                        </div>
                    </div>

                    {sectionOrder.map(section => (
                        <div key={section} className={`prepare-card ${prepareSectionsOpen[section] ? 'prepare-card--open' : ''}`}>
                            <button
                                type="button"
                                onClick={() => togglePrepareSection(section)}
                                className="prepare-card__toggle"
                                aria-expanded={prepareSectionsOpen[section]}
                            >
                                <div>
                                    <p className="font-serif text-accent text-base leading-tight">
                                        {prepareSectionLabels[section]?.title || (section === 'audio' ? 'Audio' : section.charAt(0).toUpperCase() + section.slice(1))}
                                    </p>
                                    <p className="text-xs text-muted">
                                        {prepareSummaries[section] || (section === 'audio' ? 'Voice narration and ambience settings' : '')}
                                    </p>
                                </div>
                                {prepareSectionsOpen[section]
                                    ? <CaretUp className="w-4 h-4 text-accent" />
                                    : <CaretDown className="w-4 h-4 text-accent" />}
                            </button>
                            {prepareSectionsOpen[section] && (
                                <div className="prepare-card__content">
                                    {renderSectionContent(section)}
                                </div>
                            )}
                        </div>
                    ))}
                </div>

                <div className="deck-panel-footnote prepare-panel-footnote">
                    <p className="text-[0.72rem] leading-relaxed text-muted">
                        <strong className="text-accent">Tip:</strong> Keep these steps updated before drawing to help the AI align narration tone, audio, and ritual cues.
                    </p>
                </div>
            </div>
        </section>
    );
}
</file>

<file path="src/components/RitualControls.jsx">
import { useEffect, useRef, useState } from 'react';
import { Info, Sparkle, Scissors } from '@phosphor-icons/react';
import { Tooltip } from './Tooltip';
import { usePreferences } from '../contexts/PreferencesContext';

export function RitualControls({
  hasKnocked,
  handleKnock,
  cutIndex,
  setCutIndex,
  hasCut,
  applyCut,
  knockCount = 0,
  onSkip,
  deckAnnouncement
}) {
  const { deckSize, personalization } = usePreferences();
  const [showSkipConfirm, setShowSkipConfirm] = useState(false);
  const skipPromptRef = useRef(null);
  const knockComplete = knockCount >= 3;
  const nextKnockNumber = Math.min(knockCount + 1, 3);
  const sliderMax = Math.max(0, (deckSize ?? 22) - 1);
  const ritualStatus = knockComplete && hasCut ? 'Ready' : hasKnocked || hasCut ? 'In flow' : 'Optional';
  const isExperienced = personalization?.tarotExperience === 'experienced';
  const isNewbie = personalization?.tarotExperience === 'newbie';

  const controlShellClass =
    'rounded-[1.75rem] border border-secondary/40 bg-surface/75 p-3 sm:p-4 shadow-lg shadow-secondary/20 backdrop-blur-xl space-y-4';
  const tileBaseClass =
    'flex flex-col gap-3 rounded-2xl border border-secondary/15 bg-surface/70 p-3 sm:p-4 transition-all duration-200 hover:-translate-y-0.5 hover:border-accent/60 hover:shadow-lg hover:shadow-accent/10';
  const activeTileClass = 'border-secondary/60 bg-secondary/5 shadow-lg shadow-secondary/35';
  const iconWrapperBase =
    'flex h-9 w-9 flex-shrink-0 items-center justify-center rounded-2xl border text-secondary transition-all duration-200';
  const activeIconWrapper =
    'border-secondary/60 bg-secondary/20 text-secondary shadow-lg shadow-secondary/20';
  const inactiveIconWrapper = 'border-accent/20 bg-surface/80 text-muted';
  const badgeBaseClass =
    'inline-flex items-center gap-1 rounded-full border px-2.5 py-0.5 text-xs font-semibold uppercase tracking-wider transition-all duration-200';
  const activeBadgeClass =
    'border-secondary/70 bg-secondary/20 text-secondary shadow-lg shadow-secondary/20';
  const inactiveBadgeClass = 'border-accent/20 bg-surface-muted/80 text-muted';
  // Info button - subtle icon, 44px touch target but no visible border
  const infoButtonClass =
    'inline-flex min-w-[44px] min-h-[44px] items-center justify-center rounded-full text-muted/60 transition hover:text-accent focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60 touch-manipulation -ml-2 -mr-3';
  const primaryButtonBase =
    'flex w-full items-center justify-between rounded-2xl border px-4 py-2.5 text-sm font-semibold transition-all duration-200';
  const primaryButtonActive = 'border-secondary/60 bg-secondary/15 text-secondary shadow-lg shadow-secondary/20';
  const primaryButtonIdle = 'border-accent/20 bg-surface/60 text-main/90 hover:border-accent/60 hover:text-main';
  const sliderWrapClass = 'rounded-2xl border border-accent/20 bg-surface/60 px-3 py-2.5';

  const confirmSkip = () => {
    setShowSkipConfirm(false);
    onSkip?.();
  };

  useEffect(() => {
    if (!showSkipConfirm) return;
    const handlePointer = event => {
      if (!skipPromptRef.current) return;
      if (!skipPromptRef.current.contains(event.target)) {
        setShowSkipConfirm(false);
      }
    };
    const handleKey = event => {
      if (event.key === 'Escape') {
        setShowSkipConfirm(false);
      }
    };
    document.addEventListener('pointerdown', handlePointer);
    document.addEventListener('keydown', handleKey);
    return () => {
      document.removeEventListener('pointerdown', handlePointer);
      document.removeEventListener('keydown', handleKey);
    };
  }, [showSkipConfirm]);

  return (
    <div className={`${controlShellClass} animate-fade-in`}>
      {/* Desktop Header - Hidden on Mobile */}
      <div className="hidden sm:flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
        <div>
          <p className="text-[0.78rem] uppercase tracking-[0.35em] text-secondary/80">Ritual</p>
          {!isExperienced && (
            <p className="text-sm text-muted">A grounding moment before the draw.</p>
          )}
        </div>
        <span
          className={`${badgeBaseClass} ${ritualStatus === 'Ready' ? activeBadgeClass : inactiveBadgeClass
            }`}
        >
          {ritualStatus}
        </span>
      </div>

      {/* Mobile Header */}
      <div className="sm:hidden flex items-center justify-between mb-4">
        <h3 className="text-lg font-serif text-accent">Ritual</h3>
        <span className={`${badgeBaseClass} ${ritualStatus === 'Ready' ? activeBadgeClass : inactiveBadgeClass}`}>
          {ritualStatus}
        </span>
      </div>

      {/* Desktop Grid - Hidden on Mobile */}
      <div className="hidden sm:grid grid-cols-1 gap-3 lg:grid-cols-2">
        <div className={`${tileBaseClass} ${knockComplete ? activeTileClass : ''}`}>
          <div className="flex items-center gap-2">
            <span
              className={`${iconWrapperBase} ${knockComplete ? activeIconWrapper : inactiveIconWrapper
                }`}
              aria-hidden="true"
            >
              <Sparkle className="h-4 w-4" />
            </span>
            <div className="flex flex-1 items-center gap-1.5 text-[0.85rem] normal-case tracking-normal">
              <span className="font-semibold text-main">Clear the deck</span>
              <Tooltip
                content="Clear deck energy"
                position="top"
                triggerClassName={infoButtonClass}
                ariaLabel="About clearing the deck ritual"
              >
                <Info className="h-3.5 w-3.5" />
              </Tooltip>
            </div>
            <span
              className={`${badgeBaseClass} ${knockComplete ? activeBadgeClass : inactiveBadgeClass
                }`}
            >
              {knockComplete ? 'Cleared' : `${knockCount}/3`}
            </span>
          </div>
          <button
            type="button"
            onClick={handleKnock}
            className={`${primaryButtonBase} ${knockComplete ? primaryButtonActive : primaryButtonIdle
              }`}
            aria-pressed={knockCount > 0}
            title="Knock up to 3 times"
          >
            <span>{knockComplete ? 'Deck cleared · 3 of 3' : `Knock ${nextKnockNumber} of 3`}</span>
            {!knockComplete && (
              <span className="text-[0.65rem] uppercase tracking-[0.2em] text-accent/80">Tap</span>
            )}
          </button>
          {!isExperienced && (
            <p className="text-sm text-muted">
              Ritual progress: <span className="font-semibold text-secondary">{knockCount}</span>/3 knocks registered.
            </p>
          )}
        </div>

        <div className={`${tileBaseClass} ${hasCut ? activeTileClass : ''}`}>
          <div className="flex items-center gap-2">
            <span
              className={`${iconWrapperBase} ${hasCut ? activeIconWrapper : inactiveIconWrapper}`}
              aria-hidden="true"
            >
              <Scissors className="h-4 w-4" />
            </span>
            <div className="flex flex-1 items-center gap-1.5 text-[0.85rem] normal-case tracking-normal">
              <span className="font-semibold text-main">Cut the deck</span>
              <Tooltip
                content="Choose cut position"
                position="top"
                triggerClassName={infoButtonClass}
                ariaLabel="About cutting the deck"
              >
                <Info className="h-3.5 w-3.5" />
              </Tooltip>
            </div>
            <span
              className={`${badgeBaseClass} ${hasCut ? activeBadgeClass : inactiveBadgeClass}`}
            >
              {hasCut ? 'Locked' : `Cut #${cutIndex}`}
            </span>
          </div>
          <div className={sliderWrapClass}>
            <label htmlFor="cut-range" className="sr-only">
              Choose where to cut the deck
            </label>
            <input
              id="cut-range"
              type="range"
              min={0}
              max={sliderMax}
              value={cutIndex}
              onChange={event => setCutIndex(parseInt(event.target.value, 10))}
              className="w-full cursor-pointer appearance-none"
              aria-label="Cut position"
              aria-valuetext={`Cut position ${cutIndex} of ${deckSize}`}
              style={{ accentColor: 'var(--brand-accent)' }}
            />
            <div className="mt-1 flex items-center justify-between text-[0.7rem] text-muted">
              <span>0</span>
              <span className="font-semibold text-secondary">Cut #{cutIndex}</span>
              <span>{sliderMax}</span>
            </div>
          </div>
          <button
            type="button"
            onClick={applyCut}
            className={`${primaryButtonBase} ${hasCut ? primaryButtonActive : primaryButtonIdle}`}
            aria-pressed={hasCut}
          >
            <span>{hasCut ? 'Cut confirmed' : 'Confirm cut'}</span>
            <span className="text-[0.65rem] uppercase tracking-[0.2em] text-accent/80">
              {hasCut ? 'Locked' : 'Lock'}
            </span>
          </button>
          {!isExperienced && (
            <p className="text-sm text-muted">
              Cut at <span className="font-semibold text-secondary">{cutIndex}</span> of {deckSize}.{' '}
              {hasCut ? <span className="text-secondary">Cut locked in.</span> : 'Adjust until it feels right.'}
            </p>
          )}
        </div>
      </div>

      {/* Mobile Touch Controls */}
      <div className="sm:hidden space-y-4">
        <div className="grid grid-cols-2 gap-4">
          {/* Knock Button */}
          <button
            type="button"
            onClick={handleKnock}
            className={`aspect-square rounded-2xl border flex flex-col items-center justify-center gap-2 transition-all active:scale-95 touch-manipulation ${knockComplete
              ? 'bg-secondary/20 border-secondary/60 text-secondary'
              : 'bg-surface-muted/60 border-accent/20 text-main'
              }`}
            aria-label={knockComplete ? 'Deck cleared with 3 knocks' : `Knock ${nextKnockNumber} of 3`}
          >
            <Sparkle className={`w-8 h-8 ${knockComplete ? 'text-secondary' : 'text-accent'}`} />
            <span className="text-sm font-semibold">{knockComplete ? 'Cleared' : 'Knock'}</span>
            <span className="text-xs opacity-70">{knockCount}/3</span>
          </button>

          {/* Cut Button */}
          <button
            type="button"
            onClick={applyCut}
            className={`aspect-square rounded-2xl border flex flex-col items-center justify-center gap-2 transition-all active:scale-95 touch-manipulation ${hasCut
              ? 'bg-secondary/20 border-secondary/60 text-secondary'
              : 'bg-surface-muted/60 border-accent/20 text-main'
              }`}
            aria-pressed={hasCut}
            aria-label={hasCut ? `Relock cut at position ${cutIndex}` : `Lock cut at position ${cutIndex}`}
          >
            <Scissors className={`w-8 h-8 ${hasCut ? 'text-secondary' : 'text-accent'}`} />
            <span className="text-sm font-semibold">{hasCut ? 'Relock' : 'Lock'}</span>
            <span className="text-xs opacity-70">{hasCut ? 'Adjust or relock anytime' : `Cut #${cutIndex}`}</span>
          </button>
        </div>

        {/* Mobile Cut Position Slider */}
        <div className="rounded-2xl border border-accent/20 bg-surface/60 px-4 py-3">
          <div className="flex items-center justify-between mb-2">
            <label htmlFor="mobile-cut-range" className="text-xs text-muted">
              Slide to choose cut position
            </label>
            <span className="text-sm font-semibold text-secondary">#{cutIndex}</span>
          </div>
          <input
            id="mobile-cut-range"
            type="range"
            min={0}
            max={sliderMax}
            value={cutIndex}
            onChange={event => setCutIndex(parseInt(event.target.value, 10))}
            className="w-full cursor-pointer appearance-none touch-manipulation"
            aria-label="Cut position"
            aria-valuetext={`Cut position ${cutIndex} of ${deckSize}`}
            style={{ accentColor: 'var(--brand-accent)' }}
          />
          <div className="mt-1 flex items-center justify-between text-[0.65rem] text-muted">
            <span>Top (0)</span>
            <span>Bottom ({sliderMax})</span>
          </div>
          {hasCut && (
            <p className="mt-2 text-[0.65rem] text-secondary/80">
              Adjust the slider and tap &ldquo;Relock cut&rdquo; whenever you need to fine-tune.
            </p>
          )}
        </div>
      </div>

      <div className="flex flex-col items-center gap-2 text-center mt-4 sm:mt-0">
        <div className="relative" ref={skipPromptRef}>
          <button
            type="button"
            onClick={() => setShowSkipConfirm(show => !show)}
            className="text-[0.68rem] uppercase tracking-[0.35em] text-accent/80 underline decoration-accent/60 underline-offset-4 transition hover:text-main"
            aria-haspopup="dialog"
            aria-expanded={showSkipConfirm}
          >
            Skip
          </button>
          {showSkipConfirm && (
            <div
              role="dialog"
              aria-label="Skip ritual confirmation"
              className="absolute left-1/2 top-full mt-2 w-64 -translate-x-1/2 rounded-2xl border border-accent/40 bg-surface/95 p-4 text-xs sm:text-sm text-main shadow-lg"
            >
              <p className="font-semibold text-accent">Skip?</p>
              <p className="text-muted mt-1">Draw immediately without ritual.</p>
              <div className="mt-3 flex items-center justify-end gap-2 text-[0.8rem]">
                <button
                  type="button"
                  onClick={() => setShowSkipConfirm(false)}
                  className="text-accent/80 hover:text-main"
                >
                  Stay here
                </button>
                <button
                  type="button"
                  onClick={confirmSkip}
                  className="text-secondary hover:text-secondary/80 font-semibold"
                >
                  Skip & draw
                </button>
              </div>
            </div>
          )}
        </div>
        {isNewbie && (
          <p className="text-[0.72rem] text-muted">
            You can adjust or hide these steps anytime in Settings → Personalization.
          </p>
        )}
      </div>

      {deckAnnouncement && (
        <p className="sr-only" aria-live="polite">
          {deckAnnouncement}
        </p>
      )}
    </div>
  );
}
</file>

<file path="src/components/SavedIntentionsList.jsx">
import { useState, useEffect } from 'react';
import { Trash, ClockCounterClockwise, ArrowRight, Sparkle } from '@phosphor-icons/react';
import {
  loadCoachHistory,
  deleteCoachHistoryItem,
  COACH_STORAGE_SYNC_EVENT,
  HISTORY_STORAGE_KEY
} from '../lib/coachStorage';
import { useNavigate } from 'react-router-dom';

export function SavedIntentionsList() {
  const [intentions, setIntentions] = useState(() => loadCoachHistory());
  const navigate = useNavigate();

  useEffect(() => {
    if (typeof window === 'undefined') {
      return undefined;
    }

    const relevantKeys = new Set([HISTORY_STORAGE_KEY]);
    const refreshHistory = () => setIntentions(loadCoachHistory());

    const handleStorage = (event) => {
      if (!event.key || relevantKeys.has(event.key)) {
        refreshHistory();
      }
    };

    const handleCoachSync = (event) => {
      const detailKey = event?.detail?.key;
      if (!detailKey || relevantKeys.has(detailKey)) {
        refreshHistory();
      }
    };

    window.addEventListener('storage', handleStorage);
    window.addEventListener(COACH_STORAGE_SYNC_EVENT, handleCoachSync);
    return () => {
      window.removeEventListener('storage', handleStorage);
      window.removeEventListener(COACH_STORAGE_SYNC_EVENT, handleCoachSync);
    };
  }, []);

  const handleDelete = (id) => {
    const result = deleteCoachHistoryItem(id);
    if (result.success) {
      setIntentions(result.history);
    }
  };

  const handleUseIntention = (question) => {
    navigate('/', { state: { initialQuestion: question } });
  };

  if (intentions.length === 0) {
    return null; // Don't show section if empty
  }

  return (
    <div className="mb-8 animate-fade-in">
      <div className="flex items-center gap-2 mb-1 text-accent">
        <ClockCounterClockwise className="w-5 h-5" />
        <h2 className="text-xl font-serif">Saved Intentions</h2>
      </div>
      <p className="text-xs text-muted mb-3 flex items-center gap-1">
        <Sparkle className="w-4 h-4" aria-hidden="true" /> From Guided Intention Coach
      </p>

      <div className="grid gap-3 sm:grid-cols-2 lg:grid-cols-3">
        {intentions.map((item) => (
          <button
            key={item.id}
            type="button"
            className="group relative p-4 bg-surface/50 border border-primary/20 rounded-lg hover:border-primary/40 transition-all hover:bg-surface text-left w-full"
            onClick={() => handleUseIntention(item.question)}
          >
            <div className="flex items-center gap-2 text-[0.7rem] uppercase tracking-[0.12em] text-secondary/80 mb-2">
              <Sparkle className="w-3.5 h-3.5" aria-hidden="true" /> Guided coach
            </div>

            <p className="journal-prose text-main pr-8 font-medium line-clamp-3">
              {item.question}
            </p>
            <div className="mt-2 flex items-center justify-between">
              <span className="text-xs text-muted">
                {new Date(item.createdAt).toLocaleDateString()}
              </span>
              <span className="text-xs text-primary opacity-0 group-hover:opacity-100 transition-opacity flex items-center gap-1">
                Use this <ArrowRight className="w-3 h-3" />
              </span>
            </div>

            <button
              onClick={(e) => {
                e.stopPropagation();
                handleDelete(item.id);
              }}
              className="absolute top-3 right-3 p-1.5 text-muted hover:text-error hover:bg-error/10 rounded-full transition-colors opacity-0 group-hover:opacity-100 focus:opacity-100"
              title="Delete intention"
              aria-label="Delete intention"
            >
              <Trash className="w-4 h-4" />
            </button>
          </button>
        ))}
      </div>
    </div>
  );
}
</file>

<file path="src/components/SpreadPatterns.jsx">
import { useState } from 'react';
import ReactMarkdown from 'react-markdown';
import { Fire, Drop, Wind, Leaf, Star, Triangle, Path, Infinity as InfinityIcon, CaretDown, CaretUp, BookOpen } from '@phosphor-icons/react';

// Suit icons using Phosphor icons for consistent rendering
const SUIT_ICONS = {
  Wands: <Fire className="w-4 h-4 text-orange-500" weight="fill" aria-hidden="true" />,
  Cups: <Drop className="w-4 h-4 text-blue-400" weight="fill" aria-hidden="true" />,
  Swords: <Wind className="w-4 h-4 text-sky-300" weight="fill" aria-hidden="true" />,
  Pentacles: <Leaf className="w-4 h-4 text-green-500" weight="fill" aria-hidden="true" />
};

// Pattern type icons
const PATTERN_ICONS = {
  'complete-triad': <Star className="w-4 h-4 text-accent" weight="fill" aria-hidden="true" />,
  'partial-triad': <Triangle className="w-4 h-4 text-accent" aria-hidden="true" />,
  'fools-journey': <Path className="w-4 h-4 text-accent" aria-hidden="true" />,
  'high-dyad': <InfinityIcon className="w-4 h-4 text-accent" aria-hidden="true" />,
  'medium-high-dyad': <InfinityIcon className="w-4 h-4 text-accent" aria-hidden="true" />,
  'suit-progression': null, // Uses suit-specific icon
  'emerging-suit-progression': null // Uses suit-specific icon
};

// Default icon for unknown pattern types
const DEFAULT_ICON = <Star className="w-4 h-4 text-accent" aria-hidden="true" />;

// Maximum length for passage text before truncation
// Increased from 250 to 450 to preserve complete quotes from traditional sources
const MAX_PASSAGE_LENGTH = 450;

/**
 * Get the appropriate icon for a pattern type
 * @param {string} type - Pattern type identifier
 * @param {string} [suit] - Optional suit name for suit progressions
 * @returns {JSX.Element} Icon component
 */
function getPatternIcon(type, suit) {
  // For suit progressions, use the suit icon
  if (type === 'suit-progression' || type === 'emerging-suit-progression') {
    return SUIT_ICONS[suit] || SUIT_ICONS.Wands;
  }
  // For other patterns, use the pattern icon
  return PATTERN_ICONS[type] || DEFAULT_ICON;
}

/**
 * Truncate text to a maximum length, adding ellipsis if needed
 * @param {string} text - Text to truncate
 * @param {number} maxLength - Maximum length
 * @returns {string} Truncated text
 */
function truncateText(text, maxLength = MAX_PASSAGE_LENGTH) {
  if (!text || text.length <= maxLength) return text;
  const truncated = text.slice(0, maxLength);
  const lastSpace = truncated.lastIndexOf(' ');
  // If no space found or space is too early, hard truncate
  return (lastSpace > 0 && lastSpace > maxLength * 0.8 ? truncated.slice(0, lastSpace) : truncated) + '…';
}

/**
 * Generate a stable unique key for a highlight item
 * @param {Object} highlight - Highlight object
 * @param {number} index - Array index as fallback
 * @param {string} [prefix] - Optional prefix for key uniqueness
 * @returns {string} Unique key
 */
function generateHighlightKey(highlight, index, prefix = '') {
  // Prefer explicit id if available
  if (highlight.id) return `${prefix}${highlight.id}`;
  if (highlight.key) return `${prefix}${highlight.key}`;

  // Create a deterministic key from type + text hash
  const typeKey = highlight.type || 'unknown';
  const textKey = (highlight.text || highlight.title || '')
    .slice(0, 50).replace(/\s+/g, '-').toLowerCase();

  return `${prefix}${typeKey}-${textKey}-${index}`;
}

/**
 * Generate stable key for passage
 * @param {Object} passage - Passage object
 * @param {number} index - Array index as fallback
 * @returns {string} Stable key
 */
function generatePassageKey(passage, index) {
  if (passage.id) return `passage-${passage.id}`;
  const titleKey = (passage.title || passage.theme || 'passage').slice(0, 20).replace(/\s+/g, '-');
  const sourceKey = (passage.source || '').slice(0, 15).replace(/\s+/g, '-');
  return `passage-${titleKey}-${sourceKey}-${index}`;
}

/**
 * SpreadPatterns - Unified component for all spread insights
 *
 * Displays all insight types in one place:
 * - spreadHighlights: Card relationship insights (suit dominance, reversals, etc.)
 * - themes.knowledgeGraph.narrativeHighlights: Archetypal patterns (triads, dyads, Fool's Journey)
 * - passages: Traditional wisdom from GraphRAG knowledge base
 *
 * @param {Object} props
 * @param {Object} props.themes - Themes containing knowledgeGraph.narrativeHighlights
 * @param {Array} props.spreadHighlights - Spread-specific highlight items from useReading
 * @param {Array} props.passages - Traditional wisdom passages from GraphRAG
 */
export function SpreadPatterns({ themes, spreadHighlights = [], passages = [] }) {
  const archetypeHighlights = themes?.knowledgeGraph?.narrativeHighlights || [];
  const [isExpanded, setIsExpanded] = useState(false);

  const hasArchetypes = Array.isArray(archetypeHighlights) && archetypeHighlights.length > 0;
  const hasSpreadHighlights = Array.isArray(spreadHighlights) && spreadHighlights.length > 0;
  const hasPassages = Array.isArray(passages) && passages.length > 0;

  if (!hasArchetypes && !hasSpreadHighlights && !hasPassages) {
    return null;
  }

  const totalCount = archetypeHighlights.length + spreadHighlights.length + passages.length;

  return (
    <div className="modern-surface spread-patterns-panel border border-secondary/40 p-4 sm:p-6 animate-fade-in">
      {/* Mobile: Collapsible header */}
      <button
        type="button"
        onClick={() => setIsExpanded(prev => !prev)}
        className="sm:hidden w-full flex items-center justify-between gap-2 mb-0 text-left focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/70 rounded"
        aria-expanded={isExpanded}
        aria-controls="spread-patterns-content-mobile"
      >
        <div className="flex items-center gap-2">
          <Star className="w-5 h-5 text-accent" aria-hidden="true" />
          <span className="text-accent text-base font-serif">Spread Insights</span>
          <span className="text-xs text-muted">({totalCount})</span>
        </div>
        {isExpanded ? (
          <CaretUp className="w-5 h-5 text-accent" aria-hidden="true" />
        ) : (
          <CaretDown className="w-5 h-5 text-accent" aria-hidden="true" />
        )}
      </button>

      {/* Desktop: Static header */}
      <div className="hidden sm:flex items-center gap-2 mb-4">
        <Star className="w-5 h-5 text-accent" aria-hidden="true" />
        <span className="text-accent text-lg font-serif">Spread Insights</span>
      </div>

      {/* Mobile: Collapsible content */}
      <div
        id="spread-patterns-content-mobile"
        className={`sm:hidden mt-3 space-y-4 ${isExpanded ? '' : 'hidden'}`}
      >
        {/* Spread Highlights Section */}
        {hasSpreadHighlights && (
          <div className="space-y-3">
            <h4 className="text-sm font-semibold text-accent/90">Highlights</h4>
            <ul className="space-y-2" role="list" aria-label="Spread highlights">
              {spreadHighlights.map((item, index) => (
                <li key={generateHighlightKey(item, index, 'spread-')} className="flex items-start gap-3">
                  <div className="text-accent mt-0.5 flex-shrink-0" aria-hidden="true">{item.icon}</div>
                  <div className="text-muted text-sm leading-snug">
                    <span className="font-semibold text-accent">{item.title}</span> {item.text}
                  </div>
                </li>
              ))}
            </ul>
          </div>
        )}

        {/* Archetypal Patterns Section */}
        {hasArchetypes && (
          <div className={hasSpreadHighlights ? 'pt-3 border-t border-secondary/30' : ''}>
            <h4 className="text-sm font-semibold text-accent/90 mb-3">Archetypal Patterns</h4>
            <ul className="pattern-list space-y-2" role="list" aria-label="Detected archetypal patterns">
              {archetypeHighlights.map((highlight, index) => (
                <li
                  key={generateHighlightKey(highlight, index, 'archetype-')}
                  className={`pattern pattern-${highlight.type || 'default'} flex items-start gap-2`}
                >
                  <span className="pattern-icon flex-shrink-0 mt-0.5" aria-hidden="true">
                    {getPatternIcon(highlight.type, highlight.suit)}
                  </span>
                  <ReactMarkdown
                    className="pattern-text text-sm text-main/90 leading-relaxed"
                    components={{
                      p: ({ children }) => <span>{children}</span>,
                      strong: ({ children }) => <strong className="font-semibold text-accent">{children}</strong>,
                      em: ({ children }) => <em className="italic">{children}</em>
                    }}
                  >
                    {highlight.text || ''}
                  </ReactMarkdown>
                </li>
              ))}
            </ul>
          </div>
        )}

        {/* Traditional Wisdom Section */}
        {hasPassages && (
          <div className={(hasSpreadHighlights || hasArchetypes) ? 'pt-3 border-t border-secondary/30' : ''}>
            <div className="flex items-center gap-2 mb-3">
              <BookOpen className="w-4 h-4 text-accent flex-shrink-0" aria-hidden="true" />
              <h4 className="text-sm font-semibold text-accent/90">Traditional Wisdom</h4>
            </div>
            <div className="space-y-3" role="list">
              {passages.map((passage, i) => (
                <article
                  key={generatePassageKey(passage, i)}
                  className="text-sm text-main/90 leading-relaxed bg-secondary/10 p-3 rounded border border-secondary/20"
                >
                  <p className="font-medium text-accent mb-1">{passage.title || passage.theme}</p>
                  <p className="italic opacity-90 mb-1">
                    &ldquo;{truncateText(passage.text)}&rdquo;
                  </p>
                  {passage.source && (
                    <p className="text-muted text-xs text-right mt-1">— {passage.source}</p>
                  )}
                </article>
              ))}
            </div>
          </div>
        )}
      </div>

      {/* Desktop: Always visible content */}
      <div className="hidden sm:block space-y-4">
        {/* Spread Highlights Section */}
        {hasSpreadHighlights && (
          <div className="space-y-3">
            <h4 className="text-sm font-semibold text-accent/90">Highlights</h4>
            <ul className="space-y-2" role="list" aria-label="Spread highlights">
              {spreadHighlights.map((item, index) => (
                <li key={generateHighlightKey(item, index, 'spread-')} className="flex items-start gap-3">
                  <div className="text-accent mt-0.5 flex-shrink-0" aria-hidden="true">{item.icon}</div>
                  <div className="text-muted text-sm leading-snug">
                    <span className="font-semibold text-accent">{item.title}</span> {item.text}
                  </div>
                </li>
              ))}
            </ul>
          </div>
        )}

        {/* Archetypal Patterns Section */}
        {hasArchetypes && (
          <div className={hasSpreadHighlights ? 'pt-4 border-t border-secondary/30' : ''}>
            <h4 className="text-sm font-semibold text-accent/90 mb-3">Archetypal Patterns</h4>
            <ul className="pattern-list space-y-2" role="list" aria-label="Detected archetypal patterns">
              {archetypeHighlights.map((highlight, index) => (
                <li
                  key={generateHighlightKey(highlight, index, 'archetype-')}
                  className={`pattern pattern-${highlight.type || 'default'} flex items-start gap-2`}
                >
                  <span className="pattern-icon flex-shrink-0 mt-0.5" aria-hidden="true">
                    {getPatternIcon(highlight.type, highlight.suit)}
                  </span>
                  <ReactMarkdown
                    className="pattern-text text-sm text-main/90 leading-relaxed"
                    components={{
                      p: ({ children }) => <span>{children}</span>,
                      strong: ({ children }) => <strong className="font-semibold text-accent">{children}</strong>,
                      em: ({ children }) => <em className="italic">{children}</em>
                    }}
                  >
                    {highlight.text || ''}
                  </ReactMarkdown>
                </li>
              ))}
            </ul>
          </div>
        )}

        {/* Traditional Wisdom Section */}
        {hasPassages && (
          <div className={(hasSpreadHighlights || hasArchetypes) ? 'pt-4 border-t border-secondary/30' : ''}>
            <div className="flex items-center gap-2 mb-3">
              <BookOpen className="w-4 h-4 text-accent flex-shrink-0" aria-hidden="true" />
              <h4 className="text-sm font-semibold text-accent/90">Traditional Wisdom</h4>
            </div>
            <div className="space-y-3" role="list">
              {passages.map((passage, i) => (
                <article
                  key={generatePassageKey(passage, i)}
                  className="text-sm text-main/90 leading-relaxed bg-secondary/10 p-3 rounded border border-secondary/20"
                >
                  <p className="font-medium text-accent mb-1">{passage.title || passage.theme}</p>
                  <p className="italic opacity-90 mb-1">
                    &ldquo;{truncateText(passage.text)}&rdquo;
                  </p>
                  {passage.source && (
                    <p className="text-muted text-xs text-right mt-1">— {passage.source}</p>
                  )}
                </article>
              ))}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/SpreadPatternThumbnail.jsx">
/**
 * SpreadPatternThumbnail - Visual SVG diagram showing spread layout pattern
 * @param {string} spreadKey - The spread identifier (single, threeCard, etc.)
 * @param {string} className - Additional CSS classes
 * @param {object} preview - Optional preview artwork { src, width, height, alt }
 * @param {string} spreadName - Name used for accessible alt text
 */
export function SpreadPatternThumbnail({ spreadKey, className = '', preview = null, spreadName = '' }) {
  // If we have custom artwork, prefer that over the vector fallback
  if (preview?.src) {
    const aspectRatio = preview.aspectRatio || (preview.width && preview.height ? `${preview.width} / ${preview.height}` : '2 / 1');
    const altText = preview.alt || `${spreadName || spreadKey} spread layout`;

    return (
      <div
        className={`relative overflow-hidden rounded-[14px] bg-[#0f0c14] ${className}`}
        style={{ aspectRatio }}
      >
        <img
          src={preview.src}
          alt={altText}
          className="w-full h-full object-cover"
          loading="lazy"
          decoding="async"
          onError={(e) => {
            // Hide broken image and show fallback background
            e.currentTarget.style.display = 'none';
          }}
        />
        <div
          className="pointer-events-none absolute inset-0 rounded-[14px] border border-white/10 shadow-[0_0_0_1px_rgba(232,218,195,0.08)]"
          aria-hidden="true"
        />
      </div>
    );
  }

  const baseClass = 'w-full h-full';
  const cardClass = 'fill-accent/15 stroke-accent stroke-1';
  const highlightClass = 'fill-accent/30 stroke-accent stroke-[1.5]';

  // SVG patterns for each spread type
  // Note: These are purely decorative visuals (aria-hidden on container)
  // The spread name is displayed separately as text for accessibility
  const patterns = {
    single: (
      <svg viewBox="0 0 100 80" className={baseClass} role="img" aria-hidden="true">
        <rect x="35" y="15" width="30" height="50" rx="3" className={highlightClass} />
      </svg>
    ),

    threeCard: (
      <svg viewBox="0 0 100 80" className={baseClass} role="img" aria-hidden="true">
        <rect x="8" y="15" width="24" height="50" rx="3" className={cardClass} />
        <rect x="38" y="15" width="24" height="50" rx="3" className={highlightClass} />
        <rect x="68" y="15" width="24" height="50" rx="3" className={cardClass} />
      </svg>
    ),

    fiveCard: (
      <svg viewBox="0 0 100 110" className={baseClass} role="img" aria-hidden="true">
        {/* Center */}
        <rect x="38" y="32" width="24" height="40" rx="3" className={highlightClass} />
        {/* Top */}
        <rect x="38" y="8" width="24" height="20" rx="2" className={cardClass} />
        {/* Bottom */}
        <rect x="38" y="85" width="24" height="20" rx="2" className="fill-accent/10 stroke-accent/70 stroke-1" />
        {/* Left */}
        <rect x="8" y="32" width="24" height="40" rx="3" className={cardClass} />
        {/* Right */}
        <rect x="68" y="32" width="24" height="40" rx="3" className={cardClass} />
      </svg>
    ),

    decision: (
      <svg viewBox="0 0 100 80" className={baseClass} role="img" aria-hidden="true">
        {/* Center question */}
        <rect x="38" y="5" width="24" height="35" rx="3" className={highlightClass} />
        {/* Path A */}
        <rect x="8" y="45" width="24" height="35" rx="3" className={cardClass} />
        {/* Path B */}
        <rect x="68" y="45" width="24" height="35" rx="3" className={cardClass} />
        {/* Connecting lines */}
        <path d="M 50 40 L 20 45" stroke="var(--brand-accent)" strokeWidth="1" opacity="0.3" fill="none" />
        <path d="M 50 40 L 80 45" stroke="var(--brand-accent)" strokeWidth="1" opacity="0.3" fill="none" />
        {/* Clarifier dots */}
        <circle cx="50" cy="65" r="2" className="fill-accent/50" />
        <circle cx="50" cy="75" r="2" className="fill-accent/40" />
      </svg>
    ),

    relationship: (
      <svg viewBox="0 0 100 80" className={baseClass} role="img" aria-hidden="true">
        {/* You */}
        <rect x="8" y="45" width="24" height="35" rx="3" className={cardClass} />
        {/* Them */}
        <rect x="68" y="45" width="24" height="35" rx="3" className={cardClass} />
        {/* Connection */}
        <rect x="38" y="10" width="24" height="35" rx="3" className={highlightClass} />
        {/* Triangle lines */}
        <path d="M 20 45 L 50 45" stroke="var(--brand-accent)" strokeWidth="1" opacity="0.2" fill="none" />
        <path d="M 80 45 L 50 45" stroke="var(--brand-accent)" strokeWidth="1" opacity="0.2" fill="none" />
      </svg>
    ),

    celtic: (
      <svg viewBox="0 0 110 120" className={baseClass} role="img" aria-hidden="true">
        {/* Cross base */}
        <rect x="38" y="32" width="24" height="36" rx="3" className={highlightClass} />
        {/* Crossing card */}
        <rect x="33" y="46" width="34" height="8" rx="2" className="fill-accent/40 stroke-accent stroke-[1.5]" />
        {/* Cardinal positions */}
        <rect x="38" y="10" width="24" height="20" rx="2" className={cardClass} />
        <rect x="38" y="76" width="24" height="20" rx="2" className={cardClass} />
        <rect x="8" y="32" width="24" height="36" rx="3" className={cardClass} />
        <rect x="68" y="32" width="24" height="36" rx="3" className={cardClass} />
        {/* Staff column (right side) */}
        <rect x="82" y="12" width="18" height="20" rx="2" className="fill-accent/10 stroke-accent/60 stroke-1" />
        <rect x="82" y="36" width="18" height="20" rx="2" className="fill-accent/10 stroke-accent/60 stroke-1" />
        <rect x="82" y="60" width="18" height="20" rx="2" className="fill-accent/10 stroke-accent/60 stroke-1" />
        <rect x="82" y="84" width="18" height="20" rx="2" className="fill-accent/10 stroke-accent/60 stroke-1" />
      </svg>
    )
  };

  return (
    <div className={`relative overflow-hidden rounded-[14px] bg-[#0f0c14] ${className}`} aria-hidden="true">
      {patterns[spreadKey] || patterns.single}
      <div className="pointer-events-none absolute inset-0 rounded-[14px] border border-white/10 shadow-[0_0_0_1px_rgba(232,218,195,0.08)]" aria-hidden="true"></div>
    </div>
  );
}
</file>

<file path="src/components/SpreadSelector.jsx">
import { useRef, useState, useEffect, useCallback } from 'react';
import { Sparkle, Check, Star, CaretRight } from './icons';
import { Icon } from './Icon';
import { SPREADS } from '../data/spreads';
import { SpreadPatternThumbnail } from './SpreadPatternThumbnail';
import { CarouselDots } from './CarouselDots';
import { useReducedMotion } from '../hooks/useReducedMotion';
import { useLandscape } from '../hooks/useLandscape';
import { useSmallScreen } from '../hooks/useSmallScreen';
import { usePreferences } from '../contexts/PreferencesContext';
import { getSpreadFromDepth } from '../utils/personalization';
import oneCardArt from '../../selectorimages/onecard.png';
import threeCardArt from '../../selectorimages/3card.png';
import fiveCardArt from '../../selectorimages/5card.png';
import decisionArt from '../../selectorimages/decision.png';
import relationshipArt from '../../selectorimages/relationshipsnapshot.png';
import celticArt from '../../selectorimages/celticcross.png';

const STAR_TOTAL = 3;

const FALLBACK_SPREAD_THEME = {
  accent: '#e5c48e',
  border: 'rgba(226, 195, 149, 0.28)',
  borderActive: 'rgba(226, 195, 149, 0.8)',
  glow: 'rgba(226, 195, 149, 0.35)',
  background:
    'linear-gradient(155deg, rgba(244, 209, 140, 0.08), rgba(17, 12, 21, 0.94)), radial-gradient(circle at 16% 12%, rgba(244, 209, 140, 0.16), transparent 46%), radial-gradient(circle at 82% -6%, rgba(117, 137, 255, 0.2), transparent 48)'
};

const SPREAD_THEMES = {
  single: {
    accent: '#f3d08d',
    border: 'rgba(243, 208, 141, 0.25)',
    borderActive: 'rgba(243, 208, 141, 0.8)',
    glow: 'rgba(243, 208, 141, 0.38)',
    background:
      'linear-gradient(165deg, rgba(255, 216, 158, 0.14), rgba(12, 9, 14, 0.95)), radial-gradient(circle at 15% 14%, rgba(243, 208, 141, 0.22), transparent 44%), radial-gradient(circle at 90% -10%, rgba(255, 170, 205, 0.18), transparent 50)'
  },
  threeCard: {
    accent: '#f08fb1',
    border: 'rgba(240, 143, 177, 0.2)',
    borderActive: 'rgba(240, 143, 177, 0.78)',
    glow: 'rgba(240, 143, 177, 0.32)',
    background:
      'linear-gradient(170deg, rgba(33, 24, 42, 0.96), rgba(12, 10, 18, 0.94)), radial-gradient(circle at 18% 10%, rgba(240, 143, 177, 0.32), transparent 46%), radial-gradient(circle at 88% -8%, rgba(99, 166, 255, 0.18), transparent 52)'
  },
  fiveCard: {
    accent: '#6fe0ff',
    border: 'rgba(111, 224, 255, 0.2)',
    borderActive: 'rgba(111, 224, 255, 0.75)',
    glow: 'rgba(111, 224, 255, 0.35)',
    background:
      'linear-gradient(165deg, rgba(17, 33, 44, 0.94), rgba(10, 11, 20, 0.98)), radial-gradient(circle at 8% 18%, rgba(111, 224, 255, 0.28), transparent 48%), radial-gradient(circle at 88% -12%, rgba(122, 84, 255, 0.18), transparent 50)'
  },
  decision: {
    accent: '#f6b756',
    border: 'rgba(246, 183, 86, 0.22)',
    borderActive: 'rgba(246, 183, 86, 0.82)',
    glow: 'rgba(246, 183, 86, 0.38)',
    background:
      'linear-gradient(160deg, rgba(255, 197, 110, 0.2), rgba(13, 11, 19, 0.96)), radial-gradient(circle at 14% 12%, rgba(246, 183, 86, 0.24), transparent 46%), radial-gradient(circle at 84% -6%, rgba(120, 195, 255, 0.18), transparent 50)'
  },
  relationship: {
    accent: '#f29fb4',
    border: 'rgba(242, 159, 180, 0.24)',
    borderActive: 'rgba(242, 159, 180, 0.82)',
    glow: 'rgba(242, 159, 180, 0.34)',
    background:
      'linear-gradient(165deg, rgba(242, 159, 180, 0.18), rgba(12, 8, 17, 0.96)), radial-gradient(circle at 20% 8%, rgba(242, 159, 180, 0.34), transparent 48%), radial-gradient(circle at 92% -8%, rgba(158, 190, 255, 0.18), transparent 52)'
  },
  celtic: {
    accent: '#a992ff',
    border: 'rgba(169, 146, 255, 0.24)',
    borderActive: 'rgba(169, 146, 255, 0.82)',
    glow: 'rgba(169, 146, 255, 0.4)',
    background:
      'linear-gradient(170deg, rgba(28, 24, 54, 0.95), rgba(10, 9, 17, 0.96)), radial-gradient(circle at 20% 12%, rgba(169, 146, 255, 0.28), transparent 52%), radial-gradient(circle at 88% -10%, rgba(255, 191, 140, 0.2), transparent 54)'
  }
};

const SPREAD_ART_OVERRIDES = {
  single: {
    src: oneCardArt,
    width: 4096,
    height: 4096,
    aspectRatio: '16 / 9',
    alt: 'One-card insight spread artwork'
  },
  threeCard: {
    src: threeCardArt,
    width: 4096,
    height: 4096,
    aspectRatio: '16 / 9',
    alt: 'Three-card story spread artwork'
  },
  fiveCard: {
    src: fiveCardArt,
    width: 4096,
    height: 4096,
    aspectRatio: '16 / 9',
    alt: 'Five-card clarity spread artwork'
  },
  decision: {
    src: decisionArt,
    width: 4096,
    height: 4096,
    aspectRatio: '16 / 9',
    alt: 'Decision two-path spread artwork'
  },
  relationship: {
    src: relationshipArt,
    width: 4096,
    height: 4096,
    aspectRatio: '16 / 9',
    alt: 'Relationship snapshot spread artwork'
  },
  celtic: {
    src: celticArt,
    width: 4096,
    height: 4096,
    aspectRatio: '16 / 9',
    alt: 'Celtic cross spread artwork'
  }
};

export function SpreadSelector({
  selectedSpread,
  onSelectSpread,
  onSpreadConfirm
}) {
  const spreadRefs = useRef({});
  const carouselRef = useRef(null);
  const spreadKeys = Object.keys(SPREADS);
  const [activeIndex, setActiveIndex] = useState(0);
  const [showLeftFade, setShowLeftFade] = useState(false);
  const [showRightFade, setShowRightFade] = useState(true);
  const prefersReducedMotion = useReducedMotion();
  const isLandscape = useLandscape();
  const _isSmallScreen = useSmallScreen();
  const { personalization } = usePreferences();
  const recommendedSpread = getSpreadFromDepth(personalization?.preferredSpreadDepth);
  const isExperienced = personalization?.tarotExperience === 'experienced';

  // In landscape: smaller cards to fit more on screen
  const cardBasisClass = isLandscape
    ? 'basis-[55%] xs:basis-[45%]'
    : 'basis-[82%] xs:basis-[70%]';

  // Update edge fade visibility based on scroll position
  const updateEdgeFades = useCallback((el) => {
    if (!el) return;
    const scrollLeft = el.scrollLeft;
    const scrollWidth = el.scrollWidth;
    const clientWidth = el.clientWidth;

    const threshold = Math.max(10, clientWidth * 0.05);
    const maxScrollLeft = Math.max(0, scrollWidth - clientWidth);

    setShowLeftFade(scrollLeft > threshold);
    setShowRightFade(maxScrollLeft - scrollLeft > threshold);
  }, []);

  // Track scroll position for pagination dots using actual element positions
  useEffect(() => {
    const el = carouselRef.current;
    if (!el || spreadKeys.length <= 1) return undefined;

    const handleScroll = () => {
      const cards = Array.from(el.children);
      if (cards.length === 0) return;

      // Find the card whose center is closest to the viewport center
      const viewportCenter = el.scrollLeft + el.clientWidth / 2;
      let closestIndex = 0;
      let closestDistance = Infinity;

      cards.forEach((card, idx) => {
        const cardCenter = card.offsetLeft + card.offsetWidth / 2;
        const distance = Math.abs(viewportCenter - cardCenter);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestIndex = idx;
        }
      });

      setActiveIndex(closestIndex);
      updateEdgeFades(el);
    };

    handleScroll();
    el.addEventListener('scroll', handleScroll, { passive: true });
    return () => el.removeEventListener('scroll', handleScroll);
  }, [spreadKeys.length, updateEdgeFades]);

  const scrollToIndex = (index) => {
    const clamped = Math.min(spreadKeys.length - 1, Math.max(0, index));
    setActiveIndex(clamped);
    const el = carouselRef.current;
    if (!el) return;

    // Scroll to center the target card in the viewport
    const cards = Array.from(el.children);
    const targetCard = cards[clamped];
    if (targetCard) {
      const cardCenter = targetCard.offsetLeft + targetCard.offsetWidth / 2;
      const scrollTarget = cardCenter - el.clientWidth / 2;
      el.scrollTo({
        left: Math.max(0, scrollTarget),
        behavior: prefersReducedMotion ? 'auto' : 'smooth'
      });
    }
  };

  const handleSpreadSelection = key => {
    const selectedIndex = spreadKeys.indexOf(key);
    if (selectedIndex !== -1) {
      scrollToIndex(selectedIndex);
    }
    if (onSelectSpread) {
      onSelectSpread(key);
    }
    if (onSpreadConfirm) {
      onSpreadConfirm(key);
    }
  };

  const handleCardKeyDown = (event, key) => {
    const spreadKeys = Object.keys(SPREADS);
    const currentIndex = spreadKeys.indexOf(key);

    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      handleSpreadSelection(key);
      return;
    }

    let nextIndex = -1;
    if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
      event.preventDefault();
      nextIndex = (currentIndex + 1) % spreadKeys.length;
    } else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
      event.preventDefault();
      nextIndex = (currentIndex - 1 + spreadKeys.length) % spreadKeys.length;
    } else if (event.key === 'Home') {
      event.preventDefault();
      nextIndex = 0;
    } else if (event.key === 'End') {
      event.preventDefault();
      nextIndex = spreadKeys.length - 1;
    }

    if (nextIndex !== -1) {
      const nextKey = spreadKeys[nextIndex];
      const nextElement = spreadRefs.current[nextKey];
      if (nextElement && typeof nextElement.focus === 'function') {
        nextElement.focus();
        nextElement.scrollIntoView({
          behavior: prefersReducedMotion ? 'auto' : 'smooth',
          block: 'nearest',
          inline: 'center'
        });
      }
    }
  };

  const renderStars = stars => (
    <div className="flex items-center gap-0.5 text-primary">
      {Array.from({ length: STAR_TOTAL }).map((_, index) => (
        <Icon
          key={`${index}-star`}
          icon={Star}
          size="sm"
          weight={index < stars ? 'fill' : 'regular'}
          className={index < stars
            ? 'text-primary drop-shadow-[0_0_10px_rgba(244,223,175,0.35)]'
            : 'text-secondary/60'}
          decorative
        />
      ))}
    </div>
  );

  return (
    <section className="panel-mystic spread-selector-panel animate-fade-in mb-6 sm:mb-8">
      <div className="relative z-10 space-y-5">
        <header className={`flex flex-col ${isLandscape ? 'gap-1' : 'gap-2'} sm:flex-row sm:items-center sm:justify-between`}>
          <div>
            <p className="text-[0.68rem] uppercase tracking-[0.22em] text-gold-soft">Spread Selection</p>
            {!isLandscape && (
              <p className="text-xs text-muted max-w-2xl">
                Choose how your reading unfolds.
              </p>
            )}
          </div>
          <div className="hidden sm:flex items-center gap-2 rounded-full border border-gold-soft/50 bg-black/30 px-3 py-1 text-[0.7rem] text-accent backdrop-blur">
            <Sparkle className="w-3 h-3" aria-hidden="true" />
            <span>Guided layouts</span>
          </div>
        </header>

        {/* Carousel wrapper with edge fade indicators */}
        <div className="relative">
          {/* Left edge fade - indicates scrolled content behind */}
          <div
            className={`
              absolute left-0 top-0 bottom-3 w-8 z-10
              pointer-events-none
              bg-gradient-to-r from-[rgba(13,10,20,0.9)] to-transparent
              rounded-l-2xl
              transition-opacity duration-200
              sm:hidden
              ${showLeftFade ? 'opacity-100' : 'opacity-0'}
            `}
            aria-hidden="true"
          />

          {/* Right edge fade with scroll hint arrow */}
          <div
            className={`
              absolute right-0 top-0 bottom-3 w-12 z-10
              pointer-events-none
              bg-gradient-to-l from-[rgba(13,10,20,0.9)] via-[rgba(13,10,20,0.6)] to-transparent
              rounded-r-2xl
              transition-opacity duration-200
              sm:hidden
              flex items-center justify-end pr-1
              ${showRightFade ? 'opacity-100' : 'opacity-0'}
            `}
            aria-hidden="true"
          >
            <CaretRight
              className="w-5 h-5 text-accent/70 animate-pulse drop-shadow-md"
              weight="bold"
            />
          </div>

          <div
            ref={carouselRef}
            role="radiogroup"
            aria-label="Spread selection"
            className={`spread-selector-grid flex ${isLandscape ? 'gap-2 pb-2' : 'gap-3 pb-3'} overflow-x-auto snap-x snap-mandatory scroll-smooth sm:overflow-visible sm:snap-none sm:grid sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-3 sm:gap-4`}
            style={{ scrollPaddingLeft: '1rem', scrollPaddingRight: '1rem' }}
          >
          {Object.entries(SPREADS).map(([key, spread], index) => {
            const isActive = selectedSpread === key;
            const baseDescription = spread.description || 'Guided snapshot for your focus.';
            const isFirstSpread = index === 0;
            const isTabbable = isActive || (!selectedSpread && isFirstSpread);
            const stars = spread.complexity?.stars ?? 0;
            const complexityLabel = spread.complexity?.label || 'Beginner';
            const theme = SPREAD_THEMES[key] || FALLBACK_SPREAD_THEME;
            const resolvedBorder = isActive
              ? (theme.borderActive || FALLBACK_SPREAD_THEME.borderActive)
              : (theme.border || FALLBACK_SPREAD_THEME.border);
            const previewArt = SPREAD_ART_OVERRIDES[key] || spread.preview;

            return (
              <button
                key={key}
                ref={el => { spreadRefs.current[key] = el; }}
                type="button"
                role="radio"
                tabIndex={isTabbable ? 0 : -1}
                aria-checked={isActive}
                onClick={() => handleSpreadSelection(key)}
                onKeyDown={event => handleCardKeyDown(event, key)}
                className={`spread-card relative flex h-full flex-col ${isLandscape ? 'gap-2' : 'gap-3'} cursor-pointer select-none shrink-0 ${cardBasisClass} snap-center snap-always sm:basis-auto sm:shrink focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--spread-ring)] focus-visible:ring-offset-2 focus-visible:ring-offset-[#0f0c13] ${isActive ? 'spread-card--active' : ''}`}
                style={{
                  '--spread-accent': theme.accent || FALLBACK_SPREAD_THEME.accent,
                  '--spread-border': resolvedBorder,
                  '--spread-background': theme.background || FALLBACK_SPREAD_THEME.background,
                  '--spread-glow': theme.glow || FALLBACK_SPREAD_THEME.glow,
                  '--spread-ring': theme.accent || FALLBACK_SPREAD_THEME.accent
                }}
              >
                {isActive && (
                  <div className="absolute top-3 right-3 z-20">
                    <div
                      className="w-7 h-7 rounded-full flex items-center justify-center border border-white/30"
                      style={{
                        backgroundColor: 'var(--spread-accent)',
                        boxShadow: '0 12px 26px -18px var(--spread-glow, rgba(212, 184, 150, 0.4))'
                      }}
                    >
                      <Check className="w-4 h-4 text-main" weight="bold" aria-hidden="true" />
                    </div>
                  </div>
                )}

                <SpreadPatternThumbnail
                  spreadKey={key}
                  preview={previewArt}
                  spreadName={spread.name}
                  className="spread-card__preview w-full"
                />

                <div className="spread-card__body">
                  <div className="spread-card__title font-serif font-semibold text-accent text-base leading-tight flex flex-wrap items-center gap-2">
                    <span className="spread-card__title-text">{spread.name}</span>
                    {key === recommendedSpread && (
                      <span className="text-[0.65rem] uppercase tracking-[0.18em] text-amber-200 bg-amber-500/15 border border-amber-300/40 px-2 py-0.5 rounded-full">
                        Recommended
                      </span>
                    )}
                  </div>
                  <div className="text-[0.68rem] uppercase tracking-[0.2em] text-gold-soft/90 mb-2">
                    {spread.tag || 'Guided spread'}
                    <span className="text-gold-soft/60 ml-2">· {spread.count} cards</span>
                  </div>

                  {!isLandscape && !isExperienced && (
                    <p className="spread-card__description text-xs text-muted leading-snug mb-3">
                      {baseDescription}
                    </p>
                  )}

                  <div className="spread-card__meta">
                    <div className="spread-card__complexity">
                      <span className="text-[0.68rem] uppercase tracking-[0.2em] text-gold-soft/80">Complexity</span>
                      {renderStars(stars)}
                      <span className="text-[0.72rem] text-muted capitalize">{complexityLabel}</span>
                    </div>
                    <div className="spread-card__count">
                      <span className="text-[0.7rem] text-muted">Card Count</span>
                      <span className="text-sm font-semibold text-accent">{spread.count}</span>
                    </div>
                  </div>
                </div>
              </button>
            );
          })}
          </div>
        </div>

        {/* Mobile pagination dots */}
        <div className="sm:hidden">
          <CarouselDots
            activeIndex={activeIndex}
            totalItems={spreadKeys.length}
            onSelectItem={scrollToIndex}
            labels={spreadKeys.map(key => SPREADS[key]?.name || key)}
            ariaLabel="Spread selection"
            variant="compact"
          />
        </div>

      </div>
    </section>
  );
}
</file>

<file path="src/components/SpreadTable.jsx">
import { useMemo } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { SPREADS } from '../data/spreads';
import { useReducedMotion } from '../hooks/useReducedMotion';
import { getCardImage, FALLBACK_IMAGE } from '../lib/cardLookup';

/**
 * Spread layout definitions (x, y as percentage of container)
 * Each position includes coordinates and optional rotation
 */
const SPREAD_LAYOUTS = {
  single: [
    { x: 50, y: 50, scale: 1.2 }
  ],
  threeCard: [
    { x: 20, y: 50, label: 'Past' },
    { x: 50, y: 50, label: 'Present' },
    { x: 80, y: 50, label: 'Future' }
  ],
  fiveCard: [
    { x: 50, y: 20, label: 'Core' },
    { x: 20, y: 50, label: 'Challenge' },
    { x: 50, y: 50, label: 'Hidden' },
    { x: 80, y: 50, label: 'Support' },
    { x: 50, y: 80, label: 'Direction' }
  ],
  decision: [
    { x: 50, y: 20, label: 'Heart' },
    { x: 25, y: 50, label: 'Path A' },
    { x: 75, y: 50, label: 'Path B' },
    { x: 50, y: 70, label: 'Clarity' },
    { x: 50, y: 90, label: 'Free Will' }
  ],
  relationship: [
    { x: 30, y: 50, label: 'You' },
    { x: 70, y: 50, label: 'Them' },
    { x: 50, y: 75, label: 'Connection' }
  ],
  celtic: [
    { x: 35, y: 50, label: 'Present' },
    { x: 35, y: 50, label: 'Challenge', rotate: 90, offsetX: 3 },
    { x: 15, y: 50, label: 'Past' },
    { x: 55, y: 50, label: 'Future' },
    { x: 35, y: 20, label: 'Above' },
    { x: 35, y: 80, label: 'Below' },
    { x: 80, y: 80, label: 'Self' },
    { x: 80, y: 60, label: 'Environment' },
    { x: 80, y: 40, label: 'Hopes/Fears' },
    { x: 80, y: 20, label: 'Outcome' }
  ]
};

/**
 * SpreadTable - Visual spread layout showing where cards will land
 * Displays placeholders for undealt positions and mini cards for dealt positions
 */
export function SpreadTable({
  spreadKey,
  cards = [],
  revealedIndices = new Set(),
  onCardClick,
  onCardReveal,
  nextDealIndex = 0,
  compact = false
}) {
  const prefersReducedMotion = useReducedMotion();
  const layout = SPREAD_LAYOUTS[spreadKey] || SPREAD_LAYOUTS.single;
  const spreadInfo = SPREADS[spreadKey];

  // Get position labels from spread definition or layout
  const getPositionLabel = useMemo(() => {
    return (index) => {
      if (spreadInfo?.positions?.[index]) {
        // Extract short label from full position text
        const fullPosition = spreadInfo.positions[index];
        const shortLabel = fullPosition.split(' — ')[0].split(' (')[0];
        return shortLabel;
      }
      return layout[index]?.label || `Card ${index + 1}`;
    };
  }, [spreadInfo, layout]);

  // Aspect ratio based on spread type
  const aspectRatio = spreadKey === 'celtic' ? '4/3' : '3/2';

  return (
    <div
      className={`spread-table relative w-full rounded-2xl sm:rounded-3xl border border-accent/20 overflow-hidden ${
        compact ? 'p-3' : 'p-4 sm:p-6'
      }`}
      style={{
        aspectRatio,
        background: 'linear-gradient(145deg, var(--bg-surface), var(--bg-surface-muted))',
        boxShadow: 'inset 0 0 60px color-mix(in srgb, var(--brand-accent) 6%, transparent)'
      }}
      role="region"
      aria-label={`${spreadInfo?.name || 'Spread'} layout`}
    >
      {/* Table surface texture */}
      <div
        className="absolute inset-0 opacity-[0.04] pointer-events-none"
        style={{
          backgroundImage: `radial-gradient(circle at 50% 50%, var(--brand-accent) 1px, transparent 1px)`,
          backgroundSize: '20px 20px'
        }}
        aria-hidden="true"
      />

      {/* Position placeholders */}
      {layout.map((pos, i) => {
        const card = cards?.[i];
        const isRevealed = revealedIndices?.has?.(i) || false;
        const isNext = i === nextDealIndex && !card;
        const positionLabel = getPositionLabel(i);
        const cardImage = card ? getCardImage(card) : null;

        return (
          <motion.div
            key={i}
            className="absolute transform -translate-x-1/2 -translate-y-1/2"
            style={{
              left: `${pos.x}%`,
              top: `${pos.y}%`,
              zIndex: isRevealed ? 10 : card ? 5 : 1,
              marginLeft: pos.offsetX ? `${pos.offsetX}%` : 0
            }}
            initial={false}
            animate={isNext && !prefersReducedMotion ? { scale: [1, 1.05, 1] } : {}}
            transition={{ repeat: Infinity, duration: 1.5 }}
          >
            {!card ? (
              // Empty placeholder - min 44px touch target on mobile
              <div
                className={`
                  ${compact ? 'w-11 h-[60px] xs:w-12 xs:h-16 sm:w-14 sm:h-[76px]' : 'w-14 h-[76px] xs:w-16 xs:h-[88px] sm:w-[72px] sm:h-24 md:w-20 md:h-28'}
                  rounded-lg border-2 border-dashed
                  flex items-center justify-center
                  transition-all
                  ${isNext
                    ? 'border-primary/60 bg-primary/10'
                    : 'border-accent/30 bg-surface/30'
                  }
                `}
                style={isNext && !prefersReducedMotion ? {
                  animation: 'placeholderPulse 1.5s ease-in-out infinite'
                } : {}}
                role="img"
                aria-label={`${positionLabel}: waiting for card`}
              >
                <span className={`${compact ? 'text-[0.55rem] xs:text-[0.6rem]' : 'text-[0.6rem] xs:text-[0.65rem] sm:text-xs'} text-muted text-center px-1 leading-tight`}>
                  {positionLabel}
                </span>
              </div>
            ) : (
              // Card in position (mini representation) - min 44px touch target
              <AnimatePresence mode="wait">
                <motion.button
                  key={card.name}
                  initial={prefersReducedMotion ? { opacity: 1 } : { scale: 0, rotate: -180 }}
                  animate={{ scale: pos.scale || 1, rotate: pos.rotate || 0, opacity: 1 }}
                  exit={prefersReducedMotion ? { opacity: 0 } : { scale: 0, rotate: 180 }}
                  transition={prefersReducedMotion ? { duration: 0.1 } : { type: 'spring', stiffness: 300, damping: 20 }}
                  className={`
                    ${compact ? 'w-11 h-[60px] xs:w-12 xs:h-16 sm:w-14 sm:h-[76px]' : 'w-14 h-[76px] xs:w-16 xs:h-[88px] sm:w-[72px] sm:h-24 md:w-20 md:h-28'}
                    rounded-lg border-2 cursor-pointer overflow-hidden
                    transition-all touch-manipulation
                    focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/70 focus-visible:ring-offset-2 focus-visible:ring-offset-main
                    ${isRevealed
                      ? 'border-secondary/60 shadow-lg'
                      : 'border-primary/40 hover:border-primary/60 active:scale-95'
                    }
                  `}
                  style={isRevealed ? {
                    boxShadow: '0 4px 12px color-mix(in srgb, var(--brand-secondary) 20%, transparent)'
                  } : {}}
                  onClick={() => isRevealed ? onCardClick?.(card, positionLabel, i) : onCardReveal?.(i)}
                  aria-label={isRevealed
                    ? `${card.name} in ${positionLabel} position. Click to view details.`
                    : `Card in ${positionLabel} position. Click to reveal.`
                  }
                >
                  {isRevealed ? (
                    <div className={`w-full h-full bg-surface flex items-center justify-center relative ${card.isReversed ? 'rotate-180' : ''}`}>
                      <img
                        src={cardImage}
                        alt={card.name}
                        className="w-full h-full object-cover"
                        loading="lazy"
                        onError={(e) => {
                          e.target.onerror = null;
                          e.target.src = FALLBACK_IMAGE;
                        }}
                      />
                      {/* Mini label overlay */}
                      <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/70 to-transparent p-0.5 xs:p-1 sm:p-1">
                        <span className={`${compact ? 'text-[0.5rem] xs:text-[0.55rem]' : 'text-[0.55rem] xs:text-[0.6rem] sm:text-[0.65rem]'} text-white font-semibold leading-tight block truncate`}>
                          {card.name.replace(/^The /, '')}
                        </span>
                      </div>
                    </div>
                  ) : (
                    <div className="w-full h-full bg-surface-muted flex items-center justify-center">
                      <span className={`${compact ? 'text-[0.55rem] xs:text-[0.6rem]' : 'text-[0.6rem] xs:text-[0.65rem] sm:text-xs'} text-muted`}>Tap</span>
                    </div>
                  )}
                </motion.button>
              </AnimatePresence>
            )}
          </motion.div>
        );
      })}

      {/* Spread name indicator */}
      <div className="absolute bottom-2 left-1/2 -translate-x-1/2">
        <span className={`${compact ? 'text-[0.6rem] px-2.5 py-1' : 'text-xs px-3 py-1'} text-muted/70 bg-surface/60 rounded-full border border-accent/10`}>
          {spreadInfo?.tag || spreadKey}
        </span>
      </div>
    </div>
  );
}

/**
 * Compact horizontal spread preview for mobile
 */
export function SpreadTableCompact({ spreadKey, cards = [], revealedIndices = new Set(), onCardClick: _onCardClick }) {
  const layout = SPREAD_LAYOUTS[spreadKey] || SPREAD_LAYOUTS.single;
  const spreadInfo = SPREADS[spreadKey];

  return (
    <div
      className="flex items-center justify-center gap-2 py-3 px-4 bg-surface/40 rounded-xl border border-accent/15"
      role="region"
      aria-label={`${spreadInfo?.name || 'Spread'} progress`}
    >
      {layout.map((pos, i) => {
        const card = cards?.[i];
        const isRevealed = revealedIndices?.has?.(i) || false;

        return (
          <div
            key={i}
            className={`
              w-7 h-10 xs:w-8 xs:h-11 rounded border
              flex items-center justify-center
              transition-all
              ${card
                ? isRevealed
                  ? 'border-secondary/50 bg-secondary/20'
                  : 'border-primary/40 bg-primary/10'
                : 'border-accent/20 bg-surface/50'
              }
            `}
            title={pos.label || `Position ${i + 1}`}
          >
            {card && isRevealed ? (
              <span className="text-[0.5rem] xs:text-[0.55rem] text-secondary font-bold">
                {card.name.charAt(0)}
              </span>
            ) : card ? (
              <span className="text-[0.5rem] xs:text-[0.55rem] text-primary">?</span>
            ) : null}
          </div>
        );
      })}
    </div>
  );
}
</file>

<file path="src/components/StepProgress.jsx">
import { useState, useRef, useEffect, useCallback } from 'react';
import { GridFour, Question, Sparkle, Eye } from '@phosphor-icons/react';

const STEP_ICONS = {
  'spread': GridFour,
  'intention': Question,
  'ritual': Sparkle,
  'reading': Eye
};

// Short labels for mobile (max ~6 chars for space efficiency)
const STEP_SHORT_LABELS = {
  'spread': 'Spread',
  'intention': 'Intent',
  'ritual': 'Ritual',
  'reading': 'Read'
};

export function StepProgress({ steps = [], activeStep, onSelect, condensed = false }) {
  const [activeTooltip, setActiveTooltip] = useState(null);
  const tooltipTimeoutRef = useRef(null);
  const buttonRefs = useRef({});
  const isTouchActiveRef = useRef(false);

  // Clear tooltip timeout on unmount
  useEffect(() => {
    return () => {
      if (tooltipTimeoutRef.current) {
        clearTimeout(tooltipTimeoutRef.current);
      }
    };
  }, []);

  const showTooltip = useCallback((stepId) => {
    if (tooltipTimeoutRef.current) {
      clearTimeout(tooltipTimeoutRef.current);
    }
    setActiveTooltip(stepId);
  }, []);

  const hideTooltip = useCallback(() => {
    if (tooltipTimeoutRef.current) {
      clearTimeout(tooltipTimeoutRef.current);
    }
    setActiveTooltip(null);
  }, []);

  const hideTooltipWithDelay = useCallback((delay = 1500) => {
    if (tooltipTimeoutRef.current) {
      clearTimeout(tooltipTimeoutRef.current);
    }
    tooltipTimeoutRef.current = setTimeout(() => {
      setActiveTooltip(null);
      isTouchActiveRef.current = false;
    }, delay);
  }, []);

  // Handle touch start - show tooltip and mark touch as active
  const handleTouchStart = useCallback((stepId) => {
    isTouchActiveRef.current = true;
    showTooltip(stepId);
  }, [showTooltip]);

  // Handle touch end - hide tooltip after delay
  const handleTouchEnd = useCallback(() => {
    hideTooltipWithDelay(1500);
  }, [hideTooltipWithDelay]);

  // Mouse handlers that respect touch state to avoid race conditions
  const handleMouseEnter = useCallback((stepId) => {
    // Ignore mouse events during active touch interaction
    if (isTouchActiveRef.current) return;
    showTooltip(stepId);
  }, [showTooltip]);

  const handleMouseLeave = useCallback(() => {
    // Ignore mouse events during active touch interaction
    if (isTouchActiveRef.current) return;
    hideTooltip();
  }, [hideTooltip]);

  // Handle click outside to close tooltip
  useEffect(() => {
    if (!activeTooltip) return;

    const handleClickOutside = (event) => {
      const activeButton = buttonRefs.current[activeTooltip];
      if (activeButton && !activeButton.contains(event.target)) {
        hideTooltip();
      }
    };

    const handleEscape = (event) => {
      if (event.key === 'Escape') {
        hideTooltip();
      }
    };

    document.addEventListener('pointerdown', handleClickOutside);
    document.addEventListener('keydown', handleEscape);

    return () => {
      document.removeEventListener('pointerdown', handleClickOutside);
      document.removeEventListener('keydown', handleEscape);
    };
  }, [activeTooltip, hideTooltip]);

  return (
    <nav aria-label="Tarot reading progress" className="w-full animate-fade-in">
      <ol
        className={`flex ${condensed ? 'gap-1 xs:gap-1.5 py-1' : 'gap-1.5 xs:gap-2 sm:gap-3 pb-1'} overflow-x-auto snap-x snap-mandatory`}
        role="list"
      >
        {steps.map((step, index) => {
          const isActive = step.id === activeStep;
          const StepIcon = STEP_ICONS[step.id];
          const shortLabel = STEP_SHORT_LABELS[step.id] || step.label;
          const isTooltipVisible = activeTooltip === step.id;
          
          // Calculate tooltip position adjustment for edge items
          const isFirstStep = index === 0;
          const isLastStep = index === steps.length - 1;

          return (
            <li key={step.id} className="flex-1 snap-start relative min-w-0">
              <button
                ref={(el) => { buttonRefs.current[step.id] = el; }}
                type="button"
                className={`
                  w-full rounded-xl border transition-all font-semibold
                  focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/80
                  focus-visible:ring-offset-2 focus-visible:ring-offset-main
                  touch-manipulation active:scale-[0.97]
                  min-h-[44px]
                  ${condensed
                    ? 'px-1.5 xs:px-2 sm:px-3 py-2 text-[0.7rem] xs:text-[0.75rem]'
                    : 'px-2 xs:px-3 sm:px-4 py-2 xs:py-2.5 text-[0.72rem] xs:text-[0.78rem] sm:text-sm'
                  }
                  ${isActive
                    ? 'bg-primary/20 border-primary/80 text-main shadow-md shadow-primary/35'
                    : 'bg-surface border-secondary/40 text-muted hover:bg-surface-muted hover:border-secondary/60 active:bg-surface-muted'
                  }
                `}
                onClick={() => onSelect?.(step.id)}
                onMouseEnter={() => handleMouseEnter(step.id)}
                onMouseLeave={handleMouseLeave}
                onFocus={() => showTooltip(step.id)}
                onBlur={() => hideTooltip()}
                onTouchStart={() => handleTouchStart(step.id)}
                onTouchEnd={handleTouchEnd}
                onTouchCancel={() => { isTouchActiveRef.current = false; hideTooltip(); }}
                aria-current={isActive ? 'step' : undefined}
                aria-label={`Step ${index + 1}: ${step.label}`}
                aria-describedby={isTooltipVisible ? `step-tooltip-${step.id}` : undefined}
              >
                <div className="flex items-center justify-center gap-1 xs:gap-1.5 sm:gap-2">
                  {StepIcon && (
                    <StepIcon
                      className={`shrink-0 ${condensed ? 'w-3.5 h-3.5 xs:w-4 xs:h-4' : 'w-3.5 h-3.5 xs:w-4 xs:h-4 sm:w-5 sm:h-5'}`}
                      aria-hidden="true"
                    />
                  )}
                  {/* Mobile: show short label, Desktop: show full label */}
                  <span className={`
                    font-semibold truncate
                    ${condensed
                      ? 'text-[0.65rem] xs:text-[0.7rem] text-secondary'
                      : 'text-[0.68rem] xs:text-[0.72rem] sm:text-[0.82rem]'
                    }
                    ${isActive ? 'text-main' : 'text-muted-high'}
                  `}>
                    <span className="sm:hidden">{shortLabel}</span>
                    <span className="hidden sm:inline">{step.label}</span>
                  </span>
                </div>
              </button>

              {/* Touch-friendly tooltip - positioned to avoid off-screen on edges */}
              <div
                id={`step-tooltip-${step.id}`}
                role="tooltip"
                className={`
                  absolute bottom-full mb-2
                  px-2.5 xs:px-3 py-1.5 bg-main border border-secondary/40 rounded-lg
                  shadow-lg whitespace-nowrap z-50
                  transition-all duration-200
                  ${isFirstStep 
                    ? 'left-0' 
                    : isLastStep 
                    ? 'right-0' 
                    : 'left-1/2 -translate-x-1/2'
                  }
                  ${isTooltipVisible
                    ? 'opacity-100 visible translate-y-0'
                    : 'opacity-0 invisible translate-y-1 pointer-events-none'
                  }
                `}
              >
                <div className="text-[0.7rem] xs:text-xs font-serif text-accent">{step.label}</div>
                <div className="text-[0.6rem] xs:text-[0.65rem] text-muted mt-0.5">Step {index + 1} of {steps.length}</div>
                {/* Arrow - positioned based on tooltip alignment */}
                <div
                  className={`absolute top-full -mt-1 border-4 border-transparent border-t-main ${
                    isFirstStep 
                      ? 'left-4' 
                      : isLastStep 
                      ? 'right-4' 
                      : 'left-1/2 -translate-x-1/2'
                  }`}
                  style={{ filter: 'drop-shadow(0 1px 0 rgba(0,0,0,0.1))' }}
                  aria-hidden="true"
                />
              </div>
            </li>
          );
        })}
      </ol>
    </nav>
  );
}
</file>

<file path="src/components/StreamingNarrative.jsx">
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { MarkdownRenderer } from './MarkdownRenderer';
import { useReducedMotion } from '../hooks/useReducedMotion';
import { useSmallScreen } from '../hooks/useSmallScreen';

const LONG_MOBILE_WORD_THRESHOLD = 280;
const LONG_DESKTOP_WORD_THRESHOLD = 600; // Guardrail for very long narratives on any device
const BASE_WORD_DELAY = 45;
const PUNCTUATION_DELAY_BONUS = 160;

/**
 * Split text into words for gradual reveal, preserving spaces
 */
function splitIntoWords(text) {
  if (!text) return [];

  // Split by spaces while capturing them
  const parts = text.split(/(\s+)/);

  // Filter in single pass
  return parts.filter(part => part && part.length > 0);
}

export function StreamingNarrative({
  text,
  useMarkdown = false,
  className = '',
  isStreamingEnabled = true,
  onDone,
  autoNarrate = false,
  onNarrationStart,
  displayName = '',
}) {
  const narrativeText = useMemo(() => (typeof text === 'string' ? text : ''), [text]);
  const prefersReducedMotion = useReducedMotion();
  const isSmallScreen = useSmallScreen();
  const wrapperClassName = className ? `narrative-stream ${className}` : 'narrative-stream';

  // Split text into reveal units (words)
  const units = useMemo(() => {
    if (!narrativeText) return [];
    return splitIntoWords(narrativeText);
  }, [narrativeText]);

  const totalWords = useMemo(() => {
    if (!units.length) return 0;
    return units.reduce((count, unit) => (unit.trim() ? count + 1 : count), 0);
  }, [units]);

  const [visibleCount, setVisibleCount] = useState(0);
  const [mobileStreamingOptIn, setMobileStreamingOptIn] = useState(false);
  // Initialize to null so render-time adjustment runs on first mount
  // (narrativeText is always a string, so null will never match)
  const [prevNarrativeText, setPrevNarrativeText] = useState(null);

  // Refs for cleanup and tracking
  const timerRef = useRef(null);
  const narrationTimerRef = useRef(null);
  const completionNotifiedRef = useRef(false);
  const narrationTriggeredRef = useRef(false);

  const isLongMobileNarrative = isSmallScreen && totalWords > LONG_MOBILE_WORD_THRESHOLD;
  const isVeryLongNarrative = totalWords > LONG_DESKTOP_WORD_THRESHOLD;
  const streamingActive = Boolean(
    isStreamingEnabled &&
    !prefersReducedMotion &&
    units.length > 0 &&
    !isVeryLongNarrative && // Guardrail: skip streaming for extremely long text on any device
    (!isLongMobileNarrative || mobileStreamingOptIn)
  );
  const streamingSuppressedForMobile = Boolean(
    isStreamingEnabled &&
    !prefersReducedMotion &&
    isLongMobileNarrative &&
    !isVeryLongNarrative &&
    !mobileStreamingOptIn
  );

  // Derive isComplete from visibleCount (no need for separate state)
  const isComplete = units.length > 0 && visibleCount >= units.length;

  // Adjust state during render when narrative text changes (React-recommended pattern)
  // This avoids the cascading render issue from calling setState in useEffect
  // See: https://react.dev/learn/you-might-not-need-an-effect#adjusting-some-state-when-a-prop-changes
  if (narrativeText !== prevNarrativeText) {
    setPrevNarrativeText(narrativeText);
    setMobileStreamingOptIn(false);
    
    // Compute what streamingActive will be after mobileStreamingOptIn resets to false
    const newStreamingActive = Boolean(
      isStreamingEnabled &&
      !prefersReducedMotion &&
      units.length > 0 &&
      !isVeryLongNarrative &&
      !isLongMobileNarrative // mobileStreamingOptIn will be false
    );
    
    if (!newStreamingActive) {
      setVisibleCount(units.length);
    } else {
      setVisibleCount(0);
    }
  }

  const notifyCompletion = useCallback(() => {
    if (completionNotifiedRef.current) {
      return;
    }
    completionNotifiedRef.current = true;
    onDone?.();
  }, [onDone]);

  const clearTimer = useCallback(() => {
    if (timerRef.current) {
      window.clearTimeout(timerRef.current);
      timerRef.current = null;
    }
  }, []);

  const clearNarrationTimer = useCallback(() => {
    if (narrationTimerRef.current) {
      window.clearTimeout(narrationTimerRef.current);
      narrationTimerRef.current = null;
    }
  }, []);

  // Clear timers and reset refs when text changes (side effects that must stay in useEffect)
  useEffect(() => {
    clearTimer();
    clearNarrationTimer();
    completionNotifiedRef.current = false;
    narrationTriggeredRef.current = false;
  }, [narrativeText, clearTimer, clearNarrationTimer]);

  // Notify completion when all content is visible
  // This effect only calls external callback, no setState
  useEffect(() => {
    if (isComplete && !completionNotifiedRef.current) {
      notifyCompletion();
    }
  }, [isComplete, notifyCompletion]);

  // Auto-narration effect - separate from streaming to avoid coupling
  useEffect(() => {
    if (!autoNarrate || !onNarrationStart || narrationTriggeredRef.current || units.length === 0) {
      return undefined;
    }

    const textToNarrate = narrativeText;

    if (streamingActive && visibleCount === 0) {
      narrationTriggeredRef.current = true;
      narrationTimerRef.current = window.setTimeout(() => {
        onNarrationStart(textToNarrate);
      }, 200);
    } else if (!streamingActive) {
      narrationTriggeredRef.current = true;
      narrationTimerRef.current = window.setTimeout(() => {
        onNarrationStart(textToNarrate);
      }, 80);
    }

    return () => {
      clearNarrationTimer();
    };
  }, [visibleCount, units.length, autoNarrate, onNarrationStart, narrativeText, streamingActive, clearNarrationTimer]);

  // Streaming effect: reveal units one by one
  useEffect(() => {
    if (!streamingActive) {
      return;
    }

    if (visibleCount >= units.length) {
      return;
    }

    // Calculate delay between words for natural reading pace
    const currentWord = units[visibleCount] || '';
    // Add extra delay for punctuation (pause at end of sentences/clauses)
    const hasPunctuation = /[.!?;:]/.test(currentWord);
    const delay = hasPunctuation ? BASE_WORD_DELAY + PUNCTUATION_DELAY_BONUS : BASE_WORD_DELAY;

    clearTimer();
    timerRef.current = window.setTimeout(() => {
      setVisibleCount((prev) => prev + 1);
    }, delay);

    return () => {
      clearTimer();
    };
  }, [visibleCount, units, streamingActive, clearTimer]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      clearTimer();
      clearNarrationTimer();
    };
  }, [clearTimer, clearNarrationTimer]);


  const handleSkip = () => {
    if (units.length === 0) {
      return;
    }
    clearTimer();
    setVisibleCount(units.length);
    // notifyCompletion will be called by the effect when isComplete becomes true
  };

  const handleEnableStreaming = () => {
    if (units.length === 0) {
      return;
    }
    setMobileStreamingOptIn(true);
    completionNotifiedRef.current = false;
    narrationTriggeredRef.current = false;
    clearTimer();
    setVisibleCount(0);
  };

  const visibleWords = units.slice(0, visibleCount);
  const showSkipButton = streamingActive && !isComplete;
  const textBottomPaddingClass = showSkipButton ? 'pb-16 sm:pb-10' : 'pb-6 sm:pb-6';

  // Memoize willChange styles to avoid creating new objects per word per render
  // Animation timing now controlled solely by Tailwind's animate-ink-spread class
  // Must be defined before any conditional returns to satisfy Rules of Hooks
  const recentWordStyle = useMemo(() => ({
    willChange: 'opacity, filter, transform'
  }), []);

  const settledWordStyle = useMemo(() => ({
    willChange: 'auto'
  }), []);

  const streamingOptInNotice = streamingSuppressedForMobile ? (
    <div className="sm:hidden mb-3 rounded-xl border border-secondary/40 bg-surface/80 px-3 xxs:px-4 py-3 text-center">
      <p className="text-xs-plus text-muted mb-2">Long readings show instantly on small screens.</p>
      <button
        type="button"
        onClick={handleEnableStreaming}
        className="w-full rounded-full border border-secondary/40 bg-secondary/20 px-4 py-2 text-xs-plus font-semibold text-secondary shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary"
      >
        Play typing effect
      </button>
    </div>
  ) : null;

  const personalizedIntro = displayName
    ? (
      <p className="text-xs text-muted text-center mb-2">
        For you, {displayName}, this unfolds in stages:
      </p>
    )
    : null;

  // For markdown: render completed text progressively
  if (useMarkdown) {
    const visibleText = visibleWords.join('');
    return (
      <div className={wrapperClassName} aria-live="polite">
        {streamingOptInNotice}
        {personalizedIntro}
        {/* Container with min-height to prevent layout shift during streaming */}
        <div className={`prose prose-sm xxs:prose-base md:prose-lg max-w-[min(34rem,calc(100vw-2.75rem))] xxs:max-w-[40ch] sm:max-w-[70ch] w-full min-h-[6rem] xxs:min-h-[7.5rem] md:min-h-[10rem] px-3 xxs:px-4 sm:px-1 mx-auto rounded-2xl bg-surface/70 border border-secondary/30 shadow-md narrative-stream__text narrative-stream__text--md ${textBottomPaddingClass}`}>
          <MarkdownRenderer content={visibleText} />
        </div>

        {showSkipButton && (
          <div className="mt-4 xs:mt-5 sticky bottom-[max(1rem,env(safe-area-inset-bottom,1rem))] sm:static flex justify-center px-3 xxs:px-4 sm:px-0 narrative-stream__actions">
            <button
              type="button"
              onClick={handleSkip}
              className="min-h-[44px] w-full max-w-sm sm:max-w-none px-4 xs:px-5 py-2.5 text-sm font-semibold rounded-full bg-surface-muted/90 border border-secondary/40 text-secondary hover:bg-surface-muted hover:border-secondary/60 shadow-lg sm:shadow-sm backdrop-blur-sm transition-all touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2"
              aria-label="Show full narrative immediately"
            >
              Show all now →
            </button>
          </div>
        )}
      </div>
    );
  }

  // For plain text: render words with ink-spreading effect
  // Only apply willChange to recently revealed words to avoid GPU memory exhaustion
  const RECENT_WORDS_THRESHOLD = 10;

  return (
    <div className={wrapperClassName} aria-live="polite">
      {streamingOptInNotice}
      {personalizedIntro}
      {/* Mobile-optimized text with good line height and spacing - min-height prevents layout shift */}
      <div className={`text-main text-[1rem] xxs:text-[1.05rem] md:text-lg leading-[1.85] md:leading-loose max-w-[min(34rem,calc(100vw-2.75rem))] xxs:max-w-[40ch] sm:max-w-[68ch] mx-auto text-left min-h-[5.5rem] xxs:min-h-[7.5rem] md:min-h-[10rem] px-3 xxs:px-4 sm:px-1 rounded-2xl bg-surface/70 border border-secondary/30 shadow-md narrative-stream__text narrative-stream__text--plain ${textBottomPaddingClass}`}>
        {visibleWords.map((word, idx) => {
          // Check if this is whitespace (space, newline, etc.)
          const isWhitespace = /^\s+$/.test(word);

          if (isWhitespace) {
            // Render whitespace without animation
            return <span key={idx}>{word}</span>;
          }

          // Only recent words get willChange hint to avoid exhausting GPU memory
          const isRecentWord = idx >= visibleCount - RECENT_WORDS_THRESHOLD;

          // Render word with ink-spreading animation
          return (
            <span
              key={idx}
              className={`inline-block ${prefersReducedMotion ? '' : 'animate-ink-spread'}`}
              style={prefersReducedMotion ? undefined : (isRecentWord ? recentWordStyle : settledWordStyle)}
            >
              {word}
            </span>
          );
        })}
      </div>

      {showSkipButton && (
        <div className="mt-4 xs:mt-5 sticky bottom-[max(1rem,env(safe-area-inset-bottom,1rem))] sm:static flex justify-center px-3 xxs:px-4 sm:px-0 narrative-stream__actions">
          <button
            type="button"
            onClick={handleSkip}
            className="min-h-[44px] w-full max-w-sm sm:max-w-none px-4 xs:px-5 py-2.5 text-sm font-semibold rounded-full bg-surface-muted/90 border border-secondary/40 text-secondary hover:bg-surface-muted hover:border-secondary/60 shadow-lg sm:shadow-sm backdrop-blur-sm transition-all touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-secondary focus-visible:ring-offset-2"
            aria-label="Show full narrative immediately"
          >
            Show all now →
          </button>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/components/TableuLogo.example.jsx">
import { TableuLogo } from './TableuLogo';

/**
 * TableuLogo Usage Examples
 *
 * This file demonstrates all available logo variants and usage patterns.
 * Not meant for production - just a reference guide.
 */
export function TableuLogoExamples() {
  return (
    <div className="p-8 space-y-12 bg-gray-50">
      <div>
        <h2 className="text-2xl font-bold mb-6">Tableu Logo Variants</h2>
      </div>

      {/* Primary (Full Detail) */}
      <section className="bg-white p-6 rounded-lg shadow">
        <h3 className="text-xl font-semibold mb-4">1. Primary (Full Detail)</h3>
        <p className="text-gray-600 mb-4">
          Complete logo with all elements: card frame, moon, star, octopus, tentacles, eye, wand, sparkles
        </p>
        <div className="flex items-center gap-8 flex-wrap">
          <TableuLogo variant="primary" size={120} outline glow />
          <TableuLogo variant="primary" size={160} outline glow />
          <TableuLogo variant="primary" size={200} outline glow />
        </div>
        <pre className="mt-4 bg-gray-100 p-3 rounded text-sm">
{`<TableuLogo variant="primary" size={160} />`}
        </pre>
      </section>

      {/* Icon (Simplified) */}
      <section className="bg-white p-6 rounded-lg shadow">
        <h3 className="text-xl font-semibold mb-4">2. Icon (Simplified)</h3>
        <p className="text-gray-600 mb-4">
          Simplified version without eye, wand, and bottom sparkle. Better for small sizes.
        </p>
        <div className="flex items-center gap-8 flex-wrap">
          <TableuLogo variant="icon" size={80} outline glow />
          <TableuLogo variant="icon" size={120} outline glow />
          <TableuLogo variant="icon" size={160} outline glow />
        </div>
        <pre className="mt-4 bg-gray-100 p-3 rounded text-sm">
{`<TableuLogo variant="icon" size={80} />`}
        </pre>
      </section>

      {/* Full (with Wordmark) */}
      <section className="bg-white p-6 rounded-lg shadow">
        <h3 className="text-xl font-semibold mb-4">3. Full (with Wordmark)</h3>
        <p className="text-gray-600 mb-4">
          Complete logo with &ldquo;TABLEU&rdquo; wordmark below. Best for headers and branding.
        </p>
        <div className="flex items-center gap-8 flex-wrap">
          <TableuLogo variant="full" size={150} outline glow />
          <TableuLogo variant="full" size={200} outline glow />
        </div>
        <pre className="mt-4 bg-gray-100 p-3 rounded text-sm">
{`<TableuLogo variant="full" size={200} />`}
        </pre>
      </section>

      {/* Favicon */}
      <section className="bg-white p-6 rounded-lg shadow">
        <h3 className="text-xl font-semibold mb-4">4. Favicon (Octopus Only)</h3>
        <p className="text-gray-600 mb-4">
          Minimal octopus-only mark for favicons and tiny contexts.
        </p>
        <div className="flex items-center gap-8 flex-wrap">
          <TableuLogo variant="favicon" size={32} outline glow />
          <TableuLogo variant="favicon" size={48} outline glow />
          <TableuLogo variant="favicon" size={64} outline glow />
        </div>
        <pre className="mt-4 bg-gray-100 p-3 rounded text-sm">
{`<TableuLogo variant="favicon" size={32} />`}
        </pre>
      </section>

      {/* Monochrome */}
      <section className="bg-white p-6 rounded-lg shadow">
        <h3 className="text-xl font-semibold mb-4">5. Monochrome</h3>
        <p className="text-gray-600 mb-4">
          Black version for print or high-contrast contexts.
        </p>
        <div className="flex items-center gap-8 flex-wrap">
          <TableuLogo variant="mono" size={120} outline glow />
          <TableuLogo variant="mono" size={160} outline glow />
        </div>
        <pre className="mt-4 bg-gray-100 p-3 rounded text-sm">
{`<TableuLogo variant="mono" size={160} />`}
        </pre>
      </section>

      {/* Dark Mode */}
      <section className="bg-gray-900 p-6 rounded-lg shadow">
        <h3 className="text-xl font-semibold mb-4 text-white">6. Dark Mode</h3>
        <p className="text-gray-300 mb-4">
          White version with dark background for dark mode interfaces.
        </p>
        <div className="flex items-center gap-8 flex-wrap">
          <TableuLogo variant="dark" size={120} outline glow />
          <TableuLogo variant="dark" size={160} outline glow />
        </div>
        <pre className="mt-4 bg-gray-800 text-gray-100 p-3 rounded text-sm">
{`<TableuLogo variant="dark" size={160} />`}
        </pre>
      </section>

      {/* Custom Colors */}
      <section className="bg-white p-6 rounded-lg shadow">
        <h3 className="text-xl font-semibold mb-4">7. Custom Colors</h3>
        <p className="text-gray-600 mb-4">
          Override the default color with any CSS color value.
        </p>
        <div className="flex items-center gap-8 flex-wrap">
          <TableuLogo variant="primary" size={120} color="#8B5CF6" />
          <TableuLogo variant="primary" size={120} color="#EC4899" />
          <TableuLogo variant="primary" size={120} color="#10B981" />
        </div>
        <pre className="mt-4 bg-gray-100 p-3 rounded text-sm">
{`<TableuLogo variant="primary" size={120} color="#8B5CF6" />`}
        </pre>
      </section>

      {/* Usage Guidelines */}
      <section className="bg-blue-50 p-6 rounded-lg border-2 border-blue-200">
        <h3 className="text-xl font-semibold mb-4">Usage Guidelines</h3>
        <ul className="space-y-2 text-gray-700">
          <li><strong>Headers:</strong> Use <code>variant=&quot;full&quot;</code> at size 180-240</li>
          <li><strong>Navigation:</strong> Use <code>variant=&quot;icon&quot;</code> at size 40-60</li>
          <li><strong>Favicon:</strong> Use <code>variant=&quot;favicon&quot;</code> at size 32 or 48</li>
          <li><strong>Social Cards:</strong> Use <code>variant=&quot;primary&quot;</code> at size 400-600</li>
          <li><strong>Dark Backgrounds:</strong> Use <code>variant=&quot;dark&quot;</code></li>
          <li><strong>Print:</strong> Use <code>variant=&quot;mono&quot;</code></li>
        </ul>
      </section>
    </div>
  );
}
</file>

<file path="src/components/TableuLogo.jsx">
import PropTypes from 'prop-types';

/**
 * Tableu Logo Component
 *
 * Renders the Tableu logo SVG sprite in various formats.
 *
 * @param {Object} props
 * @param {'primary'|'icon'|'mono'|'dark'|'favicon'|'full'} props.variant - Logo variant to display
 * @param {number|string} props.size - Width/height in pixels (for square variants) or width (for full)
 * @param {string} props.className - Additional CSS classes
 * @param {string} props.color - Custom color override (CSS color value)
 * @param {string} props.ariaLabel - Accessible label for screen readers
 *
 * @example
 * <TableuLogo variant="primary" size={160} />
 * <TableuLogo variant="icon" size={48} className="header-logo" />
 * <TableuLogo variant="dark" size={200} />
 * <TableuLogo variant="favicon" size={32} />
 * <TableuLogo variant="full" size={300} /> // includes wordmark
 */
export function TableuLogo({
  variant = 'primary',
  size = 160,
  className = '',
  color,
  ariaLabel = 'Tableu Logo',
  outline = false,
  glow = false,
  useRaster = false,
  rasterSrc = '/images/tableu-logo.png'
}) {
  // Determine viewBox based on variant
  const viewBoxMap = {
    primary: '0 0 432 400',
    icon: '0 0 432 400',
    mono: '0 0 432 400',
    dark: '0 0 432 400',
    favicon: '60 20 320 400',
    full: '0 0 432 500'
  };

  // Calculate dimensions
  const viewBox = viewBoxMap[variant] || viewBoxMap.primary;
  const [, , vbWidth, vbHeight] = viewBox.split(' ').map(Number);
  const aspectRatio = vbHeight / vbWidth;

  // For full logo with wordmark, treat size as width
  const width = variant === 'full' ? size : size;
  const height = variant === 'full' ? size * aspectRatio : size;

  // Build style object
  const style = color ? { color } : undefined;

  const classes = [
    'tableu-logo',
    outline ? 'tableu-logo--outline' : null,
    glow ? 'tableu-logo--glow' : null,
    className
  ]
    .filter(Boolean)
    .join(' ');

  if (useRaster) {
    const width = variant === 'full' ? size : size;
    const height = variant === 'full' ? size * aspectRatio : size;
    return (
      <img
        src={rasterSrc}
        width={width}
        height={height}
        className={classes}
        style={{ objectFit: 'contain', display: 'block', ...style }}
        alt={ariaLabel}
        loading="lazy"
        decoding="async"
      />
    );
  }

  return (
    <svg
      width={width}
      height={height}
      viewBox={viewBox}
      overflow="visible"
      preserveAspectRatio="xMidYMid meet"
      className={classes}
      style={style}
      aria-label={ariaLabel}
      role="img"
    >
      <use href={`#tableu-${variant}`} />
    </svg>
  );
}

TableuLogo.propTypes = {
  variant: PropTypes.oneOf(['primary', 'icon', 'mono', 'dark', 'favicon', 'full']),
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  className: PropTypes.string,
  color: PropTypes.string,
  ariaLabel: PropTypes.string,
  outline: PropTypes.bool,
  glow: PropTypes.bool,
  useRaster: PropTypes.bool,
  rasterSrc: PropTypes.string
};
</file>

<file path="src/components/Tooltip.jsx">
import { useEffect, useId, useRef, useState } from 'react';
import { Info } from '@phosphor-icons/react';

// Viewport padding for collision detection
const VIEWPORT_PADDING = 8;

/**
 * Accessible tooltip component with keyboard, mouse, and touch support.
 *
 * @param {Object} props
 * @param {string} props.content - Tooltip text content
 * @param {React.ReactNode} [props.children] - Optional custom trigger element
 * @param {string} [props.position='top'] - Tooltip position: 'top' | 'bottom' | 'left' | 'right'
 * @param {string} [props.size='sm'] - Icon size: 'sm' | 'md' | 'lg'
 */
export function Tooltip({
  content,
  children,
  position = 'top',
  size = 'sm',
  triggerClassName = '',
  ariaLabel = 'More information',
  asChild = false,
  enableClick = true,
  autoHideMs = 3000,
  showCloseButton = false,
  closeLabel = 'Close'
}) {
  const [isVisible, setIsVisible] = useState(false);
  const [adjustedPosition, setAdjustedPosition] = useState(null);
  const rootRef = useRef(null);
  const triggerRef = useRef(null);
  const tooltipRef = useRef(null);
  const tooltipId = useId();
  const touchHideTimeoutRef = useRef(null);

  const clearTouchHideTimeout = () => {
    if (touchHideTimeoutRef.current) {
      clearTimeout(touchHideTimeoutRef.current);
      touchHideTimeoutRef.current = null;
    }
  };

  const showTooltip = () => {
    clearTouchHideTimeout();
    setIsVisible(true);
  };

  const hideTooltip = () => {
    clearTouchHideTimeout();
    setIsVisible(false);
  };

  useEffect(() => {
    if (!isVisible || typeof window === 'undefined') {
      return undefined;
    }

    const handleKeyDown = event => {
      if (event.key === 'Escape') {
        setIsVisible(false);
      }
    };

    const handlePointerDown = event => {
      if (rootRef.current && !rootRef.current.contains(event.target)) {
        setIsVisible(false);
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('pointerdown', handlePointerDown);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('pointerdown', handlePointerDown);
    };
  }, [isVisible]);

  useEffect(() => () => clearTouchHideTimeout(), []);

  // Viewport collision detection - adjust tooltip position if it would overflow
  useEffect(() => {
    if (!isVisible || !tooltipRef.current || typeof window === 'undefined') {
      return;
    }

    // Use requestAnimationFrame to ensure tooltip is rendered before measuring
    // All setState calls happen inside rAF callback to avoid cascading renders
    const rafId = requestAnimationFrame(() => {
      const tooltip = tooltipRef.current;
      if (!tooltip) {
        setAdjustedPosition(null);
        return;
      }

      const rect = tooltip.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      let newPosition = position;
      let horizontalOffset = 0;

      // Check vertical overflow for top/bottom positions
      if (position === 'top' && rect.top < VIEWPORT_PADDING) {
        newPosition = 'bottom';
      } else if (position === 'bottom' && rect.bottom > viewportHeight - VIEWPORT_PADDING) {
        newPosition = 'top';
      }

      // Check horizontal overflow for left/right positions
      if (position === 'left' && rect.left < VIEWPORT_PADDING) {
        newPosition = 'right';
      } else if (position === 'right' && rect.right > viewportWidth - VIEWPORT_PADDING) {
        newPosition = 'left';
      }

      // For top/bottom positions, check horizontal overflow and adjust
      if (position === 'top' || position === 'bottom' || newPosition === 'top' || newPosition === 'bottom') {
        if (rect.left < VIEWPORT_PADDING) {
          horizontalOffset = VIEWPORT_PADDING - rect.left;
        } else if (rect.right > viewportWidth - VIEWPORT_PADDING) {
          horizontalOffset = viewportWidth - VIEWPORT_PADDING - rect.right;
        }
      }

      // Only update if there's a change
      if (newPosition !== position || horizontalOffset !== 0) {
        setAdjustedPosition({ position: newPosition, horizontalOffset });
      } else {
        setAdjustedPosition(null);
      }
    });

    return () => cancelAnimationFrame(rafId);
  }, [isVisible, position]);

  // Icon sizes (visual appearance inside the touch target)
  const iconSizeClasses = {
    sm: 'w-3.5 h-3.5',
    md: 'w-4 h-4',
    lg: 'w-5 h-5'
  };

  /**
   * Touch target sizes - minimum 44x44px for WCAG 2.5.8 compliance.
   *
   * Note: 'sm' and 'md' have identical touch targets (44x44px) intentionally.
   * The size prop controls the visual icon size, not the touch target.
   * All sizes meet WCAG 2.5.8 minimum requirements:
   * - sm/md: 44x44px (minimum compliant)
   * - lg: 48x48px (comfortable for primary actions)
   */
  const touchTargetClasses = {
    sm: 'min-w-[44px] min-h-[44px] w-11 h-11',
    md: 'min-w-[44px] min-h-[44px] w-11 h-11',
    lg: 'min-w-[48px] min-h-[48px] w-12 h-12'
  };

  const positionClasses = {
    top: 'bottom-full left-1/2 -translate-x-1/2 mb-2',
    bottom: 'top-full left-1/2 -translate-x-1/2 mt-2',
    left: 'right-full top-1/2 -translate-y-1/2 mr-2',
    right: 'left-full top-1/2 -translate-y-1/2 ml-2'
  };

  const arrowClasses = {
    top: 'top-full left-1/2 -translate-x-1/2 border-l-transparent border-r-transparent border-b-transparent border-t-surface-muted',
    bottom: 'bottom-full left-1/2 -translate-x-1/2 border-l-transparent border-r-transparent border-t-transparent border-b-surface-muted',
    left: 'left-full top-1/2 -translate-y-1/2 border-t-transparent border-b-transparent border-r-transparent border-l-surface-muted',
    right: 'right-full top-1/2 -translate-y-1/2 border-t-transparent border-b-transparent border-l-transparent border-r-surface-muted'
  };

  const handleToggle = event => {
    event.preventDefault();
    event.stopPropagation();
    setIsVisible(previous => !previous);
  };

  const handleMouseEnter = () => {
    showTooltip();
  };

  const handlePointerEnter = () => {
    showTooltip();
  };

  const handlePointerLeave = () => {
    if (
      typeof document !== 'undefined' &&
      triggerRef.current &&
      triggerRef.current === document.activeElement
    ) {
      return;
    }
    hideTooltip();
  };

  const handleFocus = () => {
    showTooltip();
  };

  const handleBlur = () => {
    const schedule =
      typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function'
        ? window.requestAnimationFrame
        : callback => {
          setTimeout(callback, 0);
        };

    schedule(() => {
      if (typeof document === 'undefined' || !rootRef.current) return;
      if (!rootRef.current.contains(document.activeElement)) {
        hideTooltip();
      }
    });
  };

  const handleTouchStart = event => {
    if (event.touches.length > 1) return;
    showTooltip();
  };

  const handleTouchEnd = () => {
    clearTouchHideTimeout();
    if (typeof autoHideMs === 'number') {
      touchHideTimeoutRef.current = setTimeout(() => {
        hideTooltip();
      }, autoHideMs);
    }
  };

  const handleTouchCancel = () => {
    hideTooltip();
  };

  // Base trigger class with proper touch target and visual centering
  const triggerBaseClass =
    'inline-flex items-center justify-center text-accent/60 hover:text-accent transition-colors focus:outline-none focus:ring-2 focus:ring-accent/50 rounded-full touch-manipulation';

  const rootBaseClass = asChild ? 'relative block' : 'relative inline-flex items-center';

  // ARIA pattern for tooltips:
  // - Use aria-describedby to associate trigger with tooltip content
  // - aria-expanded indicates toggle state for interactive triggers
  // - Don't use aria-haspopup (that's for menus/dialogs, not tooltips)
  const triggerProps = {
    ref: triggerRef,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handlePointerLeave,
    onPointerEnter: handlePointerEnter,
    onPointerLeave: handlePointerLeave,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onTouchStart: handleTouchStart,
    onTouchEnd: handleTouchEnd,
    onTouchCancel: handleTouchCancel,
    onClick: enableClick ? handleToggle : undefined,
    'aria-describedby': isVisible ? tooltipId : undefined,
    'aria-expanded': enableClick ? isVisible : undefined
  };

  const shouldShow = isVisible && content;

  return (
    <div ref={rootRef} className={rootBaseClass}>
      {asChild ? (
        <div
          {...triggerProps}
          role={enableClick ? "button" : undefined}
          className={triggerClassName || 'inline-flex'}
        >
          {children}
        </div>
      ) : (
        <button
          type="button"
          {...triggerProps}
          aria-label={ariaLabel}
          className={`${triggerBaseClass} ${touchTargetClasses[size]} ${triggerClassName}`.trim()}
        >
          {children || <Info className={iconSizeClasses[size]} />}
        </button>
      )}

      {/* Tooltip Content */}
      {shouldShow && (() => {
        const effectivePosition = adjustedPosition?.position || position;
        const horizontalOffset = adjustedPosition?.horizontalOffset || 0;

        return (
          <div
            role="tooltip"
            id={tooltipId}
            ref={tooltipRef}
            className={`absolute z-50 ${positionClasses[effectivePosition]} max-w-xs`}
            style={horizontalOffset ? { transform: `translateX(calc(-50% + ${horizontalOffset}px))` } : undefined}
          >
            <div className="relative bg-surface-muted text-main text-xs rounded-lg px-3 py-2 shadow-xl border border-primary/20 whitespace-normal">
              {showCloseButton && (
                <button
                  type="button"
                  onClick={hideTooltip}
                  className="absolute top-1 right-1 text-muted hover:text-main focus:outline-none focus-visible:ring-1 focus-visible:ring-accent/60 rounded"
                  aria-label={closeLabel}
                >
                  ×
                </button>
              )}
              {content}
              {/* Arrow */}
              <div
                className={`absolute w-0 h-0 border-4 ${arrowClasses[effectivePosition]}`}
                style={horizontalOffset ? { transform: `translateX(calc(-50% - ${horizontalOffset}px))` } : undefined}
                aria-hidden="true"
              />
            </div>
          </div>
        );
      })()}
    </div>
  );
}
</file>

<file path="src/components/UserMenu.jsx">
import { useEffect, useState, useRef, useCallback } from 'react';
import { SignIn, User, SignOut, BookOpen } from '@phosphor-icons/react';
import { useAuth } from '../contexts/AuthContext';
import { usePreferences } from '../contexts/PreferencesContext';
import AuthModal from './AuthModal';

export function UserMenu({ condensed = false }) {
  const { isAuthenticated, user, logout } = useAuth();
  const { resetOnboarding, onboardingComplete } = usePreferences();
  const [showAuthModal, setShowAuthModal] = useState(false);
  const [showDropdown, setShowDropdown] = useState(false);
  const [analyticsEnabled, setAnalyticsEnabled] = useState(null);
  const [prefsLoading, setPrefsLoading] = useState(false);
  const [prefsError, setPrefsError] = useState(null);
  const dropdownRef = useRef(null);
  const triggerRef = useRef(null);

  const closeDropdown = useCallback(() => {
    setShowDropdown(false);
  }, []);

  const handleLogout = async () => {
    await logout();
    closeDropdown();
    setAnalyticsEnabled(null);
    setPrefsError(null);
  };

  const handleReplayTutorial = () => {
    resetOnboarding();
    closeDropdown();
  };

  // Handle Escape key and click outside
  useEffect(() => {
    if (!showDropdown) return;

    const handleKeyDown = (event) => {
      if (event.key === 'Escape') {
        event.preventDefault();
        closeDropdown();
        // Return focus to trigger button
        triggerRef.current?.focus();
      }
    };

    const handleClickOutside = (event) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target) &&
        triggerRef.current &&
        !triggerRef.current.contains(event.target)
      ) {
        closeDropdown();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('pointerdown', handleClickOutside);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('pointerdown', handleClickOutside);
    };
  }, [showDropdown, closeDropdown]);

  // Fetch analytics preference when dropdown opens
  useEffect(() => {
    if (!isAuthenticated || !showDropdown || prefsLoading || analyticsEnabled !== null) return;
    let cancelled = false;
    const fetchPrefs = async () => {
      setPrefsLoading(true);
      setPrefsError(null);
      try {
        const response = await fetch('/api/archetype-journey', { credentials: 'include' });
        if (cancelled) return;
        if (response.status === 403) {
          await response.json().catch(() => ({}));
          setAnalyticsEnabled(false);
        } else if (response.ok) {
          setAnalyticsEnabled(true);
        } else {
          setPrefsError('Unable to load analytics preference');
          setAnalyticsEnabled(false);
        }
      } catch {
        if (!cancelled) {
          setPrefsError('Unable to load analytics preference');
          setAnalyticsEnabled(false);
        }
      } finally {
        if (!cancelled) setPrefsLoading(false);
      }
    };
    fetchPrefs();
    return () => { cancelled = true; };
  }, [isAuthenticated, showDropdown, prefsLoading, analyticsEnabled]);

  const toggleAnalytics = async () => {
    if (analyticsEnabled === null || prefsLoading) return;
    const next = !analyticsEnabled;
    setPrefsLoading(true);
    setPrefsError(null);
    try {
      const response = await fetch('/api/archetype-journey/preferences', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({ archetype_journey_enabled: next })
      });
      if (!response.ok) {
        throw new Error('Failed to update preference');
      }
      const data = await response.json().catch(() => ({}));
      setAnalyticsEnabled(data?.preferences?.archetype_journey_enabled ?? next);
    } catch {
      setPrefsError('Failed to update');
    } finally {
      setPrefsLoading(false);
    }
  };

  // Get display name - show first initial on very small screens, truncated username on larger
  const getDisplayName = () => {
    if (!user?.username) return '';
    return user.username;
  };

  const getInitial = () => {
    if (!user?.username) return '?';
    return user.username.charAt(0).toUpperCase();
  };

  return (
    <>
      <div className="relative z-40">
        {isAuthenticated ? (
          <div className="relative">
            <button
              ref={triggerRef}
              onClick={() => setShowDropdown(!showDropdown)}
              className={`
                flex items-center gap-1.5 sm:gap-2 min-h-[44px]
                rounded-full border transition text-xs-plus font-semibold text-accent touch-manipulation
                active:scale-[0.98]
                focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60
                focus-visible:ring-offset-2 focus-visible:ring-offset-main
                ${condensed
                  ? 'h-11 w-11 justify-center px-0 bg-surface/80 border-accent/30 hover:bg-surface hover:border-accent/50 active:bg-surface-muted sm:h-auto sm:w-auto sm:px-3 sm:justify-start'
                  : 'px-2 sm:px-3 bg-surface/50 border-accent/20 hover:bg-surface hover:border-accent/40 active:bg-surface-muted'
                }
              `}
              aria-expanded={showDropdown}
              aria-haspopup="menu"
              aria-label={`User menu for ${user?.username || 'account'}`}
            >
              <User className="w-4 h-4 shrink-0" aria-hidden="true" />
              {/* Mobile: show initial only, tablet+: show truncated username */}
              {!condensed && <span className="xs:hidden text-xs font-bold">{getInitial()}</span>}
              <span className={`${condensed ? 'hidden sm:inline' : 'hidden xs:inline'} max-w-[60px] sm:max-w-[80px] md:max-w-[100px] truncate text-xs sm:text-xs-plus`}>
                {getDisplayName()}
              </span>
            </button>

            {showDropdown && (
              <>
                {/* Backdrop for mobile */}
                <div
                  className="fixed inset-0 z-40 bg-black/20 sm:bg-transparent"
                  onClick={closeDropdown}
                  aria-hidden="true"
                />
                <div
                  ref={dropdownRef}
                  role="menu"
                  aria-label="User menu"
                  className="
                    absolute right-0 mt-2 w-56 sm:w-48 py-1
                    bg-surface border border-accent/20 rounded-xl
                    shadow-xl z-50 animate-fade-in
                    max-h-[calc(100vh-120px)] overflow-y-auto
                  "
                >
                  {/* User info header */}
                  <div className="px-4 py-3 border-b border-accent/10">
                    <p className="text-xs text-muted">Signed in as</p>
                    <p className="text-sm font-semibold text-accent truncate">{user?.username}</p>
                    {user?.email && (
                      <p className="text-[11px] text-muted/70 truncate mt-0.5">{user.email}</p>
                    )}
                  </div>

                  {/* Analytics toggle */}
                  <div className="px-4 py-3 border-b border-accent/10 space-y-2">
                    <div className="flex items-center justify-between gap-3">
                      <label htmlFor="analytics-toggle" className="flex-1 min-w-0">
                        <p className="text-sm font-semibold text-accent">Archetype Journey</p>
                        <p className="text-[11px] text-muted leading-tight">Track recurring cards</p>
                      </label>
                      <button
                        id="analytics-toggle"
                        role="switch"
                        onClick={toggleAnalytics}
                        disabled={prefsLoading || analyticsEnabled === null}
                        className={`
                          relative inline-flex h-7 w-12 shrink-0 items-center rounded-full
                          transition-colors touch-manipulation
                          focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/60
                          focus-visible:ring-offset-2 focus-visible:ring-offset-surface
                          ${analyticsEnabled ? 'bg-primary' : 'bg-secondary/30'}
                          ${prefsLoading || analyticsEnabled === null ? 'opacity-60 cursor-not-allowed' : 'cursor-pointer'}
                        `}
                        aria-checked={analyticsEnabled === true}
                        aria-label="Toggle archetype journey analytics"
                      >
                        <span
                          className={`
                            inline-block h-5 w-5 transform rounded-full bg-white shadow-sm
                            transition-transform duration-200
                            ${analyticsEnabled ? 'translate-x-6' : 'translate-x-1'}
                          `}
                          aria-hidden="true"
                        />
                      </button>
                    </div>
                    {prefsError && (
                      <p className="text-[11px] text-error" role="alert">{prefsError}</p>
                    )}
                  </div>

                  {/* Replay Tutorial */}
                  <button
                    role="menuitem"
                    onClick={handleReplayTutorial}
                    className="
                      w-full text-left px-4 py-3 min-h-[44px]
                      text-sm text-accent hover:bg-accent/5 active:bg-accent/10
                      flex items-center gap-2 touch-manipulation
                      focus-visible:outline-none focus-visible:bg-accent/5
                      border-b border-accent/10
                    "
                  >
                    <BookOpen className="w-4 h-4" aria-hidden="true" />
                    Replay Tutorial
                  </button>

                  {/* Sign out */}
                  <button
                    role="menuitem"
                    onClick={handleLogout}
                    className="
                      w-full text-left px-4 py-3 min-h-[44px]
                      text-sm text-accent hover:bg-accent/5 active:bg-accent/10
                      flex items-center gap-2 touch-manipulation
                      focus-visible:outline-none focus-visible:bg-accent/5
                    "
                  >
                    <SignOut className="w-4 h-4" aria-hidden="true" />
                    Sign Out
                  </button>
                </div>
              </>
            )}
          </div>
        ) : (
          <div className="flex items-center gap-2">
            {onboardingComplete && (
              <button
                onClick={handleReplayTutorial}
                className="
                  flex items-center justify-center min-w-[44px] min-h-[44px]
                  rounded-full bg-surface/50 border border-accent/20
                  text-accent hover:bg-surface hover:border-accent/40 active:bg-surface-muted
                  transition touch-manipulation
                  focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/60
                  focus-visible:ring-offset-2 focus-visible:ring-offset-main
                "
                aria-label="Replay tutorial"
                title="Replay Tutorial"
              >
                <BookOpen className="w-4 h-4" aria-hidden="true" />
              </button>
            )}
            <button
              onClick={() => setShowAuthModal(true)}
              className="
                flex items-center gap-1.5 px-3 sm:px-4 min-h-[44px]
                rounded-full bg-primary text-surface
                hover:bg-primary/90 active:bg-primary/80 active:scale-[0.98]
                shadow-sm shadow-primary/20 transition
                text-xs-plus font-semibold touch-manipulation
                focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/60
                focus-visible:ring-offset-2 focus-visible:ring-offset-main
              "
            >
              <SignIn className="w-4 h-4" aria-hidden="true" />
              <span>Sign In</span>
            </button>
          </div>
        )}
      </div>

      <AuthModal isOpen={showAuthModal} onClose={() => setShowAuthModal(false)} />
    </>
  );
}
</file>

<file path="src/components/VisionHeatmapOverlay.jsx">
import { useMemo, useState } from 'react';

/**
 * Generate heatmap cell background color using CSS custom property for theme consistency.
 * Falls back to emerald green if CSS variable unavailable.
 * @param {number} value - Intensity value between 0 and 1
 * @returns {string} CSS color string
 */
function cellColor(value) {
  // Clamp and validate input
  const safeValue = Number.isFinite(value) ? Math.min(1, Math.max(0, value)) : 0;
  const alpha = Math.min(0.85, safeValue * 0.9);
  // Use CSS custom property with fallback for theme consistency
  return `rgba(var(--color-accent-rgb, 16, 185, 129), ${alpha.toFixed(3)})`;
}

/**
 * Generate stable key for focus region lookup
 */
function focusKey(x, y) {
  return `${x}-${y}`;
}

export function VisionHeatmapOverlay({ attention, imageSrc, label }) {
  const [visible, setVisible] = useState(true);
  const hasHeatmap = Boolean(attention?.heatmap && imageSrc);

  // Extract focusRegions to a stable reference for React Compiler compatibility
  const focusRegions = attention?.focusRegions;

  // Memoize focus region lookup Set to prevent recreation on every render
  const focusLookup = useMemo(() => {
    if (!Array.isArray(focusRegions)) return new Set();
    return new Set(
      focusRegions.map((region) => focusKey(region.x, region.y))
    );
  }, [focusRegions]);

  if (!hasHeatmap) {
    return null;
  }

  const gridSize = attention.gridSize || attention.heatmap.length || 0;
  if (!gridSize) return null;

  return (
    <div className="mt-3 animate-fade-in">
      <div className="flex items-center justify-between gap-3 text-xs text-secondary/80">
        <div>
          <p className="font-semibold text-secondary">Interpretability heatmap</p>
          <p className="text-muted">Shows where the detector concentrated when matching symbols.</p>
        </div>
        <button
          type="button"
          onClick={() => setVisible((prev) => !prev)}
          aria-pressed={visible}
          aria-controls="heatmap-overlay-grid"
          className="min-h-[44px] min-w-[44px] flex-shrink-0 rounded-md border border-secondary/40 px-3 py-2 text-xs uppercase tracking-wide text-secondary/80 transition-colors hover:border-secondary/70 hover:bg-secondary/10 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/50 focus-visible:ring-offset-1 focus-visible:ring-offset-surface"
        >
          {visible ? 'Hide' : 'Show'}
        </button>
      </div>
      <div className="mt-2 rounded-lg border border-secondary/40 bg-black/20 p-2">
        <div className="relative">
          <img
            src={imageSrc}
            alt={label || 'Uploaded card'}
            className="block w-full rounded"
          />
          {visible && (
            <div
              id="heatmap-overlay-grid"
              className="pointer-events-none absolute inset-0 grid mix-blend-screen"
              style={{
                gridTemplateColumns: `repeat(${gridSize}, minmax(0, 1fr))`,
                gridTemplateRows: `repeat(${gridSize}, minmax(0, 1fr))`
              }}
            >
              {attention.heatmap.flatMap((row, rowIndex) =>
                row.map((value, colIndex) => {
                  const key = focusKey(colIndex, rowIndex);
                  return (
                    <div
                      key={`${colIndex}-${rowIndex}`}
                      className={`border ${focusLookup.has(key) ? 'border-secondary/70' : 'border-transparent'}`}
                      style={{
                        backgroundColor: cellColor(value)
                      }}
                    />
                  );
                })
              )}
            </div>
          )}
        </div>
        {attention.focusRegions?.length > 0 && (
          <div className="mt-2 grid grid-cols-2 gap-2 text-xs text-secondary/70">
            {attention.focusRegions.slice(0, 4).map((region) => (
              <div
                key={`${label || 'heatmap'}-region-${region.x}-${region.y}`}
                className="rounded border border-secondary/20 px-2 py-1.5"
              >
                <span className="sr-only">Focus region at </span>
                Cell ({region.x}, {region.y}) · {(region.intensity * 100).toFixed(0)}%
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}
</file>

<file path="src/components/VisionValidationPanel.jsx">
import { useState, useRef, useCallback } from 'react';
import { useVisionValidation } from '../hooks/useVisionValidation';
import { VisionHeatmapOverlay } from './VisionHeatmapOverlay';
import { PhotoInputModal } from './PhotoInputModal';
import { CameraCapture } from './CameraCapture';

/** Maximum number of images allowed for vision validation */
const MAX_UPLOADS = 5;
/** Maximum file size in bytes (10MB) */
const MAX_FILE_SIZE = 10 * 1024 * 1024;
/** Allowed MIME type prefix */
const ALLOWED_TYPE_PREFIX = 'image/';

/**
 * Validates a file for type and size constraints
 * @param {File} file - File to validate
 * @returns {{ valid: boolean, reason?: string }}
 */
function validateFile(file) {
  if (!file.type.startsWith(ALLOWED_TYPE_PREFIX)) {
    return { valid: false, reason: `"${file.name}" is not an image file` };
  }
  if (file.size > MAX_FILE_SIZE) {
    const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
    return { valid: false, reason: `"${file.name}" is too large (${sizeMB}MB, max 10MB)` };
  }
  return { valid: true };
}

export function VisionValidationPanel({
  deckStyle = 'rws-1909',
  onResults,
  onRemoveResult,
  onClearResults,
  conflicts = [],
  results = []
}) {
  const { status, error, validateFiles } = useVisionValidation({ deckStyle });
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [isCameraOpen, setIsCameraOpen] = useState(false);
  const [localError, setLocalError] = useState(null);
  const fileInputRef = useRef(null);
  const uploadLimitReached = results.length >= MAX_UPLOADS;
  const remainingSlots = MAX_UPLOADS - results.length;

  const handleFileChange = useCallback(async (event) => {
    const inputEl = event.target;
    const files = Array.from(inputEl?.files || []);

    // Reset input immediately to allow re-selecting same file
    if (inputEl) inputEl.value = '';

    if (files.length === 0) return;

    // Clear previous local errors
    setLocalError(null);

    // Validate all files
    const validationResults = files.map(validateFile);
    const invalidFiles = validationResults.filter(r => !r.valid);

    if (invalidFiles.length > 0) {
      setLocalError(invalidFiles.map(r => r.reason).join('. '));
      return;
    }

    // Limit files to remaining slots
    const filesToProcess = files.slice(0, remainingSlots);
    if (filesToProcess.length < files.length) {
      setLocalError(`Only ${remainingSlots} slot${remainingSlots !== 1 ? 's' : ''} remaining. ${files.length - filesToProcess.length} file(s) skipped.`);
    }

    if (filesToProcess.length === 0) return;

    try {
      const analyses = await validateFiles(filesToProcess);
      if (analyses.length) {
        onResults?.(analyses);
      }
    } catch (err) {
      setLocalError(`Analysis failed: ${err.message || 'Unknown error'}`);
    }
  }, [validateFiles, onResults, remainingSlots]);

  const handleChooseFromLibrary = () => {
    setIsModalOpen(false);
    fileInputRef.current?.click();
  };

  const handleTakePhoto = () => {
    setIsModalOpen(false);
    setIsCameraOpen(true);
  };

  const handleCapture = async (files) => {
    setIsCameraOpen(false);
    if (!files || files.length === 0) return;
    try {
      const analyses = await validateFiles(files);
      if (analyses.length) {
        onResults?.(analyses);
      }
    } catch (err) {
      console.error('Error processing captured image:', err);
    }
  };

  return (
    <div className="modern-surface border border-primary/30 p-3 xs:p-4 sm:p-5 animate-fade-in">
      <div className="flex flex-col gap-3 sm:flex-row sm:items-start sm:justify-between">
        <div className="min-w-0 flex-1">
          <p className="text-sm text-main font-semibold">Vision Research Console</p>
          <p className="text-xs text-muted leading-relaxed">
            Upload card photos to test vision model recognition. Compares uploads against the active deck&rsquo;s embeddings.
          </p>
        </div>
        <div className="flex flex-wrap items-center gap-2 text-sm font-medium text-secondary">
          {results.length > 0 && (
            <button
              type="button"
              onClick={() => onClearResults?.()}
              className="min-h-[44px] min-w-[44px] px-3 py-2 rounded-lg border border-accent/30 text-main/90 hover:border-accent/60 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/50 transition-colors touch-manipulation text-xs xs:text-sm"
            >
              Clear
            </button>
          )}
          <input
            ref={fileInputRef}
            type="file"
            accept="image/*"
            multiple
            onChange={handleFileChange}
            className="hidden"
            disabled={uploadLimitReached}
            aria-describedby={uploadLimitReached ? 'upload-limit-info' : undefined}
          />
          <button
            type="button"
            onClick={() => setIsModalOpen(true)}
            disabled={uploadLimitReached || status === 'loading'}
            aria-haspopup="dialog"
            aria-expanded={isModalOpen}
            aria-describedby="upload-limit-info"
            className={`min-h-[44px] min-w-[44px] px-3 py-2 rounded-lg border border-secondary/40 transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-accent/50 touch-manipulation text-xs xs:text-sm ${
              uploadLimitReached || status === 'loading'
                ? 'opacity-60 cursor-not-allowed'
                : 'hover:border-secondary/70 hover:bg-secondary/10 active:bg-secondary/20'
            }`}
          >
            {status === 'loading'
              ? 'Analyzing…'
              : uploadLimitReached
                ? `Limit reached`
                : `Add Photo${remainingSlots < MAX_UPLOADS ? ` (${remainingSlots})` : ''}`}
          </button>
          <span id="upload-limit-info" className="sr-only">
            {uploadLimitReached
              ? `Maximum ${MAX_UPLOADS} images allowed. Remove an image to add more.`
              : `${remainingSlots} of ${MAX_UPLOADS} upload slots remaining.`}
          </span>
        </div>
      </div>
      {isModalOpen && (
        <PhotoInputModal
          onTakePhoto={handleTakePhoto}
          onChooseFromLibrary={handleChooseFromLibrary}
          onCancel={() => setIsModalOpen(false)}
        />
      )}
      {isCameraOpen && (
        <CameraCapture
          onCapture={handleCapture}
          onCancel={() => setIsCameraOpen(false)}
        />
      )}
      {(error || localError) && (
        <p role="alert" className="mt-2 text-xs text-error">
          {error || localError}
        </p>
      )}
      {conflicts.length > 0 && (
        <div className="mt-3 rounded border border-error/40 bg-error/20 p-3 text-xs text-main">
          <p className="font-semibold">Card mismatch detected</p>
          <p>Please confirm the following cards before generating a reading:</p>
          <ul className="mt-1 list-disc list-inside">
            {conflicts.map((conflict) => (
              <li key={conflict.uploadId || conflict.label || conflict.imagePath}>
                {conflict.label || 'Uploaded image'} was recognized as <strong>{conflict.topMatch?.cardName || 'unknown'}</strong>
              </li>
            ))}
          </ul>
        </div>
      )}
      {results.length > 0 && (
        <ul role="list" className="mt-4 space-y-3" aria-label="Vision analysis results">
          {results.map((result) => (
            <li
              key={result.uploadId || result.label || result.imagePath}
              className="rounded border border-secondary/20 p-3"
            >
              <div className="flex items-center justify-between text-sm text-secondary">
                <span className="font-medium">{result.label || 'Uploaded image'}</span>
                <div className="flex items-center gap-3">
                  <span className="text-muted">
                    Confidence:{' '}
                    <span className={typeof result.confidence === 'number' && result.confidence >= 0.7 ? 'text-accent' : ''}>
                      {typeof result.confidence === 'number'
                        ? `${(result.confidence * 100).toFixed(1)}%`
                        : 'n/a'}
                    </span>
                  </span>
                  <button
                    type="button"
                    onClick={() => onRemoveResult?.(result.uploadId || result.label)}
                    className="min-h-[44px] min-w-[44px] px-2 text-sm text-error/80 hover:text-error focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-error/50 rounded transition-colors"
                    aria-label={`Remove ${result.label || 'uploaded image'}`}
                  >
                    Remove
                  </button>
                </div>
              </div>
              {Array.isArray(result.matches) && result.matches.length > 0 && (
                <ul className="mt-2 text-xs text-muted">
                  {result.matches.map((match) => (
                    <li key={`${result.label}-${match.cardName}`}>
                      {match.cardName}
                      {' '}
                      ·
                      {' '}
                      {typeof match.score === 'number' ? `${(match.score * 100).toFixed(1)}%` : 'n/a'}
                    </li>
                  ))}
                </ul>
              )}
              {result.attention?.focusRegions?.length > 0 && (
                <div className="mt-2 text-xs text-secondary/70">
                  <p className="font-semibold text-secondary">Model focus</p>
                  <p className="mb-1 text-muted">Highlight patches where CLIP paid the most attention.</p>
                  <div className="flex flex-wrap gap-2">
                    {result.attention.focusRegions.slice(0, 4).map((region) => (
                      <span
                        key={`${result.label || 'result'}-region-${region.x}-${region.y}`}
                        className="px-2 py-1 rounded-full border border-secondary/30"
                      >
                        ({region.x}, {region.y}) · {(region.intensity * 100).toFixed(0)}%
                      </span>
                    ))}
                  </div>
                </div>
              )}
              <VisionHeatmapOverlay
                attention={result.attention}
                imageSrc={result.dataUrl || result.imagePath}
                label={result.label}
              />
              {Array.isArray(result.attention?.symbolAlignment) && result.attention.symbolAlignment.length > 0 && (
                <div className="mt-2 text-xs text-secondary/70">
                  <p className="font-semibold text-secondary">Symbol alignment</p>
                  <ul className="list-disc list-inside space-y-1">
                    {result.attention.symbolAlignment.slice(0, 3).map((symbol) => (
                      <li key={`${result.label || 'result'}-symbol-${symbol.object}`}>
                        {symbol.object}
                        {' '}· focus {(symbol.attentionScore * 100).toFixed(0)}%
                        {symbol.isModelFocused && (
                          <span className="ml-1" aria-label="Model focused on this symbol">✅</span>
                        )}
                      </li>
                    ))}
                  </ul>
                </div>
              )}
              {result.symbolVerification && (
                <div className="mt-2 text-xs text-secondary/70">
                  <p className="font-semibold text-secondary">Symbol verification</p>
                  <p>
                    Match rate:{' '}
                    <span className={typeof result.symbolVerification.matchRate === 'number' && result.symbolVerification.matchRate >= 0.7 ? 'text-accent' : ''}>
                      {typeof result.symbolVerification.matchRate === 'number'
                        ? `${(result.symbolVerification.matchRate * 100).toFixed(0)}%`
                        : 'n/a'}
                    </span>
                  </p>
                  {Array.isArray(result.symbolVerification.missingSymbols) && result.symbolVerification.missingSymbols.length > 0 && (
                    <p className="mt-1 text-error/80">
                      Missing: {result.symbolVerification.missingSymbols.join(', ')}
                    </p>
                  )}
                  {Array.isArray(result.symbolVerification.unexpectedDetections) && result.symbolVerification.unexpectedDetections.length > 0 && (
                    <p className="mt-1 text-muted">
                      Extra objects: {result.symbolVerification.unexpectedDetections.map((det) => det.label).join(', ')}
                    </p>
                  )}
                </div>
              )}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
</file>

<file path="src/contexts/AuthContext.jsx">
import { createContext, useContext, useState, useEffect } from 'react';

const AuthContext = createContext(null);

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Check if user is authenticated on mount
  useEffect(() => {
    checkAuth();
  }, []);

  const checkAuth = async () => {
    try {
      const response = await fetch('/api/auth/me', {
        credentials: 'include' // Include cookies
      });

      if (response.ok) {
        const data = await response.json();
        setUser(data.user);
      } else {
        setUser(null);
      }
    } catch (err) {
      console.error('Auth check failed:', err);
      setUser(null);
    } finally {
      setLoading(false);
    }
  };

  const register = async (email, username, password) => {
    setError(null);
    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        credentials: 'include',
        body: JSON.stringify({ email, username, password })
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Registration failed');
      }

      setUser(data.user);
      return { success: true, user: data.user };
    } catch (err) {
      setError(err.message);
      return { success: false, error: err.message };
    }
  };

  const login = async (email, password) => {
    setError(null);
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        credentials: 'include',
        body: JSON.stringify({ email, password })
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Login failed');
      }

      setUser(data.user);
      return { success: true, user: data.user };
    } catch (err) {
      setError(err.message);
      return { success: false, error: err.message };
    }
  };

  const logout = async () => {
    setError(null);
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include'
      });

      setUser(null);
      return { success: true };
    } catch (err) {
      setError(err.message);
      return { success: false, error: err.message };
    }
  };

  const value = {
    user,
    loading,
    error,
    isAuthenticated: !!user,
    register,
    login,
    logout,
    checkAuth
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}
</file>

<file path="src/contexts/PreferencesContext.jsx">
import { createContext, useContext, useState, useEffect, useMemo } from 'react';
import { MAJOR_ARCANA } from '../data/majorArcana';
import { getDeckPool } from '../lib/deck';
import { initAudio, cleanupAudio, stopTTS, toggleAmbience } from '../lib/audio';

const PreferencesContext = createContext(null);

const PREPARE_SECTIONS_STORAGE_KEY = 'tarot-prepare-sections';
const ONBOARDING_STORAGE_KEY = 'tarot-onboarding-complete';
const PERSONALIZATION_STORAGE_KEY = 'tarot-personalization';
const PERSONALIZATION_BANNER_KEY = 'tarot-personalization-banner';
const DEFAULT_PREPARE_SECTIONS = {
  intention: false,
  experience: false,
  ritual: false,
  audio: false
};

const DEFAULT_PERSONALIZATION = {
  displayName: '',
  tarotExperience: 'newbie',
  readingTone: 'balanced',
  focusAreas: [],
  preferredSpreadDepth: 'standard',
  spiritualFrame: 'mixed',
  showRitualSteps: true
};

export function PreferencesProvider({ children }) {
  // --- Theme ---
  const [theme, setTheme] = useState(() => {
    if (typeof localStorage !== 'undefined') {
      return localStorage.getItem('tarot-theme') || 'dark';
    }
    return 'dark';
  });

  useEffect(() => {
    const root = typeof document !== 'undefined' ? document.documentElement : null;
    if (root) {
      root.classList.remove('light-mode');
      root.classList.toggle('light', theme === 'light');
    }
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem('tarot-theme', theme);
    }
    if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function') {
      try {
        window.dispatchEvent(new CustomEvent('tarot-theme-change', { detail: { theme } }));
      } catch (error) {
        console.debug('Unable to broadcast theme change', error);
      }
    }
  }, [theme]);

  // --- Audio: Voice ---
  const [voiceOn, setVoiceOn] = useState(() => {
    if (typeof localStorage !== 'undefined') {
      const saved = localStorage.getItem('tarot-voice-enabled');
      return saved === 'true';
    }
    return false;
  });

  // Persist voice setting
  useEffect(() => {
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem('tarot-voice-enabled', voiceOn.toString());
    }
    // If turned off, stop any current narration
    if (!voiceOn) {
      stopTTS();
    }
  }, [voiceOn]);

  // --- Audio: Auto-narrate on first view ---
  const [autoNarrate, setAutoNarrate] = useState(() => {
    if (typeof localStorage !== 'undefined') {
      const saved = localStorage.getItem('tarot-auto-narrate');
      // Default to true if not set
      return saved === null ? true : saved === 'true';
    }
    return true;
  });

  // Persist auto-narrate setting
  useEffect(() => {
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem('tarot-auto-narrate', autoNarrate.toString());
    }
  }, [autoNarrate]);

  // --- Audio: TTS Provider (azure or hume) ---
  const [ttsProvider, setTtsProvider] = useState(() => {
    if (typeof localStorage !== 'undefined') {
      const saved = localStorage.getItem('tarot-tts-provider');
      return saved || 'hume'; // Default to Hume for expressive readings
    }
    return 'hume';
  });

  // Persist TTS provider setting
  useEffect(() => {
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem('tarot-tts-provider', ttsProvider);
    }
  }, [ttsProvider]);

  // --- Audio: Ambience ---
  const [ambienceOn, setAmbienceOn] = useState(() => {
    if (typeof localStorage !== 'undefined') {
      const saved = localStorage.getItem('tarot-ambience-enabled');
      return saved === 'true';
    }
    return false;
  });

  // Persist ambience setting and toggle audio
  useEffect(() => {
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem('tarot-ambience-enabled', ambienceOn.toString());
    }
    toggleAmbience(ambienceOn);
  }, [ambienceOn]);

  // Initialize audio on mount
  useEffect(() => {
    initAudio();
    // We don't cleanup here because this context wraps the app and we might want audio to persist
    // or we rely on app unmount. However, standard practice is usually cleanup on unmount.
    return () => {
      cleanupAudio();
    };
  }, []);

  // --- Deck Style ---
  const [deckStyleId, setDeckStyleId] = useState(() => {
    if (typeof localStorage !== 'undefined') {
      const saved = localStorage.getItem('tarot-deck-style');
      return saved || 'rws-1909';
    }
    return 'rws-1909';
  });

  useEffect(() => {
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem('tarot-deck-style', deckStyleId);
    }
  }, [deckStyleId]);

  // --- Deck Scope & Composition ---
  const [includeMinors, setIncludeMinors] = useState(true); // Default to full 78 cards

  // Computed deck properties
  const { deckSize, minorsDataIncomplete } = useMemo(() => {
    const pool = getDeckPool(includeMinors);
    return {
      deckSize: pool.length,
      minorsDataIncomplete: includeMinors && pool.length === MAJOR_ARCANA.length
    };
  }, [includeMinors]);

  // --- Reversal Framework ---
  // Not persisted by default in original code, but kept as state
  const [reversalFramework, setReversalFramework] = useState(null);

  // --- Personalization Preferences ---
  const [personalization, setPersonalizationState] = useState(() => {
    if (typeof localStorage !== 'undefined') {
      try {
        const stored = localStorage.getItem(PERSONALIZATION_STORAGE_KEY);
        if (stored) {
          const parsed = JSON.parse(stored);
          return { ...DEFAULT_PERSONALIZATION, ...parsed };
        }
      } catch (error) {
        console.debug('Unable to load personalization:', error);
      }
    }
    return { ...DEFAULT_PERSONALIZATION };
  });

  // Persist personalization changes
  useEffect(() => {
    if (typeof localStorage !== 'undefined') {
      try {
        localStorage.setItem(PERSONALIZATION_STORAGE_KEY, JSON.stringify(personalization));
      } catch (error) {
        console.debug('Unable to persist personalization:', error);
      }
    }
  }, [personalization]);

  // Individual setters for personalization fields
  const setDisplayName = (value) => {
    setPersonalizationState(prev => ({ ...prev, displayName: value }));
  };

  const setTarotExperience = (value) => {
    setPersonalizationState(prev => ({ ...prev, tarotExperience: value }));
  };

  const setReadingTone = (value) => {
    setPersonalizationState(prev => ({ ...prev, readingTone: value }));
  };

  const setFocusAreas = (value) => {
    setPersonalizationState(prev => ({ ...prev, focusAreas: value }));
  };

  const setPreferredSpreadDepth = (value) => {
    setPersonalizationState(prev => ({ ...prev, preferredSpreadDepth: value }));
  };

  const setSpiritualFrame = (value) => {
    setPersonalizationState(prev => ({ ...prev, spiritualFrame: value }));
  };

  const setShowRitualSteps = (value) => {
    setPersonalizationState(prev => ({ ...prev, showRitualSteps: value }));
  };

  // Toggle a focus area (for multi-select)
  const toggleFocusArea = (area) => {
    setPersonalizationState(prev => {
      const current = prev.focusAreas || [];
      if (current.includes(area)) {
        return { ...prev, focusAreas: current.filter(a => a !== area) };
      } else {
        return { ...prev, focusAreas: [...current, area] };
      }
    });
  };

  // --- UI State: Prepare Sections ---
  const [prepareSectionsOpen, setPrepareSectionsOpen] = useState(() => {
    if (typeof sessionStorage === 'undefined') {
      return { ...DEFAULT_PREPARE_SECTIONS };
    }
    try {
      const stored = sessionStorage.getItem(PREPARE_SECTIONS_STORAGE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        return { ...DEFAULT_PREPARE_SECTIONS, ...parsed };
      }
    } catch (error) {
      console.debug('Unable to load prepare panel state:', error);
    }
    return { ...DEFAULT_PREPARE_SECTIONS };
  });

  useEffect(() => {
    if (typeof sessionStorage === 'undefined') return;
    try {
      sessionStorage.setItem(
        PREPARE_SECTIONS_STORAGE_KEY,
        JSON.stringify(prepareSectionsOpen)
      );
    } catch (error) {
      console.debug('Unable to persist prepare panel state:', error);
    }
  }, [prepareSectionsOpen]);

  const togglePrepareSection = (section) => {
    setPrepareSectionsOpen(prev => ({
      ...prev,
      [section]: !prev[section]
    }));
  };

  // --- Onboarding State ---
  const [onboardingComplete, setOnboardingCompleteState] = useState(() => {
    if (typeof localStorage !== 'undefined') {
      return localStorage.getItem(ONBOARDING_STORAGE_KEY) === 'true';
    }
    return false;
  });

  const [onboardingSpreadKey, setOnboardingSpreadKey] = useState(null);

  // Initialize personalization banner visibility based on localStorage
  // Using lazy initializer avoids needing an effect to set initial state
  const [showPersonalizationBanner, setShowPersonalizationBanner] = useState(() => {
    if (typeof localStorage === 'undefined') return false;
    try {
      const hasReadings = localStorage.getItem('tarot_journal');
      const hasCompletedOnboarding = localStorage.getItem(ONBOARDING_STORAGE_KEY) === 'true';
      const bannerDismissed = localStorage.getItem(PERSONALIZATION_BANNER_KEY) === 'dismissed';
      // Show banner if user has readings but hasn't completed onboarding and hasn't dismissed
      return !!(hasReadings && !hasCompletedOnboarding && !bannerDismissed);
    } catch (error) {
      console.debug('Unable to evaluate personalization banner state:', error);
      return false;
    }
  });

  const setOnboardingComplete = (value) => {
    setOnboardingCompleteState(value);
    if (typeof localStorage !== 'undefined') {
      localStorage.setItem(ONBOARDING_STORAGE_KEY, value.toString());
    }
  };

  const resetOnboarding = () => {
    setOnboardingComplete(false);
    setOnboardingSpreadKey(null);
  };

  const value = {
    theme,
    setTheme,
    voiceOn,
    setVoiceOn,
    ambienceOn,
    setAmbienceOn,
    autoNarrate,
    setAutoNarrate,
    ttsProvider,
    setTtsProvider,
    deckStyleId,
    setDeckStyleId,
    includeMinors,
    setIncludeMinors,
    deckSize,
    minorsDataIncomplete,
    reversalFramework,
    setReversalFramework,
    prepareSectionsOpen,
    togglePrepareSection,
    // Personalization
    personalization,
    setDisplayName,
    setTarotExperience,
    setReadingTone,
    setFocusAreas,
    setPreferredSpreadDepth,
    setSpiritualFrame,
    setShowRitualSteps,
    toggleFocusArea,
    // Onboarding
    onboardingComplete,
    setOnboardingComplete,
    onboardingSpreadKey,
    setOnboardingSpreadKey,
    resetOnboarding,
    showPersonalizationBanner,
    setShowPersonalizationBanner
  };

  return (
    <PreferencesContext.Provider value={value}>
      {children}
    </PreferencesContext.Provider>
  );
}

// eslint-disable-next-line react-refresh/only-export-components -- Context + hook pattern is intentional
export function usePreferences() {
  const context = useContext(PreferencesContext);
  if (!context) {
    throw new Error('usePreferences must be used within a PreferencesProvider');
  }
  return context;
}
</file>

<file path="src/contexts/ReadingContext.jsx">
import { createContext, useContext, useState, useCallback, useMemo, useRef } from 'react';
import { useTarotState } from '../hooks/useTarotState';
import { useVisionAnalysis } from '../hooks/useVisionAnalysis';
import { useAudioController } from '../hooks/useAudioController';
import { usePreferences } from './PreferencesContext';
import { getSpreadInfo, normalizeSpreadKey } from '../data/spreads';
import { MAJOR_ARCANA } from '../data/majorArcana';
import { MINOR_ARCANA } from '../data/minorArcana';
import { formatReading } from '../lib/formatting';
import { canonicalCardKey, canonicalizeCardName } from '../../shared/vision/cardNameMapping.js';
import { computeRelationships } from '../lib/deck';
import { safeParseReadingRequest } from '../../shared/contracts/readingSchema.js';

const ReadingContext = createContext(null);

export function ReadingProvider({ children }) {
    // 1. Audio Controller
    const audioController = useAudioController();
    const { speak } = audioController;

    // 2. Core Tarot State
    const tarotState = useTarotState(speak);
    const {
        reading,
        selectedSpread,
        userQuestion,
        revealedCards,
        shuffle,
        dealIndex,
        dealNext: baseDealNext,
        revealCard: baseRevealCard,
        revealAll: baseRevealAll,
        sessionSeed
    } = tarotState;
    const { deckStyleId, includeMinors, reversalFramework, personalization } = usePreferences();

    // 3. Vision Analysis
    const visionAnalysis = useVisionAnalysis(reading);
    const { visionResults, visionConflicts, resetVisionProof: _resetVisionProof, ensureVisionProof, getVisionConflictsForCards, setVisionConflicts } = visionAnalysis;

    const personalizationForRequest = useMemo(() => {
        if (!personalization || typeof personalization !== 'object') {
            return null;
        }
        const sanitizedName =
            typeof personalization.displayName === 'string'
                ? personalization.displayName.trim()
                : '';

        const focusAreas = Array.isArray(personalization.focusAreas)
            ? personalization.focusAreas
                .map((area) => (typeof area === 'string' ? area.trim() : ''))
                .filter((area) => area.length > 0)
            : [];

        const payload = {
            displayName: sanitizedName || undefined,
            readingTone: personalization.readingTone || undefined,
            spiritualFrame: personalization.spiritualFrame || undefined,
            tarotExperience: personalization.tarotExperience || undefined,
            preferredSpreadDepth: personalization.preferredSpreadDepth || undefined,
            focusAreas: focusAreas.length ? focusAreas : undefined
        };

        return Object.values(payload).some((value) => value !== undefined) ? payload : null;
    }, [personalization]);

    // 4. Reading Generation State
    const [personalReading, setPersonalReading] = useState(null);
    const [isGenerating, setIsGenerating] = useState(false);
    const [narrativePhase, setNarrativePhase] = useState('idle');
    const [spreadAnalysis, setSpreadAnalysis] = useState(null);
    const [themes, setThemes] = useState(null);
    const [emotionalTone, setEmotionalTone] = useState(null);
    const [analysisContext, setAnalysisContext] = useState(null);
    const [readingMeta, setReadingMeta] = useState({
        requestId: null,
        provider: null,
        spreadKey: null,
        spreadName: null,
        deckStyle: null,
        userQuestion: null,
        graphContext: null
    });

    // 5. UI State
    const [journalStatus, setJournalStatus] = useState(null);
    const [reflections, setReflections] = useState({});
    const [lastCardsForFeedback, setLastCardsForFeedback] = useState([]);
    const [showAllHighlights, setShowAllHighlights] = useState(false);
    const [srAnnouncement, setSrAnnouncement] = useState('');

    const visionResearchEnabled = import.meta.env?.VITE_ENABLE_VISION_RESEARCH === 'true';
    const inFlightReadingRef = useRef(null);

    const cancelInFlightReading = useCallback(() => {
        if (inFlightReadingRef.current?.controller) {
            inFlightReadingRef.current.controller.abort();
        }
        inFlightReadingRef.current = null;
    }, []);

    // Reset analysis state when Shuffle is triggered
    const handleShuffle = useCallback(() => {
        cancelInFlightReading();
        shuffle(() => {
            setPersonalReading(null);
            setThemes(null);
            setEmotionalTone(null);
            setSpreadAnalysis(null);
            setAnalysisContext(null);
            setIsGenerating(false);
            setNarrativePhase('idle');
            setJournalStatus(null);
            setReflections({});
            visionAnalysis.setVisionResults([]);
            visionAnalysis.setVisionConflicts([]);
            visionAnalysis.resetVisionProof();
            setShowAllHighlights(false);
            setSrAnnouncement('');
        });
    }, [shuffle, visionAnalysis, cancelInFlightReading]);

    // Generate Personal Reading Logic
    const generatePersonalReading = useCallback(async () => {
        if (!reading || reading.length === 0) {
            const errorMsg = 'Please draw your cards before requesting a personalized reading.';
            const formattedError = formatReading(errorMsg);
            formattedError.isError = true;
            setPersonalReading(formattedError);
            setJournalStatus({
                type: 'error',
                message: 'Draw and reveal your cards before requesting a personalized narrative.'
            });
            setNarrativePhase('error');
            setSrAnnouncement('Please draw and reveal your cards before requesting a personalized narrative.');
            return;
        }
        if (isGenerating) return;

        cancelInFlightReading();
        const controller = new AbortController();
        inFlightReadingRef.current = { controller, sessionSeed };

        setIsGenerating(true);
        setPersonalReading(null);
        setJournalStatus(null);
        setNarrativePhase('analyzing');
        setSrAnnouncement('Step 1 of 3: Analyzing your spread, positions, and reflections.');
        setReadingMeta((prev) => ({ ...prev, requestId: null }));
        setLastCardsForFeedback([]);

        try {
            const safeSpreadKey = normalizeSpreadKey(selectedSpread);
            const spreadInfo = getSpreadInfo(safeSpreadKey);
            if (!spreadInfo) {
                throw new Error('Unable to find spread definition.');
            }
            const allCards = [...MAJOR_ARCANA, ...MINOR_ARCANA];

            const cardsInfo = reading.map((card, idx) => {
                const originalCard = allCards.find(item => item.name === card.name) || card;
                const meaningText = card.isReversed ? originalCard.reversed : originalCard.upright;
                const position = spreadInfo.positions[idx] || `Position ${idx + 1}`;

                const suit = originalCard.suit || null;
                const rank = originalCard.rank || null;
                const rankValue =
                    typeof originalCard.rankValue === 'number' ? originalCard.rankValue : null;
                const canonicalName = canonicalizeCardName(originalCard.name, deckStyleId) || originalCard.name;
                const canonicalKey = canonicalCardKey(canonicalName || originalCard.name, deckStyleId);

                return {
                    position,
                    card: card.name,
                    canonicalName,
                    canonicalKey,
                    aliases: Array.isArray(originalCard.aliases) ? originalCard.aliases : [],
                    orientation: card.isReversed ? 'Reversed' : 'Upright',
                    meaning: meaningText,
                    number: card.number,
                    suit,
                    rank,
                    rankValue,
                    userReflection: (reflections[idx] || '').trim() || null
                };
            });

            const reflectionsText = Object.entries(reflections)
                .sort((a, b) => Number(a[0]) - Number(b[0]))
                .map(([index, text]) => {
                    if (typeof text !== 'string' || !text.trim()) return '';
                    const idx = Number(index);
                    const position = cardsInfo[idx]?.position || `Position ${idx + 1}`;
                    return `${position}: ${text.trim()}`;
                })
                .filter(Boolean)
                .join('\n');

            setNarrativePhase('analyzing');
            setSrAnnouncement('Step 1 of 3: Analyzing spread for your narrative.');

            const shouldAttachVisionProof = visionResearchEnabled && visionResults.length > 0;
            if (shouldAttachVisionProof) {
                const conflicts = getVisionConflictsForCards(cardsInfo, visionResults, deckStyleId);
                setVisionConflicts(conflicts);
                if (conflicts.length > 0) {
                    setJournalStatus({
                        type: 'info',
                        message: 'Research Telemetry: Vision model detected a mismatch between uploaded image and digital card.'
                    });
                }
            } else if (visionConflicts.length > 0) {
                setVisionConflicts([]);
            }

            let proof = null;
            if (shouldAttachVisionProof) {
                try {
                    proof = await ensureVisionProof();
                } catch (proofError) {
                    setJournalStatus({
                        type: 'warning',
                        message: proofError.message || 'Vision verification failed. Skipping research telemetry for this reading.'
                    });
                }
            }

            const requestPayload = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: null,
                signal: controller.signal
            };

            const payload = {
                spreadInfo: {
                    name: spreadInfo.name,
                    key: safeSpreadKey,
                    deckStyle: deckStyleId
                },
                cardsInfo,
                userQuestion,
                reflectionsText,
                reversalFrameworkOverride: reversalFramework,
                deckStyle: deckStyleId
            };
            if (proof) {
                payload.visionProof = proof;
            }
            if (personalizationForRequest) {
                payload.personalization = personalizationForRequest;
            }
            const normalizedPayload = safeParseReadingRequest(payload);
            if (!normalizedPayload.success) {
                setIsGenerating(false);
                setNarrativePhase('error');
                setJournalStatus({
                    type: 'error',
                    message: normalizedPayload.error || 'Reading request is missing required details.'
                });
                setSrAnnouncement('Reading request is missing required details for narrative generation.');
                return;
            }

            requestPayload.body = JSON.stringify(normalizedPayload.data);

            setNarrativePhase('drafting');
            setSrAnnouncement('Step 2 of 3: Drafting narrative insights.');

            const response = await fetch('/api/tarot-reading', requestPayload);

            if (!response.ok) {
                const errText = await response.text();
                console.error('Tarot reading API error:', response.status, errText);
                throw new Error('Failed to generate reading');
            }

            const data = await response.json();
            if (!data?.reading || !data.reading.trim()) {
                throw new Error('Empty reading returned');
            }

            if (
                controller.signal.aborted ||
                !inFlightReadingRef.current ||
                inFlightReadingRef.current.controller !== controller
            ) {
                return;
            }

            setNarrativePhase('polishing');
            setSrAnnouncement('Step 3 of 3: Final polishing and assembling your narrative.');

            setThemes(data.themes || null);
            setEmotionalTone(data.emotionalTone || null);
            setSpreadAnalysis(data.spreadAnalysis || null);
            setAnalysisContext(data.context || null);

            const formatted = formatReading(data.reading.trim());
            formatted.isError = false;
            formatted.provider = data.provider || 'local-composer';
            formatted.requestId = data.requestId || null;
            setPersonalReading(formatted);
            setNarrativePhase('complete');
            setLastCardsForFeedback(
                cardsInfo.map((card) => ({
                    position: card.position,
                    card: card.card,
                    orientation: card.orientation
                }))
            );
            setReadingMeta({
                requestId: data.requestId || null,
                provider: data.provider || 'local',
                spreadKey: safeSpreadKey,
                spreadName: spreadInfo.name,
                deckStyle: deckStyleId,
                userQuestion,
                graphContext: data.themes?.knowledgeGraph || null
            });
        } catch (error) {
            if (error?.name === 'AbortError') {
                console.debug('generatePersonalReading aborted');
                return;
            }
            console.error('generatePersonalReading error:', error);
            const errorMsg = 'Unable to generate reading at this time. Please try again in a moment.';
            const formattedError = formatReading(errorMsg);
            formattedError.isError = true;
            setPersonalReading(formattedError);
            setJournalStatus({
                type: 'error',
                message: 'Unable to generate your narrative right now. Please try again shortly.'
            });
            setNarrativePhase('error');
            setSrAnnouncement('Unable to generate your narrative right now.');
        } finally {
            if (inFlightReadingRef.current?.controller === controller) {
                inFlightReadingRef.current = null;
            }
            setIsGenerating(false);
        }
    }, [
        reading,
        isGenerating,
        selectedSpread,
        userQuestion,
        reflections,
        sessionSeed,
        deckStyleId,
        reversalFramework,
        visionResearchEnabled,
        visionResults,
        visionConflicts,
        getVisionConflictsForCards,
        setVisionConflicts,
        ensureVisionProof,
        cancelInFlightReading,
        personalizationForRequest
    ]);

    // --- Logic: Analysis Highlights ---

    // Local fallback relationships
    const relationships = useMemo(() => {
        if (!reading || !reading.length) return [];
        if (spreadAnalysis && Array.isArray(spreadAnalysis.relationships)) {
            return []; // Server analysis takes precedence
        }
        return computeRelationships(reading || []);
    }, [reading, spreadAnalysis]);

    // Highlights Memoization
    const derivedHighlights = useMemo(() => {
        if (!reading || revealedCards.size !== (reading?.length || 0)) return null;
        if (spreadAnalysis && Array.isArray(spreadAnalysis.relationships)) {
            const notes = [];
            if (themes) {
                const deckScope = includeMinors
                    ? 'Full deck (Major + Minor Arcana).'
                    : 'Major Arcana focus (archetypal themes).';
                notes.push({ key: 'deck-scope', icon: '-', title: 'Deck scope:', text: deckScope });
                if (themes.dominantSuit || themes.suitFocus) {
                    notes.push({ key: 'suit-dominance', icon: '♠', title: 'Suit Dominance:', text: themes.suitFocus || `A strong presence of ${themes.dominantSuit} suggests this suit's themes are central to your situation.` });
                }
                if (themes.elementalBalance) {
                    notes.push({ key: 'elemental-balance', icon: '⚡', title: 'Elemental Balance:', text: themes.elementalBalance });
                }
                if (themes.reversalDescription) {
                    notes.push({ key: 'reversal-framework', icon: '⤴', title: 'Reversal Lens:', text: `${themes.reversalDescription.name} — ${themes.reversalDescription.description}` });
                }
            }
            // Track cross-checks separately to limit them (reduces information overload)
            let crossCheckCount = 0;
            const MAX_CROSS_CHECKS = 2;

            spreadAnalysis.relationships.forEach((rel, index) => {
                if (!rel || !rel.summary) return;

                // Limit cross-checks to the 2 most important to reduce density
                if (rel.type === 'cross-check') {
                    crossCheckCount++;
                    if (crossCheckCount > MAX_CROSS_CHECKS) return;
                }

                let title = 'Pattern';
                let icon = '•';
                const typeMap = {
                    'sequence': { title: 'Story Flow', icon: '→' },
                    'elemental-run': { title: 'Elemental Pattern', icon: '⚡' },
                    'elemental': { title: 'Elemental Pattern', icon: '⚡' },
                    'axis': { title: rel.axis || 'Axis Insight', icon: '⇄' },
                    'nucleus': { title: 'Heart of the Matter', icon: '★' },
                    'timeline': { title: 'Timeline', icon: '⏱' },
                    'consciousness-axis': { title: 'Conscious ↔ Subconscious', icon: '☯' },
                    'staff-axis': { title: 'Advice ↔ Outcome', icon: '⚖' },
                    'cross-check': { title: 'Cross-Check', icon: '✦' }
                };
                if (typeMap[rel.type]) {
                    title = typeMap[rel.type].title;
                    icon = typeMap[rel.type].icon;
                }
                notes.push({ key: `rel-${index}-${rel.type || 'rel'}`, icon, title, text: rel.summary });
            });
            // Note: positionNotes are intentionally omitted from UI display.
            // They contain generic reader guidelines (e.g., "Core situation; anchor for nucleus")
            // useful for AI narrative building but not for end-user card-specific insights.
            return notes;
        }
        return null;
    }, [reading, revealedCards, spreadAnalysis, themes, includeMinors]);

    const fallbackHighlights = useMemo(() => {
        const totalCards = reading?.length ?? 0;
        if (!reading || totalCards === 0 || revealedCards.size !== totalCards) {
            return [];
        }
        const items = [];
        items.push({
            key: 'deck-scope',
            icon: '-',
            title: 'Deck scope:',
            text: includeMinors ? 'Full deck (Major + Minor Arcana).' : 'Major Arcana focus (archetypal themes).'
        });
        const reversedIdx = reading.map((card, index) => (card.isReversed ? index : -1)).filter(index => index >= 0);
        if (reversedIdx.length > 0) {
            const hasCluster = reversedIdx.some((idx, j) => j > 0 && idx === reversedIdx[j - 1] + 1);
            let text = `These often point to inner processing, timing delays, or tension in the theme.`;
            if (hasCluster) text += ' Consecutive reversals suggest the theme persists across positions.';
            items.push({ key: 'reversal-summary', icon: '⤴', title: `Reversed cards (${reversedIdx.length}):`, text });
        }
        const relationshipMeta = {
            sequence: { icon: '→', title: 'Sequence:' },
            'reversal-heavy': { icon: '⚠', title: 'Reversal Pattern:' },
            'reversal-moderate': { icon: '•', title: 'Reversal Pattern:' },
            'reversed-court-cluster': { icon: '👑', title: 'Court Dynamics:' },
            'consecutive-reversals': { icon: '↔', title: 'Pattern Flow:' },
            'suit-dominance': { icon: '♠', title: 'Suit Dominance:' },
            'suit-run': { icon: '→', title: 'Suit Run:' },
            'court-cluster': { icon: '👥', title: 'Court Cards:' },
            'court-pair': { icon: '👥', title: 'Court Cards:' },
            'court-suit-focus': { icon: '👥', title: 'Court Cards:' },
            pairing: { icon: '>', title: 'Card Connection:' },
            arc: { icon: '>', title: 'Card Connection:' }
        };
        relationships.forEach((relationship, index) => {
            if (!relationship?.text) return;
            const meta = relationshipMeta[relationship.type] || { icon: '✦', title: 'Pattern:' };
            items.push({ key: `relationship-${relationship.type || 'pattern'}-${index}`, icon: meta.icon, title: meta.title, text: relationship.text });
        });
        return items;
    }, [reading, revealedCards, includeMinors, relationships]);

    const highlightItems = useMemo(() => {
        if (Array.isArray(derivedHighlights) && derivedHighlights.length > 0) return derivedHighlights;
        if (Array.isArray(fallbackHighlights) && fallbackHighlights.length > 0) return fallbackHighlights;
        return [];
    }, [derivedHighlights, fallbackHighlights]);

    const describeCardAtIndex = useCallback((index) => {
        const card = reading?.[index];
        if (!card) return null;
        const spreadInfo = getSpreadInfo(selectedSpread);
        const position = spreadInfo?.positions?.[index] || `Card ${index + 1}`;
        return `${position}: ${card.name}${card.isReversed ? ' reversed' : ''}`;
    }, [reading, selectedSpread]);

    const dealNext = useCallback(() => {
        if (!reading || dealIndex >= reading.length) return;
        const description = describeCardAtIndex(dealIndex);
        if (description) {
            setSrAnnouncement(`Revealed ${description}.`);
        }
        baseDealNext();
    }, [baseDealNext, dealIndex, describeCardAtIndex, reading]);

    const revealCard = useCallback((index) => {
        if (!reading || !reading[index]) return;
        const description = describeCardAtIndex(index);
        if (description) {
            setSrAnnouncement(`Revealed ${description}.`);
        }
        baseRevealCard(index);
    }, [baseRevealCard, describeCardAtIndex, reading]);

    const revealAll = useCallback(() => {
        if (!reading || reading.length === 0) return;
        const descriptions = reading
            .map((_, index) => (!revealedCards.has(index) ? describeCardAtIndex(index) : null))
            .filter(Boolean);

        if (descriptions.length === 1) {
            setSrAnnouncement(`Revealed ${descriptions[0]}.`);
        } else if (descriptions.length > 1) {
            const preview = descriptions.slice(0, 2).join('; ');
            const suffix = descriptions.length > 2 ? '…' : '.';
            setSrAnnouncement(`Revealed ${descriptions.length} cards — ${preview}${suffix}`);
        } else if (revealedCards.size === reading.length) {
            setSrAnnouncement('All cards already revealed.');
        }

        baseRevealAll();
    }, [baseRevealAll, describeCardAtIndex, reading, revealedCards]);

    const value = useMemo(() => ({
        ...audioController,
        ...tarotState,
        ...visionAnalysis,
        shuffle: handleShuffle,
        dealNext,
        revealCard,
        revealAll,
        personalReading, setPersonalReading,
        isGenerating, setIsGenerating,
        narrativePhase, setNarrativePhase,
        spreadAnalysis, setSpreadAnalysis,
        themes, setThemes,
        emotionalTone, setEmotionalTone,
        analysisContext, setAnalysisContext,
        readingMeta, setReadingMeta,
        journalStatus, setJournalStatus,
        reflections, setReflections,
        lastCardsForFeedback, setLastCardsForFeedback,
        showAllHighlights, setShowAllHighlights,
        generatePersonalReading,
        highlightItems,
        srAnnouncement, setSrAnnouncement
    }), [
        audioController,
        tarotState,
        visionAnalysis,
        handleShuffle,
        dealNext,
        revealCard,
        revealAll,
        personalReading,
        isGenerating,
        narrativePhase,
        spreadAnalysis,
        themes,
        emotionalTone,
        analysisContext,
        readingMeta,
        journalStatus,
        reflections,
        lastCardsForFeedback,
        showAllHighlights,
        generatePersonalReading,
        highlightItems,
        srAnnouncement
    ]);

    return (
        <ReadingContext.Provider value={value}>
            {children}
        </ReadingContext.Provider>
    );
}

export function useReading() {
    const context = useContext(ReadingContext);
    if (!context) {
        throw new Error('useReading must be used within a ReadingProvider');
    }
    return context;
}
</file>

<file path="src/contexts/ToastContext.jsx">
import { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';
import { CheckCircle, Info, WarningCircle, X, XCircle } from '@phosphor-icons/react';

const ToastContext = createContext(null);

const DEFAULT_DURATION = {
  success: 3200,
  info: 3600,
  warning: 4800,
  error: 5200
};

const ICONS = {
  success: CheckCircle,
  info: Info,
  warning: WarningCircle,
  error: XCircle
};

const VARIANTS = {
  success: {
    container: 'border-emerald-400/40 bg-emerald-500/10 text-emerald-50 shadow-emerald-500/20',
    icon: 'text-emerald-300',
    description: 'text-emerald-50/90'
  },
  info: {
    container: 'border-secondary/30 bg-secondary/10 text-secondary shadow-secondary/20',
    icon: 'text-secondary',
    description: 'text-secondary/80'
  },
  warning: {
    container: 'border-amber-400/40 bg-amber-500/10 text-amber-50 shadow-amber-500/30',
    icon: 'text-amber-300',
    description: 'text-amber-50/90'
  },
  error: {
    container: 'border-error/40 bg-error/10 text-error shadow-error/30',
    icon: 'text-error',
    description: 'text-error/90'
  }
};

export function ToastProvider({ children }) {
  const [toasts, setToasts] = useState([]);
  const timersRef = useRef(new Map());

  const dismiss = useCallback((id) => {
    setToasts((prev) => prev.filter((toast) => toast.id !== id));
    const timeoutId = timersRef.current.get(id);
    if (timeoutId) {
      clearTimeout(timeoutId);
      timersRef.current.delete(id);
    }
  }, []);

  const publish = useCallback((toast = {}) => {
    const { title, description, type = 'info', duration } = toast;
    if (!title && !description) {
      return null;
    }
    const id = globalThis.crypto?.randomUUID?.() || `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    const ttl = typeof duration === 'number' ? duration : DEFAULT_DURATION[type] || 3600;
    setToasts((prev) => [...prev, { id, title, description, type }]);
    if (ttl !== Infinity) {
      const timeoutId = setTimeout(() => dismiss(id), ttl);
      timersRef.current.set(id, timeoutId);
    }
    return id;
  }, [dismiss]);

  useEffect(() => () => {
    timersRef.current.forEach(clearTimeout);
    timersRef.current.clear();
  }, []);

  const contextValue = useMemo(() => ({ publish, dismiss }), [publish, dismiss]);

  return (
    <ToastContext.Provider value={contextValue}>
      {children}
      <ToastViewport toasts={toasts} onDismiss={dismiss} />
    </ToastContext.Provider>
  );
}

export function useToast() {
  const ctx = useContext(ToastContext);
  if (!ctx) {
    throw new Error('useToast must be used within a ToastProvider');
  }
  return ctx;
}

function ToastViewport({ toasts, onDismiss }) {
  if (!toasts.length) {
    return null;
  }
  return (
    <div className="pointer-events-none fixed inset-x-0 top-4 z-[1200] flex flex-col items-center gap-3 px-4 sm:top-6 sm:items-end sm:px-6">
      {toasts.map((toast) => (
        <ToastItem key={toast.id} toast={toast} onDismiss={onDismiss} />
      ))}
    </div>
  );
}

function ToastItem({ toast, onDismiss }) {
  const Icon = ICONS[toast.type] || Info;
  const variant = VARIANTS[toast.type] || VARIANTS.info;
  const role = toast.type === 'error' ? 'alert' : 'status';

  return (
    <div
      role={role}
      aria-live={toast.type === 'error' ? 'assertive' : 'polite'}
      className={`pointer-events-auto w-full max-w-sm rounded-2xl border px-4 py-3 text-sm shadow-xl backdrop-blur ${variant.container}`}
    >
      <div className="flex items-start gap-3">
        <Icon className={`h-5 w-5 flex-shrink-0 ${variant.icon}`} aria-hidden="true" />
        <div className="flex-1 space-y-1">
          {toast.title && <p className="font-semibold leading-tight">{toast.title}</p>}
          {toast.description && <p className={`text-sm leading-snug ${variant.description}`}>{toast.description}</p>}
        </div>
        <button
          type="button"
          onClick={() => onDismiss(toast.id)}
          className="rounded-full p-1 text-sm text-white/70 transition hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white/50"
          aria-label="Dismiss notification"
        >
          <X className="h-4 w-4" weight="bold" />
        </button>
      </div>
    </div>
  );
}
</file>

<file path="src/data/emotionMapping.js">
/**
 * Emotion Mapping for GraphRAG-based TTS
 *
 * Maps detected archetypal patterns (triads, dyads, journey stages, suit progressions)
 * to emotional tones for Hume TTS acting instructions.
 *
 * Used by both frontend (audioHume.js) and backend (tts-hume.js).
 */

/**
 * Maps triad themes (from ARCHETYPAL_TRIADS) to emotional tones
 */
export const TRIAD_EMOTIONS = {
  'Healing Arc': 'hopeful-transformative',
  'Liberation Arc': 'triumphant-revelatory',
  'Inner Work Arc': 'contemplative-mysterious',
  'Mastery Arc': 'confident-empowering',
  'Relationship & Values Arc': 'warm-reflective',
  'Complete Manifestation Cycle': 'expansive-triumphant',
  'Authority & Structure Arc': 'grounded-wise',
  'Karmic Acceptance Arc': 'accepting-serene',
  'Post-Crisis Navigation Arc': 'tender-hopeful',
  'Inner Mastery Through Solitude Arc': 'introspective-peaceful'
};

/**
 * Maps dyad categories (from ARCHETYPAL_DYADS) to emotional tones
 */
export const DYAD_CATEGORY_EMOTIONS = {
  'empowerment': 'confident-empowering',
  'transformation': 'transformative-profound',
  'shadow-challenge': 'thoughtful-cautionary',
  'wisdom-intuition': 'contemplative-mysterious',
  'cycles-fate': 'accepting-wise',
  'power-structure': 'grounded-authoritative',
  'hope-vision': 'hopeful-inspiring'
};

/**
 * Maps Fool's Journey stages (from FOOLS_JOURNEY) to emotional tones
 */
export const JOURNEY_STAGE_EMOTIONS = {
  'initiation': 'curious-hopeful',
  'integration': 'transformative-deep',
  'culmination': 'profound-transcendent'
};

/**
 * Maps suit + progression stage to emotional tones
 */
export const SUIT_EMOTIONS = {
  Wands: {
    beginning: 'passionate-inspired',
    challenge: 'determined-fierce',
    mastery: 'accomplished-weary'
  },
  Cups: {
    beginning: 'loving-open',
    challenge: 'grieving-complex',
    mastery: 'fulfilled-wise'
  },
  Swords: {
    beginning: 'clear-piercing',
    challenge: 'conflicted-strategic',
    mastery: 'liberated-dawning'
  },
  Pentacles: {
    beginning: 'grounded-promising',
    challenge: 'resourceful-testing',
    mastery: 'abundant-legacy'
  }
};

/**
 * Maps emotional tones to Hume acting instructions (voice descriptions)
 * These descriptions guide how the TTS voice should express the emotion.
 */
export const EMOTION_DESCRIPTIONS = {
  // Triad-derived emotions
  'hopeful-transformative':
    'Speak with gentle hope and acknowledgment of change. Your voice should convey that while transformation may be difficult, renewal awaits. Pace yourself with compassion, allowing space for the weight of change.',

  'triumphant-revelatory':
    'Speak with quiet triumph and revelation. Your voice carries the energy of breakthrough—not boastful, but genuinely liberated. Allow moments of wonder and relief to color your delivery.',

  'contemplative-mysterious':
    'Speak with deep contemplation and mystery. Your voice should feel like it comes from within a sacred space. Slow, deliberate pacing with space for the unconscious to breathe. Honor the unknown.',

  'confident-empowering':
    'Speak with grounded confidence and empowerment. Your voice conveys mastery and capability. Clear, assured, but not arrogant—wise authority that uplifts the listener.',

  'warm-reflective':
    'Speak with warmth and gentle reflection. Your voice nurtures and invites introspection about values and connections. Soft, caring, fully present with the listener.',

  'expansive-triumphant':
    'Speak with expansive energy and celebration. Your voice carries the fullness of achievement—joyful completion, the satisfaction of a journey well-traveled. Grand but grounded.',

  'grounded-wise':
    'Speak with earthy wisdom and stability. Your voice conveys deep knowledge born of experience. Measured, trustworthy, like a wise elder sharing hard-won understanding.',

  'grounded-authoritative':
    'Speak with grounded authority and structure. Your voice conveys leadership and clear direction. Firm but not harsh—the voice of someone who has earned their position.',

  'accepting-serene':
    'Speak with peaceful acceptance and serenity. Your voice conveys surrender to what is, finding peace in the flow of fate. Calm, centered, at ease with uncertainty.',

  'accepting-wise':
    'Speak with the wisdom of acceptance. Your voice acknowledges life\'s cycles with equanimity. Neither resigned nor passive—actively at peace with change.',

  'tender-hopeful':
    'Speak with tender care and gentle hope. Your voice acknowledges fragility while nurturing possibility. Soft, encouraging, like a hand offered in the dark.',

  'introspective-peaceful':
    'Speak with quiet introspection and inner peace. Your voice comes from a place of solitary wisdom, comfortable with silence, at home in the depths.',

  // Journey-derived emotions
  'curious-hopeful':
    'Speak with fresh curiosity and open-hearted hope. Your voice carries the energy of new beginnings—exploratory, encouraging, full of possibility. Light and inviting.',

  'transformative-deep':
    'Speak with acknowledgment of difficulty and honor for the process. Your voice recognizes the weight of transformation while holding space for growth. Patient, compassionate, understanding.',

  'profound-transcendent':
    'Speak with deep wisdom and cosmic perspective. Your voice touches the transcendent—aware of larger patterns, connected to something greater. Reverent but not distant.',

  // Dyad-derived emotions
  'transformative-profound':
    'Speak with recognition of deep change. Your voice honors the profound nature of transformation. Serious but not heavy—carrying weight with grace.',

  'thoughtful-cautionary':
    'Speak with gentle warning and supportive concern. Your voice is caring but honest about shadows. Not alarming—thoughtfully protective, like a wise friend.',

  'hopeful-inspiring':
    'Speak with hope that inspires action. Your voice lifts and motivates. Encouraging without being saccharine—genuine optimism grounded in possibility.',

  // Suit-derived emotions
  'passionate-inspired':
    'Speak with creative fire and inspired energy. Your voice carries enthusiasm and vision. Dynamic, alive, ready to ignite possibility.',

  'determined-fierce':
    'Speak with fierce determination and protective strength. Your voice holds ground with conviction. Intense but focused—fire that has learned discipline.',

  'accomplished-weary':
    'Speak with the weight of accomplishment. Your voice acknowledges both achievement and exhaustion. Proud but tired—success that needs rest.',

  'loving-open':
    'Speak with open-hearted love and emotional availability. Your voice flows with connection and warmth. Tender, receptive, emotionally generous.',

  'grieving-complex':
    'Speak with acknowledgment of emotional complexity. Your voice holds space for grief, confusion, and mixed feelings. Compassionate with the messiness of the heart.',

  'fulfilled-wise':
    'Speak with emotional fulfillment and relational wisdom. Your voice carries the satisfaction of authentic connection. Content, grateful, emotionally mature.',

  'clear-piercing':
    'Speak with mental clarity and truth-telling directness. Your voice cuts through confusion with precision. Clear, honest, unafraid of difficult truths.',

  'conflicted-strategic':
    'Speak with acknowledgment of mental conflict and strategic thinking. Your voice navigates complexity without oversimplifying. Thoughtful, tactical, aware of tensions.',

  'liberated-dawning':
    'Speak with the freshness of mental liberation. Your voice carries the relief of clarity finally achieved. Light, free, awakening from confusion.',

  'grounded-promising':
    'Speak with earthy groundedness and practical promise. Your voice conveys solid foundations and real potential. Steady, reliable, genuinely encouraging.',

  'resourceful-testing':
    'Speak with practical resourcefulness under pressure. Your voice acknowledges challenges while emphasizing capability. Steady, problem-solving, resilient.',

  'abundant-legacy':
    'Speak with the fullness of material and spiritual abundance. Your voice carries generational wisdom and lasting achievement. Rich, substantial, enduring.',

  // Default fallback
  'default':
    'Speak as a wise, compassionate tarot reader. Use a thoughtful, contemplative tone with natural pauses for reflection. Your voice should feel like a trusted guide—warm, insightful, and present.'
};

/**
 * Derive dominant emotional tone from GraphRAG pattern analysis
 *
 * Uses weighted scoring to determine the most significant emotional tone
 * based on detected patterns in the reading.
 *
 * Priority weights:
 * - Complete triads: 3 (strongest narrative arc)
 * - Fool's Journey stage: 2 (developmental significance)
 * - High-significance dyads: 2 (powerful card combinations)
 * - Suit progressions: 1 (contextual coloring)
 *
 * @param {Object} themes - The themes object from reading response
 * @returns {Object} { emotion, confidence, sources }
 */
export function deriveEmotionalTone(themes) {
  if (!themes) {
    return { emotion: 'default', confidence: 'low', sources: [] };
  }

  const patterns = themes.knowledgeGraph?.patterns;
  if (!patterns) {
    return { emotion: 'default', confidence: 'low', sources: [] };
  }

  const sources = [];
  const emotionWeights = {};

  // Priority 1: Complete triads (weight: 3)
  if (patterns.triads?.length > 0) {
    const completeTriad = patterns.triads.find(t => t.isComplete);
    if (completeTriad) {
      const emotion = TRIAD_EMOTIONS[completeTriad.theme] || 'transformative-profound';
      emotionWeights[emotion] = (emotionWeights[emotion] || 0) + 3;
      sources.push({ type: 'triad', theme: completeTriad.theme, emotion, weight: 3 });
    } else {
      // Partial triads get weight 1
      const partialTriad = patterns.triads[0];
      if (partialTriad?.theme) {
        const emotion = TRIAD_EMOTIONS[partialTriad.theme] || 'transformative-profound';
        emotionWeights[emotion] = (emotionWeights[emotion] || 0) + 1;
        sources.push({ type: 'partial-triad', theme: partialTriad.theme, emotion, weight: 1 });
      }
    }
  }

  // Priority 2: Fool's Journey stage (weight: 2)
  if (patterns.foolsJourney?.stageKey) {
    const emotion = JOURNEY_STAGE_EMOTIONS[patterns.foolsJourney.stageKey] || 'contemplative-mysterious';
    emotionWeights[emotion] = (emotionWeights[emotion] || 0) + 2;
    sources.push({
      type: 'journey',
      stage: patterns.foolsJourney.stageKey,
      significance: patterns.foolsJourney.significance,
      emotion,
      weight: 2
    });
  }

  // Priority 3: High-significance dyads (weight: 2)
  if (patterns.dyads?.length > 0) {
    const highSigDyad = patterns.dyads.find(d => d.significance === 'high');
    if (highSigDyad?.category) {
      const emotion = DYAD_CATEGORY_EMOTIONS[highSigDyad.category] || 'transformative-profound';
      emotionWeights[emotion] = (emotionWeights[emotion] || 0) + 2;
      sources.push({
        type: 'dyad',
        category: highSigDyad.category,
        theme: highSigDyad.theme,
        emotion,
        weight: 2
      });
    } else {
      // Lower significance dyads get weight 1
      const dyad = patterns.dyads[0];
      if (dyad?.category) {
        const emotion = DYAD_CATEGORY_EMOTIONS[dyad.category] || 'transformative-profound';
        emotionWeights[emotion] = (emotionWeights[emotion] || 0) + 1;
        sources.push({ type: 'dyad', category: dyad.category, emotion, weight: 1 });
      }
    }
  }

  // Priority 4: Suit progressions (weight: 1)
  if (patterns.suitProgressions?.length > 0) {
    const prog = patterns.suitProgressions[0];
    const suitEmotions = SUIT_EMOTIONS[prog.suit];
    if (suitEmotions && prog.stage) {
      const emotion = suitEmotions[prog.stage] || 'grounded-wise';
      emotionWeights[emotion] = (emotionWeights[emotion] || 0) + 1;
      sources.push({
        type: 'suit',
        suit: prog.suit,
        stage: prog.stage,
        emotion,
        weight: 1
      });
    }
  }

  // Find dominant emotion by total weight
  const sortedEmotions = Object.entries(emotionWeights)
    .sort((a, b) => b[1] - a[1]);

  const dominant = sortedEmotions[0];

  if (!dominant) {
    return { emotion: 'default', confidence: 'low', sources: [] };
  }

  // Determine confidence based on total weight
  const totalWeight = dominant[1];
  let confidence;
  if (totalWeight >= 4) {
    confidence = 'high';
  } else if (totalWeight >= 2) {
    confidence = 'medium';
  } else {
    confidence = 'low';
  }

  return {
    emotion: dominant[0],
    confidence,
    totalWeight,
    sources
  };
}

/**
 * Get Hume acting instructions for a given emotion
 *
 * @param {string} emotion - The emotion key
 * @returns {string} The voice description/acting instructions
 */
export function getActingInstructions(emotion) {
  return EMOTION_DESCRIPTIONS[emotion] || EMOTION_DESCRIPTIONS['default'];
}
</file>

<file path="src/data/exampleQuestions.js">
export const EXAMPLE_QUESTIONS = [
  'What should I focus on this week?',
  'How can I navigate this relationship?',
  'What energy do I need right now?',
  'What lesson am I meant to learn?',
  'How can I move forward with clarity?'
];
</file>

<file path="src/data/knowledgeGraphData.js">
// src/data/knowledgeGraphData.js
// Knowledge Graph data structures for archetypal pattern detection
// Based on traditional tarot wisdom: Pollack, Greer, Place, Golden Dawn

/**
 * THE FOOL'S JOURNEY
 * Three-act structure dividing the 22 Major Arcana into developmental stages
 * following Joseph Campbell's Hero's Journey and Jungian individuation
 */
export const FOOLS_JOURNEY = {
  initiation: {
    range: [0, 7],
    stage: 'departure',
    theme: 'Innocence, learning, establishing ego and identity',
    lifePhase: 'Childhood through early adulthood',
    psychologicalTask: 'Building ego structure, learning societal roles',
    cards: [
      { num: 0, name: 'The Fool', role: 'Innocent beginning' },
      { num: 1, name: 'The Magician', role: 'Conscious will' },
      { num: 2, name: 'The High Priestess', role: 'Unconscious knowing' },
      { num: 3, name: 'The Empress', role: 'Creative abundance' },
      { num: 4, name: 'The Emperor', role: 'Structure & authority' },
      { num: 5, name: 'The Hierophant', role: 'Tradition & teaching' },
      { num: 6, name: 'The Lovers', role: 'Choice & values' },
      { num: 7, name: 'The Chariot', role: 'Disciplined action' }
    ],
    narrative:
      'The querent is encountering foundational forces, learning who they are and what they value.',
    readingSignificance:
      'Building identity, establishing in the world, learning new skills'
  },

  integration: {
    range: [8, 14],
    stage: 'initiation',
    theme: 'Testing, sacrifice, shadow work, necessary endings',
    lifePhase: 'Midlife transitions',
    psychologicalTask: 'Shadow integration, ego transcendence, finding balance',
    cards: [
      { num: 8, name: 'Strength', role: 'Inner fortitude' },
      { num: 9, name: 'The Hermit', role: 'Solitary wisdom' },
      { num: 10, name: 'Wheel of Fortune', role: 'Cycles & fate' },
      { num: 11, name: 'Justice', role: 'Truth & balance' },
      { num: 12, name: 'The Hanged Man', role: 'Surrender' },
      { num: 13, name: 'Death', role: 'Transformation' },
      { num: 14, name: 'Temperance', role: 'Alchemy' }
    ],
    narrative:
      'The querent faces trials that demand surrender, perspective shifts, and integration of opposites.',
    readingSignificance:
      'Difficult but necessary transition, releasing control, shadow work'
  },

  culmination: {
    range: [15, 21],
    stage: 'return',
    theme: 'Shadow integration, revelation, cosmic consciousness, completion',
    lifePhase: 'Mature adulthood, elder wisdom',
    psychologicalTask:
      'Integration of the Self, transcendence, bringing wisdom to the world',
    cards: [
      { num: 15, name: 'The Devil', role: 'Shadow confrontation' },
      { num: 16, name: 'The Tower', role: 'Necessary destruction' },
      { num: 17, name: 'The Star', role: 'Hope restored' },
      { num: 18, name: 'The Moon', role: 'Illusion & intuition' },
      { num: 19, name: 'The Sun', role: 'Illumination' },
      { num: 20, name: 'Judgement', role: 'Rebirth' },
      { num: 21, name: 'The World', role: 'Integration & wholeness' }
    ],
    narrative:
      'The querent confronts deepest shadow and emerges transformed, integrating all lessons into wholeness.',
    readingSignificance:
      'Soul-level themes, completing cycles, spiritual awakening'
  }
};

/**
 * ARCHETYPAL TRIADS
 * Powerful three-card combinations forming complete narrative arcs
 * Based on sequential logic, thematic resonance, and professional reading practice
 */
export const ARCHETYPAL_TRIADS = [
  {
    id: 'death-temperance-star',
    cards: [13, 14, 17],
    names: ['Death', 'Temperance', 'The Star'],
    theme: 'Healing Arc',
    narrative: 'Ending → Alchemical integration → Renewed hope',
    description:
      'The classic healing journey: releasing what must die, integrating the lesson, emerging into restored faith.',
    strength: 'complete',
    contexts: {
      grief: 'Literal healing from loss',
      transition: 'Life changes requiring integration',
      shadow: 'Releasing old patterns, integrating new self'
    },
    partialNarrative: {
      'death-temperance': 'Transformation actively seeking balance',
      'temperance-star': 'Patient integration leading to renewal',
      'death-star':
        'Dramatic shift from ending to rebirth (skipping integration)'
    }
  },

  {
    id: 'devil-tower-sun',
    cards: [15, 16, 19],
    names: ['The Devil', 'The Tower', 'The Sun'],
    theme: 'Liberation Arc',
    narrative: 'Bondage → Rupture → Freedom',
    description:
      'Breaking free: recognizing chains, experiencing collapse, emerging into clarity and joy.',
    strength: 'complete',
    contexts: {
      addiction: 'Recovery from literal or metaphorical bondage',
      relationship: 'Leaving toxic dynamics',
      career: 'Breaking from unfulfilling work',
      spiritual: 'Freedom from limiting beliefs'
    },
    partialNarrative: {
      'devil-tower': 'Attachments meet necessary disruption',
      'tower-sun': 'Upheaval clearing the path to clarity',
      'devil-sun': 'From shadow to light (sudden liberation)'
    }
  },

  {
    id: 'hermit-hangedman-moon',
    cards: [9, 12, 18],
    names: ['The Hermit', 'The Hanged Man', 'The Moon'],
    theme: 'Inner Work Arc',
    narrative: 'Solitude → Surrender → Deep Mystery',
    description:
      'The contemplative path: withdrawing for wisdom, releasing control, diving into unconscious depths.',
    strength: 'complete',
    contexts: {
      spiritual: 'Meditation, dreamwork, shadow integration',
      therapy: 'Deep psychological processing',
      creative: 'Allowing ideas to gestate',
      grief: 'Internal mourning work'
    },
    partialNarrative: {
      'hermit-hangedman': 'Introspection leading to necessary pause',
      'hangedman-moon': 'Suspension opening to shadow realm',
      'hermit-moon': 'Solo journey into the unconscious'
    }
  },

  {
    id: 'magician-chariot-world',
    cards: [1, 7, 21],
    names: ['The Magician', 'The Chariot', 'The World'],
    theme: 'Mastery Arc',
    narrative: 'Skill → Directed action → Complete achievement',
    description:
      'The path of manifestation: marshaling resources, focused willpower, total integration.',
    strength: 'complete',
    contexts: {
      career: 'Professional mastery and achievement',
      creative: 'Completing major projects',
      personal: 'Reaching developmental milestones',
      manifestation: 'Bringing vision into reality'
    },
    partialNarrative: {
      'magician-chariot': 'Potential directed into decisive movement',
      'chariot-world': 'Determined effort reaching culmination',
      'magician-world': 'From first spark to full realization'
    }
  },

  {
    id: 'empress-lovers-hierophant',
    cards: [3, 6, 5],
    names: ['The Empress', 'The Lovers', 'The Hierophant'],
    theme: 'Relationship & Values Arc',
    narrative: 'Abundance → Choice → Commitment',
    description:
      'Examining what you value: abundance opens choices, choices require commitment to tradition or personal truth.',
    strength: 'complete',
    contexts: {
      romantic: 'From attraction to commitment',
      creative: 'From inspiration to disciplined practice',
      spiritual: 'From exploration to choosing a path',
      values: 'Clarifying what merits dedication'
    },
    partialNarrative: {
      'empress-lovers': 'Creative fertility meeting decisive choice',
      'lovers-hierophant': 'Personal values versus collective tradition',
      'empress-hierophant': 'Nurturing energy seeking formal structure'
    }
  },

  {
    id: 'fool-magician-world',
    cards: [0, 1, 21],
    names: ['The Fool', 'The Magician', 'The World'],
    theme: 'Complete Manifestation Cycle',
    narrative: 'Innocent beginning → Conscious skill → Total integration',
    description:
      'The ouroboros of creation: from first spark of potential, through focused manifestation, to complete achievement and new beginning.',
    strength: 'complete',
    contexts: {
      career: 'Starting a venture and bringing it to completion',
      creative: 'From initial inspiration to finished masterpiece',
      personal: 'Full developmental cycle from innocence to mastery',
      spiritual: 'Soul journey from potential to realized wholeness'
    },
    partialNarrative: {
      'fool-magician': 'Pure potential meeting conscious will',
      'magician-world': 'Skillful action achieving total integration',
      'fool-world': 'From zero to wholeness (quantum leap)'
    }
  },

  {
    id: 'empress-emperor-hierophant',
    cards: [3, 4, 5],
    names: ['The Empress', 'The Emperor', 'The Hierophant'],
    theme: 'Authority & Structure Arc',
    narrative: 'Nurturing abundance → Order & structure → Traditional wisdom',
    description:
      'Building institutions: from creative abundance through structured authority to codified tradition. Parenting, leadership, or establishing lasting systems.',
    strength: 'complete',
    contexts: {
      parenting: 'From nurturing children to establishing family structure to teaching values',
      leadership: 'Building organizations through care, structure, and shared principles',
      creative: 'From fertile creativity to disciplined craft to teaching mastery',
      career: 'From abundance to organization to institutional wisdom'
    },
    partialNarrative: {
      'empress-emperor': 'Nurturing meets structure',
      'emperor-hierophant': 'Authority seeking traditional validation',
      'empress-hierophant': 'Abundance channeled through tradition'
    }
  },

  {
    id: 'wheel-justice-hangedman',
    cards: [10, 11, 12],
    names: ['Wheel of Fortune', 'Justice', 'The Hanged Man'],
    theme: 'Karmic Acceptance Arc',
    narrative: 'Fate turns → Truth demanded → Surrender to flow',
    description:
      'The path of acceptance: recognizing cycles beyond control, facing truth with clarity, releasing resistance through surrender.',
    strength: 'complete',
    contexts: {
      legal: 'Court decisions, karmic justice, accepting outcomes',
      relationships: 'Recognizing patterns, seeking fairness, letting go of control',
      spiritual: 'Understanding karma, truth-seeking, ego surrender',
      healing: 'Accepting what cannot be changed, finding balance, releasing attachment'
    },
    partialNarrative: {
      'wheel-justice': 'Fate meeting accountability',
      'justice-hangedman': 'Truth requiring suspension of judgment',
      'wheel-hangedman': 'Cycles demanding surrender'
    }
  },

  {
    id: 'tower-star-moon',
    cards: [16, 17, 18],
    names: ['The Tower', 'The Star', 'The Moon'],
    theme: 'Post-Crisis Navigation Arc',
    narrative: 'Upheaval → Hope restored → Navigating uncertainty',
    description:
      'The aftermath journey: structures collapse, hope emerges from rubble, but the path forward remains shrouded in mystery requiring faith and intuition.',
    strength: 'complete',
    contexts: {
      trauma: 'After crisis, finding hope, navigating healing with patience',
      career: 'Job loss to new vision to uncertain next steps',
      relationships: 'Breakup to renewed faith to navigating dating again',
      spiritual: 'Dark night to glimpse of light to mysterious unfolding'
    },
    partialNarrative: {
      'tower-star': 'Destruction clearing space for hope',
      'star-moon': 'Hope meeting shadow work',
      'tower-moon': 'Upheaval plunging into deep mystery'
    }
  },

  {
    id: 'strength-hermit-wheel',
    cards: [8, 9, 10],
    names: ['Strength', 'The Hermit', 'Wheel of Fortune'],
    theme: 'Inner Mastery Through Solitude Arc',
    narrative: 'Taming inner beasts → Solitary wisdom → Accepting cycles',
    description:
      'The contemplative path to wisdom: mastering inner turmoil through gentleness, withdrawing to seek truth, accepting the turning of fate with equanimity.',
    strength: 'complete',
    contexts: {
      personal: 'Self-mastery through introspection and acceptance',
      spiritual: 'Meditation, shadow work, surrendering to divine timing',
      healing: 'Gentle self-compassion, inner work, accepting recovery cycles',
      creative: 'Cultivating discipline, solitary practice, trusting the process'
    },
    partialNarrative: {
      'strength-hermit': 'Inner fortitude seeking deeper wisdom',
      'hermit-wheel': 'Solitary truth-seeking accepting fate',
      'strength-wheel': 'Gentle mastery meeting life\'s cycles'
    }
  }
];

/**
 * ARCHETYPAL DYADS
 * Extended from existing implementation in deck.js:computeRelationships()
 * Powerful two-card combinations creating synergistic meaning
 */
export const ARCHETYPAL_DYADS = [
  // Existing dyads (preserve backward compatibility)
  {
    cards: [0, 1],
    names: ['The Fool', 'The Magician'],
    theme: 'Innocent potential meeting conscious skill',
    category: 'empowerment',
    description:
      "Beginner's mind empowered by mastery. Fresh vision with the tools to manifest it.",
    narrative:
      'You have both the fresh perspective of a beginner AND the tools to manifest your vision.',
    significance: 'high'
  },
  {
    cards: [13, 17],
    names: ['Death', 'The Star'],
    theme: 'Transformation clearing into hope',
    category: 'transformation',
    description:
      'Necessary ending creating space for renewal. Grief making room for healing.',
    narrative:
      "What you're releasing is making space for renewed hope and purpose.",
    significance: 'high'
  },
  {
    cards: [16, 19],
    names: ['The Tower', 'The Sun'],
    theme: 'Upheaval revealing clarity',
    category: 'transformation',
    description:
      'Necessary destruction bringing authentic joy. Illusions shattered, truth shining through.',
    narrative:
      "What's falling apart needed to fall apart so truth and joy could emerge.",
    significance: 'high'
  },
  {
    cards: [15, 6],
    names: ['The Devil', 'The Lovers'],
    theme: 'Attachment patterns affecting choice',
    category: 'shadow-challenge',
    description:
      'Shadow bondage influencing values-based decisions. Addiction affecting relationship choices.',
    narrative:
      'Your attachment patterns are affecting your capacity to choose freely and align with true values.',
    significance: 'high'
  },
  {
    cards: [9, 2],
    names: ['The Hermit', 'The High Priestess'],
    theme: 'Solitary wisdom accessing intuition',
    category: 'wisdom-intuition',
    description:
      'Outer withdrawal revealing inner knowing. Solitude allowing the inner voice to be heard.',
    narrative:
      'Solitude creates the quiet space where deep intuitive knowing can finally be heard.',
    significance: 'medium-high'
  },

  // NEW dyads (extending the library)
  {
    cards: [12, 13],
    names: ['The Hanged Man', 'Death'],
    theme: 'Surrender enabling transformation',
    category: 'transformation',
    description:
      'Letting go making way for metamorphosis. Acceptance easing the transition.',
    narrative:
      'Your willingness to release control determines how gracefully transformation unfolds.',
    significance: 'medium-high'
  },
  {
    cards: [8, 11],
    names: ['Strength', 'Justice'],
    theme: 'Compassion balanced with accountability',
    category: 'empowerment',
    description:
      "Gentle power meeting fair judgment. Kindness that doesn't bypass accountability.",
    narrative:
      "Be both kind AND fair. Compassion doesn't mean avoiding responsibility.",
    significance: 'medium'
  },
  {
    cards: [2, 5],
    names: ['The High Priestess', 'The Hierophant'],
    theme: 'Inner knowing versus outer teaching',
    category: 'wisdom-intuition',
    description:
      'Personal intuition meeting traditional wisdom. Inner voice versus received teachings.',
    narrative:
      'Navigate where your inner knowing and traditional wisdom align or diverge.',
    significance: 'medium'
  },
  {
    cards: [18, 19],
    names: ['The Moon', 'The Sun'],
    theme: 'Mystery yielding to illumination',
    category: 'transformation',
    description:
      'Confusion clarifying into truth. Unconscious material becoming conscious.',
    narrative:
      "What's confusing now is in the process of being revealed and clarified.",
    significance: 'medium-high'
  },
  {
    cards: [15, 16],
    names: ['The Devil', 'The Tower'],
    theme: 'Bondage meeting disruption',
    category: 'shadow-challenge',
    description:
      'Attachment being forcefully broken. Liberation through crisis.',
    narrative:
      "The chains are breaking whether you're ready or not. Embrace the liberation.",
    significance: 'high'
  },
  {
    cards: [10, 20],
    names: ['Wheel of Fortune', 'Judgement'],
    theme: 'Fate meeting conscious reckoning',
    category: 'cycles-fate',
    description:
      'Karmic cycle completing, calling for integration and conscious evolution.',
    narrative:
      'A major cycle is completing; integrate the lesson and rise transformed.',
    significance: 'high'
  },
  {
    cards: [4, 3],
    names: ['The Emperor', 'The Empress'],
    theme: 'Structure and abundance in dialogue',
    category: 'power-structure',
    description:
      'Masculine structure meeting feminine flow. Discipline supporting creativity.',
    narrative: 'Honor both structure and flow, discipline and abundance.',
    significance: 'medium'
  },
  {
    cards: [5, 15],
    names: ['The Hierophant', 'The Devil'],
    theme: 'Tradition becoming restriction',
    category: 'shadow-challenge',
    description:
      'When guidance becomes bondage, when tradition restricts rather than liberates.',
    narrative:
      'Discern where traditional wisdom serves you and where it binds you.',
    significance: 'medium'
  },
  {
    cards: [17, 20],
    names: ['The Star', 'Judgement'],
    theme: 'Renewed hope calling forth rebirth',
    category: 'hope-vision',
    description:
      'Hope inspiring transformation. Vision catalyzing conscious evolution.',
    narrative: 'Renewed hope is calling you into a higher version of yourself.',
    significance: 'high'
  },
  {
    cards: [7, 21],
    names: ['The Chariot', 'The World'],
    theme: 'Determined action reaching completion',
    category: 'hope-vision',
    description:
      'Victory approaching culmination. Sustained effort bearing full fruit.',
    narrative:
      'Your focused effort is leading to complete achievement and mastery.',
    significance: 'high'
  }
];

/**
 * SUIT PROGRESSIONS
 * Minor Arcana developmental arcs within each suit (Aces – Tens)
 * Structured in three stages per suit: beginning, challenge, mastery
 */
export const SUIT_PROGRESSIONS = {
  Wands: {
    element: 'Fire',
    domain: 'Creativity, passion, will, enterprise',

    beginning: {
      ranks: [1, 2, 3],
      theme: 'Ignition',
      narrative:
        'Ace: Pure creative spark → Two: Planning & vision → Three: Confident expansion',
      readingSignificance:
        "You're in the ignition phase of a creative or professional endeavor—high enthusiasm, planning, early momentum.",
      cards: [
        { rank: 1, name: 'Ace of Wands', role: 'Inspired beginning' },
        { rank: 2, name: 'Two of Wands', role: 'Strategic planning' },
        { rank: 3, name: 'Three of Wands', role: 'Confident expansion' }
      ]
    },

    challenge: {
      ranks: [4, 5, 6, 7],
      theme: 'Testing the Fire',
      narrative:
        'Four: Celebration → Five: Competition → Six: Victory → Seven: Defensive perseverance',
      readingSignificance:
        "You're in the testing phase—navigating competition, earning recognition, and defending your position.",
      cards: [
        { rank: 4, name: 'Four of Wands', role: 'Joyful milestone' },
        { rank: 5, name: 'Five of Wands', role: 'Conflict & competition' },
        { rank: 6, name: 'Six of Wands', role: 'Public recognition' },
        { rank: 7, name: 'Seven of Wands', role: 'Standing your ground' }
      ]
    },

    mastery: {
      ranks: [8, 9, 10],
      theme: 'Culmination',
      narrative:
        'Eight: Swift momentum → Nine: Guarded resilience → Ten: Overburdened completion',
      readingSignificance:
        "You're in the culmination phase—things moving fast, resilience tested, burden of success felt. Consider delegating or resting after completion.",
      cards: [
        { rank: 8, name: 'Eight of Wands', role: 'Rapid progress' },
        { rank: 9, name: 'Nine of Wands', role: 'Wounded but standing' },
        { rank: 10, name: 'Ten of Wands', role: 'Carrying the full weight' }
      ],
      shadow: 'Culmination often carries burden or burnout'
    }
  },

  Cups: {
    element: 'Water',
    domain: 'Emotions, relationships, intuition, love',

    beginning: {
      ranks: [1, 2, 3],
      theme: 'Emotional Opening',
      narrative:
        'Ace: Overflowing heart → Two: Partnership & reciprocity → Three: Celebration & friendship',
      readingSignificance:
        "You're in the emotional opening phase—love, connection, and celebration are abundant.",
      cards: [
        { rank: 1, name: 'Ace of Cups', role: 'Overflowing heart' },
        { rank: 2, name: 'Two of Cups', role: 'Mutual devotion' },
        { rank: 3, name: 'Three of Cups', role: 'Joyful community' }
      ]
    },

    challenge: {
      ranks: [4, 5, 6, 7],
      theme: 'Emotional Complexity',
      narrative:
        'Four: Apathy → Five: Loss & grief → Six: Nostalgia → Seven: Overwhelming options',
      readingSignificance:
        "You're in the emotional complexity phase—processing disappointment, grief, or confusion about desires. Discernment needed.",
      cards: [
        { rank: 4, name: 'Four of Cups', role: 'Contemplative withdrawal' },
        { rank: 5, name: 'Five of Cups', role: 'Mourning what is lost' },
        { rank: 6, name: 'Six of Cups', role: 'Sweet memory' },
        { rank: 7, name: 'Seven of Cups', role: 'Fantasy & illusion' }
      ]
    },

    mastery: {
      ranks: [8, 9, 10],
      theme: 'Emotional Maturity',
      narrative: 'Eight: Walking away → Nine: Wish fulfillment → Ten: Blessed union',
      readingSignificance:
        "You're in the emotional maturity phase—making conscious choices to release or embrace, finding authentic fulfillment.",
      cards: [
        { rank: 8, name: 'Eight of Cups', role: 'Conscious release' },
        { rank: 9, name: 'Nine of Cups', role: 'Contentment achieved' },
        { rank: 10, name: 'Ten of Cups', role: 'Blessed union' }
      ],
      light: 'Culmination is deeply fulfilling when authentic'
    }
  },

  Swords: {
    element: 'Air',
    domain: 'Thought, communication, truth, conflict',

    beginning: {
      ranks: [1, 2, 3],
      theme: 'Mental Clarity',
      narrative:
        'Ace: Breakthrough insight → Two: Difficult choice → Three: Heartbreak',
      readingSignificance:
        "You're in the mental clarity phase—truth is emerging, choices are hard, and grief may be necessary. Don't bypass the pain.",
      cards: [
        { rank: 1, name: 'Ace of Swords', role: 'Cutting truth' },
        { rank: 2, name: 'Two of Swords', role: 'Stalemate' },
        { rank: 3, name: 'Three of Swords', role: 'Necessary grief' }
      ]
    },

    challenge: {
      ranks: [4, 5, 6, 7],
      theme: 'Mental Struggle',
      narrative:
        'Four: Rest → Five: Hollow victory → Six: Transition → Seven: Strategy',
      readingSignificance:
        "You're in the mental struggle phase—resting, fighting, transitioning, strategizing. Choose peace over hollow victory.",
      cards: [
        { rank: 4, name: 'Four of Swords', role: 'Contemplative pause' },
        { rank: 5, name: 'Five of Swords', role: 'Pyrrhic win' },
        { rank: 6, name: 'Six of Swords', role: 'Moving toward calm' },
        { rank: 7, name: 'Seven of Swords', role: 'Cunning or theft' }
      ]
    },

    mastery: {
      ranks: [8, 9, 10],
      theme: 'Mental Crisis & Liberation',
      narrative:
        'Eight: Self-imprisonment → Nine: Anxiety → Ten: Rock bottom (then dawn)',
      readingSignificance:
        "You're in the mental crisis phase—feeling trapped, anxious, or hitting bottom. But Swords' culmination promises breakthrough after darkness. The dawn is coming.",
      cards: [
        { rank: 8, name: 'Eight of Swords', role: 'Bound by thought' },
        { rank: 9, name: 'Nine of Swords', role: 'Anguish' },
        { rank: 10, name: 'Ten of Swords', role: 'Painful ending, daybreak coming' }
      ],
      shadow: 'Crisis before breakthrough',
      light: 'The worst is over; dawn is promised'
    }
  },

  Pentacles: {
    element: 'Earth',
    domain: 'Material, body, resources, craft, security',

    beginning: {
      ranks: [1, 2, 3],
      theme: 'Material Foundation',
      narrative:
        'Ace: Seed of prosperity → Two: Juggling resources → Three: Skilled collaboration',
      readingSignificance:
        "You're in the material foundation phase—new opportunities, balancing demands, building expertise through collaboration.",
      cards: [
        { rank: 1, name: 'Ace of Pentacles', role: 'Seed of prosperity' },
        { rank: 2, name: 'Two of Pentacles', role: 'Adaptive balance' },
        { rank: 3, name: 'Three of Pentacles', role: 'Recognized expertise' }
      ]
    },

    challenge: {
      ranks: [4, 5, 6, 7],
      theme: 'Resource Management',
      narrative:
        'Four: Holding tight → Five: Hardship → Six: Generosity → Seven: Patient assessment',
      readingSignificance:
        "You're in the resource management phase—navigating scarcity, learning generosity, assessing whether effort is paying off.",
      cards: [
        { rank: 4, name: 'Four of Pentacles', role: 'Security or greed' },
        { rank: 5, name: 'Five of Pentacles', role: 'Material/spiritual poverty' },
        { rank: 6, name: 'Six of Pentacles', role: 'Balanced giving' },
        { rank: 7, name: 'Seven of Pentacles', role: 'Evaluating progress' }
      ]
    },

    mastery: {
      ranks: [8, 9, 10],
      theme: 'Material Mastery',
      narrative:
        'Eight: Diligent craftsmanship → Nine: Self-sufficiency → Ten: Lasting legacy',
      readingSignificance:
        "You're in the material mastery phase—dedicated practice, self-sufficiency achieved, building legacy.",
      cards: [
        { rank: 8, name: 'Eight of Pentacles', role: 'Dedicated practice' },
        { rank: 9, name: 'Nine of Pentacles', role: 'Refined independence' },
        { rank: 10, name: 'Ten of Pentacles', role: 'Generational wealth' }
      ],
      light: 'Stable, lasting prosperity and legacy'
    }
  }
};

/**
 * COURT FAMILY PATTERNS
 * Highlights when multiple court cards from the same suit appear, indicating lineage dynamics.
 */
export const COURT_FAMILY_PATTERNS = {
  Wands: {
    element: 'Fire',
    theme: 'Creative lineage and torch-passing leadership',
    duoNarrative:
      'Two Wands court cards show creative mentorship—one figure fuels bold action while another shapes direction.',
    trioNarrative:
      'Three or more Wands courts form a fire council handing the torch responsibly across experience levels.',
    deckNotes: {
      'thoth-a1': 'Princess sparks, Prince mobilizes, Queen magnetizes, Knight broadcasts the final blaze.',
      'marseille-classic': 'Valet and Chevalier labor in the field while Reine and Roi codify how the flame is used.'
    }
  },
  Cups: {
    element: 'Water',
    theme: 'Emotional lineage, family systems, and care work',
    duoNarrative:
      'Two Cups court cards reflect emotional mirroring—caregivers trading notes about vulnerability and trust.',
    trioNarrative:
      'Three or more Cups courts indicate a full healing lineage tending to ancestral feelings and relationship repair.',
    deckNotes: {
      'thoth-a1': 'Princess opens the heart, Prince pursues devotion, Queen holds sanctuary, Knight blesses the waters.',
      'marseille-classic': 'Valet and Chevalier carry news of the heart while Reine and Roi tend the household bonds.'
    }
  },
  Swords: {
    element: 'Air',
    theme: 'Strategic councils, truth-telling, and boundary work',
    duoNarrative:
      'Two Swords court cards expose a critical dialogue where intellect meets decisive motion.',
    trioNarrative:
      'Three or more Swords courts activate a strategic tribunal balancing honesty, critique, and decisive action.',
    deckNotes: {
      'thoth-a1': 'Princess gathers data, Prince advances the plan, Queen shapes discourse, Knight delivers the verdict.',
      'marseille-classic': 'Valet scouts, Chevalier confronts, Reine deliberates, Roi codifies the law.'
    }
  },
  Pentacles: {
    element: 'Earth',
    theme: 'Legacy building, stewardship, and material mentorship',
    duoNarrative:
      'Two Pentacles court cards highlight pragmatic mentorship around resources, body wisdom, or business.',
    trioNarrative:
      'Three or more Pentacles courts reveal a full stewardship lineage tending to land, labor, and legacy.',
    deckNotes: {
      'thoth-a1': 'Princess tends the seed, Prince engineers systems, Queen nourishes, Knight ensures lasting structure.',
      'marseille-classic': 'Valet and Chevalier manage the craft while Reine and Roi formalize the guild legacy.'
    }
  }
};

/**
 * THOTH MINOR ARCANA TITLES
 * Crowley/Harris epithets for pip cards with decan assignments
 */
export const THOTH_MINOR_TITLES = {
  'Ace of Wands': { suit: 'Wands', rank: 1, title: 'Root of the Powers of Fire', astrology: 'Pure Fire', description: 'Primordial creative spark—the seed of will and spiritual fire.' },

  'Two of Wands': { suit: 'Wands', rank: 2, title: 'Dominion', astrology: 'Mars in Aries', description: 'Commanding new territory and asserting will with precision.' },
  'Three of Wands': { suit: 'Wands', rank: 3, title: 'Virtue', astrology: 'Sun in Aries', description: 'Radiant integrity that uplifts collaborators and projects.' },
  'Four of Wands': { suit: 'Wands', rank: 4, title: 'Completion', astrology: 'Venus in Aries', description: 'Stabilizing achievements through shared celebration and artistry.' },
  'Five of Wands': { suit: 'Wands', rank: 5, title: 'Strife', astrology: 'Saturn in Leo', description: 'Creative friction forcing refinement of ego and ambition.' },
  'Six of Wands': { suit: 'Wands', rank: 6, title: 'Victory', astrology: 'Jupiter in Leo', description: 'Momentum gathered through wholehearted leadership and recognition.' },
  'Seven of Wands': { suit: 'Wands', rank: 7, title: 'Valour', astrology: 'Mars in Leo', description: 'Courageous stand for truth even when odds are overwhelming.' },
  'Eight of Wands': { suit: 'Wands', rank: 8, title: 'Swiftness', astrology: 'Mercury in Sagittarius', description: 'Rapid downloads, messages, and arrows of intention in flight.' },
  'Nine of Wands': { suit: 'Wands', rank: 9, title: 'Strength', astrology: 'Moon in Sagittarius', description: 'Spiritual stamina—reserves of will gathered through discipline.' },
  'Ten of Wands': { suit: 'Wands', rank: 10, title: 'Oppression', astrology: 'Saturn in Sagittarius', description: 'Burnout warning when passion is trapped in rigid obligation.' },

  'Ace of Cups': { suit: 'Cups', rank: 1, title: 'Root of the Powers of Water', astrology: 'Pure Water', description: 'Source spring of feeling—raw devotion, empathy, and heart-opening.' },

  'Two of Cups': { suit: 'Cups', rank: 2, title: 'Love', astrology: 'Venus in Cancer', description: 'Tender reciprocity and devotion born of emotional safety.' },
  'Three of Cups': { suit: 'Cups', rank: 3, title: 'Abundance', astrology: 'Mercury in Cancer', description: 'Overflow of feeling, creative bonding, communal nourishment.' },
  'Four of Cups': { suit: 'Cups', rank: 4, title: 'Luxury', astrology: 'Moon in Cancer', description: 'Soft indulgence asking for recalibration toward heartfelt purpose.' },
  'Five of Cups': { suit: 'Cups', rank: 5, title: 'Disappointment', astrology: 'Mars in Scorpio', description: 'Emotional expectations dissolving so deeper desire can surface.' },
  'Six of Cups': { suit: 'Cups', rank: 6, title: 'Pleasure', astrology: 'Sun in Scorpio', description: 'Sensual, memory-rich joy that heals through presence and play.' },
  'Seven of Cups': { suit: 'Cups', rank: 7, title: 'Debauch', astrology: 'Venus in Scorpio', description: 'Overindulgence or glamour that muddies intuition and vitality.' },
  'Eight of Cups': { suit: 'Cups', rank: 8, title: 'Indolence', astrology: 'Saturn in Pisces', description: 'Energetic leak—fatigue from clinging to a dream past its ripeness.' },
  'Nine of Cups': { suit: 'Cups', rank: 9, title: 'Happiness', astrology: 'Jupiter in Pisces', description: 'Spiritual contentment, devotion, and gratitude refilling the well.' },
  'Ten of Cups': { suit: 'Cups', rank: 10, title: 'Satiety', astrology: 'Mars in Pisces', description: 'Emotional saturation prompting surrender and compassionate release.' },

  'Ace of Swords': { suit: 'Swords', rank: 1, title: 'Root of the Powers of Air', astrology: 'Pure Air', description: 'First flash of insight—razor-sharp clarity cutting through confusion.' },

  'Two of Swords': { suit: 'Swords', rank: 2, title: 'Peace', astrology: 'Moon in Libra', description: 'Ceasefire energy—mental clarity through balancing opposites.' },
  'Three of Swords': { suit: 'Swords', rank: 3, title: 'Sorrow', astrology: 'Saturn in Libra', description: 'Sacred grief and necessary reckoning with piercing truths.' },
  'Four of Swords': { suit: 'Swords', rank: 4, title: 'Truce', astrology: 'Jupiter in Libra', description: 'Pause and recovery so mind and body can integrate the lesson.' },
  'Five of Swords': { suit: 'Swords', rank: 5, title: 'Defeat', astrology: 'Venus in Aquarius', description: 'Self-sabotage or pride blocks inviting a new mental strategy.' },
  'Six of Swords': { suit: 'Swords', rank: 6, title: 'Science', astrology: 'Mercury in Aquarius', description: 'Elegant solutions and innovation through clear thinking.' },
  'Seven of Swords': { suit: 'Swords', rank: 7, title: 'Futility', astrology: 'Moon in Aquarius', description: 'Fragmented efforts and leaky focus demanding prioritization.' },
  'Eight of Swords': { suit: 'Swords', rank: 8, title: 'Interference', astrology: 'Jupiter in Gemini', description: 'Mental clutter, competing inputs, and crossed signals causing delay.' },
  'Nine of Swords': { suit: 'Swords', rank: 9, title: 'Cruelty', astrology: 'Mars in Gemini', description: 'Inner critic or harsh words—need for compassionate self-dialogue.' },
  'Ten of Swords': { suit: 'Swords', rank: 10, title: 'Ruin', astrology: 'Sun in Gemini', description: 'Mental burnout clearing the slate for radically new paradigms.' },

  'Ace of Pentacles': { suit: 'Pentacles', rank: 1, title: 'Root of the Powers of Earth', astrology: 'Pure Earth', description: 'Seed of manifestation—embodied potential in its most concentrated form.' },

  'Two of Pentacles': { suit: 'Pentacles', rank: 2, title: 'Change', astrology: 'Jupiter in Capricorn', description: 'Dynamic adaptation—turning chaos into rhythm and flow.' },
  'Three of Pentacles': { suit: 'Pentacles', rank: 3, title: 'Works', astrology: 'Mars in Capricorn', description: 'Material mastery through teamwork, craft, and focused effort.' },
  'Four of Pentacles': { suit: 'Pentacles', rank: 4, title: 'Power', astrology: 'Sun in Capricorn', description: 'Stability, infrastructure, and strategic stewardship of resources.' },
  'Five of Pentacles': { suit: 'Pentacles', rank: 5, title: 'Worry', astrology: 'Mercury in Taurus', description: 'Scarcity mindset signalling a need for somatic trust and support.' },
  'Six of Pentacles': { suit: 'Pentacles', rank: 6, title: 'Success', astrology: 'Moon in Taurus', description: 'Tangible wins and steady nourishment—remember generous reciprocity.' },
  'Seven of Pentacles': { suit: 'Pentacles', rank: 7, title: 'Failure', astrology: 'Saturn in Taurus', description: 'Slow harvest prompting patience, pruning, and systems thinking.' },
  'Eight of Pentacles': { suit: 'Pentacles', rank: 8, title: 'Prudence', astrology: 'Sun in Virgo', description: 'Methodical craft, refinement, and devotion to incremental mastery.' },
  'Nine of Pentacles': { suit: 'Pentacles', rank: 9, title: 'Gain', astrology: 'Venus in Virgo', description: 'Self-sufficiency, lush results, and discerning stewardship.' },
  'Ten of Pentacles': { suit: 'Pentacles', rank: 10, title: 'Wealth', astrology: 'Mercury in Virgo', description: 'Legacy resources—build structures that benefit community and lineage.' }
};

/**
 * Marseille numerology + pip geometry themes
 */
export const MARSEILLE_NUMERICAL_THEMES = {
  1: { keyword: 'Essence', description: 'Single stem on the central axis—the seed of purpose asking for direction.', geometry: 'Vertical wand/cup anchoring the entire motif.' },
  2: { keyword: 'Duality', description: 'Mirrored forms show dialogue, choice, and polarity seeking harmony.', geometry: 'Paired emblems meeting across a central flower.' },
  3: { keyword: 'Expansion', description: 'Triadic symmetry indicates growth, creativity, and collaborative momentum.', geometry: 'Three-petal arcs forming a triangle of flow.' },
  4: { keyword: 'Structure', description: 'Crossed stems create a stable lattice; emphasizes foundations and boundaries.', geometry: 'Quadrants built from intersecting batons or swords.' },
  5: { keyword: 'Vital Shift', description: 'Center blossom disrupted—tension prompting recalibration and courage.', geometry: 'Central flower pierced or contrasted by the fifth symbol.' },
  6: { keyword: 'Harmony', description: 'Balanced weaving of stems; receptive, beautiful equilibrium of forces.', geometry: 'Hexagonal arrangement framing a radiant center.' },
  7: { keyword: 'Challenge', description: 'Asymmetry appears; invites introspection and faith beyond comfort.', geometry: 'Single emblem misaligned above or below the stable lattice.' },
  8: { keyword: 'Movement', description: 'Loops and crossings accelerate—depicts cycles, diligence, and momentum.', geometry: 'Double loops suggesting infinity symbols within the pip art.' },
  9: { keyword: 'Ripeness', description: 'Dense patternation shows fullness and stewardship of completion.', geometry: 'Three triads stacked, flowers blooming at intersections.' },
10: { keyword: 'Threshold', description: 'Pip forms create portals—culmination transitioning into a new cycle.', geometry: 'Four pairs framing a central staff or sword, indicating closure.' }
};

const THOTH_MAJOR_TITLES = {
  0: 'The Fool',
  1: 'The Magus',
  2: 'The Priestess',
  3: 'The Empress',
  4: 'The Emperor',
  5: 'The Hierophant',
  6: 'The Lovers',
  7: 'The Chariot',
  8: 'Adjustment',
  9: 'The Hermit',
 10: 'Fortune',
 11: 'Lust',
 12: 'The Hanged Man',
 13: 'Death',
 14: 'Art',
 15: 'The Devil',
 16: 'The Tower',
 17: 'The Star',
 18: 'The Moon',
 19: 'The Sun',
 20: 'The Aeon',
 21: 'The Universe'
};

const MARSEILLE_MAJOR_TITLES = {
  0: 'Le Mat',
  1: 'Le Bateleur',
  2: 'La Papesse',
  3: "L'Imperatrice",
  4: "L'Empereur",
  5: 'Le Pape',
  6: "L'Amoureux",
  7: 'Le Chariot',
  8: 'La Justice',
  9: "L'Hermite",
 10: 'La Roue de Fortune',
 11: 'La Force',
 12: 'Le Pendu',
 13: 'La Mort',
 14: 'Temperance',
 15: 'Le Diable',
 16: 'La Maison Dieu',
 17: "L'Etoile",
 18: 'La Lune',
 19: 'Le Soleil',
 20: 'Le Jugement',
 21: 'Le Monde'
};

export const DECK_STYLE_OVERRIDES = {
  'rws-1909': {
    displayName: 'Rider-Waite-Smith 1909',
    suitAliases: {},
    courtAliases: { Page: 'Page', Knight: 'Knight', Queen: 'Queen', King: 'King' },
    majorAliases: {},
    numerologyThemes: null
  },
  'thoth-a1': {
    displayName: 'Thoth',
    suitAliases: { Pentacles: 'Disks' },
    courtAliases: { Page: 'Princess', Knight: 'Prince', Queen: 'Queen', King: 'Knight' },
    majorAliases: THOTH_MAJOR_TITLES,
    minorTitles: THOTH_MINOR_TITLES,
    courtNotes: 'Princess ignites, Prince mobilizes, Queen magnetizes, Knight radiates the final expression.',
    numerologyThemes: null
  },
  'marseille-classic': {
    displayName: 'Tarot de Marseille',
    suitAliases: { Pentacles: 'Coins', Wands: 'Batons' },
    courtAliases: { Page: 'Valet', Knight: 'Chevalier', Queen: 'Reine', King: 'Roi' },
    majorAliases: MARSEILLE_MAJOR_TITLES,
    numerologyThemes: MARSEILLE_NUMERICAL_THEMES,
    courtNotes: 'Valet carries the message, Chevalier rides into action, Reine and Roi codify the legacy.'
  }
};
</file>

<file path="src/data/majorArcana.js">
// Major Arcana data with 1909 Rider-Waite card images
// Images are from Wikimedia Commons (public domain)
export const MAJOR_ARCANA = [
  { name: 'The Fool', number: 0, upright: 'New beginnings, innocence, spontaneity, free spirit', reversed: 'Recklessness, taken advantage of, inconsideration', image: '/images/cards/RWS1909_-_00_Fool.jpeg' },
  { name: 'The Magician', number: 1, upright: 'Manifestation, resourcefulness, power, inspired action', reversed: 'Manipulation, poor planning, untapped talents', image: '/images/cards/RWS1909_-_01_Magician.jpeg' },
  { name: 'The High Priestess', number: 2, upright: 'Intuition, sacred knowledge, divine feminine, subconscious', reversed: 'Secrets, disconnected from intuition, withdrawal', image: '/images/cards/RWS1909_-_02_High_Priestess.jpeg' },
  { name: 'The Empress', number: 3, upright: 'Femininity, beauty, nature, nurturing, abundance', reversed: 'Creative block, dependence on others', image: '/images/cards/RWS1909_-_03_Empress.jpeg' },
  { name: 'The Emperor', number: 4, upright: 'Authority, establishment, structure, father figure', reversed: 'Domination, excessive control, lack of discipline', image: '/images/cards/RWS1909_-_04_Emperor.jpeg' },
  { name: 'The Hierophant', number: 5, upright: 'Spiritual wisdom, tradition, conformity, institutions', reversed: 'Personal beliefs, freedom, challenging the status quo', image: '/images/cards/RWS1909_-_05_Hierophant.jpeg' },
  { name: 'The Lovers', number: 6, upright: 'Love, harmony, relationships, values alignment, choices', reversed: 'Self-love, disharmony, imbalance, misalignment', image: '/images/cards/RWS1909_-_06_Lovers.jpeg' },
  { name: 'The Chariot', number: 7, upright: 'Control, willpower, success, action, determination', reversed: 'Self-discipline, opposition, lack of direction', image: '/images/cards/RWS1909_-_07_Chariot.jpeg' },
  { name: 'Strength', number: 8, upright: 'Strength, courage, persuasion, influence, compassion', reversed: 'Inner strength, self-doubt, low energy, raw emotion', image: '/images/cards/RWS1909_-_08_Strength.jpeg' },
  { name: 'The Hermit', number: 9, upright: 'Soul-searching, introspection, inner guidance, solitude', reversed: 'Isolation, loneliness, withdrawal', image: '/images/cards/RWS1909_-_09_Hermit.jpeg' },
  { name: 'Wheel of Fortune', number: 10, upright: 'Good luck, karma, life cycles, destiny, turning point', reversed: 'Bad luck, resistance to change, breaking cycles', image: '/images/cards/RWS1909_-_10_Wheel_of_Fortune.jpeg' },
  { name: 'Justice', number: 11, upright: 'Justice, fairness, truth, cause and effect, law', reversed: 'Unfairness, lack of accountability, dishonesty', image: '/images/cards/RWS1909_-_11_Justice.jpeg' },
  { name: 'The Hanged Man', number: 12, upright: 'Pause, surrender, letting go, new perspectives', reversed: 'Delays, resistance, stalling, indecision', image: '/images/cards/RWS1909_-_12_Hanged_Man.jpeg' },
  { name: 'Death', number: 13, upright: 'Endings, change, transformation, transition', reversed: 'Resistance to change, personal transformation, inner purging', image: '/images/cards/RWS1909_-_13_Death.jpeg' },
  { name: 'Temperance', number: 14, upright: 'Balance, moderation, patience, purpose', reversed: 'Imbalance, excess, self-healing, re-alignment', image: '/images/cards/RWS1909_-_14_Temperance.jpeg' },
  { name: 'The Devil', number: 15, upright: 'Shadow self, attachment, addiction, restriction, sexuality', reversed: 'Releasing limiting beliefs, exploring dark thoughts, detachment', image: '/images/cards/RWS1909_-_15_Devil.jpeg' },
  { name: 'The Tower', number: 16, upright: 'Sudden change, upheaval, chaos, revelation, awakening', reversed: 'Personal transformation, fear of change, averting disaster', image: '/images/cards/RWS1909_-_16_Tower.jpeg' },
  { name: 'The Star', number: 17, upright: 'Hope, faith, purpose, renewal, spirituality', reversed: 'Lack of faith, despair, self-trust, disconnection', image: '/images/cards/RWS1909_-_17_Star.jpeg' },
  { name: 'The Moon', number: 18, upright: 'Illusion, fear, anxiety, subconscious, intuition', reversed: 'Release of fear, repressed emotion, inner confusion', image: '/images/cards/RWS1909_-_18_Moon.jpeg' },
  { name: 'The Sun', number: 19, upright: 'Positivity, fun, warmth, success, vitality', reversed: 'Inner child, feeling down, overly optimistic', image: '/images/cards/RWS1909_-_19_Sun.jpeg' },
  { name: 'Judgement', number: 20, upright: 'Judgement, rebirth, inner calling, absolution', reversed: 'Self-doubt, inner critic, ignoring the call', image: '/images/cards/RWS1909_-_20_Judgement.jpeg' },
  { name: 'The World', number: 21, upright: 'Completion, accomplishment, travel, achievement', reversed: 'Seeking closure, shortcuts, delays', image: '/images/cards/RWS1909_-_21_World.jpeg' }
];
</file>

<file path="src/data/minorArcana.js">
// Minor Arcana data for Tableau
// Shape is aligned with MINORS_TOGGLE_PLAN and existing majorArcana.js style.
// - name: "Rank of Suit"
// - suit: "Wands" | "Cups" | "Swords" | "Pentacles"
// - rank: "Ace" | "Two" | ... | "Ten" | "Page" | "Knight" | "Queen" | "King"
// - rankValue: 1–14 (for sequence/suit-run analysis)
// - upright / reversed: concise, RWS-aligned meanings
// - image: path to 1909 Rider-Waite card image (public domain)

function makeCard(suit, rank, rankValue, upright, reversed) {
    // Generate image path based on suit and rankValue
    const paddedRank = String(rankValue).padStart(2, '0');
    const image = `/images/cards/RWS1909_-_${suit}_${paddedRank}.jpeg`;

    return {
        name: `${rank} of ${suit}`,
        suit,
        rank,
        rankValue,
        upright,
        reversed,
        image
    };
}

export const MINOR_ARCANA = [
    // WANDS (Fire) - inspiration, action, will

    makeCard(
        'Wands',
        'Ace',
        1,
        'Inspiration, new energy, creative spark, potential for bold action',
        'Scattered energy, lack of direction, missed opportunities to act'
    ),
    makeCard(
        'Wands',
        'Two',
        2,
        'Planning, looking ahead, making empowered choices, considering options',
        'Fear of expansion, staying small, over-planning without movement'
    ),
    makeCard(
        'Wands',
        'Three',
        3,
        'Progress, momentum, ventures launching, seeing first results',
        'Delays, limited foresight, frustration waiting for returns'
    ),
    makeCard(
        'Wands',
        'Four',
        4,
        'Celebration, stability, milestone reached, supportive community',
        'Tension at home, instability under the surface, needing true belonging'
    ),
    makeCard(
        'Wands',
        'Five',
        5,
        'Competition, testing ideas, lively conflict, proving yourself',
        'Avoidance of conflict, resentment, unproductive tension'
    ),
    makeCard(
        'Wands',
        'Six',
        6,
        'Recognition, victory, validation, visible progress',
        'Self-doubt, lack of recognition, seeking approval from others'
    ),
    makeCard(
        'Wands',
        'Seven',
        7,
        'Defensiveness, standing your ground, maintaining boundaries',
        'Feeling overwhelmed, burnout, giving up too soon'
    ),
    makeCard(
        'Wands',
        'Eight',
        8,
        'Swift movement, acceleration, messages, rapid developments',
        'Delays, miscommunication, scattered efforts, mixed signals'
    ),
    makeCard(
        'Wands',
        'Nine',
        9,
        'Resilience, perseverance, cautious strength, near completion',
        'Hyper-vigilance, exhaustion, struggling to trust or continue'
    ),
    makeCard(
        'Wands',
        'Ten',
        10,
        'Burden, responsibilities, carrying a heavy load to completion',
        'Overload, unsustainable pressure, needing to delegate or release'
    ),
    makeCard(
        'Wands',
        'Page',
        11,
        'Enthusiasm, creative curiosity, messages of opportunity',
        'Restlessness, immaturity, unfocused inspiration'
    ),
    makeCard(
        'Wands',
        'Knight',
        12,
        'Courage, bold pursuit, adventure, passionate action',
        'Impulsiveness, recklessness, inconsistency, burnout risk'
    ),
    makeCard(
        'Wands',
        'Queen',
        13,
        'Confidence, charisma, leadership through warmth and vision',
        'Jealousy, insecurity, manipulation, shrinking your light'
    ),
    makeCard(
        'Wands',
        'King',
        14,
        'Strategic vision, authority, entrepreneurial fire, leading by example',
        'Domineering, rigid, intolerant, misusing influence'
    ),

    // CUPS (Water) - emotions, relationships, intuition

    makeCard(
        'Cups',
        'Ace',
        1,
        'New feelings, emotional openness, intuition, beginnings in love or healing',
        'Emotional block, numbness, repressed or unexpressed feelings'
    ),
    makeCard(
        'Cups',
        'Two',
        2,
        'Connection, partnership, mutual respect, heartfelt unity',
        'Imbalance, misunderstanding, emotional distance between people'
    ),
    makeCard(
        'Cups',
        'Three',
        3,
        'Friendship, joy, community, shared celebration',
        'Overindulgence, gossip, feeling left out or excluded'
    ),
    makeCard(
        'Cups',
        'Four',
        4,
        'Apathy, contemplation, reevaluating offers, emotional withdrawal',
        'New interest, emotional re-engagement, seeing opportunities again'
    ),
    makeCard(
        'Cups',
        'Five',
        5,
        'Grief, regret, focusing on loss, emotional disappointment',
        'Acceptance, perspective returning, learning from sorrow'
    ),
    makeCard(
        'Cups',
        'Six',
        6,
        'Nostalgia, innocence, kind memories, simple affection',
        'Living in the past, rose-colored views, difficulty moving on'
    ),
    makeCard(
        'Cups',
        'Seven',
        7,
        'Choices, dreams, fantasies, many options, visioning',
        'Confusion, illusion, overwhelm, need for grounded decision'
    ),
    makeCard(
        'Cups',
        'Eight',
        8,
        'Walking away, deeper search, leaving what no longer nourishes',
        'Fear of leaving, stagnation, staying in unfulfilling situations'
    ),
    makeCard(
        'Cups',
        'Nine',
        9,
        'Contentment, emotional satisfaction, wishes fulfilled',
        'Smugness, dissatisfaction, surface-level comfort without depth'
    ),
    makeCard(
        'Cups',
        'Ten',
        10,
        'Emotional fulfillment, harmony, chosen family, stable joy',
        'Disconnection, family tension, ideals of happiness not matching reality'
    ),
    makeCard(
        'Cups',
        'Page',
        11,
        'Gentle curiosity, creative sensitivity, messages from the heart',
        'Emotional immaturity, escapism, ignoring intuitive nudges'
    ),
    makeCard(
        'Cups',
        'Knight',
        12,
        'Romantic pursuit, idealism, following the heart, poetic action',
        'Over-idealization, inconsistency, moodiness, avoidance of reality'
    ),
    makeCard(
        'Cups',
        'Queen',
        13,
        'Compassion, empathy, emotional intelligence, intuition in flow',
        'Emotional overwhelm, martyrdom, blurred boundaries'
    ),
    makeCard(
        'Cups',
        'King',
        14,
        'Emotional mastery, stability, wise counsel, calm depth',
        'Emotional suppression, control, manipulation or detachment'
    ),

    // SWORDS (Air) - mind, truth, conflict, clarity

    makeCard(
        'Swords',
        'Ace',
        1,
        'Clarity, breakthrough, new idea, honest communication',
        'Confusion, misinformation, harsh words, overthinking'
    ),
    makeCard(
        'Swords',
        'Two',
        2,
        'Stalemate, difficult choice, guarded heart, weighing options',
        'Avoidance, indecision, denial of truth, inner tension'
    ),
    makeCard(
        'Swords',
        'Three',
        3,
        'Heartache, painful truth, disappointment, release through honesty',
        'Lingering hurt, suppression, difficulty processing pain'
    ),
    makeCard(
        'Swords',
        'Four',
        4,
        'Rest, retreat, mental recovery, intentional pause',
        'Restlessness, burnout, resisting needed downtime'
    ),
    makeCard(
        'Swords',
        'Five',
        5,
        'Pyrrhic victory, conflict, ego battles, questionable win',
        'Desire to reconcile, walking away, learning from conflict'
    ),
    makeCard(
        'Swords',
        'Six',
        6,
        'Transition, moving on, mental shift toward calmer waters',
        'Difficulty leaving, emotional baggage, stalled transition'
    ),
    makeCard(
        'Swords',
        'Seven',
        7,
        'Strategy, discretion, working quietly, questioning trust',
        'Exposure, consequences, call for transparency and integrity'
    ),
    makeCard(
        'Swords',
        'Eight',
        8,
        'Feeling trapped, limiting beliefs, mental imprisonment',
        'Releasing constraints, seeing options, reclaiming agency'
    ),
    makeCard(
        'Swords',
        'Nine',
        9,
        'Anxiety, worry, sleepless thoughts, mental overwhelm',
        'Recovery from anxiety, gaining perspective, support arriving'
    ),
    makeCard(
        'Swords',
        'Ten',
        10,
        'Ending, rock bottom, harsh conclusion, clearing for renewal',
        'Resistance to ending, lingering pain, slowly rising again'
    ),
    makeCard(
        'Swords',
        'Page',
        11,
        'Curiosity, new ideas, vigilance, honest questions',
        'Rumors, hastiness, mental scatteredness, intrusive thoughts'
    ),
    makeCard(
        'Swords',
        'Knight',
        12,
        'Decisive action, sharp focus, pursuing truth swiftly',
        'Impulsivity, aggression, speaking without care, tunnel vision'
    ),
    makeCard(
        'Swords',
        'Queen',
        13,
        'Clear thinking, boundaries, discernment, direct communication',
        'Coldness, cynicism, cutting words, over-detachment'
    ),
    makeCard(
        'Swords',
        'King',
        14,
        'Authority in truth, rational leadership, strategic intellect',
        'Manipulative logic, rigidity, misusing knowledge or power'
    ),

    // PENTACLES (Earth) - body, work, resources, stability

    makeCard(
        'Pentacles',
        'Ace',
        1,
        'New material opportunity, seed of prosperity, tangible beginning',
        'Blocked opportunity, short-term thinking, hesitating to invest'
    ),
    makeCard(
        'Pentacles',
        'Two',
        2,
        'Balance, juggling priorities, adaptable resource management',
        'Overwhelm, instability, disorganized responsibilities'
    ),
    makeCard(
        'Pentacles',
        'Three',
        3,
        'Collaboration, skill development, building something of quality',
        'Lack of teamwork, misalignment, underappreciated skills'
    ),
    makeCard(
        'Pentacles',
        'Four',
        4,
        'Security, holding on, protecting resources, stability',
        'Fear-based clinging, scarcity mindset, resistance to flow'
    ),
    makeCard(
        'Pentacles',
        'Five',
        5,
        'Hardship, scarcity, feeling left out, material or emotional struggle',
        'Support available, recovery path, shifting from isolation to help'
    ),
    makeCard(
        'Pentacles',
        'Six',
        6,
        'Generosity, reciprocity, fair exchange, support in balance',
        'Strings attached, inequality, imbalance in giving and receiving'
    ),
    makeCard(
        'Pentacles',
        'Seven',
        7,
        'Patience, evaluation, long-term investment, slow growth',
        'Impatience, doubt, misallocation of effort, reconsidering path'
    ),
    makeCard(
        'Pentacles',
        'Eight',
        8,
        'Mastery through practice, craftsmanship, dedicated work',
        'Monotony, overwork, stagnation, lack of intentional growth'
    ),
    makeCard(
        'Pentacles',
        'Nine',
        9,
        'Self-sufficiency, comfort, earned success, enjoying the fruits',
        'Dependence, imposter feelings, not owning your achievements'
    ),
    makeCard(
        'Pentacles',
        'Ten',
        10,
        'Legacy, long-term stability, family, wealth, foundations',
        'Inheritances of pattern, financial tension, misaligned values'
    ),
    makeCard(
        'Pentacles',
        'Page',
        11,
        'Student mindset, new skill, practical opportunity, grounded curiosity',
        'Procrastination, lack of follow-through, missed chances to learn'
    ),
    makeCard(
        'Pentacles',
        'Knight',
        12,
        'Steady progress, responsibility, reliability, slow and sure effort',
        'Stagnation, stubbornness, resistance to adapt'
    ),
    makeCard(
        'Pentacles',
        'Queen',
        13,
        'Nurturing abundance, practicality, resourceful care, body wisdom',
        'Overextension, neglecting self, imbalance between care and depletion'
    ),
    makeCard(
        'Pentacles',
        'King',
        14,
        'Material mastery, stability, stewardship, grounded leadership',
        'Greed, rigidity, over-identification with status or control'
    )
];
</file>

<file path="src/data/spreads.js">
export const SPREADS = {
  // One-card: simple, focused, great as daily draw or core theme
  single: {
    name: 'One-Card Insight',
    tag: 'Quick',
    positions: ['Theme / Guidance of the Moment'],
    roleKeys: ['theme'],
    count: 1,
    description: "One card focused on your question's core energy.",
    complexity: { stars: 1, label: 'Easy' },
    preview: {
      src: '/images/spread-art/single.png',
      width: 220,
      height: 108,
      alt: 'Single card centered on a starry field'
    }
  },

  // Three-card: foundational narrative spread
  threeCard: {
    name: 'Three-Card Story (Past · Present · Future)',
    tag: 'Story',
    positions: [
      'Past — influences that led here',
      'Present — where you stand now',
      'Future — trajectory if nothing shifts'
    ],
    roleKeys: ['past', 'present', 'future'],
    count: 3,
    description: 'Past, present, and future—see how your story moves.',
    complexity: { stars: 2, label: 'Normal' },
    preview: {
      src: '/images/spread-art/threeCard.png',
      width: 219,
      height: 108,
      alt: 'Three cards aligned for past, present, and future'
    }
  },

  // Five-card: structured clarity without full deep-dive
  fiveCard: {
    name: 'Five-Card Clarity',
    tag: 'Clarity',
    positions: [
      'Core of the matter',
      'Challenge or tension',
      'Hidden / subconscious influence',
      'Support / helpful energy',
      'Likely direction on current path'
    ],
    roleKeys: ['core', 'challenge', 'subconscious', 'support', 'direction'],
    count: 5,
    description: 'Core tension, support, challenge, and direction.',
    complexity: { stars: 2, label: 'Normal' },
    preview: {
      src: '/images/spread-art/fiveCard.png',
      width: 219,
      height: 108,
      alt: 'Five-card cross layout'
    }
  },

  // Decision / two-path: compare options while honoring agency
  decision: {
    name: 'Decision / Two-Path',
    tag: 'Decision',
    positions: [
      'Heart of the decision',
      'Path A — energy & likely outcome',
      'Path B — energy & likely outcome',
      'What clarifies the best path',
      'What to remember about your free will'
    ],
    roleKeys: ['heart', 'pathA', 'pathB', 'clarifier', 'freeWill'],
    count: 5,
    description: 'Compare two paths. Choose with clarity.',
    complexity: { stars: 2, label: 'Normal' },
    preview: {
      src: '/images/spread-art/decision.png',
      width: 220,
      height: 108,
      alt: 'Dual path layout with clarifying center'
    }
  },

  // Relationship: focused dynamic between querent and other
  relationship: {
    name: 'Relationship Snapshot',
    tag: 'Relationship',
    positions: [
      'You / your energy',
      'Them / their energy',
      'The connection / shared lesson'
    ],
    roleKeys: ['you', 'them', 'connection'],
    count: 3,
    description: 'Your energy, their energy, your shared connection.',
    complexity: { stars: 2, label: 'Normal' },
    preview: {
      src: '/images/spread-art/relationship.png',
      width: 220,
      height: 109,
      alt: 'Three-card relationship triangle layout'
    }
  },

  // Celtic Cross: classic full spread for complex questions
  celtic: {
    name: 'Celtic Cross (Classic 10-Card)',
    tag: 'Deep dive',
    positions: [
      'Present — core situation',
      'Challenge — crossing / tension',
      'Past — what lies behind',
      'Near Future — what lies before',
      'Conscious — goals & focus',
      'Subconscious — roots / hidden forces',
      'Self / Advice — how to meet this',
      'External Influences — people & environment',
      'Hopes & Fears — deepest wishes & worries',
      'Outcome — likely path if unchanged'
    ],
    // Canonical position roles aligned with AI Tarot Master guide §10 + Appendix A
    roleKeys: [
      'present',       // 1
      'challenge',     // 2
      'past',          // 3
      'near_future',   // 4
      'conscious',     // 5
      'subconscious',  // 6
      'self_advice',   // 7
      'external',      // 8
      'hopes_fears',   // 9
      'outcome'        // 10
    ],
    count: 10,
    description: 'The classic deep dive—ten cards, full picture.',
    complexity: { stars: 3, label: 'Hard' },
    preview: {
      src: '/images/spread-art/celtic.png',
      width: 220,
      height: 109,
      alt: 'Celtic Cross ten-card arrangement'
    }
  }
};

export const DEFAULT_SPREAD_KEY = 'single';

export function normalizeSpreadKey(spreadKey, fallbackKey = DEFAULT_SPREAD_KEY) {
  if (spreadKey && SPREADS[spreadKey]) {
    return spreadKey;
  }
  if (fallbackKey && SPREADS[fallbackKey]) {
    return fallbackKey;
  }
  const [firstKey] = Object.keys(SPREADS);
  return firstKey || '';
}

export function getSpreadInfo(spreadKey, fallbackKey = DEFAULT_SPREAD_KEY) {
  const key = normalizeSpreadKey(spreadKey, fallbackKey);
  return key ? SPREADS[key] : null;
}
</file>

<file path="src/data/symbolCoordinates.js">
import { SYMBOL_ANNOTATIONS } from '../../shared/symbols/symbolAnnotations';

/**
 * symbolCoordinates.js
 * SVG coordinate mappings for interactive card symbol tooltips
 *
 * ViewBox: 820 x 1430 (standard RWS card aspect ratio)
 * Coordinates are approximate and based on typical RWS 1909 composition
 *
 * Touch targets are generous (60-100 units) for mobile usability
 *
 * Shape types:
 * - circle: { shape: 'circle', cx, cy, r }
 * - rect: { shape: 'rect', x, y, width, height }
 * - polygon: { shape: 'polygon', points: 'x1,y1 x2,y2 ...' }
 *
 * indicatorCx/Cy: Optional pulsing dot to show interactivity
 */

export const SYMBOL_COORDINATES = {
  // Card 0: The Fool
  0: {
    symbols: [
      {
        symbol: SYMBOL_ANNOTATIONS[0].symbols[0], // Sun
        shape: 'circle',
        cx: 120,
        cy: 140,
        r: 70,
        indicatorCx: 120,
        indicatorCy: 140
      },
      {
        symbol: SYMBOL_ANNOTATIONS[0].symbols[1], // Dog
        shape: 'rect',
        x: 520,
        y: 1100,
        width: 150,
        height: 180,
        indicatorCx: 595,
        indicatorCy: 1190
      },
      {
        symbol: SYMBOL_ANNOTATIONS[0].symbols[2], // Cliff
        shape: 'rect',
        x: 700,
        y: 600,
        width: 100,
        height: 400,
        indicatorCx: 750,
        indicatorCy: 800
      },
      {
        symbol: SYMBOL_ANNOTATIONS[0].symbols[3], // White rose
        shape: 'circle',
        cx: 200,
        cy: 620,
        r: 50,
        indicatorCx: 200,
        indicatorCy: 620
      },
      {
        symbol: SYMBOL_ANNOTATIONS[0].symbols[4], // Bundle
        shape: 'circle',
        cx: 250,
        cy: 380,
        r: 60,
        indicatorCx: 250,
        indicatorCy: 380
      },
      {
        symbol: SYMBOL_ANNOTATIONS[0].symbols[5], // Feather in hat
        shape: 'circle',
        cx: 440,
        cy: 180,
        r: 45,
        indicatorCx: 440,
        indicatorCy: 180
      }
    ]
  },

  // Card 1: The Magician
  1: {
    symbols: [
      {
        symbol: SYMBOL_ANNOTATIONS[1].symbols[0], // Infinity symbol
        shape: 'circle',
        cx: 410,
        cy: 120,
        r: 55,
        indicatorCx: 410,
        indicatorCy: 120
      },
      {
        symbol: SYMBOL_ANNOTATIONS[1].symbols[1], // Wand (right hand raised)
        shape: 'rect',
        x: 550,
        y: 320,
        width: 80,
        height: 180,
        indicatorCx: 590,
        indicatorCy: 410
      },
      {
        symbol: SYMBOL_ANNOTATIONS[1].symbols[2], // Cup on table
        shape: 'circle',
        cx: 220,
        cy: 950,
        r: 60,
        indicatorCx: 220,
        indicatorCy: 950
      },
      {
        symbol: SYMBOL_ANNOTATIONS[1].symbols[3], // Sword on table
        shape: 'rect',
        x: 360,
        y: 920,
        width: 100,
        height: 80,
        indicatorCx: 410,
        indicatorCy: 960
      },
      {
        symbol: SYMBOL_ANNOTATIONS[1].symbols[4], // Pentacle on table
        shape: 'circle',
        cx: 600,
        cy: 950,
        r: 60,
        indicatorCx: 600,
        indicatorCy: 950
      },
      {
        symbol: SYMBOL_ANNOTATIONS[1].symbols[5], // Red roses (garden)
        shape: 'rect',
        x: 150,
        y: 1250,
        width: 200,
        height: 120,
        indicatorCx: 250,
        indicatorCy: 1310
      },
      {
        symbol: SYMBOL_ANNOTATIONS[1].symbols[6], // White lilies (garden)
        shape: 'rect',
        x: 470,
        y: 1250,
        width: 200,
        height: 120,
        indicatorCx: 570,
        indicatorCy: 1310
      }
    ]
  },

  // Card 2: The High Priestess
  2: {
    symbols: [
      {
        symbol: SYMBOL_ANNOTATIONS[2].symbols[0], // Pillars (B & J)
        shape: 'rect',
        x: 40,
        y: 350,
        width: 740,
        height: 800,
        indicatorCx: 410,
        indicatorCy: 500
      },
      {
        symbol: SYMBOL_ANNOTATIONS[2].symbols[1], // Lunar crown
        shape: 'circle',
        cx: 410,
        cy: 180,
        r: 80,
        indicatorCx: 410,
        indicatorCy: 180
      },
      {
        symbol: SYMBOL_ANNOTATIONS[2].symbols[2], // Scroll (Tora)
        shape: 'rect',
        x: 310,
        y: 850,
        width: 200,
        height: 150,
        indicatorCx: 410,
        indicatorCy: 925
      },
      {
        symbol: SYMBOL_ANNOTATIONS[2].symbols[3], // Veil
        shape: 'rect',
        x: 150,
        y: 300,
        width: 520,
        height: 600,
        indicatorCx: 250,
        indicatorCy: 400
      },
      {
        symbol: SYMBOL_ANNOTATIONS[2].symbols[5], // Crescent moon
        shape: 'circle',
        cx: 200,
        cy: 1250,
        r: 90,
        indicatorCx: 200,
        indicatorCy: 1250
      }
    ]
  },

  // Card 3: The Empress
  3: {
    symbols: [
      {
        symbol: SYMBOL_ANNOTATIONS[3].symbols[0], // Wheat fields
        shape: 'rect',
        x: 50,
        y: 1100,
        width: 300,
        height: 250,
        indicatorCx: 200,
        indicatorCy: 1225
      },
      {
        symbol: SYMBOL_ANNOTATIONS[3].symbols[2], // Venus shield
        shape: 'circle',
        cx: 650,
        cy: 1100,
        r: 100,
        indicatorCx: 650,
        indicatorCy: 1100
      },
      {
        symbol: SYMBOL_ANNOTATIONS[3].symbols[3], // Scepter
        shape: 'rect',
        x: 580,
        y: 350,
        width: 80,
        height: 400,
        indicatorCx: 620,
        indicatorCy: 450
      }
    ]
  }
};

/**
 * NOTES FOR FUTURE COORDINATE MAPPING:
 *
 * 1. View the actual card image at public/images/cards/RWS1909_-_XX_*.jpeg
 * 2. Use an SVG editor or browser dev tools to measure positions
 * 3. Coordinate system: (0,0) is top-left, (820, 1430) is bottom-right
 * 4. Make touch targets 60-100 units minimum for mobile usability
 * 5. Use indicatorCx/Cy to place pulsing dots at symbol centers
 * 6. Prefer circles for radial/organic symbols, rects for geometric ones
 * 7. Use polygons for complex/irregular shapes (e.g., flowing robes, animals)
 *
 * TESTING COORDINATES:
 * - Open card in browser
 * - Enable overlay by setting feature flag
 * - Adjust coordinates in dev tools until alignment is correct
 * - Fine-tune for all screen sizes (mobile, tablet, desktop)
 */
</file>

<file path="src/hooks/useAudioController.js">
import { useState, useEffect, useCallback, useRef } from 'react';
import {
  speakText,
  pauseTTS,
  resumeTTS,
  stopTTS,
  subscribeToTTS,
  getCurrentTTSState,
  unlockAudio
} from '../lib/audio';
import {
  speakWithHume,
  stopHumeAudio,
  resetGenerationId
} from '../lib/audioHume';
import { usePreferences } from '../contexts/PreferencesContext';

export function useAudioController() {
  const { voiceOn, setVoiceOn, ttsProvider } = usePreferences();
  const [ttsState, setTtsState] = useState(() => getCurrentTTSState());
  const [ttsAnnouncement, setTtsAnnouncement] = useState('');
  const [voicePromptRequested, setVoicePromptRequested] = useState(false);
  const showVoicePrompt = voicePromptRequested && !voiceOn;

  // Track Hume audio state separately
  const humeAudioRef = useRef(null);
  const [humeState, setHumeState] = useState({ status: 'idle', error: null });

  // Subscribe to TTS state changes
  useEffect(() => {
    const unsubscribe = subscribeToTTS(state => {
      setTtsState(state);

      const isAnnounceContext =
        state.context === 'full-reading' ||
        state.context === 'card-reveal';

      const baseMessage =
        state.message ||
        (state.status === 'completed'
          ? (state.context === 'card-reveal'
            ? 'Card narration finished.'
            : 'Narration finished.')
          : state.status === 'paused'
            ? (state.context === 'card-reveal'
              ? 'Card narration paused.'
              : 'Narration paused.')
            : state.status === 'playing'
              ? (state.context === 'card-reveal'
                ? 'Card narration playing.'
                : 'Narration playing.')
              : state.status === 'loading'
                ? (state.context === 'card-reveal'
                  ? 'Preparing card narration.'
                  : 'Preparing narration.')
                : state.status === 'stopped'
                  ? 'Narration stopped.'
                  : state.status === 'error'
                    ? 'Narration unavailable.'
                    : '');

      const announcement = isAnnounceContext ? baseMessage : '';
      setTtsAnnouncement(announcement);
    });
    return unsubscribe;
  }, []);

  // Stop TTS when voice is toggled off
  useEffect(() => {
    if (!voiceOn) {
      stopTTS();
      stopHumeAudio();
      setTimeout(() => {
        setHumeState({ status: 'idle', error: null });
      }, 0);
    }
  }, [voiceOn]);

  // Hume TTS speak function with emotion support
  const speakWithHumeProvider = useCallback(async (text, context = 'default', emotion = null) => {
    if (!text || !voiceOn) return;

    try {
      // Stop any currently playing Hume audio
      if (humeAudioRef.current) {
        humeAudioRef.current.stop();
      }

      setHumeState({ status: 'loading', error: null });
      setTtsAnnouncement('Preparing mystical narration...');

      const result = await speakWithHume(text, {
        context,
        voiceName: 'ITO', // Warm, contemplative voice for readings
        speed: 0.95, // Slightly slower for contemplation
        emotion // GraphRAG-derived emotion for acting instructions
      });

      humeAudioRef.current = result;
      setHumeState({ status: 'playing', error: null });
      setTtsAnnouncement('Playing your personalized reading...');

      // Play the audio
      await result.play();

      // Handle audio end
      result.audio.onended = () => {
        setHumeState({ status: 'completed', error: null });
        setTtsAnnouncement('Narration finished.');
        humeAudioRef.current = null;
      };

      // Handle audio errors
      result.audio.onerror = (e) => {
        console.error('Hume audio playback error:', e);
        setHumeState({ status: 'error', error: 'Audio playback failed' });
        setTtsAnnouncement('Narration unavailable.');
        humeAudioRef.current = null;
      };

    } catch (error) {
      console.error('Hume TTS error:', error);
      setHumeState({ status: 'error', error: error.message || 'Failed to generate speech' });
      setTtsAnnouncement('Narration unavailable.');
    }
  }, [voiceOn]);

  // Azure TTS speak function (original)
  const speakWithAzure = useCallback(async (text, context = 'default') => {
    await speakText({
      text,
      enabled: voiceOn,
      context,
      voice: 'nova' // Default voice for mystical tarot readings
    });
  }, [voiceOn]);

  // Unified speak function that routes to appropriate provider
  const speak = useCallback(async (text, context = 'default', emotion = null) => {
    if (ttsProvider === 'hume') {
      await speakWithHumeProvider(text, context, emotion);
    } else {
      // Azure TTS doesn't support emotion parameter
      await speakWithAzure(text, context);
    }
  }, [ttsProvider, speakWithHumeProvider, speakWithAzure]);

  const handleNarrationButtonClick = useCallback(async (fullReadingText, isPersonalReadingError, emotion = null) => {
    if (!voiceOn) {
      setVoicePromptRequested(true);
      return;
    }
    const isNarrationAvailable = Boolean(fullReadingText);
    if (!isNarrationAvailable || isPersonalReadingError) return;

    // Determine current state based on provider
    const currentState = ttsProvider === 'hume' ? humeState : ttsState;
    const isLoading = currentState.status === 'loading';
    
    // Check if either provider is playing to prevent race conditions or overlap
    const isHumePlaying = humeState.status === 'playing';
    const isAzurePlaying = ttsState.status === 'playing';
    const isPlaying = isHumePlaying || isAzurePlaying;
    const isPaused = currentState.status === 'paused';

    if (isLoading && !isPaused && !isPlaying) return;

    if (isPlaying) {
      if (isHumePlaying && humeAudioRef.current) {
        humeAudioRef.current.pause();
        setHumeState({ status: 'paused', error: null });
        setTtsAnnouncement('Narration paused.');
      }
      
      if (isAzurePlaying) {
        pauseTTS();
      }
      return;
    }

    const unlocked = await unlockAudio();
    if (!unlocked) {
      return;
    }

    if (isPaused) {
      if (ttsProvider === 'hume' && humeAudioRef.current) {
        humeAudioRef.current.audio.play();
        setHumeState({ status: 'playing', error: null });
        setTtsAnnouncement('Resuming narration...');
      } else {
        void resumeTTS();
      }
      return;
    }

    // Reset voice continuity when starting a new reading narration
    if (ttsProvider === 'hume') {
      resetGenerationId();
    }

    void speak(fullReadingText, 'full-reading', emotion);
  }, [voiceOn, ttsState, humeState, ttsProvider, speak]);

  const handleNarrationStop = useCallback(() => {
    // Always attempt to stop both providers to prevent orphaned audio
    stopHumeAudio();
    if (humeAudioRef.current) {
      humeAudioRef.current = null;
    }
    setHumeState({ status: 'stopped', error: null });
    setTtsAnnouncement('Narration stopped.');
    resetGenerationId(); // Reset for next reading
    
    stopTTS();
  }, []);

  const handleVoicePromptEnable = useCallback(async (fullReadingText, emotion) => {
    setVoiceOn(true);
    setVoicePromptRequested(false);
    if (!fullReadingText) return;
    const unlocked = await unlockAudio();
    if (!unlocked) return;
    setTimeout(() => {
      void speak(fullReadingText, 'full-reading', emotion);
    }, 120);
  }, [setVoiceOn, speak]);

  const setShowVoicePrompt = useCallback((nextVisible) => {
    setVoicePromptRequested(Boolean(nextVisible));
  }, []);

  // Expose the correct TTS state based on current provider
  const effectiveTtsState = ttsProvider === 'hume' ? humeState : ttsState;

  return {
    ttsState: effectiveTtsState,
    ttsAnnouncement,
    showVoicePrompt,
    setShowVoicePrompt,
    speak,
    handleNarrationButtonClick,
    handleNarrationStop,
    handleVoicePromptEnable,
    ttsProvider
  };
}
</file>

<file path="src/hooks/useBodyScrollLock.js">
import { useEffect, useLayoutEffect, useRef, useState } from 'react';

// Use useLayoutEffect on client, useEffect during SSR
const useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;

/**
 * useBodyScrollLock prevents background scroll when overlays are open.
 *
 * Two strategies:
 * - 'simple': Sets overflow: hidden (may cause content shift on scrollbar removal)
 * - 'fixed': Positions body fixed and compensates for scrollbar width (no shift)
 *
 * @param {boolean} isLocked - Whether to lock body scroll
 * @param {Object} options
 * @param {'simple' | 'fixed'} options.strategy - Lock strategy (default: 'fixed')
 * @returns {{ scrollY: number }} - Current scroll position when locked
 */
export function useBodyScrollLock(isLocked, { strategy = 'fixed' } = {}) {
  // State for return value (safe to read during render)
  const [scrollY, setScrollY] = useState(0);
  const previousStylesRef = useRef(null);
  const prevIsLockedRef = useRef(false);

  // Capture scroll position when transitioning to locked state.
  // Must run in a layout effect (not during render) to avoid re-render loops.
  useIsomorphicLayoutEffect(() => {
    if (isLocked && !prevIsLockedRef.current) {
      const currentScrollY = typeof window !== 'undefined' ? window.scrollY : 0;
      setScrollY(currentScrollY);
    }
    prevIsLockedRef.current = isLocked;
  }, [isLocked]);

  useEffect(() => {
    if (!isLocked) {
      return undefined;
    }

    // Capture scroll position at the time effect runs
    const capturedScrollY = window.scrollY;

    // Calculate scrollbar width to prevent content shift
    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;

    // Store original styles for restoration
    previousStylesRef.current = {
      overflow: document.body.style.overflow,
      position: document.body.style.position,
      top: document.body.style.top,
      width: document.body.style.width,
      paddingRight: document.body.style.paddingRight,
    };

    if (strategy === 'simple') {
      // Simple strategy: just hide overflow
      document.body.style.overflow = 'hidden';
      if (scrollbarWidth > 0) {
        document.body.style.paddingRight = `${scrollbarWidth}px`;
      }
    } else {
      // Fixed strategy: prevents iOS bounce and maintains scroll position
      document.body.style.overflow = 'hidden';
      document.body.style.position = 'fixed';
      document.body.style.top = `-${capturedScrollY}px`;
      document.body.style.width = '100%';
      if (scrollbarWidth > 0) {
        document.body.style.paddingRight = `${scrollbarWidth}px`;
      }
    }

    return () => {
      // Restore original styles
      if (previousStylesRef.current) {
        const prev = previousStylesRef.current;
        document.body.style.overflow = prev.overflow;
        document.body.style.position = prev.position;
        document.body.style.top = prev.top;
        document.body.style.width = prev.width;
        document.body.style.paddingRight = prev.paddingRight;
      }
      previousStylesRef.current = null;

      // Restore scroll position (only needed for fixed strategy)
      if (strategy === 'fixed') {
        window.scrollTo(0, capturedScrollY);
      }
    };
  }, [isLocked, strategy]);

  return { scrollY };
}
</file>

<file path="src/hooks/useFeatureFlags.js">
/**
 * Centralized feature flag checking
 * 
 * Provides consistent feature flag evaluation across the application.
 * All environment-based feature flags should be checked through this hook.
 */

import { useMemo } from 'react';

export function useFeatureFlags() {
  const flags = useMemo(() => ({
    // Vision Research Mode
    visionResearch: import.meta.env?.VITE_ENABLE_VISION_RESEARCH === 'true',

    // New Deck Ritual Interface (unified deck + ritual controls)
    // Set VITE_NEW_DECK_INTERFACE=true to enable the reimagined deck interface
    newDeckInterface: import.meta.env?.VITE_NEW_DECK_INTERFACE === 'true',

    // Future flags can be added here
    // Example: betaFeatures: import.meta.env?.VITE_BETA_FEATURES === 'true',
  }), []);

  return flags;
}

/**
 * Direct feature flag check (for non-hook contexts)
 */
export function isVisionResearchEnabled() {
  return import.meta.env?.VITE_ENABLE_VISION_RESEARCH === 'true';
}

/**
 * Check if new deck interface is enabled
 */
export function isNewDeckInterfaceEnabled() {
  return import.meta.env?.VITE_NEW_DECK_INTERFACE === 'true';
}
</file>

<file path="src/hooks/useInlineStatus.js">
import { useCallback, useEffect, useRef, useState } from 'react';

const DEFAULT_STATUS = { tone: 'info', message: '', action: null };

export function useInlineStatus(timeoutMs = 3200) {
  const [status, setStatus] = useState(DEFAULT_STATUS);
  const timerRef = useRef(null);

  const clearStatus = useCallback(() => {
    setStatus(DEFAULT_STATUS);
  }, []);

  const showStatus = useCallback((next) => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }

    if (!next?.message) {
      setStatus(DEFAULT_STATUS);
      return;
    }

    const merged = {
      ...DEFAULT_STATUS,
      ...next
    };

    setStatus(merged);

    if (timeoutMs > 0) {
      timerRef.current = setTimeout(() => {
        setStatus(DEFAULT_STATUS);
        timerRef.current = null;
      }, timeoutMs);
    }
  }, [timeoutMs]);

  useEffect(() => () => {
    if (timerRef.current) {
      clearTimeout(timerRef.current);
    }
  }, []);

  return {
    status,
    showStatus,
    clearStatus,
    isActive: Boolean(status.message)
  };
}
</file>

<file path="src/hooks/useJournal.js">
import { useState, useEffect } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { persistJournalInsights } from '../lib/journalInsights';

const LOCALSTORAGE_KEY = 'tarot_journal';
const CACHE_KEY = 'tarot_journal_cache';

/**
 * Journal hook with automatic API/localStorage routing
 *
 * - If user is authenticated: saves to D1 database via API (with local caching)
 * - If user is not authenticated: saves to localStorage
 *
 * This provides backward compatibility while enabling cloud sync for auth users
 */
export function useJournal({ autoLoad = true } = {}) {
  const { isAuthenticated } = useAuth();
  const [entries, setEntries] = useState([]);
  const [loading, setLoading] = useState(autoLoad);
  const [error, setError] = useState(null);

  // Load entries on mount or when auth state changes
  useEffect(() => {
    if (!autoLoad && isAuthenticated) {
      return;
    }
    loadEntries();
    // eslint-disable-next-line react-hooks/exhaustive-deps -- loadEntries is stable, avoid infinite loop
  }, [isAuthenticated, autoLoad]);

  const loadEntries = async () => {
    setLoading(true);
    setError(null);

    try {
      if (isAuthenticated) {
        // Try loading from API first
        try {
          const response = await fetch('/api/journal', {
            credentials: 'include'
          });

          if (!response.ok) {
            throw new Error('Failed to load journal entries');
          }

          const data = await response.json();
          const apiEntries = data.entries || [];
          setEntries(apiEntries);

          // Update cache
          if (typeof localStorage !== 'undefined') {
            localStorage.setItem(CACHE_KEY, JSON.stringify(apiEntries));
            persistJournalInsights(apiEntries);
          }
        } catch (apiError) {
          console.warn('API load failed, falling back to cache:', apiError);
          // Fallback to cache
          if (typeof localStorage !== 'undefined') {
            const cached = localStorage.getItem(CACHE_KEY);
            if (cached) {
              const parsedCache = JSON.parse(cached);
              setEntries(parsedCache);
              persistJournalInsights(parsedCache);
              // Don't set error if we have cache, just warn
            } else {
              throw apiError;
            }
          } else {
            throw apiError;
          }
        }
      } else {
        // Load from localStorage
        if (typeof localStorage === 'undefined') {
          setEntries([]);
          if (typeof window !== 'undefined') {
            persistJournalInsights([]);
          }
        } else {
          const stored = localStorage.getItem(LOCALSTORAGE_KEY);
          if (stored) {
            try {
              const parsed = JSON.parse(stored);
              const safeEntries = Array.isArray(parsed) ? parsed : [];
              setEntries(safeEntries);
              if (typeof window !== 'undefined') {
                persistJournalInsights(safeEntries);
              }
            } catch (err) {
              console.error('Failed to parse localStorage journal:', err);
              setEntries([]);
              if (typeof window !== 'undefined') {
                persistJournalInsights([]);
              }
            }
          } else {
            setEntries([]);
            if (typeof window !== 'undefined') {
              persistJournalInsights([]);
            }
          }
        }
      }
    } catch (err) {
      console.error('Failed to load journal entries:', err);
      setError(err.message);
      setEntries([]);
    } finally {
      setLoading(false);
    }
  };

  const saveEntry = async (entry) => {
    setError(null);

    try {
      if (isAuthenticated) {
        // Save to API
        const response = await fetch('/api/journal', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          credentials: 'include',
          body: JSON.stringify(entry)
        });

        if (!response.ok) {
          throw new Error('Failed to save journal entry');
        }

        const data = await response.json();

        // Build entry object from server response
        const newEntry = {
          id: data.entry.id,
          ts: data.entry.ts,
          ...entry
        };

        // If server detected a duplicate (same session_seed), skip local state
        // updates to keep client in sync with DB
        if (data.deduplicated) {
          return { success: true, entry: newEntry, deduplicated: true };
        }

        // Add to local state only for genuinely new entries
        setEntries(prev => {
          const next = [newEntry, ...prev];
          if (typeof window !== 'undefined') {
            persistJournalInsights(next);
            localStorage.setItem(CACHE_KEY, JSON.stringify(next));
          }
          return next;
        });

        // Track card appearances for archetype journey analytics
        if (Array.isArray(entry.cards) && entry.cards.length > 0) {
          trackCardAppearances(entry.cards, newEntry.ts);
        }

        return { success: true, entry: newEntry };
      } else {
        // Save to localStorage
        if (typeof localStorage === 'undefined') {
          return { success: false, error: 'localStorage not available' };
        }

        const newEntry = {
          id: crypto.randomUUID?.() || `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          ts: Date.now(),
          ...entry
        };

        const updated = [newEntry, ...entries];

        // Limit to 100 entries in localStorage
        if (updated.length > 100) {
          updated.length = 100;
        }

        localStorage.setItem(LOCALSTORAGE_KEY, JSON.stringify(updated));
        setEntries(updated);
        if (typeof window !== 'undefined') {
          persistJournalInsights(updated);
        }

        return { success: true, entry: newEntry };
      }
    } catch (err) {
      console.error('Failed to save journal entry:', err);
      setError(err.message);
      return { success: false, error: err.message };
    }
  };

  /**
   * Track card appearances for archetype journey analytics
   */
  const trackCardAppearances = async (cards, timestamp) => {
    if (!isAuthenticated) {
      return; // Only track for authenticated users
    }

    try {
      await fetch('/api/archetype-journey/track', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        credentials: 'include',
        body: JSON.stringify({
          cards,
          timestamp
        })
      });
      // Silent failure - don't block reading save if tracking fails
    } catch (err) {
      console.warn('Failed to track card appearances:', err);
    }
  };

  const deleteEntry = async (entryId) => {
    setError(null);

    try {
      if (isAuthenticated) {
        // Delete from API
        const response = await fetch(`/api/journal/${entryId}`, {
          method: 'DELETE',
          credentials: 'include'
        });

        if (!response.ok) {
          throw new Error('Failed to delete journal entry');
        }

        // Remove from local state
        setEntries(prev => {
          const next = prev.filter(e => e.id !== entryId);
          if (typeof window !== 'undefined') {
            persistJournalInsights(next);
            localStorage.setItem(CACHE_KEY, JSON.stringify(next));
          }
          return next;
        });

        return { success: true };
      } else {
        // Delete from localStorage
        if (typeof localStorage === 'undefined') {
          return { success: false, error: 'localStorage not available' };
        }

        const updated = entries.filter(e => e.id !== entryId);
        localStorage.setItem(LOCALSTORAGE_KEY, JSON.stringify(updated));
        setEntries(updated);
        if (typeof window !== 'undefined') {
          persistJournalInsights(updated);
        }

        return { success: true };
      }
    } catch (err) {
      console.error('Failed to delete journal entry:', err);
      setError(err.message);
      return { success: false, error: err.message };
    }
  };

  const migrateToCloud = async () => {
    if (!isAuthenticated) {
      return { success: false, error: 'Not authenticated', skipped: 0 };
    }

    if (typeof localStorage === 'undefined') {
      return { success: false, error: 'localStorage not available', skipped: 0 };
    }

    try {
      // Get localStorage entries
      const stored = localStorage.getItem(LOCALSTORAGE_KEY);
      if (!stored) {
        return { success: true, migrated: 0, skipped: 0 };
      }

      const localEntries = JSON.parse(stored);
      if (!Array.isArray(localEntries) || localEntries.length === 0) {
        return { success: true, migrated: 0, skipped: 0 };
      }

      // Fetch existing cloud entries to check for duplicates
      const existingResponse = await fetch('/api/journal', {
        credentials: 'include'
      });

      const existingSeeds = new Set();
      const existingCompositeKeys = new Set();
      if (existingResponse.ok) {
        const { entries: cloudEntries } = await existingResponse.json();
        // Build sets for deduplication
        cloudEntries.forEach(entry => {
          // Primary: track by session_seed
          if (entry.sessionSeed) {
            existingSeeds.add(entry.sessionSeed);
          }
          // Fallback: track by composite key for entries without sessionSeed
          const timestamp = entry.ts || entry.created_at * 1000 || entry.updated_at * 1000;
          if (timestamp) {
            const cardsFingerprint = (Array.isArray(entry?.cards) ? entry.cards : [])
              .map((card) => `${card?.name || 'card'}:${card?.orientation || (card?.isReversed ? 'reversed' : 'upright')}`)
              .join(',');
            const compositeKey = `${timestamp}_${entry.question || ''}_${entry.spreadKey || ''}_${cardsFingerprint}`;
            existingCompositeKeys.add(compositeKey);
          }
        });
      }

      // Upload each entry to the API, skipping duplicates
      let migrated = 0;
      let skipped = 0;
      for (const entry of localEntries) {
        try {
          let isDuplicate = false;

          // Primary: Check by session_seed
          if (entry.sessionSeed && existingSeeds.has(entry.sessionSeed)) {
            isDuplicate = true;
          }

          // Fallback: Check by composite key (timestamp + question + spread + cards)
          if (!isDuplicate && !entry.sessionSeed && entry.ts) {
            const cardsFingerprint = (Array.isArray(entry?.cards) ? entry.cards : [])
              .map((card) => `${card?.name || 'card'}:${card?.orientation || (card?.isReversed ? 'reversed' : 'upright')}`)
              .join(',');
            const compositeKey = `${entry.ts}_${entry.question || ''}_${entry.spreadKey || ''}_${cardsFingerprint}`;
            if (existingCompositeKeys.has(compositeKey)) {
              isDuplicate = true;
            }
          }

          if (isDuplicate) {
            skipped++;
            continue;
          }

          const response = await fetch('/api/journal', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            credentials: 'include',
            body: JSON.stringify({
              // Preserve the original local timestamp when migrating so the
              // server can store an accurate created_at for historical entries.
              ...entry,
              timestampMs: typeof entry.ts === 'number' ? entry.ts : undefined
            })
          });

          if (response.ok) {
            migrated++;
            // Add to sets to prevent duplicate uploads in this batch
            if (entry.sessionSeed) {
              existingSeeds.add(entry.sessionSeed);
            }
            if (entry.ts) {
              const cardsFingerprint = (Array.isArray(entry?.cards) ? entry.cards : [])
                .map((card) => `${card?.name || 'card'}:${card?.orientation || (card?.isReversed ? 'reversed' : 'upright')}`)
                .join(',');
              const compositeKey = `${entry.ts}_${entry.question || ''}_${entry.spreadKey || ''}_${cardsFingerprint}`;
              existingCompositeKeys.add(compositeKey);
            }
          }
        } catch (err) {
          console.error('Failed to migrate entry:', err);
        }
      }

      // Only clear localStorage when we've either migrated or explicitly
      // skipped every entry in this batch. If some entries failed to upload
      // (e.g. due to a flaky network), keep the local copy so the user can
      // retry the migration later without losing data.
      const totalLocal = Array.isArray(localEntries) ? localEntries.length : 0;
      if (totalLocal > 0 && migrated + skipped === totalLocal) {
        localStorage.removeItem(LOCALSTORAGE_KEY);
      }

      // Reload entries from API
      await loadEntries();

      return {
        success: true,
        migrated,
        skipped
      };
    } catch (err) {
      console.error('Migration failed:', err);
      return { success: false, error: err.message };
    }
  };

  return {
    entries,
    loading,
    error,
    saveEntry,
    deleteEntry,
    migrateToCloud,
    reload: loadEntries
  };
}
</file>

<file path="src/hooks/useLandscape.js">
import { useEffect, useState } from 'react';

/**
 * useLandscape detects landscape orientation on small viewport devices.
 * Returns true when device is in landscape AND viewport height is constrained.
 * This helps identify cramped mobile landscape situations.
 */
export function useLandscape(maxHeight = 600) {
  const getInitial = () => {
    if (typeof window === 'undefined') {
      return false;
    }
    const isLandscape = window.matchMedia('(orientation: landscape)').matches;
    const isShortViewport = window.innerHeight <= maxHeight;
    return isLandscape && isShortViewport;
  };

  const [isSmallLandscape, setIsSmallLandscape] = useState(getInitial);

  useEffect(() => {
    if (typeof window === 'undefined') {
      return undefined;
    }

    const checkOrientation = () => {
      const isLandscape = window.matchMedia('(orientation: landscape)').matches;
      const isShortViewport = window.innerHeight <= maxHeight;
      setIsSmallLandscape(isLandscape && isShortViewport);
    };

    // Check on resize and orientation change
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', checkOrientation);

    // Initial sync
    checkOrientation();

    return () => {
      window.removeEventListener('resize', checkOrientation);
      window.removeEventListener('orientationchange', checkOrientation);
    };
  }, [maxHeight]);

  return isSmallLandscape;
}
</file>

<file path="src/hooks/useModalA11y.js">
import { useEffect, useRef, useCallback } from 'react';
import { useBodyScrollLock } from './useBodyScrollLock';

/**
 * Focusable element selectors for focus trapping
 */
const FOCUSABLE_SELECTORS = [
  'a[href]',
  'button:not([disabled])',
  'textarea:not([disabled])',
  'input:not([disabled])',
  'select:not([disabled])',
  '[tabindex]:not([tabindex="-1"])',
  '[contenteditable]',
  'audio[controls]',
  'video[controls]'
].join(', ');

/**
 * useModalA11y - Shared accessibility hook for modals and drawers
 *
 * Provides:
 * - Body scroll locking (prevents background scroll)
 * - Escape key to close
 * - Focus restoration on close
 * - Optional built-in focus trapping (if not using FocusTrap library)
 *
 * @param {boolean} isOpen - Whether the modal is open
 * @param {Object} options
 * @param {Function} options.onClose - Callback when modal should close
 * @param {React.RefObject} options.containerRef - Ref to the modal container element
 * @param {'simple' | 'fixed'} options.scrollLockStrategy - Scroll lock strategy (default: 'fixed')
 * @param {boolean} options.trapFocus - Whether to trap focus within the modal (default: true)
 * @param {boolean} options.closeOnEscape - Whether to close on Escape key (default: true)
 * @param {boolean} options.restoreFocus - Whether to restore focus on close (default: true)
 * @param {React.RefObject} options.initialFocusRef - Ref to element that should receive initial focus
 *
 * @returns {Object} - { previousFocusRef }
 *
 * @example
 * function MyModal({ isOpen, onClose }) {
 *   const modalRef = useRef(null);
 *   useModalA11y(isOpen, {
 *     onClose,
 *     containerRef: modalRef,
 *   });
 *
 *   if (!isOpen) return null;
 *
 *   return (
 *     <div ref={modalRef} role="dialog" aria-modal="true">
 *       ...
 *     </div>
 *   );
 * }
 */
export function useModalA11y(isOpen, {
  onClose,
  containerRef,
  scrollLockStrategy = 'fixed',
  trapFocus = true,
  closeOnEscape = true,
  restoreFocus = true,
  initialFocusRef = null,
} = {}) {
  const previousFocusRef = useRef(null);

  // Body scroll lock
  useBodyScrollLock(isOpen, { strategy: scrollLockStrategy });

  // Store previous focus when modal opens
  useEffect(() => {
    if (!isOpen) return;

    if (restoreFocus && document.activeElement instanceof HTMLElement) {
      previousFocusRef.current = document.activeElement;
    }
  }, [isOpen, restoreFocus]);

  // Restore focus when modal closes
  useEffect(() => {
    if (isOpen) return;

    if (!restoreFocus || !previousFocusRef.current || typeof previousFocusRef.current.focus !== 'function') {
      return undefined;
    }

    // Use setTimeout to ensure focus restoration happens after animations
    const timer = setTimeout(() => {
      previousFocusRef.current?.focus();
      previousFocusRef.current = null;
    }, 0);

    return () => clearTimeout(timer);
  }, [isOpen, restoreFocus]);

  // Set initial focus when modal opens
  useEffect(() => {
    if (!isOpen) return;

    const setInitialFocus = () => {
      if (initialFocusRef?.current) {
        initialFocusRef.current.focus();
      } else if (containerRef?.current) {
        // Focus the container if no specific element is specified
        containerRef.current.focus({ preventScroll: true });
      }
    };

    // Small delay to allow for animations
    const timer = setTimeout(setInitialFocus, 50);
    return () => clearTimeout(timer);
  }, [isOpen, initialFocusRef, containerRef]);

  // Keyboard handling (Escape + Tab focus trap)
  const handleKeyDown = useCallback((event) => {
    if (!isOpen) return;

    // Escape to close
    if (closeOnEscape && event.key === 'Escape') {
      event.preventDefault();
      onClose?.();
      return;
    }

    // Focus trap on Tab
    if (trapFocus && event.key === 'Tab' && containerRef?.current) {
      const focusable = containerRef.current.querySelectorAll(FOCUSABLE_SELECTORS);

      if (focusable.length === 0) {
        event.preventDefault();
        containerRef.current.focus();
        return;
      }

      const first = focusable[0];
      const last = focusable[focusable.length - 1];

      if (event.shiftKey && document.activeElement === first) {
        event.preventDefault();
        last.focus();
      } else if (!event.shiftKey && document.activeElement === last) {
        event.preventDefault();
        first.focus();
      }
    }
  }, [isOpen, closeOnEscape, trapFocus, onClose, containerRef]);

  // Attach keyboard listener
  useEffect(() => {
    if (!isOpen) return undefined;

    // Use capture phase to catch events before other handlers
    document.addEventListener('keydown', handleKeyDown, true);

    return () => {
      document.removeEventListener('keydown', handleKeyDown, true);
    };
  }, [isOpen, handleKeyDown]);

  return { previousFocusRef };
}

/**
 * Helper to handle backdrop clicks (close when clicking outside modal content)
 *
 * @param {Function} onClose - Close callback
 * @returns {Function} - Click handler for the backdrop element
 *
 * @example
 * <div className="backdrop" onClick={createBackdropHandler(onClose)}>
 *   <div className="modal-content" onClick={e => e.stopPropagation()}>
 *     ...
 *   </div>
 * </div>
 */
export function createBackdropHandler(onClose) {
  return (event) => {
    if (event.target === event.currentTarget) {
      onClose?.();
    }
  };
}
</file>

<file path="src/hooks/useReducedMotion.js">
import { useSyncExternalStore } from 'react';

const REDUCED_MOTION_QUERY = '(prefers-reduced-motion: reduce)';

/**
 * Subscribe to reduced motion media query changes.
 * Handles both modern and legacy Safari APIs.
 */
function subscribe(callback) {
  if (typeof window === 'undefined' || typeof window.matchMedia !== 'function') {
    return () => {};
  }

  const mediaQuery = window.matchMedia(REDUCED_MOTION_QUERY);

  // Modern browsers
  if (typeof mediaQuery.addEventListener === 'function') {
    mediaQuery.addEventListener('change', callback);
    return () => mediaQuery.removeEventListener('change', callback);
  }

  // Legacy Safari (< 14) fallback
  if (typeof mediaQuery.addListener === 'function') {
    mediaQuery.addListener(callback);
    return () => mediaQuery.removeListener(callback);
  }

  return () => {};
}

/**
 * Get current reduced motion preference from browser.
 */
function getSnapshot() {
  if (typeof window === 'undefined' || typeof window.matchMedia !== 'function') {
    return false;
  }
  return window.matchMedia(REDUCED_MOTION_QUERY).matches;
}

/**
 * Server snapshot - always returns false to prevent hydration mismatches.
 */
function getServerSnapshot() {
  return false;
}

/**
 * Hook to detect user's reduced motion preference.
 *
 * Uses useSyncExternalStore for proper React integration with browser media queries.
 * SSR-safe: returns false on server to prevent hydration mismatches.
 *
 * Listens for preference changes and updates accordingly.
 *
 * @returns {boolean} True if user prefers reduced motion
 */
export function useReducedMotion() {
  return useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
}
</file>

<file path="src/hooks/useSaveReading.js">
import { useState, useRef, useCallback } from 'react';
import { useReading } from '../contexts/ReadingContext';
import { usePreferences } from '../contexts/PreferencesContext';
import { useJournal } from './useJournal';
import { getSpreadInfo } from '../data/spreads';

export function useSaveReading() {
    const {
        reading,
        personalReading,
        themes,
        reflections,
        analysisContext,
        sessionSeed,
        userQuestion,
        selectedSpread,
        setJournalStatus,
        readingMeta
    } = useReading();

    const { deckStyleId, personalization } = usePreferences();
    const { saveEntry } = useJournal({ autoLoad: false });

    // Prevent double-saves from rapid clicks or network retries
    const [isSaving, setIsSaving] = useState(false);
    const lastSavedSeedRef = useRef(null);

    const saveReading = useCallback(async function saveReading() {
        // Prevent double-saves
        if (isSaving) {
            return;
        }

        // Skip if this exact reading was already saved (same session seed)
        if (sessionSeed && lastSavedSeedRef.current === sessionSeed) {
            setJournalStatus({ type: 'info', message: 'This reading is already saved to your journal.' });
            return;
        }

        if (!reading) {
            setJournalStatus({ type: 'error', message: 'Draw your cards before saving to the journal.' });
            return;
        }
        if (!personalReading || personalReading.isError) {
            setJournalStatus({ type: 'error', message: 'Generate a personalized narrative before saving to the journal.' });
            return;
        }
        const spreadInfo = getSpreadInfo(selectedSpread);
        const entry = {
            spread: spreadInfo?.name || 'Tarot Spread',
            spreadKey: selectedSpread,
            question: userQuestion || '',
            cards: reading.map((card, index) => ({
                position: spreadInfo?.positions?.[index] || `Position ${index + 1}`,
                name: card.name,
                // Major Arcana have `number` (0-21), Minor Arcana have `rankValue` (1-14)
                number: card.number ?? null,
                suit: card.suit ?? null,
                rank: card.rank ?? null,
                rankValue: card.rankValue ?? null,
                orientation: card.isReversed ? 'Reversed' : 'Upright'
            })),
            personalReading: personalReading?.raw || personalReading?.normalized || '',
            themes: themes || null,
            reflections: reflections || {},
            context: analysisContext || readingMeta?.graphContext || null,
            provider: personalReading?.provider || readingMeta?.provider || 'local',
            sessionSeed,
            deckId: deckStyleId,
            // Snapshot of user preferences at the time of the reading (Phase 5.1)
            userPreferences: personalization ? {
                readingTone: personalization.readingTone || 'balanced',
                spiritualFrame: personalization.spiritualFrame || 'mixed',
                tarotExperience: personalization.tarotExperience || 'intermediate',
                // Capture reading depth preference for narrative length consistency
                preferredSpreadDepth: personalization.preferredSpreadDepth || 'standard',
                // Store displayName only if set (avoid null/empty)
                ...(personalization.displayName?.trim() ? { displayName: personalization.displayName.trim() } : {})
            } : null
        };
        setIsSaving(true);
        try {
            const result = await saveEntry(entry);
            if (result.success) {
                // Track successful save to prevent duplicate saves of same reading
                if (sessionSeed) {
                    lastSavedSeedRef.current = sessionSeed;
                }
                if (typeof navigator !== 'undefined' && typeof navigator.vibrate === 'function') navigator.vibrate(12);
                const message = result.deduplicated
                    ? 'This reading is already in your journal.'
                    : 'Saved to your journal.';
                setJournalStatus({ type: 'success', message });
            } else {
                setJournalStatus({ type: 'error', message: result.error || 'Unable to save to your journal. Please try again.' });
            }
        } catch (error) {
            console.error('Failed to save tarot reading', error);
            setJournalStatus({ type: 'error', message: 'Unable to save to your journal. Please try again.' });
        } finally {
            setIsSaving(false);
        }
    }, [
        isSaving, sessionSeed, reading, personalReading, selectedSpread,
        userQuestion, themes, reflections, analysisContext, readingMeta,
        deckStyleId, personalization, saveEntry, setJournalStatus
    ]);

    return { saveReading, isSaving };
}
</file>

<file path="src/hooks/useSmallScreen.js">
import { useEffect, useState } from 'react';

/**
 * useSmallScreen detects when the viewport width is below a breakpoint.
 * Defaults defer until mounted to avoid hydration mismatch.
 */
export function useSmallScreen(maxWidth = 640) {
  const getInitial = () => {
    if (typeof window === 'undefined') {
      return false;
    }
    return window.matchMedia(`(max-width: ${maxWidth}px)`).matches;
  };

  const [isSmall, setIsSmall] = useState(getInitial);

  useEffect(() => {
    if (typeof window === 'undefined' || typeof window.matchMedia !== 'function') {
      return undefined;
    }

    const mediaQuery = window.matchMedia(`(max-width: ${maxWidth}px)`);

    const handleChange = (event) => {
      setIsSmall(event.matches);
    };

    // Sync immediately in case layout changed before effect ran
    handleChange(mediaQuery);

    // Modern browsers
    if (typeof mediaQuery.addEventListener === 'function') {
      mediaQuery.addEventListener('change', handleChange);
      return () => mediaQuery.removeEventListener('change', handleChange);
    }

    // Legacy Safari (<14) fallback
    if (typeof mediaQuery.addListener === 'function') {
      mediaQuery.addListener(handleChange);
      return () => mediaQuery.removeListener(handleChange);
    }

    return undefined;
  }, [maxWidth]);

  return isSmall;
}
</file>

<file path="src/hooks/useTarotState.js">
import { useState, useRef, useEffect, useCallback } from 'react';
import { computeSeed, drawSpread } from '../lib/deck';
import { playFlip, unlockAudio } from '../lib/audio';
import { DEFAULT_SPREAD_KEY, normalizeSpreadKey, getSpreadInfo } from '../data/spreads';
import { usePreferences } from '../contexts/PreferencesContext';
import { getSpreadFromDepth } from '../utils/personalization';

const SKIP_RITUAL_DEFAULTS = {
  knockTimes: [100, 200, 300],
  knockCount: 3
};

export function useTarotState(speak) {
  const { includeMinors, deckSize, personalization } = usePreferences();
  const [selectedSpreadState, setSelectedSpreadState] = useState(DEFAULT_SPREAD_KEY);
  const [hasUserSelectedSpread, setHasUserSelectedSpread] = useState(false);
  const selectedSpread = normalizeSpreadKey(selectedSpreadState);
  const setSelectedSpread = useCallback((nextKey) => {
    setSelectedSpreadState(normalizeSpreadKey(nextKey));
  }, []);
  const [reading, setReading] = useState(null);
  const [isShuffling, setIsShuffling] = useState(false);
  const [revealedCards, setRevealedCards] = useState(new Set());
  const [dealIndex, setDealIndex] = useState(0);

  const [hasKnocked, setHasKnocked] = useState(false);
  const [knockCount, setKnockCount] = useState(0);
  const [hasCut, setHasCut] = useState(false);
  const [cutIndex, setCutIndex] = useState(Math.floor(deckSize / 2));
  const [hasConfirmedSpread, setHasConfirmedSpread] = useState(false);
  const [sessionSeed, setSessionSeed] = useState(null);
  const [userQuestion, setUserQuestion] = useState('');
  const [deckAnnouncement, setDeckAnnouncement] = useState('');

  const knockTimesRef = useRef([]);
  const shuffleTimeoutRef = useRef(null);
  const deckAnnouncementTimeoutRef = useRef(null);
  const deckSizeInitializedRef = useRef(false);
  const shouldSkipRitual = personalization?.showRitualSteps === false;

  // Keep cut index centered on active deck and announce deck scope changes
  useEffect(() => {
    const scheduleReset = () => {
      const nextCutIndex = Math.floor(deckSize / 2);
      setCutIndex(nextCutIndex);

      if (!deckSizeInitializedRef.current) {
        deckSizeInitializedRef.current = true;
        return;
      }

      setHasCut(false);
      setHasKnocked(false);
      setKnockCount(0);
      knockTimesRef.current = [];
      const announcement = `Deck now ${deckSize} cards. Cut index reset to ${nextCutIndex}.`;
      setDeckAnnouncement(announcement);
      if (deckAnnouncementTimeoutRef.current) {
        clearTimeout(deckAnnouncementTimeoutRef.current);
      }
      deckAnnouncementTimeoutRef.current = setTimeout(() => {
        setDeckAnnouncement('');
      }, 4000);
    };

    if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
      const frameId = window.requestAnimationFrame(scheduleReset);
      return () => window.cancelAnimationFrame(frameId);
    }

    const timeoutId = setTimeout(scheduleReset, 0);
    return () => clearTimeout(timeoutId);
  }, [deckSize]);

  useEffect(() => {
    return () => {
      if (deckAnnouncementTimeoutRef.current) {
        clearTimeout(deckAnnouncementTimeoutRef.current);
      }
      if (shuffleTimeoutRef.current) {
        clearTimeout(shuffleTimeoutRef.current);
      }
    };
  }, []);

  const handleKnock = useCallback(() => {
    if (hasKnocked) return;
    if (typeof performance === 'undefined') return;
    const now = performance.now();
    const recent = knockTimesRef.current.filter(timestamp => now - timestamp < 2000);
    recent.push(now);
    knockTimesRef.current = recent;
    setKnockCount(Math.min(recent.length, 3));
    if (recent.length >= 3) {
      setHasKnocked(true);
      if (typeof navigator !== 'undefined' && typeof navigator.vibrate === 'function') {
        navigator.vibrate([18, 40, 18]);
      }
    }
  }, [hasKnocked]);

  const applyCut = useCallback(() => {
    setHasCut(true);
    if (typeof navigator !== 'undefined' && typeof navigator.vibrate === 'function') {
      navigator.vibrate(12);
    }
  }, []);

  const onSpreadConfirm = useCallback((key) => {
    setHasConfirmedSpread(true);
    if (key) {
      // spreadSelector handles setSelectedSpread, but we can ensure sync if needed
      // though strictly spreadSelector could call this just to flag confirmation
    }
  }, []);

  const resetReadingState = useCallback((resetQuestion = false) => {
    // Does NOT reset userQuestion unless specified, to preserve intention
    setReading(null);
    setRevealedCards(new Set());
    setDealIndex(0);
    setHasKnocked(false);
    setKnockCount(0);
    setHasCut(false);
    setSessionSeed(null);
    knockTimesRef.current = [];
    if (resetQuestion) {
      setUserQuestion('');
    }
  }, []);

  // Track previous preferred depth to detect changes (use ref to avoid render-time state updates)
  const prevPreferredDepthRef = useRef(undefined);

  // Auto-select spread based on personalization (only when user hasn't manually selected).
  // Must run in an effect to avoid calling state setters during render.
  useEffect(() => {
    if (!hasUserSelectedSpread &&
        personalization?.preferredSpreadDepth &&
        personalization?.preferredSpreadDepth !== prevPreferredDepthRef.current) {
      prevPreferredDepthRef.current = personalization.preferredSpreadDepth;
      const preferred = getSpreadFromDepth(personalization.preferredSpreadDepth);
      setSelectedSpreadState(preferred);
    }
  }, [hasUserSelectedSpread, personalization?.preferredSpreadDepth]);

  const selectSpread = useCallback((key) => {
    setHasUserSelectedSpread(true);
    setSelectedSpread(key);
    resetReadingState(false); // Keep question
    // Reset cut index to deck center
    setCutIndex(Math.floor(deckSize / 2));
  }, [setSelectedSpread, resetReadingState, deckSize]);

  const shuffle = useCallback((onShuffleComplete) => {
    const currentSpread = selectedSpread;

    if (shuffleTimeoutRef.current) {
      clearTimeout(shuffleTimeoutRef.current);
    }

    setIsShuffling(true);
    if (!hasConfirmedSpread) {
      setHasConfirmedSpread(true);
    }

    resetReadingState(false);
    if (onShuffleComplete) onShuffleComplete(); // Callback to clear external state like vision/analysis

    if (typeof performance !== 'undefined') {
      const now = performance.now();
      knockTimesRef.current = knockTimesRef.current.filter(timestamp => now - timestamp < 2000);
    }

    let effectiveKnockTimes = knockTimesRef.current;
    let effectiveCutIndex = cutIndex;
    const shouldAutoComplete = shouldSkipRitual && !hasKnocked;

    if (shouldAutoComplete) {
      effectiveKnockTimes = [...SKIP_RITUAL_DEFAULTS.knockTimes];
      effectiveCutIndex = Math.floor(deckSize / 2);
      knockTimesRef.current = effectiveKnockTimes;
      setCutIndex(effectiveCutIndex);
    }

    const seed = computeSeed({
      cutIndex: effectiveCutIndex,
      knockTimes: effectiveKnockTimes,
      userQuestion
    });

    // Use deterministic seed when the user performs any ritual or sets a question.
    const useSeed = Boolean(hasKnocked || hasCut || (userQuestion && userQuestion.trim()) || shouldAutoComplete);
    const nextSessionSeed = useSeed ? seed : null;

    const cards = drawSpread({
      spreadKey: currentSpread,
      useSeed,
      seed,
      includeMinors
    });

    shuffleTimeoutRef.current = setTimeout(() => {
      if (selectedSpread !== currentSpread) {
        setIsShuffling(false);
        return;
      }
      setReading(cards);
      setIsShuffling(false);
      setSessionSeed(nextSessionSeed);

      if (shouldAutoComplete) {
        setKnockCount(SKIP_RITUAL_DEFAULTS.knockCount);
        setHasKnocked(true);
        setHasCut(true);
      }
    }, 1200);
  }, [selectedSpread, hasConfirmedSpread, hasKnocked, hasCut, userQuestion, cutIndex, includeMinors, resetReadingState, shouldSkipRitual, deckSize]);

  const shortLineForCard = useCallback((card, position) => {
    const meaning = card.isReversed ? card.reversed : card.upright;
    const first = meaning.split(',')[0];
    return `${position}: ${card.name} - ${first}.`;
  }, []);

  const dealNext = useCallback(() => {
    if (!reading) return;
    if (dealIndex >= reading.length) return;

    void unlockAudio();
    const next = dealIndex;
    setRevealedCards(prev => new Set([...prev, next]));
    setDealIndex(next + 1);

    if (typeof navigator !== 'undefined' && typeof navigator.vibrate === 'function') {
      navigator.vibrate(10);
    }
    playFlip();

    const spreadInfo = getSpreadInfo(selectedSpread);
    const position = spreadInfo?.positions?.[next] || `Position ${next + 1}`;

    if (speak) {
      void speak(shortLineForCard(reading[next], position), 'card-reveal');
    }
  }, [reading, dealIndex, selectedSpread, speak, shortLineForCard]);

  const revealCard = useCallback((index) => {
    if (!reading || !reading[index]) return;
    if (revealedCards.has(index)) return;

    void unlockAudio();
    setRevealedCards(prev => new Set([...prev, index]));
    setDealIndex(prev => Math.max(prev, index + 1));

    if (typeof navigator !== 'undefined' && typeof navigator.vibrate === 'function') {
      navigator.vibrate(10);
    }
    playFlip();

    const spreadInfo = getSpreadInfo(selectedSpread);
    const position = spreadInfo?.positions?.[index] || `Position ${index + 1}`;

    if (speak) {
      void speak(shortLineForCard(reading[index], position), 'card-reveal');
    }
  }, [reading, revealedCards, selectedSpread, speak, shortLineForCard]);

  const revealAll = useCallback(() => {
    if (!reading || reading.length === 0) return;
    const allIndices = new Set(Array.from({ length: reading.length }, (_, index) => index));
    setRevealedCards(allIndices);
    setDealIndex(reading.length);
  }, [reading]);

  return {
    selectedSpread,
    setSelectedSpread,
    selectSpread,
    reading,
    setReading,
    isShuffling,
    revealedCards,
    setRevealedCards,
    dealIndex,
    setDealIndex,
    hasKnocked,
    setHasKnocked,
    knockCount,
    setKnockCount,
    hasCut,
    setHasCut,
    cutIndex,
    setCutIndex,
    hasConfirmedSpread,
    setHasConfirmedSpread,
    sessionSeed,
    setSessionSeed,
    userQuestion,
    setUserQuestion,
    deckAnnouncement,
    shuffle,
    handleKnock,
    applyCut,
    dealNext,
    revealCard,
    revealAll,
    onSpreadConfirm,
    resetReadingState,
    knockTimesRef,
    shouldSkipRitual
  };
}
</file>

<file path="src/hooks/useVisionAnalysis.js">
import { useState, useMemo, useCallback } from 'react';
import { canonicalCardKey } from '../../shared/vision/cardNameMapping.js';
import { usePreferences } from '../contexts/PreferencesContext';
import { isVisionResearchEnabled } from './useFeatureFlags';

const MAX_VISION_UPLOADS = 5;
const supportsBrowserUUID = typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function';

const generateVisionUploadId = () => {
  if (supportsBrowserUUID) {
    return crypto.randomUUID();
  }
  const random = Math.random().toString(36).slice(2, 10);
  return `vision-upload-${Date.now()}-${random}`;
};

const getVisionConflictsForCards = (cardsInfoList = [], results = [], deckStyle = 'rws-1909') => {
  if (!Array.isArray(results) || results.length === 0) return [];
  const normalizedDeck = deckStyle || 'rws-1909';
  const cardKeys = new Set(
    cardsInfoList
      .map(card => {
        if (card?.canonicalKey) {
          return card.canonicalKey;
        }
        const candidateName = card?.canonicalName || card?.card || card?.name;
        return canonicalCardKey(candidateName, normalizedDeck);
      })
      .filter(Boolean)
  );
  if (cardKeys.size === 0) return [];
  return results.filter(result => {
    const candidateKey = canonicalCardKey(
      result?.predictedCard || result?.topMatch?.cardName || result?.matches?.[0]?.cardName,
      normalizedDeck
    );
    return candidateKey && !cardKeys.has(candidateKey);
  });
};

const summarizeVisionInsights = (insights = []) => {
  if (!Array.isArray(insights) || insights.length === 0) {
    return null;
  }
  const uploads = insights.length;
  const avgConfidence = insights.reduce((sum, entry) => sum + (entry.confidence ?? 0), 0) / uploads;
  const focusedSymbols = insights.reduce((sum, entry) => {
    if (!Array.isArray(entry.attention?.symbolAlignment)) {
      return sum;
    }
    return sum + entry.attention.symbolAlignment.filter((symbol) => symbol.isModelFocused).length;
  }, 0);
  const symbolMatchSamples = insights.filter((entry) => typeof entry.symbolVerification?.matchRate === 'number');
  const avgSymbolMatch = symbolMatchSamples.length > 0
    ? symbolMatchSamples.reduce((sum, entry) => sum + entry.symbolVerification.matchRate, 0) / symbolMatchSamples.length
    : null;
  return {
    uploads,
    avgConfidence,
    focusedSymbols,
    avgSymbolMatch
  };
};

let anonymousVisionLabelCounter = 0;

const deriveVisionLabel = (entry) => {
  if (entry?.label && entry.label.trim()) {
    return entry.label.trim();
  }
  if (entry?.userFile?.name && entry.userFile.name.trim()) {
    return entry.userFile.name.trim();
  }
  if (entry?.imagePath && typeof entry.imagePath === 'string' && entry.imagePath.trim()) {
    return entry.imagePath.trim();
  }
  if (entry?.topMatch?.cardName) {
    return `uploaded-${entry.topMatch.cardName}`;
  }
  anonymousVisionLabelCounter += 1;
  return `uploaded-image-${anonymousVisionLabelCounter}`;
};

const normalizeVisionEntry = (entry) => {
  if (!entry || typeof entry !== 'object') return null;
  const normalizedLabel = deriveVisionLabel(entry);
  const uploadId = entry.uploadId || entry?.userFile?.__visionUploadId || generateVisionUploadId();
  return {
    ...entry,
    label: normalizedLabel,
    uploadId
  };
};

const mergeVisionResults = (existing = [], incoming = []) => {
  if (!Array.isArray(incoming) || incoming.length === 0) {
    return existing;
  }

  const map = new Map();

  const addBatch = (batch) => {
    batch.forEach((item) => {
      const normalized = normalizeVisionEntry(item);
      if (!normalized) return;
      map.set(normalized.uploadId, normalized);
    });
  };

  addBatch(existing);
  addBatch(incoming);

  const merged = Array.from(map.values());
  return merged.slice(-MAX_VISION_UPLOADS);
};

export function useVisionAnalysis(reading = []) {
  const { deckStyleId } = usePreferences();
  const [visionResults, setVisionResults] = useState([]);
  const [visionConflicts, setVisionConflicts] = useState([]);
  const [visionProof, setVisionProof] = useState(null);
  const [visionSummarySnapshot, setVisionSummarySnapshot] = useState(null);

  const visionResearchEnabled = isVisionResearchEnabled();
  const isVisionReady = visionResearchEnabled && visionResults.length > 0 && visionConflicts.length === 0;
  const hasVisionData = visionResearchEnabled && visionResults.length > 0;

  const liveVisionSummary = useMemo(() => {
    if (!visionResearchEnabled || !visionResults.length) return null;
    const uploads = visionResults.length;
    const avgConfidence = visionResults.reduce((sum, entry) => sum + (entry.confidence ?? 0), 0) / uploads;
    const focusedSymbols = visionResults.reduce((sum, entry) => {
      if (!Array.isArray(entry.attention?.symbolAlignment)) {
        return sum;
      }
      const focused = entry.attention.symbolAlignment.filter((symbol) => symbol.isModelFocused).length;
      return sum + focused;
    }, 0);
    const symbolMatchSamples = visionResults.filter((entry) => typeof entry.symbolVerification?.matchRate === 'number');
    const avgSymbolMatch = symbolMatchSamples.length > 0
      ? symbolMatchSamples.reduce((sum, entry) => sum + entry.symbolVerification.matchRate, 0) / symbolMatchSamples.length
      : null;
    return {
      uploads,
      avgConfidence,
      focusedSymbols,
      avgSymbolMatch
    };
  }, [visionResults, visionResearchEnabled]);

  const feedbackVisionSummary = visionResearchEnabled ? (visionSummarySnapshot || liveVisionSummary) : null;

  const resetVisionProof = useCallback(() => {
    setVisionProof(null);
    setVisionSummarySnapshot(null);
  }, []);

  const handleVisionResults = useCallback((results) => {
    if (!visionResearchEnabled || !Array.isArray(results) || results.length === 0) {
      return;
    }

    resetVisionProof();
    setVisionResults((prev) => {
      const merged = mergeVisionResults(prev, results);
      if (Array.isArray(reading) && reading.length) {
        setVisionConflicts(getVisionConflictsForCards(reading, merged, deckStyleId));
      } else {
        setVisionConflicts([]);
      }
      return merged;
    });
  }, [reading, deckStyleId, resetVisionProof, visionResearchEnabled]);

  const handleRemoveVisionResult = useCallback((label) => {
    if (!visionResearchEnabled || !label) return;
    resetVisionProof();
    setVisionResults((prev) => {
      const filtered = prev.filter((entry) => {
        if (entry.uploadId) {
          return entry.uploadId !== label;
        }
        return entry.label?.toLowerCase() !== label.toLowerCase();
      });
      if (Array.isArray(reading) && reading.length && filtered.length) {
        setVisionConflicts(getVisionConflictsForCards(reading, filtered, deckStyleId));
      } else {
        setVisionConflicts([]);
      }
      return filtered;
    });
  }, [reading, deckStyleId, resetVisionProof, visionResearchEnabled]);

  const handleClearVisionResults = useCallback(() => {
    if (!visionResearchEnabled) return;
    resetVisionProof();
    setVisionResults([]);
    setVisionConflicts([]);
  }, [resetVisionProof, visionResearchEnabled]);

  const ensureVisionProof = useCallback(async () => {
    const now = Date.now();
    if (visionProof?.expiresAt && Date.parse(visionProof.expiresAt) > now + 2000) {
      return visionProof;
    }
    const evidence = visionResults
      .slice(0, 5)
      .map((entry) => ({
        label: entry.label,
        dataUrl: entry.dataUrl
      }))
      .filter((entry) => typeof entry.dataUrl === 'string' && entry.dataUrl.startsWith('data:'));

    if (evidence.length === 0) {
      throw new Error('Vision uploads missing photo data. Please re-upload the drawn cards.');
    }

    const response = await fetch('/api/vision-proof', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ deckStyle: deckStyleId, evidence })
    });

    if (!response.ok) {
      let message = 'Unable to verify card photos. Please try again.';
      try {
        const payload = await response.json();
        if (payload?.error) {
          message = payload.error;
        }
      } catch (err) {
        console.debug('vision-proof parse failed:', err);
      }
      throw new Error(message);
    }

    const data = await response.json();
    if (!data?.proof) {
      throw new Error('Vision verification response malformed.');
    }
    setVisionProof(data.proof);
    setVisionSummarySnapshot(summarizeVisionInsights(data.proof.insights));
    return data.proof;
  }, [deckStyleId, visionProof, visionResults]);

  const checkConflicts = useCallback((cardsInfo) => {
      const conflicts = getVisionConflictsForCards(cardsInfo, visionResults, deckStyleId);
      setVisionConflicts(conflicts);
      return conflicts;
  }, [visionResults, deckStyleId]);
  
   const clearConflicts = useCallback(() => {
       setVisionConflicts([]);
   }, []);

  return {
    visionResults,
    visionConflicts,
    visionProof,
    feedbackVisionSummary,
    isVisionReady,
    hasVisionData,
    handleVisionResults,
    handleRemoveVisionResult,
    handleClearVisionResults,
    ensureVisionProof,
    resetVisionProof,
    setVisionResults,
    setVisionConflicts,
    liveVisionSummary,
    checkConflicts,
    clearConflicts,
    getVisionConflictsForCards // Exported for direct use if needed
  };
}
</file>

<file path="src/hooks/useVisionValidation.js">
import { useCallback, useRef, useState, useEffect } from 'react';

function fileToDataUrl(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
}

const hasCryptoUUID = typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function';

function generateUploadId(prefix = 'vision-upload') {
  if (hasCryptoUUID) {
    return `${prefix}-${crypto.randomUUID()}`;
  }
  const random = Math.random().toString(36).slice(2, 10);
  return `${prefix}-${Date.now()}-${random}`;
}

function getFileLabel(file, fallback) {
  if (file?.__visionLabel && typeof file.__visionLabel === 'string') {
    return file.__visionLabel;
  }
  if (file?.name && typeof file.name === 'string') {
    return file.name;
  }
  return fallback;
}

export function useVisionValidation({ deckStyle = 'rws-1909' } = {}) {
  const pipelineRef = useRef(null);
  const [status, setStatus] = useState('idle');
  const [error, setError] = useState(null);

  useEffect(() => {
    pipelineRef.current = null;
    setStatus('idle');
    setError(null);
  }, [deckStyle]);

  const ensurePipeline = useCallback(async () => {
    if (!pipelineRef.current) {
      const { createVisionBackend } = await import('../../shared/vision/visionBackends.js');
      const backend = await createVisionBackend({
        backendId: 'clip-default',
        cardScope: 'all',
        deckStyle,
        maxResults: 5
      });
      if (typeof backend.warmup === 'function') {
        await backend.warmup();
      }
      pipelineRef.current = backend;
    }
    return pipelineRef.current;
  }, [deckStyle]);

  const validateFiles = useCallback(async (fileList) => {
    if (!fileList || fileList.length === 0) {
      setError('Please select at least one image.');
      return [];
    }

    setStatus('loading');
    setError(null);

    try {
      const files = Array.from(fileList);
      const uploadsMetadata = files.map((file, index) => ({
        file,
        label: getFileLabel(file, `upload-${index + 1}`),
        uploadId: file?.__visionUploadId || generateUploadId()
      }));
      const dataUrls = await Promise.all(files.map(fileToDataUrl));
      const pipeline = await ensurePipeline();
      const analyses = await pipeline.analyzeImages(
        dataUrls.map((dataUrl, index) => ({
          source: dataUrl,
          label: uploadsMetadata[index].label
        })),
        { includeAttention: true, includeSymbols: true }
      );
      setStatus('success');
      return analyses.map((analysis, index) => ({
        ...analysis,
        userFile: uploadsMetadata[index].file,
        dataUrl: dataUrls[index],
        timestamp: Date.now(),
        uploadId: uploadsMetadata[index].uploadId
      }));
    } catch (err) {
      console.error('Vision validation failed', err);
      setStatus('error');
      setError(err.message || 'Vision validation failed.');
      return [];
    }
  }, [ensurePipeline]);

  return {
    status,
    error,
    validateFiles
  };
}
</file>

<file path="src/lib/archetypeJourney.js">
/**
 * Archetype Journey Utilities
 * 
 * Provides helper functions for gamified analytics features
 * including growth prompts, badges, and analytics normalization.
 */

import { Fire, Star, Lightning, Sparkle, Medal, Trophy, Flame, Sun, Moon, Heart } from '@phosphor-icons/react';

/**
 * Badge icons mapped by streak/achievement type
 */
const BADGE_ICONS = {
  fire: Fire,
  star: Star,
  lightning: Lightning,
  sparkle: Sparkle,
  medal: Medal,
  trophy: Trophy,
  flame: Flame,
  sun: Sun,
  moon: Moon,
  heart: Heart
};

/**
 * Get the icon component for a badge type
 * @param {string} type - Badge type (fire, star, etc.)
 * @returns {React.ComponentType} Icon component
 */
export function getBadgeIcon(type) {
  return BADGE_ICONS[type] || Star;
}

/**
 * Normalize raw analytics data into consistent shape
 * Preserves API response format expected by ArchetypeJourneySection component
 * @param {Object} rawData - Raw analytics from API
 * @returns {Object} Normalized analytics object
 */
export function normalizeAnalyticsShape(rawData) {
  if (!rawData) return null;

  // Format currentMonth for display (API returns "YYYY-MM")
  let currentMonth = rawData.currentMonth;
  if (currentMonth && /^\d{4}-\d{2}$/.test(currentMonth)) {
    const [year, month] = currentMonth.split('-');
    const date = new Date(parseInt(year, 10), parseInt(month, 10) - 1, 1);
    currentMonth = date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
  }

  return {
    // Current month label for display
    currentMonth: currentMonth || new Date().toLocaleDateString('en-US', { month: 'long', year: 'numeric' }),

    // Top cards this month - preserve card_name for component compatibility
    topCards: Array.isArray(rawData.topCards)
      ? rawData.topCards.map(card => ({
          card_name: card.card_name || card.name || card.cardName || 'Unknown Card',
          card_number: card.card_number ?? null,
          count: card.count || 0,
          last_seen: card.last_seen || null,
          first_seen: card.first_seen || null
        }))
      : [],

    // Streak information as array - cards appearing multiple times this month
    // Component calls .slice() on this, so it MUST be an array
    streaks: Array.isArray(rawData.streaks)
      ? rawData.streaks.map(streak => ({
          cardName: streak.cardName || streak.card_name || 'Unknown Card',
          cardNumber: streak.cardNumber ?? streak.card_number ?? null,
          count: streak.count || 0,
          month: streak.month || null
        }))
      : [],

    // Earned badges - preserve API field names for component compatibility
    badges: Array.isArray(rawData.badges)
      ? rawData.badges.map(badge => ({
          badge_type: badge.badge_type || badge.type || 'star',
          badge_key: badge.badge_key || badge.id || 'badge',
          card_name: badge.card_name || badge.label || badge.name || null,
          earned_at: badge.earned_at || badge.earnedAt || null,
          metadata: badge.metadata || {}
        }))
      : [],

    // Reading statistics
    stats: {
      totalReadings: rawData.stats?.totalReadings || rawData.totalReadings || rawData.totalReadingsThisMonth || 0,
      thisMonth: rawData.stats?.thisMonth || rawData.totalReadingsThisMonth || 0,
      avgPerWeek: rawData.stats?.avgPerWeek || 0,
      entriesProcessed: rawData.stats?.entriesProcessed ?? rawData.entriesProcessed ?? null,
      lastAnalyzedAt: rawData.stats?.lastAnalyzedAt ?? rawData.stats?.lastRunAt ?? rawData.lastAnalyzedAt ?? rawData.lastRunAt ?? null
    },

    // Growth prompts/suggestions
    growthPrompts: Array.isArray(rawData.growthPrompts)
      ? rawData.growthPrompts
      : [],

    // Journey stage for gamification
    journeyStage: rawData.journeyStage || rawData.stage || 'beginner'
  };
}

/**
 * Generate a growth prompt based on card patterns
 * @param {string} cardName - Name of the recurring card
 * @param {number} count - How many times it's appeared
 * @returns {string} Growth prompt text
 */
export function getGrowthPrompt(cardName, count) {
  if (!cardName) return '';
  
  const prompts = [
    `${cardName} has appeared ${count} times recently. What message is it trying to convey?`,
    `Reflect on your relationship with ${cardName}. What aspects of this card resonate with your current journey?`,
    `${cardName} keeps showing up. Consider journaling about what this archetype means in your life right now.`,
    `The repeated appearance of ${cardName} suggests an important theme. What lesson is it offering?`,
    `${cardName} is calling for your attention. Take a moment to meditate on its imagery and symbolism.`
  ];
  
  // Use card name hash to select prompt for consistency
  const index = cardName.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0) % prompts.length;
  return prompts[index];
}

/**
 * Calculate streak status message
 * @param {number} current - Current streak count
 * @param {number} longest - Longest streak ever
 * @returns {string} Status message
 */
export function getStreakMessage(current, longest) {
  if (current === 0) {
    return 'Start a new streak with a reading today!';
  }
  
  if (current >= longest && current > 1) {
    return `🔥 New record! ${current} day streak!`;
  }
  
  if (current >= 7) {
    return `Incredible! ${current} day streak. Keep the momentum!`;
  }
  
  if (current >= 3) {
    return `Nice! ${current} day streak going strong.`;
  }
  
  return `${current} day${current === 1 ? '' : 's'} and counting!`;
}

/**
 * Get badge display color based on type
 * @param {string} type - Badge type
 * @returns {string} Tailwind color class
 */
export function getBadgeColor(type) {
  const colors = {
    fire: 'text-orange-400',
    star: 'text-yellow-400',
    lightning: 'text-blue-400',
    sparkle: 'text-purple-400',
    medal: 'text-amber-500',
    trophy: 'text-yellow-500',
    flame: 'text-red-400',
    sun: 'text-yellow-300',
    moon: 'text-indigo-400',
    heart: 'text-pink-400'
  };
  
  return colors[type] || 'text-secondary';
}
</file>

<file path="src/lib/audio.js">
import { normalizeReadingText, prepareForTTS } from './formatting.js';
import { generateFallbackWaveform } from '../../shared/fallbackAudio.js';

let flipAudio = null;
let ambienceAudio = null;
let ttsAudio = null;
let currentTTSState = {
  status: 'idle',
  provider: null,
  source: null,
  cached: false,
  error: null,
  message: null,
  reason: null,
  context: null
};
const ttsListeners = new Set();
let currentNarrationRequestId = 0;
let activeNarrationId = null;
let cancelledUpToRequestId = 0;
let audioUnlocked = false;
const _audioUnlockPromise = null;
let unlockListenersRegistered = false;
const TTS_CACHE_PREFIX = 'tts_cache_';
const TTS_CACHE_MAX_ENTRIES = 50;
const TTS_CACHE_PURGE_THRESHOLD = 30;
const TTS_CACHE_PURGE_TARGET = 20;
const TTS_CACHE_EVICT_BATCH = 10;
const TTS_CACHE_SWEEP_INTERVAL_MS = 5 * 60 * 1000;
const CACHE_MAX_AGE_MS = 7 * 24 * 60 * 60 * 1000;
const trackedObjectUrls = new Set();
const audioObjectUrlMap = new WeakMap();
let cleanupListenersRegistered = false;
let lastCacheSweep = 0;

const SILENT_AUDIO_URI = 'data:audio/mp3;base64,//MkxAAHiAICWABElBeKPL/RANb2w+yiT1g/gTok//lP/W/l3h8QO/OCdCqCW2Cw//MkxAQHkAIWUAhEmAQXWUOFW2dxPu//9mr60ElY5sseQ+xxesmHKtZr7bsqqX2L//MkxAgFwAYiQAhEAC2hq22d3///9FTV6tA36JdgBJoOGgc+7qvqej5Zu7/7uI9l//MkxBQHAAYi8AhEAO193vt9KGOq+6qcT7hhfN5FTInmwk8RkqKImTM55pRQHQSq//MkxBsGkgoIAABHhTACIJLf99nVI///yuW1uBqWfEu7CgNPWGpUadBmZ////4sL//MkxCMHMAH9iABEmAsKioqKigsLCwtVTEFNRTMuOTkuNVVVVVVVVVVVVVVVVVVV//MkxCkECAUYCAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';

/**
 * Unlock audio playback by creating and playing a silent audio element.
 * Must be called from a user interaction event (click, touch, keydown, etc.)
 * to satisfy browser autoplay policies.
 */
export async function unlockAudio() {
  if (audioUnlocked) return true;
  if (typeof Audio === 'undefined' || typeof window === 'undefined') return false;

  ensureGlobalCleanupListeners();

  try {
    const silentAudio = new Audio(SILENT_AUDIO_URI);
    silentAudio.volume = 0.01;
    await silentAudio.play();
    audioUnlocked = true;
    return true;
  } catch (err) {
    console.warn('[Audio] Audio unlock failed - user interaction needed', err);
    emitTTSState({
      status: 'unlock-failed',
      reason: 'interaction-required',
      error: err?.message || String(err),
      message: 'Tap anywhere on the page to enable audio.'
    });
    return false;
  }
}

export function initAudio() {
  ensureGlobalCleanupListeners();

  if (typeof Audio === 'undefined') {
    return {
      flipAudio: null,
      ambienceAudio: null
    };
  }

  // Set up robust unlock listeners on first init
  if (typeof window !== 'undefined' && !unlockListenersRegistered) {
    unlockListenersRegistered = true;
    const unlockEvents = ['click', 'touchstart', 'keydown'];

    const unlockHandler = () => {
      // Create and play immediately within the event handler
      const s = new Audio(SILENT_AUDIO_URI);
      s.volume = 0.01;
      const p = s.play();

      if (p !== undefined) {
        p.then(() => {
          audioUnlocked = true;
          // Remove listeners once successfully unlocked
          unlockEvents.forEach(event => {
            window.removeEventListener(event, unlockHandler, { capture: true });
          });
        }).catch(_e => {
          // If it fails (e.g. rapid clicks), we just keep the listeners attached
          // and try again on next interaction
        });
      }
    };

    // Use capture: true to catch the event as early as possible
    unlockEvents.forEach(event => {
      window.addEventListener(event, unlockHandler, { capture: true, passive: false });
    });
  }

  if (!flipAudio) {
    try {
      flipAudio = new Audio('/sounds/flip.mp3');
      flipAudio.preload = 'auto';
    } catch {
      flipAudio = null;
    }
  }

  if (!ambienceAudio) {
    try {
      ambienceAudio = new Audio('/sounds/ambience.mp3');
      ambienceAudio.loop = true;
      ambienceAudio.volume = 0.2;
    } catch {
      ambienceAudio = null;
    }
  }

  return {
    flipAudio,
    ambienceAudio
  };
}

export function playFlip() {
  if (!flipAudio) return;
  try {
    flipAudio.currentTime = 0;
    void flipAudio.play();
  } catch {
    // ignore autoplay / interruption errors
  }
}

export function toggleAmbience(on) {
  if (!ambienceAudio) return;
  try {
    if (on) {
      void ambienceAudio.play();
    } else {
      ambienceAudio.pause();
    }
  } catch {
    // ignore autoplay / interruption errors
  }
}

/**
 * Enhanced text-to-speech with intelligent caching and context-aware narration.
 *
 * Normalizes Markdown text before speaking to avoid "asterisk asterisk" narration
 * and create a natural, human storyteller voice.
 *
 * @param {Object} options
 * @param {string} options.text - Text to speak (can be Markdown)
 * @param {boolean} options.enabled - Whether TTS is enabled
 * @param {string} [options.context='default'] - Reading context (card-reveal, full-reading, synthesis, etc.)
 * @param {string} [options.voice='verse'] - Voice selection (alloy, ash, ballad, coral, echo, fable, nova, onyx, sage, shimmer, verse)
 * @param {number} [options.speed] - Playback speed (0.25-4.0, default 1.1 for engaging pace)
 * @param {boolean} [options.stream=false] - Use streaming mode for progressive audio playback
 */
export async function speakText({ text, enabled, context = 'default', voice = 'verse', speed, stream = false }) {
  ensureGlobalCleanupListeners();

  if (!enabled) {
    emitTTSState({ status: 'idle', reason: 'disabled', message: null });
    return;
  }
  if (!text || !text.trim()) {
    emitTTSState({ status: 'idle', reason: 'no-text', message: null });
    return;
  }
  if (typeof window === 'undefined' || typeof Audio === 'undefined') {
    emitTTSState({ status: 'error', error: 'Audio playback not supported in this environment.' });
    return;
  }

  const narrationContext = context || 'default';
  const normalizedText = normalizeReadingText(text);
  const ttsText = prepareForTTS(normalizedText);

  const requestId = ++currentNarrationRequestId;
  activeNarrationId = requestId;

  try {
    // Stop any currently playing TTS
    if (ttsAudio) {
      releaseAudioObjectUrl(ttsAudio);
      ttsAudio.pause();
      emitTTSState({ status: 'stopped', reason: 'replaced' });
      ttsAudio = null;
    }

    // Check cache first (using normalized text for consistent keys)
    // Include speed in cache key to cache different speeds separately
    const cacheKey = generateCacheKey(ttsText, context, voice, speed);
    const cachedAudio = getCachedAudio(cacheKey);

    let audioDataUri;
    let provider = cachedAudio?.provider || null;
    let source = cachedAudio ? 'cache' : 'network';
    let objectUrlForCleanup = null;

    emitTTSState({
      status: 'loading',
      provider,
      source,
      cached: !!cachedAudio,
      error: null,
      message: cachedAudio ? 'Loading narration from cache.' : 'Preparing narration...',
      context: narrationContext
    });

    if (cachedAudio && !stream) {
      // Use cached audio (streaming responses are not cached)
      audioDataUri = cachedAudio.audio;
    } else {
      // Fetch from API with normalized TTS text
      const url = stream ? '/api/tts?stream=true' : '/api/tts';
      const requestBody = { text: ttsText, context, voice };

      // Add speed parameter if specified
      if (speed !== undefined) {
        requestBody.speed = speed;
      }

      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        console.error('TTS error:', response.status);
        emitTTSState({
          status: 'error',
          provider,
          source,
          error: `TTS service returned ${response.status}.`,
          context: narrationContext,
          message: response.status === 429
            ? 'Too many requests. Please wait a moment before trying again.'
            : 'Unable to generate audio right now.'
        });
        return;
      }

      if (stream) {
        // Streaming mode: response body is a ReadableStream of audio chunks
        // Convert stream to blob for audio playback
        const audioBlob = await response.blob();
        const objectUrl = URL.createObjectURL(audioBlob);
        trackObjectUrl(objectUrl);
        audioDataUri = objectUrl;
        objectUrlForCleanup = objectUrl;
        provider = 'azure-gpt-4o-mini-tts'; // Streaming only works with Azure
        source = 'stream';
      } else {
        // Non-streaming mode: response is JSON with base64 data URI
        const data = await response.json();
        if (!data?.audio) {
          console.error('No audio field in TTS response');
          emitTTSState({
            status: 'error',
            provider: data?.provider || null,
            source,
            error: 'No audio field in response.',
            context: narrationContext,
            message: 'Unable to prepare audio for this reading.'
          });
          return;
        }

        audioDataUri = data.audio;
        provider = data?.provider || null;

        // Cache the audio for future use, but never cache fallback provider
        if (provider && provider !== 'fallback') {
          cacheAudio(cacheKey, audioDataUri, provider);
        }
      }

      emitTTSState({
        status: 'loading',
        provider,
        source: stream ? 'stream' : source,
        cached: false,
        error: null,
        context: narrationContext,
        message: getPreparingMessage(provider, narrationContext)
      });
    }

    if (requestId <= cancelledUpToRequestId) {
      emitTTSState({
        status: 'stopped',
        reason: 'user',
        context: narrationContext,
        message: 'Narration stopped.'
      });
      activeNarrationId = null;
      return;
    }

    // Ensure audio is unlocked before attempting playback
    if (!audioUnlocked) {
      const unlocked = await unlockAudio();
      if (!unlocked) {
        emitTTSState({
          status: 'unlock-failed',
          provider,
          source,
          context: narrationContext,
          error: 'Audio not unlocked',
          message: 'Tap anywhere on the page to enable audio, then try again.',
          reason: 'interaction-required'
        });
        activeNarrationId = null;
        return;
      }
    }

    // Play the audio
    const audio = new Audio(audioDataUri);
    // Important: set volume based on ambience setting or default
    audio.volume = 1.0;

    if (objectUrlForCleanup) {
      audioObjectUrlMap.set(audio, objectUrlForCleanup);
    }
    ttsAudio = audio;
    wireTTSEvents(audio, provider, source, requestId, narrationContext);

    try {
      await audio.play();
      emitTTSState({
        status: 'playing',
        provider,
        source,
        context: narrationContext,
        message: getPlayMessage(provider, narrationContext)
      });
    } catch (err) {
      console.error('Error playing TTS audio:', err);
      const isAutoplayError = err.name === 'NotAllowedError' ||
        err.message?.toLowerCase().includes('autoplay') ||
        err.message?.toLowerCase().includes('user interaction');

      emitTTSState({
        status: 'error',
        provider,
        source,
        context: narrationContext,
        error: err?.message || String(err),
        message: isAutoplayError
          ? 'Tap anywhere on the page to enable audio, then try again.'
          : 'Unable to play audio. Please try again.'
      });
      activeNarrationId = null;
    }
  } catch (err) {
    console.error('Error playing TTS audio:', err);
    const fallbackPlayed = await tryPlayLocalFallback({
      requestId,
      context: narrationContext,
      fallbackText: normalizedText || text
    });

    if (fallbackPlayed) {
      return;
    }

    emitTTSState({
      status: 'error',
      context: narrationContext,
      error: err?.message || String(err),
      message: 'Unable to play audio right now.'
    });
    activeNarrationId = null;
  }
}

async function tryPlayLocalFallback({ requestId, context, fallbackText }) {
  try {
    const safeText = fallbackText && fallbackText.length
      ? fallbackText
      : 'The cards rest quietly; here is a gentle chime instead.';
    const audioDataUri = generateFallbackWaveform(safeText);

    emitTTSState({
      status: 'loading',
      provider: 'fallback',
      source: 'local',
      cached: false,
      error: null,
      context,
      message: getPreparingMessage('fallback', context)
    });

    if (requestId <= cancelledUpToRequestId) {
      emitTTSState({
        status: 'stopped',
        reason: 'user',
        context,
        message: 'Narration stopped.'
      });
      activeNarrationId = null;
      return true;
    }

    if (!audioUnlocked) {
      const unlocked = await unlockAudio();
      if (!unlocked) {
        emitTTSState({
          status: 'unlock-failed',
          provider: 'fallback',
          source: 'local',
          context,
          error: 'Audio not unlocked',
          message: 'Tap anywhere on the page to enable audio, then try again.',
          reason: 'interaction-required'
        });
        activeNarrationId = null;
        return true;
      }
    }

    const fallbackAudio = new Audio(audioDataUri);
    ttsAudio = fallbackAudio;
    wireTTSEvents(fallbackAudio, 'fallback', 'local', requestId, context);
    await fallbackAudio.play();

    emitTTSState({
      status: 'playing',
      provider: 'fallback',
      source: 'local',
      context,
      message: getPlayMessage('fallback', context)
    });

    return true;
  } catch (fallbackErr) {
    console.error('Local fallback audio failed:', fallbackErr);
    return false;
  }
}

/**
 * Generate a cache key from text, context, voice, and speed.
 * Uses simple hash to keep localStorage keys reasonable.
 */
function generateCacheKey(text, context, voice, speed) {
  const speedKey = speed !== undefined ? speed : 'default';
  const content = `${text}|${context}|${voice}|${speedKey}`;
  let hash = 0;
  for (let i = 0; i < content.length; i++) {
    const char = content.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return `${TTS_CACHE_PREFIX}${Math.abs(hash).toString(36)}`;
}

/**
 * Get cached audio from localStorage.
 * Returns null if not found or cache is stale.
 */
function getCachedAudio(key) {
  try {
    if (typeof localStorage === 'undefined') return null;

    const cached = localStorage.getItem(key);
    if (!cached) return null;

    const data = JSON.parse(cached);
    const now = Date.now();
    const cacheAge = now - data.timestamp;

    // Invalidate stale cache
    if (cacheAge > CACHE_MAX_AGE_MS) {
      localStorage.removeItem(key);
      return null;
    }

    return data;
  } catch (err) {
    console.warn('Error reading TTS cache:', err);
    return null;
  }
}

/**
 * Cache audio data URI in localStorage.
 * Implements size limit and eviction strategy.
 */
function cacheAudio(key, audioDataUri, provider = null) {
  try {
    if (typeof localStorage === 'undefined') return;

    const data = {
      audio: audioDataUri,
      timestamp: Date.now(),
      provider
    };
    const payload = JSON.stringify(data);
    let entries = collectCacheEntries();
    maybeSweepCache(entries.length);

    if (entries.length >= TTS_CACHE_MAX_ENTRIES) {
      evictOldestEntries(entries, TTS_CACHE_EVICT_BATCH);
      entries = entries.slice(TTS_CACHE_EVICT_BATCH);
    }

    try {
      localStorage.setItem(key, payload);
    } catch (err) {
      if (isQuotaExceededError(err)) {
        entries = collectCacheEntries();
        const removalTarget = Math.max(TTS_CACHE_EVICT_BATCH, entries.length - TTS_CACHE_PURGE_TARGET);
        if (removalTarget > 0) {
          evictOldestEntries(entries, removalTarget);
        } else {
          clearTTSCache({ keepLatest: TTS_CACHE_PURGE_TARGET });
        }

        try {
          localStorage.setItem(key, payload);
          return;
        } catch (retryErr) {
          console.warn('Unable to cache TTS audio after eviction:', retryErr);
        }
      } else {
        console.warn('Unable to cache TTS audio:', err);
      }
    }
  } catch (err) {
    // localStorage full or unavailable - just continue without caching
    console.warn('Unable to cache TTS audio:', err);
  }
}

export function clearTTSCache({ keepLatest = 0 } = {}) {
  try {
    if (typeof localStorage === 'undefined') return;
    const entries = collectCacheEntries();
    if (!entries.length) return;

    if (keepLatest <= 0) {
      for (const entry of entries) {
        localStorage.removeItem(entry.key);
      }
      return;
    }

    if (keepLatest >= entries.length) {
      return;
    }

    const removeCount = entries.length - keepLatest;
    for (let i = 0; i < removeCount; i += 1) {
      localStorage.removeItem(entries[i].key);
    }
  } catch (err) {
    console.warn('Failed to clear TTS cache:', err);
  }
}

function collectCacheEntries() {
  if (typeof localStorage === 'undefined') return [];

  return Object.keys(localStorage)
    .filter(key => key.startsWith(TTS_CACHE_PREFIX))
    .map(key => {
      try {
        const value = JSON.parse(localStorage.getItem(key));
        return { key, timestamp: value?.timestamp || 0 };
      } catch {
        return { key, timestamp: 0 };
      }
    })
    .sort((a, b) => a.timestamp - b.timestamp);
}

function evictOldestEntries(entries, count) {
  if (typeof localStorage === 'undefined') return;
  const toRemove = Math.min(count, entries.length);
  for (let i = 0; i < toRemove; i += 1) {
    localStorage.removeItem(entries[i].key);
  }
}

function maybeSweepCache(entryCount) {
  if (entryCount < TTS_CACHE_PURGE_THRESHOLD) return;
  const now = Date.now();
  if (now - lastCacheSweep < TTS_CACHE_SWEEP_INTERVAL_MS) {
    return;
  }
  lastCacheSweep = now;
  clearTTSCache({ keepLatest: TTS_CACHE_PURGE_TARGET });
}

function isQuotaExceededError(err) {
  if (!err) return false;
  const name = err.name || '';
  return name === 'QuotaExceededError' || name === 'NS_ERROR_DOM_QUOTA_REACHED';
}

/**
 * Stop any currently playing TTS audio.
 * This is called when the user toggles voice off in settings.
 */
export function stopTTS() {
  try {
    const targetId = activeNarrationId ?? currentNarrationRequestId;
    if (targetId) {
      cancelledUpToRequestId = Math.max(cancelledUpToRequestId, targetId);
    }
    activeNarrationId = null;

    if (ttsAudio) {
      releaseAudioObjectUrl(ttsAudio);
      ttsAudio.pause();
      ttsAudio.currentTime = 0;
      ttsAudio = null;
      emitTTSState({
        status: 'stopped',
        reason: 'user',
        message: 'Narration stopped.'
      });
    } else {
      emitTTSState({
        status: 'stopped',
        reason: 'user',
        message: 'Narration stopped.'
      });
    }
  } catch {
    // ignore errors
  }
}

export function cleanupAudio() {
  try {
    if (flipAudio) {
      flipAudio.pause();
      flipAudio = null;
    }
    if (ambienceAudio) {
      ambienceAudio.pause();
      ambienceAudio = null;
    }
    if (ttsAudio) {
      releaseAudioObjectUrl(ttsAudio);
      ttsAudio.pause();
      ttsAudio = null;
    }
  } catch {
    // ignore cleanup errors
  }

  emitTTSState({
    status: 'idle',
    provider: null,
    source: null,
    cached: false,
    error: null,
    message: null,
    context: null
  });
}

export function pauseTTS() {
  if (!ttsAudio) return;
  try {
    if (!ttsAudio.paused) {
      ttsAudio.pause();
      emitTTSState({
        status: 'paused',
        reason: 'user',
        message: currentTTSState.provider === 'fallback'
          ? 'Fallback chime paused.'
          : 'Narration paused.'
      });
    }
  } catch {
    // ignore pause errors
  }
}

export async function resumeTTS() {
  if (!ttsAudio) return;
  try {
    await ttsAudio.play();
    emitTTSState({
      status: 'playing',
      reason: 'resume',
      message: currentTTSState.provider === 'fallback'
        ? 'Resuming fallback chime.'
        : 'Resuming narration.'
    });
  } catch (err) {
    emitTTSState({
      status: 'error',
      error: err?.message || String(err),
      message: 'Unable to resume audio. Tap the page, then try again.'
    });
  }
}

export function subscribeToTTS(listener) {
  if (typeof listener !== 'function') return () => { };
  ttsListeners.add(listener);
  listener(currentTTSState);
  return () => {
    ttsListeners.delete(listener);
  };
}

export function getCurrentTTSState() {
  return currentTTSState;
}

function emitTTSState(update) {
  const nextStatus = update.status ?? currentTTSState.status;
  const isResetState = nextStatus === 'loading' || nextStatus === 'idle';

  currentTTSState = {
    status: nextStatus,
    provider: update.provider ?? (isResetState ? null : currentTTSState.provider) ?? null,
    source: update.source ?? (isResetState ? null : currentTTSState.source) ?? null,
    cached: update.cached ?? (isResetState ? false : currentTTSState.cached) ?? false,
    error: nextStatus === 'error'
      ? (update.error ?? currentTTSState.error ?? null)
      : null,
    message: update.message ??
      (nextStatus === 'error'
        ? (currentTTSState.message ?? null)
        : (isResetState ? null : currentTTSState.message ?? null)),
    reason: update.reason ?? (isResetState ? null : currentTTSState.reason) ?? null,
    context: update.context ?? (isResetState ? null : currentTTSState.context) ?? null
  };

  for (const listener of ttsListeners) {
    try {
      listener(currentTTSState);
    } catch (err) {
      console.warn('TTS listener error:', err);
    }
  }
}

function wireTTSEvents(audio, provider, source, requestId, context) {
  audio.addEventListener('ended', () => {
    emitTTSState({
      status: 'completed',
      provider,
      source,
      context,
      message: getEndedMessage(provider, context)
    });
    releaseAudioObjectUrl(audio);
    if (ttsAudio === audio) {
      ttsAudio = null;
    }
    if (activeNarrationId === requestId) {
      activeNarrationId = null;
    }
  });

  audio.addEventListener('pause', () => {
    if (!audio.ended) {
      emitTTSState({
        status: 'paused',
        provider,
        source,
        context,
        message: getPauseMessage(provider, context)
      });
    }
  });

  audio.addEventListener('error', () => {
    emitTTSState({
      status: 'error',
      provider,
      source,
      context,
      error: 'Audio playback error.',
      message: 'Something went wrong while playing audio.'
    });
    releaseAudioObjectUrl(audio);
    if (activeNarrationId === requestId) {
      activeNarrationId = null;
    }
  });
}

function getPlayMessage(provider, context) {
  if (provider === 'fallback') {
    return 'Voice service unavailable; playing a gentle chime instead of narration.';
  }
  if (context === 'card-reveal') {
    return 'Speaking this card reveal.';
  }
  if (context === 'full-reading') {
    return 'Playing your personal reading narration.';
  }
  return 'Playing narration.';
}

function getPreparingMessage(provider, context) {
  if (provider === 'fallback') {
    return 'Preparing fallback chime.';
  }
  if (context === 'card-reveal') {
    return 'Preparing card reveal narration.';
  }
  if (context === 'full-reading') {
    return 'Preparing personal reading narration.';
  }
  return 'Preparing narration...';
}

function getEndedMessage(provider, context) {
  if (provider === 'fallback') {
    return 'Fallback chime finished.';
  }
  if (context === 'card-reveal') {
    return 'Card narration finished.';
  }
  if (context === 'full-reading') {
    return 'Personal reading narration finished.';
  }
  return 'Narration finished.';
}

function getPauseMessage(provider, context) {
  if (provider === 'fallback') {
    return 'Fallback chime paused.';
  }
  if (context === 'card-reveal') {
    return 'Card narration paused.';
  }
  if (context === 'full-reading') {
    return 'Personal reading narration paused.';
  }
  return 'Narration paused.';
}

function ensureGlobalCleanupListeners() {
  if (cleanupListenersRegistered || typeof window === 'undefined') {
    return;
  }
  cleanupListenersRegistered = true;

  const handleLifecycleEnd = () => {
    revokeAllObjectUrls();
    clearTTSCache();
  };

  window.addEventListener('beforeunload', handleLifecycleEnd);
  window.addEventListener('pagehide', handleLifecycleEnd);
}

function trackObjectUrl(url) {
  if (!url || typeof URL === 'undefined') {
    return;
  }
  trackedObjectUrls.add(url);
}

function releaseAudioObjectUrl(audio) {
  if (!audio) return;
  const objectUrl = audioObjectUrlMap.get(audio);
  if (objectUrl) {
    revokeTrackedObjectUrl(objectUrl);
    audioObjectUrlMap.delete(audio);
  }
}

function revokeTrackedObjectUrl(url) {
  if (!url || typeof URL === 'undefined') {
    return;
  }
  try {
    URL.revokeObjectURL(url);
  } catch {
    // Ignore browsers that throw on redundant revoke
  }
  trackedObjectUrls.delete(url);
}

function revokeAllObjectUrls() {
  if (!trackedObjectUrls.size || typeof URL === 'undefined') {
    return;
  }
  for (const url of trackedObjectUrls) {
    try {
      URL.revokeObjectURL(url);
    } catch {
      // Ignore browsers that throw on redundant revoke
    }
  }
  trackedObjectUrls.clear();
}
</file>

<file path="src/lib/audioCache.js">
/**
 * Audio Cache for TTS responses
 * 
 * Caches short audio clips (phrases under a certain length) in memory
 * to avoid repeated API calls for common utterances.
 */

const MAX_CACHE_SIZE = 50;
const MAX_CACHEABLE_LENGTH = 200; // Only cache short phrases

class AudioCache {
  constructor() {
    this.cache = new Map();
  }

  /**
   * Generate a cache key from text and emotion
   * @param {string} text - The text content
   * @param {string} emotion - The emotion/style applied
   * @returns {string} Cache key
   */
  _key(text, emotion) {
    return `${text}::${emotion || 'default'}`;
  }

  /**
   * Check if text is short enough to be cached
   * @param {string} text - Text to check
   * @returns {boolean} Whether the text can be cached
   */
  isCacheable(text) {
    return typeof text === 'string' && text.length <= MAX_CACHEABLE_LENGTH;
  }

  /**
   * Get cached audio for text
   * @param {string} text - The text
   * @param {string} emotion - The emotion applied
   * @returns {string|null} Data URL of cached audio, or null
   */
  get(text, emotion) {
    if (!this.isCacheable(text)) return null;
    const key = this._key(text, emotion);
    const entry = this.cache.get(key);
    if (entry) {
      // Move to end (LRU behavior)
      this.cache.delete(key);
      this.cache.set(key, entry);
      return entry;
    }
    return null;
  }

  /**
   * Store audio in cache
   * @param {string} text - The text
   * @param {string} emotion - The emotion applied
   * @param {string} audioDataUrl - Base64 data URL of the audio
   */
  set(text, emotion, audioDataUrl) {
    if (!this.isCacheable(text)) return;
    const key = this._key(text, emotion);
    
    // Evict oldest if at capacity
    if (this.cache.size >= MAX_CACHE_SIZE) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) this.cache.delete(firstKey);
    }
    
    this.cache.set(key, audioDataUrl);
  }

  /**
   * Clear all cached audio
   */
  clear() {
    this.cache.clear();
  }

  /**
   * Get current cache size
   * @returns {number} Number of cached entries
   */
  get size() {
    return this.cache.size;
  }
}

export const audioCache = new AudioCache();
</file>

<file path="src/lib/audioHume.js">
/**
 * Hume AI Octave TTS Integration for Tarot Readings
 *
 * This module provides client-side utilities for generating expressive,
 * emotionally-aware speech using Hume AI's Octave TTS service.
 *
 * Features:
 * - Context-aware voice selection (card reveals, full readings, synthesis)
 * - Voice continuity across multiple utterances via generation IDs
 * - GraphRAG emotion-based acting instructions
 * - Automatic retry and error handling
 * - Audio caching for common phrases
 *
 * API Documentation: https://dev.hume.ai/reference/text-to-speech-tts
 */

import { getActingInstructions } from '../data/emotionMapping.js';
import { audioCache } from './audioCache.js';

let currentAudio = null;
let lastGenerationId = null;

/**
 * Generate and play speech using Hume AI Octave TTS
 *
 * @param {string} text - The text to speak (max 5000 characters)
 * @param {Object} options - TTS options
 * @param {string} options.context - Context type (card-reveal, full-reading, synthesis, etc.)
 * @param {string} options.voiceName - Specific Hume voice name (e.g., "ITO", "KORA")
 * @param {string} options.description - Custom voice description/acting instructions
 * @param {string} options.emotion - GraphRAG-derived emotion for acting instructions
 * @param {number} options.speed - Speech speed (0.5-2.0)
 * @param {boolean} options.continuePrevious - Continue from previous generation for voice consistency
 * @param {number} options.trailingSilence - Silence after utterance (0-5 seconds)
 * @returns {Promise<Object>} Result with audio element and generation ID
 */
export async function speakWithHume(text, options = {}) {
  const {
    context = 'default',
    voiceName,
    description,
    emotion,
    speed,
    continuePrevious = false,
    trailingSilence
  } = options;

  try {
    // Check cache first for short phrases
    const cachedAudio = audioCache.get(text, emotion);
    if (cachedAudio) {
      const audio = new Audio(cachedAudio);

      // Stop any currently playing audio
      if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0;
      }

      currentAudio = audio;

      return {
        audio,
        generationId: null,
        voiceUsed: voiceName || 'ITO',
        cached: true,
        play: () => audio.play(),
        pause: () => audio.pause(),
        stop: () => {
          audio.pause();
          audio.currentTime = 0;
        }
      };
    }

    // Build request payload
    const payload = {
      text,
      context
    };

    if (voiceName) payload.voiceName = voiceName;

    // Priority: custom description > emotion-based > none (let backend use context)
    if (description) {
      payload.description = description;
    } else if (emotion) {
      payload.description = getActingInstructions(emotion);
      payload.emotion = emotion; // Also send emotion key for backend logging
    }

    if (speed !== undefined) payload.speed = speed;
    if (trailingSilence !== undefined) payload.trailingSilence = trailingSilence;

    // Add continuation if requested and we have a previous generation
    if (continuePrevious && lastGenerationId) {
      payload.previousGenerationId = lastGenerationId;
    }

    // Call the Hume TTS endpoint
    const response = await fetch('/api/tts-hume', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const responseText = await response.text();
      let errorMsg = 'TTS request failed';
      try {
        const errorData = JSON.parse(responseText);
        errorMsg = errorData.error ?? errorMsg;
      } catch {
        // Keep default if response is not JSON
      }
      throw new Error(errorMsg);
    }

    const result = await response.json();

    // Store generation ID for potential continuation
    if (result.generationId) {
      lastGenerationId = result.generationId;
    }

    // Cache the result for short phrases
    if (result.audio && audioCache.isCacheable(text)) {
      audioCache.set(text, emotion, result.audio);
    }

    // Create and play audio
    const audio = new Audio(result.audio);

    // Stop any currently playing audio
    if (currentAudio) {
      currentAudio.pause();
      currentAudio.currentTime = 0;
    }

    currentAudio = audio;

    return {
      audio,
      generationId: result.generationId,
      voiceUsed: result.voiceUsed,
      cached: false,
      play: () => audio.play(),
      pause: () => audio.pause(),
      stop: () => {
        audio.pause();
        audio.currentTime = 0;
      }
    };

  } catch (error) {
    console.error('Hume TTS error:', error);
    throw error;
  }
}

/**
 * Speak a tarot card reveal with appropriate mystical tone
 * 
 * @param {string} cardName - Name of the card
 * @param {string} orientation - "upright" or "reversed"
 * @param {string} meaning - Brief meaning or interpretation
 * @returns {Promise<Object>} Audio result
 */
export async function speakCardReveal(cardName, orientation, meaning) {
  const text = `${cardName}, ${orientation}. ${meaning}`;
  return speakWithHume(text, {
    context: 'card-reveal',
    voiceName: 'ITO',
    speed: 0.9, // Slightly slower for contemplation
    trailingSilence: 1.5
  });
}

/**
 * Speak a complete tarot reading with natural pauses and flow
 * 
 * @param {string} readingText - The full reading narrative
 * @param {Object} options - Additional options
 * @returns {Promise<Object>} Audio result
 */
export async function speakFullReading(readingText, options = {}) {
  return speakWithHume(readingText, {
    context: 'full-reading',
    voiceName: options.voiceName || 'ITO',
    speed: options.speed || 1.0,
    ...options
  });
}

/**
 * Speak reading synthesis/summary with storytelling flow
 * 
 * @param {string} synthesisText - The synthesis or summary text
 * @param {Object} options - Additional options
 * @returns {Promise<Object>} Audio result
 */
export async function speakSynthesis(synthesisText, options = {}) {
  return speakWithHume(synthesisText, {
    context: 'synthesis',
    voiceName: options.voiceName || 'KORA',
    speed: options.speed || 1.05,
    ...options
  });
}

/**
 * Speak multiple segments with voice continuity
 * Useful for breaking long readings into natural chunks
 * 
 * @param {Array<string>} segments - Array of text segments to speak
 * @param {Object} options - TTS options
 * @returns {Promise<Array<Object>>} Array of audio results
 */
export async function speakSequence(segments, options = {}) {
  const results = [];
  
  for (let i = 0; i < segments.length; i++) {
    const result = await speakWithHume(segments[i], {
      ...options,
      continuePrevious: i > 0 // Continue voice from previous segment
    });
    
    results.push(result);
    
    // Wait for current segment to finish before starting next
    if (options.autoPlay !== false) {
      await new Promise((resolve) => {
        result.audio.onended = resolve;
        result.audio.play();
      });
    }
  }
  
  return results;
}

/**
 * Stop any currently playing Hume audio
 */
export function stopHumeAudio() {
  if (currentAudio) {
    currentAudio.pause();
    currentAudio.currentTime = 0;
    currentAudio = null;
  }
}

/**
 * Check if Hume TTS is available
 * 
 * @returns {Promise<boolean>} True if Hume TTS is configured and available
 */
export async function isHumeTTSAvailable() {
  try {
    const response = await fetch('/api/tts-hume');
    const result = await response.json();
    return result.status === 'ok' && result.provider === 'hume-ai';
  } catch (error) {
    console.error('Error checking Hume TTS availability:', error);
    return false;
  }
}

/**
 * Get the last generation ID for voice continuation
 * 
 * @returns {string|null} Last generation ID or null
 */
export function getLastGenerationId() {
  return lastGenerationId;
}

/**
 * Reset the generation ID (useful when starting a new reading)
 */
export function resetGenerationId() {
  lastGenerationId = null;
}

// Available Hume preset voices for tarot readings
// Based on Hume's Voice Library: https://platform.hume.ai/tts/voice-library
export const HUME_VOICES = {
  mystical: [
    'ITO',           // Warm, contemplative - excellent for readings
    'KORA',          // Smooth, storytelling quality
    'DACHER',        // Gentle, supportive
    'STELLA',        // Clear, inviting
    'WHIMSY'         // Playful yet wise
  ],
  narrators: [
    'HANK',          // Deep, authoritative narrator
    'RAMONA',        // Warm, engaging storyteller
    'LIVIA'          // Elegant, refined narrator
  ],
  conversational: [
    'AURA',          // Friendly, approachable
    'FINN',          // Casual, relatable
    'ORION'          // Calm, measured
  ],
  dramatic: [
    'LUNA',          // Mysterious, dramatic
    'COVE',          // Rich, theatrical
    'EMBER'          // Intense, passionate
  ]
};

// Context to voice mapping
export const CONTEXT_VOICE_MAP = {
  'card-reveal': 'ITO',
  'full-reading': 'ITO',
  'synthesis': 'KORA',
  'question': 'STELLA',
  'reflection': 'DACHER',
  'default': 'ITO'
};
</file>

<file path="src/lib/cardInsights.js">
import { SYMBOL_ANNOTATIONS } from '../../shared/symbols/symbolAnnotations.js';
import { getMinorSymbolAnnotation } from '../../shared/vision/minorSymbolLexicon.js';
import { MAJOR_ARCANA } from '../data/majorArcana';
import { MINOR_ARCANA } from '../data/minorArcana';

const CARD_LOOKUP = (() => {
  const map = new Map();
  [...MAJOR_ARCANA, ...MINOR_ARCANA].forEach((card) => {
    if (card?.name) {
      map.set(card.name.toLowerCase(), card);
    }
  });
  return map;
})();

function getCanonicalCard(card) {
  if (!card?.name) return null;
  return CARD_LOOKUP.get(card.name.toLowerCase()) || card;
}

function getAnnotation(card) {
  if (!card) return null;
  if (typeof card.number === 'number' && SYMBOL_ANNOTATIONS[card.number]) {
    return SYMBOL_ANNOTATIONS[card.number];
  }
  if (card.suit && card.rank) {
    return getMinorSymbolAnnotation(card);
  }
  return null;
}

function splitKeywords(text) {
  if (!text || typeof text !== 'string') return [];
  return text
    .split(',')
    .map((part) => part.trim())
    .filter(Boolean);
}

export function buildCardInsights(card, { orientationOverride } = {}) {
  if (!card) return null;
  const baseCard = getCanonicalCard(card);
  if (!baseCard) return null;

  const isReversed = typeof orientationOverride === 'boolean'
    ? orientationOverride
    : Boolean(card.isReversed);

  const keywords = isReversed
    ? splitKeywords(baseCard.reversed)
    : splitKeywords(baseCard.upright);

  const annotation = getAnnotation(baseCard);
  const dominantSymbols = Array.isArray(annotation?.symbols)
    ? annotation.symbols.slice(0, 3)
    : [];
  const dominantColors = Array.isArray(annotation?.dominantColors)
    ? annotation.dominantColors.slice(0, 3)
    : [];

  return {
    name: baseCard.name || card.name,
    isReversed,
    keywords,
    archetype: annotation?.archetype || null,
    composition: annotation?.composition || null,
    symbols: dominantSymbols,
    colors: dominantColors,
    suit: baseCard.suit || null,
    rank: baseCard.rank || null
  };
}
</file>

<file path="src/lib/cardLookup.js">
/**
 * Card Lookup Utilities
 * 
 * Provides card image lookup, canonical card data access,
 * and orientation meaning helpers.
 */

import { MAJOR_ARCANA } from '../data/majorArcana';
import { MINOR_ARCANA } from '../data/minorArcana';

// Fallback image for missing cards
export const FALLBACK_IMAGE = '/images/cards/card-back.jpeg';

// Build lookup table from all cards
const ALL_CARDS = [...MAJOR_ARCANA, ...MINOR_ARCANA];

export const CARD_LOOKUP = ALL_CARDS.reduce((acc, card) => {
  // Normalize card name for lookup (lowercase, no spaces)
  const normalizedName = card.name.toLowerCase().replace(/\s+/g, '-');
  acc[normalizedName] = card;
  acc[card.name] = card; // Also allow exact name lookup
  acc[card.name.toLowerCase()] = card; // Allow lowercase lookup
  return acc;
}, {});

/**
 * Get card image path
 * @param {Object} card - Card object with name/image properties
 * @returns {string} Image path or fallback
 */
export function getCardImage(card) {
  if (!card) return FALLBACK_IMAGE;
  
  // If card has an image property, use it
  if (card.image) return card.image;
  
  // Try to look up the canonical card
  const canonical = getCanonicalCard(card);
  if (canonical?.image) return canonical.image;
  
  return FALLBACK_IMAGE;
}

/**
 * Get the canonical card data from the lookup table
 * @param {Object|string} card - Card object or name
 * @returns {Object|null} Canonical card data
 */
export function getCanonicalCard(card) {
  if (!card) return null;
  
  const name = typeof card === 'string' ? card : card.name;
  if (!name) return null;
  
  // Try various normalizations
  const lookups = [
    name,
    name.toLowerCase(),
    name.toLowerCase().replace(/\s+/g, '-'),
    name.replace(/\s+/g, '-')
  ];
  
  for (const lookup of lookups) {
    if (CARD_LOOKUP[lookup]) {
      return CARD_LOOKUP[lookup];
    }
  }
  
  return null;
}

/**
 * Get meaning based on card orientation
 * @param {Object} card - Card with isReversed property
 * @returns {string} Upright or reversed meaning
 */
export function getOrientationMeaning(card) {
  if (!card) return '';
  
  const canonical = getCanonicalCard(card);
  if (!canonical) return '';
  
  return card.isReversed ? canonical.reversed : canonical.upright;
}

/**
 * Check if a card exists in our lookup
 * @param {string} name - Card name
 * @returns {boolean} Whether card exists
 */
export function cardExists(name) {
  return getCanonicalCard(name) !== null;
}

/**
 * Get all cards matching a filter
 * @param {Function} filterFn - Filter function
 * @returns {Array} Matching cards
 */
export function filterCards(filterFn) {
  return ALL_CARDS.filter(filterFn);
}

/**
 * Get all Major Arcana cards
 * @returns {Array} Major Arcana cards
 */
export function getMajorArcana() {
  return MAJOR_ARCANA;
}

/**
 * Get all Minor Arcana cards
 * @returns {Array} Minor Arcana cards  
 */
export function getMinorArcana() {
  return MINOR_ARCANA;
}

/**
 * Get all cards
 * @returns {Array} All tarot cards
 */
export function getAllCards() {
  return ALL_CARDS;
}
</file>

<file path="src/lib/coachStorage.js">
export const TEMPLATE_STORAGE_KEY = 'tarot_coach_templates';
export const HISTORY_STORAGE_KEY = 'tarot_coach_history';
export const MAX_TEMPLATES = 8;
export const MAX_HISTORY_ITEMS = 10;
export const COACH_STORAGE_SYNC_EVENT = 'coach-storage-sync';

const dispatchCoachStorageEvent = (key) => {
  if (typeof window === 'undefined' || typeof window.dispatchEvent !== 'function') {
    return;
  }
  try {
    window.dispatchEvent(new CustomEvent(COACH_STORAGE_SYNC_EVENT, { detail: { key } }));
  } catch {
    // CustomEvent or dispatch can fail in older browsers; swallow to avoid crashing.
  }
};

function safeParse(value, fallback) {
  try {
    return value ? JSON.parse(value) : fallback;
  } catch (error) {
    console.warn('Failed to parse coach storage payload:', error);
    return fallback;
  }
}

function readFromStorage(key) {
  if (typeof localStorage === 'undefined') {
    return null;
  }
  try {
    return localStorage.getItem(key);
  } catch (error) {
    console.warn('Unable to read coach storage payload:', error);
    return null;
  }
}

function writeToStorage(key, value) {
  if (typeof localStorage === 'undefined') {
    return { success: false, error: 'Coach storage is unavailable in this environment.' };
  }
  try {
    localStorage.setItem(key, JSON.stringify(value));
    dispatchCoachStorageEvent(key);
    return { success: true };
  } catch (error) {
    console.warn('Unable to persist coach storage payload:', error);
    return { success: false, error: 'We could not update your coach data. Please check storage settings and try again.' };
  }
}

function generateId(prefix) {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `${prefix}_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}

export function loadCoachTemplates() {
  const raw = readFromStorage(TEMPLATE_STORAGE_KEY);
  const templates = safeParse(raw, []);
  return Array.isArray(templates) ? templates : [];
}

export function saveCoachTemplate(template) {
  if (!template || !template.label) {
    return { success: false, error: 'Template requires a label.' };
  }
  const trimmedLabel = template.label.trim();
  if (!trimmedLabel) {
    return { success: false, error: 'Template label cannot be empty.' };
  }
  const existing = loadCoachTemplates();
  const filtered = existing.filter(item => item.label.toLowerCase() !== trimmedLabel.toLowerCase());
  const entry = {
    id: template.id || generateId('template'),
    label: trimmedLabel,
    topic: template.topic,
    timeframe: template.timeframe,
    depth: template.depth,
    customFocus: template.customFocus || '',
    useCreative: Boolean(template.useCreative),
    savedQuestion: template.savedQuestion || '',
    updatedAt: Date.now()
  };
  const next = [entry, ...filtered].slice(0, MAX_TEMPLATES);
  const persistence = writeToStorage(TEMPLATE_STORAGE_KEY, next);
  if (!persistence.success) {
    return { success: false, error: persistence.error || 'Unable to save template right now.' };
  }
  return { success: true, templates: next, template: entry };
}

export function deleteCoachTemplate(templateId) {
  if (!templateId) {
    return { success: false, templates: loadCoachTemplates() };
  }
  const existing = loadCoachTemplates();
  const next = existing.filter(template => template.id !== templateId);
  const persistence = writeToStorage(TEMPLATE_STORAGE_KEY, next);
  if (!persistence.success) {
    return {
      success: false,
      error: persistence.error || 'Unable to update templates right now.',
      templates: existing
    };
  }
  return { success: true, templates: next };
}

export function loadCoachHistory(limit = MAX_HISTORY_ITEMS) {
  const raw = readFromStorage(HISTORY_STORAGE_KEY);
  const history = safeParse(raw, []);
  if (!Array.isArray(history)) {
    return [];
  }
  const normalized = history.filter(entry => entry && typeof entry.question === 'string');
  return typeof limit === 'number' ? normalized.slice(0, limit) : normalized;
}

export function recordCoachQuestion(question, limit = MAX_HISTORY_ITEMS) {
  const trimmed = (question || '').trim();
  const normalizedLimit = typeof limit === 'number' && limit > 0 ? limit : MAX_HISTORY_ITEMS;
  const historyPool = loadCoachHistory(normalizedLimit * 2);
  const currentHistory = historyPool.slice(0, normalizedLimit);

  if (!trimmed) {
    return { success: true, history: currentHistory };
  }

  const filtered = historyPool.filter(entry => entry.question.toLowerCase() !== trimmed.toLowerCase());
  const entry = {
    id: generateId('question'),
    question: trimmed,
    createdAt: Date.now()
  };
  const next = [entry, ...filtered].slice(0, normalizedLimit);
  const persistence = writeToStorage(HISTORY_STORAGE_KEY, next);
  if (!persistence.success) {
    return {
      success: false,
      history: currentHistory,
      error: persistence.error || 'Question applied, but we could not save it to your recent history. Check browser storage or privacy settings.'
    };
  }
  return { success: true, history: next };
}

export function deleteCoachHistoryItem(itemId) {
  if (!itemId) {
    return { success: false, history: loadCoachHistory() };
  }
  const existing = loadCoachHistory(100); // Load more to ensure we don't lose items unnecessarily, though we usually cap at MAX_HISTORY_ITEMS
  const next = existing.filter(item => item.id !== itemId);
  const persistence = writeToStorage(HISTORY_STORAGE_KEY, next);
  if (!persistence.success) {
    return {
      success: false,
      error: persistence.error || 'Unable to update history right now.',
      history: existing
    };
  }
  return { success: true, history: next };
}
</file>

<file path="src/lib/deck.js">
import { MAJOR_ARCANA } from '../data/majorArcana.js';
import { SPREADS } from '../data/spreads.js';
import { MINOR_ARCANA } from '../data/minorArcana.js';

export function hashString(s) {
  let h = 2166136261 >>> 0;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

export function xorshift32(seed) {
  let x = seed >>> 0 || 0x9e3779b9;
  return () => {
    x ^= x << 13;
    x ^= x >>> 17;
    x ^= x << 5;
    return (x >>> 0) / 0x100000000;
  };
}

export function seededShuffle(arr, seed) {
  const copy = arr.slice();
  const rand = xorshift32(seed >>> 0);
  for (let i = copy.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [copy[i], copy[j]] = [copy[j], copy[i]];
  }
  return copy;
}

export function cryptoShuffle(arr) {
  const copy = arr.slice();
  if (typeof window !== 'undefined' && window.crypto?.getRandomValues) {
    const cryptoObj = window.crypto;
    for (let i = copy.length - 1; i > 0; i--) {
      const r = cryptoObj.getRandomValues(new Uint32Array(1))[0];
      const j = r % (i + 1);
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
  } else {
    for (let i = copy.length - 1; i > 0; i--) {
      const r = Math.floor(Math.random() * 2 ** 32);
      const j = r % (i + 1);
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
  }
  return copy;
}

export function computeSeed({ cutIndex, knockTimes, userQuestion }) {
  const intervals = (knockTimes || [])
    .slice(-3)
    .map((t, i, arr) => (i ? t - arr[i - 1] : 0))
    .reduce((sum, value) => sum + value, 0);

  const knockCount = (knockTimes || []).length;
  
  // Calculate timing pattern (rapid vs slow knocks)
  const avgInterval = knockCount > 1 ? intervals / (knockCount - 1) : 0;
  const timingPattern = avgInterval > 500 ? 'slow' : avgInterval > 200 ? 'medium' : 'rapid';
  const timingHash = hashString(timingPattern);

  const qHash = hashString(userQuestion || '');
  let seed = (qHash ^ (cutIndex * 2654435761) ^ Math.floor(intervals) ^ (knockCount * 1664525) ^ timingHash) >>> 0;
  if (seed === 0) seed = 0x9e3779b9;
  return seed >>> 0;
}

// Active deck pool based on toggle (with safety fallback)
export function getDeckPool(includeMinors = false) {
  try {
    if (includeMinors) {
      // Basic dataset integrity guard; if missing, fall back to majors
      if (!Array.isArray(MINOR_ARCANA) || MINOR_ARCANA.length !== 56) {
        console.warn('Minor Arcana dataset incomplete; falling back to majors-only.');
        return MAJOR_ARCANA;
      }
      
      // Deep validation of Minor Arcana structure
      const isValidMinor = MINOR_ARCANA.every(card => {
        return card &&
               typeof card.name === 'string' &&
               typeof card.suit === 'string' &&
               typeof card.rank === 'string' &&
               typeof card.rankValue === 'number' &&
               card.rankValue >= 1 && card.rankValue <= 14 &&
               typeof card.upright === 'string' &&
               typeof card.reversed === 'string';
      });
      
      if (!isValidMinor) {
        console.warn('Minor Arcana dataset malformed; falling back to majors-only.');
        return MAJOR_ARCANA;
      }
      
      return [...MAJOR_ARCANA, ...MINOR_ARCANA];
    }
    return MAJOR_ARCANA;
  } catch (err) {
    console.error('getDeckPool failed:', err);
    return MAJOR_ARCANA;
  }
}

export function computeRelationships(cards) {
  if (!cards || cards.length === 0) return [];

  const relationships = [];
  const numbers = cards.map(card => card.number);

  if (numbers.length > 1) {
    const hasSequence = numbers.some(
      (number, index) => index > 0 && Math.abs(number - numbers[index - 1]) === 1
    );
    if (hasSequence) {
      relationships.push({
        type: 'sequence',
        text: 'Sequential cards suggest a natural progression or journey through connected themes.'
      });
    }
  }

  const pairings = [
    {
      cards: ['The Fool', 'The Magician'],
      desc: 'New beginnings (Fool) empowered by manifesting ability (Magician).'
    },
    {
      cards: ['Death', 'The Star'],
      desc: 'Transformation (Death) leading to hope and renewal (Star).'
    },
    {
      cards: ['The Tower', 'The Sun'],
      desc: 'Upheaval (Tower) clearing the path to joy and clarity (Sun).'
    },
    {
      cards: ['The Devil', 'The Lovers'],
      desc: 'Attachment patterns (Devil) affecting relationship choices (Lovers).'
    },
    {
      cards: ['The Hermit', 'The High Priestess'],
      desc: 'Deep introspection (Hermit) accessing inner wisdom (High Priestess).'
    }
  ];

  const cardNames = cards.map(card => card.name);
  pairings.forEach(pair => {
    if (pair.cards.every(name => cardNames.includes(name))) {
      relationships.push({ type: 'pairing', text: pair.desc });
    }
  });

  if (cards.length >= 3) {
    const firstNum = cards[0].number;
    const lastNum = cards[cards.length - 1].number;
    if (typeof firstNum === 'number' && typeof lastNum === 'number' && lastNum > firstNum + 5) {
      relationships.push({
        type: 'arc',
        text: 'Your spread shows significant growth from early stages to mastery or completion.'
      });
    }
  }

  // Suit-run detection for Minors (3+ consecutive ranks in one suit)
  const suitMap = new Map();
  for (const c of cards) {
    if (!c || typeof c.rankValue !== 'number' || !c.suit) continue;
    if (!suitMap.has(c.suit)) suitMap.set(c.suit, new Set());
    suitMap.get(c.suit).add(c.rankValue);
  }
  for (const [suit, ranksSet] of suitMap.entries()) {
    const ranks = Array.from(ranksSet).sort((a, b) => a - b);
    if (ranks.length < 3) continue;
    let bestLen = 1;
    let currLen = 1;
    let bestStart = ranks[0];
    let currStart = ranks[0];
    for (let i = 1; i < ranks.length; i++) {
      if (ranks[i] === ranks[i - 1] + 1) {
        currLen += 1;
      } else {
        if (currLen > bestLen) {
          bestLen = currLen;
          bestStart = currStart;
        }
        currLen = 1;
        currStart = ranks[i];
      }
    }
    if (currLen > bestLen) {
      bestLen = currLen;
      bestStart = currStart;
    }
    if (bestLen >= 3 && typeof bestStart === 'number') {
      const run = Array.from({ length: bestLen }, (_, i) => bestStart + i);
      relationships.push({
        type: 'suit-run',
        text: `Consecutive ranks in ${suit} (${run.join(', ')}) highlight a focused theme in this suit.`
      });
    }
  }

  // Suit dominance: highlight when one Minor suit clearly dominates
  const suitCounts = cards.reduce((acc, c) => {
    if (c && c.suit) {
      acc[c.suit] = (acc[c.suit] || 0) + 1;
    }
    return acc;
  }, {});
  const totalSuitCards = Object.values(suitCounts).reduce((a, b) => a + b, 0);
  if (totalSuitCards >= 3) {
    const sortedSuits = Object.entries(suitCounts).sort((a, b) => b[1] - a[1]);
    const [topSuit, topCount] = sortedSuits[0];
    const secondCount = sortedSuits[1]?.[1] || 0;
    const hasClearLead =
      topCount >= 3 && // at least 3 cards of the same suit
      (topCount >= secondCount + 2 || topCount >= Math.ceil(totalSuitCards * 0.6));
    if (hasClearLead) {
      relationships.push({
        type: 'suit-dominance',
        text: `A strong presence of ${topSuit} cards suggests this suit's themes are central to your situation.`
      });
    }
  }

  // Court card gathering: Pages, Knights, Queens, Kings clustering
  const courtRanks = new Set(['Page', 'Knight', 'Queen', 'King']);
  const courtCards = cards.filter(c => c && courtRanks.has(c.rank));
  if (courtCards.length >= 2) {
    const suitsInCourts = new Set(courtCards.map(c => c.suit).filter(Boolean));
    if (courtCards.length >= 3) {
      relationships.push({
        type: 'court-cluster',
        text:
          'Multiple court cards appear, highlighting key people, roles, or aspects of your own maturity and leadership in this story.'
      });
    } else if (courtCards.length === 2) {
      relationships.push({
        type: 'court-pair',
        text:
          'Two court cards in this spread point to important dynamics between personalities, approaches, or stages of growth.'
      });
    }
    if (suitsInCourts.size === 1 && courtCards.length >= 2) {
      const suit = courtCards[0].suit;
      relationships.push({
        type: 'court-suit-focus',
        text: `Court cards clustered in ${suit} emphasize developed patterns or relationships within this suit's realm.`
      });
    }
  }

  // Reversal ratio analysis
  const reversedCards = cards.filter(c => c && c.isReversed);
  const reversalRatio = reversedCards.length / cards.length;
  
  if (reversalRatio >= 0.6) {
    relationships.push({
      type: 'reversal-heavy',
      text: 'A majority of reversed cards suggests significant inner processing, resistance, or timing delays are at play.'
    });
  } else if (reversalRatio >= 0.3) {
    relationships.push({
      type: 'reversal-moderate',
      text: 'Several reversals indicate areas where energy is meeting resistance or requiring conscious attention.'
    });
  }
  
  // Reversed court cards cluster detection
  const reversedCourts = courtCards.filter(c => c.isReversed);
  if (reversedCourts.length >= 2) {
    relationships.push({
      type: 'reversed-court-cluster',
      text: 'Multiple reversed court cards suggest challenges in how personalities or approaches are expressing themselves.'
    });
  }
  
  // Consecutive reversed cards detection
  for (let i = 1; i < cards.length; i++) {
    if (cards[i].isReversed && cards[i-1].isReversed) {
      relationships.push({
        type: 'consecutive-reversals',
        text: 'Consecutive reversed cards suggest a persistent theme of inner work or resistance across these positions.'
      });
      break;
    }
  }

  return relationships;
}

export function drawSpread({ spreadKey, useSeed, seed, includeMinors = false }) {
  const spread = SPREADS[spreadKey];
  if (!spread) throw new Error(`Unknown spread: ${spreadKey}`);

  const poolSource = getDeckPool(includeMinors);
  const pool = useSeed ? seededShuffle(poolSource, seed) : cryptoShuffle(poolSource);
  const count = spread.count;
  
  // Validate deck has enough cards for the spread
  if (pool.length < count) {
    throw new Error(`Deck too small for spread: need ${count} cards but only have ${pool.length}. Try enabling Minor Arcana or choosing a smaller spread.`);
  }

  const orientationRand = useSeed ? xorshift32((seed ^ 0xa5a5a5a5) >>> 0) : null;

  return pool.slice(0, count).map(card => ({
    ...card,
    isReversed: useSeed ? orientationRand() > 0.5 : Math.random() > 0.5
  }));
}
</file>

<file path="src/lib/formatting.js">
/**
 * Formatting Utilities for Tarot Readings
 *
 * Normalizes Markdown-formatted readings into human-readable plain text
 * for both UI display and TTS narration, maintaining the "human storyteller"
 * tone while avoiding "asterisk asterisk" and rigid headings.
 */

/**
 * Normalize reading text by stripping or softening Markdown markers
 *
 * This creates a gentle, conversational reading experience by:
 * - Removing bold/italic markers (**, *, _)
 * - Converting headings to natural section breaks
 * - Preserving paragraph structure
 * - Collapsing excessive whitespace
 *
 * @param {string} markdown - Raw Markdown reading text
 * @returns {string} Normalized plain text
 */
export function normalizeReadingText(markdown) {
  if (!markdown || typeof markdown !== 'string') {
    return '';
  }

  return markdown
    // Remove bold markers (** or __)
    .replace(/\*\*(.*?)\*\*/g, '$1')
    .replace(/__(.*?)__/g, '$1')

    // Remove italic markers (* or _)
    .replace(/\*([^*]+)\*/g, '$1')
    .replace(/_([^_]+)_/g, '$1')

    // Remove inline code markers (`)
    .replace(/`([^`]+)`/g, '$1')

    // Remove strikethrough markers (~~)
    .replace(/~~(.*?)~~/g, '$1')

    // Convert headings to natural section breaks
    // H1 (# ) -> Double line break + text
    .replace(/^#\s+(.+)$/gm, '\n\n$1\n')

    // H2 (## ) -> Double line break + text
    .replace(/^#{2}\s+(.+)$/gm, '\n\n$1\n')

    // H3-H6 (### to ######) -> Single line break + text
    .replace(/^#{3,6}\s+(.+)$/gm, '\n$1\n')

    // Remove bullet points and list markers, keeping content
    .replace(/^\s*[-*+]\s+/gm, '')
    .replace(/^\s*\d+\.\s+/gm, '')

    // Remove blockquote markers (>)
    .replace(/^>\s+/gm, '')

    // Remove horizontal rules (---, ***, ___)
    .replace(/^[\s]*[-*_]{3,}[\s]*$/gm, '')

    // Remove link syntax but keep link text: [text](url) -> text
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')

    // Remove image syntax: ![alt](url) -> ""
    .replace(/!\[([^\]]*)\]\([^)]+\)/g, '')

    // Collapse multiple newlines into double newlines (paragraph breaks)
    .replace(/\n{3,}/g, '\n\n')

    // Trim leading/trailing whitespace
    .trim();
}

/**
 * Prepare text specifically for TTS (Text-to-Speech) narration
 *
 * Adds natural pauses, emphasis cues, and pacing adjustments to make
 * the reading sound like a human storyteller, not a robot.
 *
 * @param {string} text - Normalized plain text
 * @returns {string} TTS-optimized text with pause markers and emphasis
 */
export function prepareForTTS(text) {
  if (!text || typeof text !== 'string') {
    return '';
  }

  return text
    // Add pauses after section breaks (double newlines)
    // Some TTS engines respect SSML-like pauses, but we'll use ellipsis for natural pausing
    .replace(/\n\n/g, '... ')

    // Add slight pause after sentences
    .replace(/([.!?])\s+/g, '$1.. ')

    // Remove parenthetical asides that don't narrate well
    // E.g., "(Card 1)" -> ""
    .replace(/\(Card \d+\)/gi, '')
    .replace(/\([^)]{1,30}\)/g, '') // Remove short parentheticals

    // Convert em dashes to natural pauses
    .replace(/\s*—\s*/g, '... ')
    .replace(/\s*–\s*/g, '... ')

    // Add emphasis markers for key phrases (optional, depends on TTS engine)
    // For now, we'll keep it simple and let natural language handle emphasis

    // Clean up excessive ellipsis (more than 3 dots)
    .replace(/\.{4,}/g, '...')

    // Collapse multiple spaces
    .replace(/\s{2,}/g, ' ')

    // Trim
    .trim();
}

/**
 * Split normalized text into natural paragraphs for UI rendering
 *
 * @param {string} text - Normalized plain text
 * @returns {string[]} Array of paragraph strings
 */
export function splitIntoParagraphs(text) {
  if (!text || typeof text !== 'string') {
    return [];
  }

  return text
    .split(/\n\n+/)
    .map(para => para.trim())
    .filter(para => para.length > 0);
}

/**
 * Preserve headings as semantic sections while normalizing content
 *
 * Returns structured sections with headers and content, useful for
 * rendering with accessible heading hierarchy.
 *
 * @param {string} markdown - Raw Markdown reading text
 * @returns {Array<{level: number, title: string, content: string}>}
 */
export function extractSections(markdown) {
  if (!markdown || typeof markdown !== 'string') {
    return [];
  }

  const sections = [];
  const lines = markdown.split('\n');
  let currentSection = null;

  for (const line of lines) {
    const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);

    if (headingMatch) {
      // Save previous section if exists
      if (currentSection) {
        currentSection.content = normalizeReadingText(currentSection.content);
        sections.push(currentSection);
      }

      // Start new section
      currentSection = {
        level: headingMatch[1].length,
        title: headingMatch[2].trim(),
        content: ''
      };
    } else if (currentSection) {
      // Add to current section content
      currentSection.content += line + '\n';
    } else {
      // Content before first heading (introduction)
      if (!sections.length || sections[sections.length - 1].title !== 'Introduction') {
        sections.push({
          level: 0,
          title: 'Introduction',
          content: line + '\n'
        });
      } else {
        sections[sections.length - 1].content += line + '\n';
      }
    }
  }

  // Save last section
  if (currentSection) {
    currentSection.content = normalizeReadingText(currentSection.content);
    sections.push(currentSection);
  }

  // Normalize all content
  return sections.map(section => ({
    ...section,
    content: section.content.trim()
  })).filter(section => section.content.length > 0);
}

/**
 * Format reading for export (preserve some structure but make readable)
 *
 * Keeps paragraph breaks and section divisions but removes distracting
 * Markdown syntax, suitable for copying to journal or sharing.
 *
 * @param {string} markdown - Raw Markdown reading text
 * @returns {string} Export-friendly formatted text
 */
export function formatForExport(markdown) {
  if (!markdown || typeof markdown !== 'string') {
    return '';
  }

  return markdown
    // Keep bold as UPPERCASE for emphasis
    .replace(/\*\*([^*]+)\*\*/g, (match, text) => text.toUpperCase())
    .replace(/__([^_]+)__/g, (match, text) => text.toUpperCase())

    // Remove italics markers
    .replace(/\*([^*]+)\*/g, '$1')
    .replace(/_([^_]+)_/g, '$1')

    // Convert headings to section dividers
    .replace(/^#\s+(.+)$/gm, '\n═══════════════════════════════════════\n$1\n═══════════════════════════════════════')
    .replace(/^#{2}\s+(.+)$/gm, '\n───────────────────────────────────────\n$1\n───────────────────────────────────────')
    .replace(/^#{3,6}\s+(.+)$/gm, '\n$1\n')

    // Keep paragraph breaks
    .replace(/\n{3,}/g, '\n\n')

    // Remove other markers
    .replace(/`([^`]+)`/g, '$1')
    .replace(/~~(.*?)~~/g, '$1')
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
    .replace(/!\[([^\]]*)\]\([^)]+\)/g, '')

    .trim();
}

/**
 * Create a cache key from normalized text for TTS storage
 *
 * This ensures TTS cache keys align with the cleaned version,
 * preventing cache misses and duplicate storage.
 *
 * @param {string} text - Text to create cache key from
 * @returns {string} Stable hash key
 */
export function createTextCacheKey(text) {
  if (!text || typeof text !== 'string') {
    return '';
  }

  // Normalize first to ensure consistent keys
  const normalized = normalizeReadingText(text);

  // Simple hash function (same as used in audio.js)
  let hash = 0;
  for (let i = 0; i < normalized.length; i++) {
    const char = normalized.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32-bit integer
  }

  return `tts_${Math.abs(hash).toString(36)}`;
}

/**
 * Detect if text contains Markdown formatting
 *
 * Useful for conditionally applying normalization.
 *
 * @param {string} text - Text to check
 * @returns {boolean} True if Markdown markers detected
 */
export function hasMarkdownFormatting(text) {
  if (!text || typeof text !== 'string') {
    return false;
  }

  const markdownPatterns = [
    /\*\*.*?\*\*/,          // Bold
    /\*.*?\*/,             // Italic
    /__.*?__/,             // Bold alt
    /_.*?_/,               // Italic alt
    /^#{1,6}\s+/m,         // Headings
    /`.*?`/,               // Code
    /\[.*?\]\(.*?\)/,      // Links
    /!\[.*?\]\(.*?\)/      // Images
  ];

  return markdownPatterns.some(pattern => pattern.test(text));
}

/**
 * Comprehensive formatter that handles both display and narration
 *
 * Returns both UI-ready and TTS-ready versions, plus structured sections.
 * This is the main entry point for reading formatting.
 *
 * @param {string} rawMarkdown - Original Markdown reading text
 * @returns {Object} Formatted reading in multiple representations
 */
export function formatReading(rawMarkdown) {
  if (!rawMarkdown || typeof rawMarkdown !== 'string') {
    return {
      raw: '',
      normalized: '',
      tts: '',
      paragraphs: [],
      sections: [],
      exportText: '',
      cacheKey: ''
    };
  }

  const normalized = normalizeReadingText(rawMarkdown);
  const tts = prepareForTTS(normalized);
  const paragraphs = splitIntoParagraphs(normalized);
  const sections = extractSections(rawMarkdown);
  const exportText = formatForExport(rawMarkdown);
  const cacheKey = createTextCacheKey(normalized);

  return {
    raw: rawMarkdown,
    normalized,
    tts,
    paragraphs,
    sections,
    exportText,
    cacheKey,
    hasMarkdown: hasMarkdownFormatting(rawMarkdown)
  };
}
</file>

<file path="src/lib/intentionCoach.js">
import { EXAMPLE_QUESTIONS } from '../data/exampleQuestions.js';
import { loadStoredJournalInsights } from './journalInsights.js';
import { loadCoachHistory } from './coachStorage.js';
import { hashString } from './deck.js';

const STOP_PHRASES = [' this week', ' this relationship', ' right now', ' with clarity'];

function deriveOpener(seed) {
  if (!seed) return 'How can I';
  let opener = seed.replace(/\?$/, '').trim();
  for (const phrase of STOP_PHRASES) {
    if (opener.endsWith(phrase)) {
      opener = opener.slice(0, -phrase.length).trim();
      break;
    }
  }
  return opener || 'How can I';
}

const focusSeed = EXAMPLE_QUESTIONS[0] || 'What should I focus on this week?';
const navigateSeed = EXAMPLE_QUESTIONS[1] || 'How can I navigate this relationship?';
const lessonSeed = EXAMPLE_QUESTIONS[3] || 'What lesson am I meant to learn?';
const claritySeed = EXAMPLE_QUESTIONS[4] || 'How can I move forward with clarity?';

/**
 * Deterministically picks a variant from a list based on a seed.
 * Same inputs always produce the same output.
 *
 * @param {Array} list - Array of variants to choose from
 * @param {number|string} seed - Seed value for deterministic selection
 * @returns {string} Selected variant
 */
function pickVariantDeterministic(list, seed) {
  if (!Array.isArray(list) || list.length === 0) return '';

  // Convert seed to number if it's a string
  const numericSeed = typeof seed === 'string' ? hashString(seed) : (seed >>> 0);

  // Use simple modulo for deterministic selection
  return list[numericSeed % list.length];
}

/**
 * Legacy variant picker with time-based randomization (non-deterministic).
 * Kept for backward compatibility when no seed is provided.
 *
 * @param {Array} list - Array of variants to choose from
 * @param {string} seedBase - Base string to influence selection
 * @returns {string} Selected variant
 */
function pickVariant(list, seedBase = '') {
  if (!Array.isArray(list) || list.length === 0) return '';
  const seed = hashString(`${seedBase}|${Date.now()}|${Math.random()}`);
  return list[seed % list.length];
}

function ensureQuestionMark(text) {
  if (!text) return '';
  const trimmed = text.trim();
  return trimmed.endsWith('?') ? trimmed : `${trimmed}?`;
}

export const INTENTION_TOPIC_OPTIONS = [
  {
    value: 'relationships',
    label: 'Love & Relationships',
    description: 'Partners, dating, family dynamics, community.',
    focus: 'my closest relationships and connections'
  },
  {
    value: 'career',
    label: 'Career & Purpose',
    description: 'Work, calling, leadership, creative path.',
    focus: 'my career direction and purpose'
  },
  {
    value: 'wellbeing',
    label: 'Wellbeing & Balance',
    description: 'Energy, health, daily flow, emotional balance.',
    focus: 'my wellbeing and day-to-day balance'
  },
  {
    value: 'growth',
    label: 'Self-Growth & Spiritual',
    description: 'Inner work, intuition, healing, spiritual practice.',
    focus: 'my personal growth and spiritual practice'
  },
  {
    value: 'decision',
    label: 'Choices & Crossroads',
    description: 'Making a call, weighing paths, bold changes.',
    focus: 'the decision that is on my mind'
  },
  {
    value: 'abundance',
    label: 'Money & Resources',
    description: 'Finances, home, stability, material support.',
    focus: 'my finances and sense of stability'
  }
];

export const INTENTION_TIMEFRAME_OPTIONS = [
  { value: 'today', label: 'Today / Daily', phrase: 'today', description: 'Immediate clarity' },
  { value: 'week', label: 'This week', phrase: 'this week', description: 'Short-term focus' },
  { value: 'month', label: 'Next 30 days', phrase: 'over the next month', description: 'Medium timeline' },
  { value: 'season', label: 'Season ahead', phrase: 'over the next few months', description: 'Quarterly planning' },
  { value: 'open', label: 'Open timeline', phrase: 'right now', description: 'Timeless guidance' }
];

export const INTENTION_DEPTH_OPTIONS = [
  {
    value: 'pulse',
    label: 'Quick pulse',
    description: 'Gentle check-in on the energy.',
    opener: deriveOpener(focusSeed),
    pattern: 'support',
    closing: 'with calm awareness'
  },
  {
    value: 'guided',
    label: 'Focused guidance',
    description: 'Clarify the next move or plan.',
    opener: deriveOpener(navigateSeed),
    pattern: 'navigate',
    closing: 'with confidence'
  },
  {
    value: 'lesson',
    label: 'Lesson & insight',
    description: 'Zoom out for the deeper teaching.',
    opener: deriveOpener(lessonSeed),
    pattern: 'lesson',
    closing: ''
  },
  {
    value: 'deep',
    label: 'Deep dive',
    description: 'Transformational, soulful work.',
    opener: deriveOpener(claritySeed),
    pattern: 'transform',
    closing: 'honor my growth'
  }
];

/**
 * Local creative question builder (fallback when API is unavailable).
 * Mirrors the guided templates so creative mode keeps the same intention-aware tone.
 *
 * @param {Object} params - Question parameters
 * @param {string} params.focus - Focus area text
 * @param {string} [params.timeframePhrase] - Timeframe phrase
 * @param {string} params.depthLabel - Depth label
 * @param {string} params.topicLabel - Topic label
 * @param {string} params.pattern - Depth pattern (support/navigate/lesson/transform)
 * @param {string} [params.closing] - Closing phrase based on depth
 * @param {number|string} [params.seed] - Optional seed for deterministic output
 * @returns {string} Generated question text
 */
export function buildLocalCreativeQuestion({ focus, timeframePhrase, depthLabel, topicLabel, pattern, closing, seed }) {
  const cleanFocus = (focus || 'this area of my life').replace(/\s+/g, ' ').trim();
  const timeframeText = timeframePhrase ? ` ${timeframePhrase}` : '';
  const closingSuffix = pattern === 'transform'
    ? (closing ? ` so I can ${closing}` : '')
    : (closing ? ` ${closing}` : '');
  const focusWithTimeframe = `${cleanFocus}${timeframeText}`;

  const supportVariants = [
    `How can I better support ${focusWithTimeframe}${closingSuffix}`,
    `What would help me tend to ${focusWithTimeframe}${closingSuffix}`,
    `Where should I focus to steady ${focusWithTimeframe}${closingSuffix}`,
    `What support will help me honor ${focusWithTimeframe}${closingSuffix}`,
    `How can I hold space for ${focusWithTimeframe}${closingSuffix}`,
    `How can I show up for ${focusWithTimeframe}${closingSuffix}`
  ];

  const navigateVariants = [
    `How can I navigate ${focusWithTimeframe}${closingSuffix}`,
    `How can I stay aligned with ${focusWithTimeframe}${closingSuffix}`,
    `What next step would move ${cleanFocus} forward${timeframeText}${closingSuffix}`,
    `What should I prioritize to move through ${focusWithTimeframe}${closingSuffix}`,
    `Where should I direct my energy to navigate ${focusWithTimeframe}${closingSuffix}`,
    `How can I make progress with ${cleanFocus}${timeframeText}${closingSuffix}`
  ];

  const lessonVariants = [
    `What deeper lesson is ${cleanFocus} offering${timeframeText}${closingSuffix}`,
    `How can I interpret ${focusWithTimeframe} as guidance${closingSuffix}`,
    `What am I being shown about ${focusWithTimeframe}${closingSuffix}`,
    `Where is ${cleanFocus} inviting me to grow${timeframeText}${closingSuffix}`,
    `How does ${focusWithTimeframe} reflect my bigger story${closingSuffix}`
  ];

  const transformVariants = [
    `How can I transform ${focusWithTimeframe}${closingSuffix}`,
    `What needs to shift within ${focusWithTimeframe}${closingSuffix}`,
    `What would renewal look like for ${focusWithTimeframe}${closingSuffix}`,
    `How might I nurture ${focusWithTimeframe}${closingSuffix}`,
    `What must I release to renew ${focusWithTimeframe}${closingSuffix}`,
    `How can I support the transformation of ${focusWithTimeframe}${closingSuffix}`
  ];

  const variantsByPattern = {
    support: supportVariants,
    navigate: navigateVariants,
    lesson: lessonVariants,
    transform: transformVariants
  };

  const variants = variantsByPattern[pattern] || [`How can I explore ${focusWithTimeframe}${closingSuffix}`];

  // Choose picker based on seed presence and bake the context into the seed to reduce collisions
  const picker = seed !== undefined ? pickVariantDeterministic : pickVariant;
  const pickerSeed = seed !== undefined
    ? `${seed}|${focusWithTimeframe}|${depthLabel}|${pattern}`
    : `${focusWithTimeframe}|${depthLabel}|${topicLabel}|${pattern}`;

  const question = picker(variants, pickerSeed);
  return ensureQuestionMark(question);
}

export async function callLlmApi(prompt, metadata, options = {}) {
  const { signal } = options;
  try {
    const response = await fetch('/api/generate-question', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ prompt, metadata }),
      signal
    });

    if (!response.ok) {
      throw new Error('API request failed');
    }

    const data = await response.json();
    if (data && typeof data === 'object') {
      return {
        question: data.question,
        provider: data.provider || data.source || null,
        model: data.model || null,
        forecast: data.forecast || null
      };
    }
    return null;
  } catch (error) {
    console.error('LLM API call failed:', error);
    return null;
  }
}

/**
 * Builds a creative/personalized tarot question with journal context integration.
 *
 * @param {Object} params - Question parameters
 * @param {string} params.topic - Topic area (relationships, career, etc.)
 * @param {string} params.timeframe - Time scope (today, week, month, etc.)
 * @param {string} params.depth - Depth level (pulse, guided, lesson, deep)
 * @param {string} [params.customFocus] - Optional custom focus text
 * @param {number|string} [params.seed] - Optional seed for deterministic output
 * @returns {Promise<Object>} { question: string, source: 'api'|'local' }
 */
export async function buildCreativeQuestion({ topic, timeframe, depth, customFocus, seed, focusAreas }, options = {}) {
  const { signal } = options;
  const topicData = INTENTION_TOPIC_OPTIONS.find(option => option.value === topic) || INTENTION_TOPIC_OPTIONS[0];
  const timeframeData = INTENTION_TIMEFRAME_OPTIONS.find(option => option.value === timeframe) || INTENTION_TIMEFRAME_OPTIONS[0];
  const depthData = INTENTION_DEPTH_OPTIONS.find(option => option.value === depth) || INTENTION_DEPTH_OPTIONS[0];

  const focus = customFocus?.trim() || topicData.focus;
  const timeframeClause = timeframeData?.phrase || 'the current moment';
  const normalizedFocusAreas = Array.isArray(focusAreas)
    ? focusAreas.map(area => (typeof area === 'string' ? area.trim() : '')).filter(Boolean)
    : [];

  const insights = loadStoredJournalInsights();
  const stats = insights?.stats || null;
  const recentThemes = stats?.recentThemes || [];
  const frequentCard = stats?.frequentCards?.[0]?.name || null;
  const leadingContext = stats?.contextBreakdown?.[0]?.name || null;
  const reversalRate = typeof stats?.reversalRate === 'number' ? `${stats.reversalRate}% reversals logged` : null;
  const recentQuestions = loadCoachHistory(3)
    .map(entry => (typeof entry?.question === 'string' ? entry.question.trim() : ''))
    .filter(Boolean);

  const personalizationFragments = [];
  if (recentThemes.length > 0) {
    personalizationFragments.push(`Recent themes to honor: ${recentThemes.slice(0, 3).join(', ')}`);
  }
  if (frequentCard) {
    personalizationFragments.push(`Recurring card: ${frequentCard}`);
  }
  if (leadingContext) {
    personalizationFragments.push(`Common context: ${leadingContext}`);
  }
  if (reversalRate) {
    personalizationFragments.push(reversalRate);
  }
  if (recentQuestions.length > 0) {
    personalizationFragments.push(`Avoid repeating prior asks like: ${recentQuestions.join('; ')}`);
  }
  if (normalizedFocusAreas.length > 0) {
    personalizationFragments.push(`User focus areas: ${normalizedFocusAreas.join(', ')}`);
  }

  const personalizationNote = personalizationFragments.length > 0
    ? `Personalization: ${personalizationFragments.join(' | ')}.`
    : '';

  const promptParts = [
    `Generate a tarot question about ${focus} for ${timeframeClause}.`,
    `The desired depth is ${depthData.label}.`,
    personalizationNote
  ].filter(Boolean);
  const prompt = promptParts.join(' ').trim();
  const metadata = {
    focus,
    customFocus: customFocus?.trim() || null,
    topic: topicData.label,
    topicValue: topicData.value,
    timeframe: timeframeData.label,
    timeframeValue: timeframeData.value,
    timeframePhrase: timeframeData.phrase,
    depth: depthData.label,
    pattern: depthData.pattern,
    closing: depthData.closing,
    recentThemes,
    frequentCard,
    leadingContext,
    reversalRate,
    recentQuestions,
    seed: seed !== undefined ? seed : null,  // Pass seed to backend
    focusAreas: normalizedFocusAreas
  };

  let apiResult = null;
  try {
    apiResult = await callLlmApi(prompt, metadata, { signal });
  } catch (error) {
    console.warn('Creative question API failed, falling back to local generator:', error);
  }

  const apiQuestion = typeof apiResult === 'string' ? apiResult : apiResult?.question;
  const apiSource = apiResult?.provider || 'api';
  const apiForecast = apiResult?.forecast || null;

  if (apiQuestion) {
    return { question: apiQuestion, source: apiSource, forecast: apiForecast };
  }

  // Local creative fallback adds variety instead of repeating guided wording
  const localCreative = buildLocalCreativeQuestion({
    focus,
    timeframePhrase: timeframeData?.phrase,
    depthLabel: depthData.label,
    pattern: depthData.pattern,
    closing: depthData.closing,
    topicLabel: topicData.label,
    seed  // Pass seed to fallback
  });

  return { question: localCreative, source: 'local', forecast: null };
}

/**
 * Builds a guided tarot question from structured parameters.
 *
 * @param {Object} params - Question parameters
 * @param {string} params.topic - Topic area (relationships, career, etc.)
 * @param {string} params.timeframe - Time scope (today, week, month, etc.)
 * @param {string} params.depth - Depth level (pulse, guided, lesson, deep)
 * @param {string} [params.customFocus] - Optional custom focus text
 * @param {number|string} [params.seed] - Optional seed for deterministic output
 * @returns {string} Generated question text
 */
export function buildGuidedQuestion({ topic, timeframe, depth, customFocus, seed }) {
  const topicData = INTENTION_TOPIC_OPTIONS.find(option => option.value === topic) || INTENTION_TOPIC_OPTIONS[0];
  const timeframeData = INTENTION_TIMEFRAME_OPTIONS.find(option => option.value === timeframe) || INTENTION_TIMEFRAME_OPTIONS[0];
  const depthData = INTENTION_DEPTH_OPTIONS.find(option => option.value === depth) || INTENTION_DEPTH_OPTIONS[0];

  const focus = (customFocus?.trim() || topicData.focus || '').replace(/\s+/g, ' ').trim() || 'this area of my life';
  const timeframeText = timeframeData?.phrase ? ` ${timeframeData.phrase}` : '';
  const closingSuffix = depthData.pattern === 'transform'
    ? (depthData.closing ? ` so I can ${depthData.closing}` : '')
    : (depthData.closing ? ` ${depthData.closing}` : '');
  const focusWithTimeframe = `${focus}${timeframeText}`;

  const supportVariants = [
    `How can I better support ${focusWithTimeframe}${closingSuffix}`,
    `What would help me hold space for ${focusWithTimeframe}${closingSuffix}`,
    `Where should I focus my energy to bring balance to ${focusWithTimeframe}${closingSuffix}`
  ];

  const navigateVariants = [
    `How can I navigate ${focusWithTimeframe}${closingSuffix}`,
    `How can I stay aligned with ${focusWithTimeframe}${closingSuffix}`,
    `What next step would move ${focus} forward${timeframeText}${closingSuffix}`,
    `What should I prioritize to navigate ${focus}${timeframeText}${closingSuffix}`,
    `How can I make progress with ${focus}${timeframeText}${closingSuffix}`
  ];

  const lessonVariants = [
    `What deeper lesson is ${focus} offering${timeframeText}`,
    `How can I interpret ${focus}${timeframeText} as guidance`,
    `Where is ${focus} inviting me to grow${timeframeText}`
  ];

  const transformVariants = [
    `How can I transform ${focus}${timeframeText}${closingSuffix}`,
    `What needs to shift within ${focus}${timeframeText}${closingSuffix}`,
    `How might I nurture ${focus}${timeframeText}${closingSuffix}`,
    `What must I release to renew ${focus}${timeframeText}${closingSuffix}`
  ];

  const variantsByPattern = {
    support: supportVariants,
    navigate: navigateVariants,
    lesson: lessonVariants,
    transform: transformVariants
  };

  const variants = variantsByPattern[depthData.pattern] || [`How can I explore ${focus}${timeframeText}`];

  // Choose picker based on seed presence
  const picker = seed !== undefined ? pickVariantDeterministic : pickVariant;
  const pickerSeed = seed !== undefined
    ? String(seed)
    : `${focus}|${timeframe}|${depth}`;

  const question = picker(variants, pickerSeed);
  return ensureQuestionMark(question);
}

export function getCoachSummary({ topic, timeframe, depth }) {
  const topicData = INTENTION_TOPIC_OPTIONS.find(option => option.value === topic);
  const timeframeData = INTENTION_TIMEFRAME_OPTIONS.find(option => option.value === timeframe);
  const depthData = INTENTION_DEPTH_OPTIONS.find(option => option.value === depth);

  return {
    topicLabel: topicData?.label || 'Topic',
    timeframeLabel: timeframeData?.label || 'Timeframe',
    depthLabel: depthData?.label || 'Depth'
  };
}
</file>

<file path="src/lib/journalInsights.js">
import { computeJournalStats, REVERSED_PATTERN } from '../../shared/journal/stats.js';
import { buildThemeQuestion, normalizeThemeLabel } from './themeText.js';

export { computeJournalStats, REVERSED_PATTERN };

const JOURNAL_INSIGHTS_STORAGE_KEY = 'tarot_journal_insights';
const SHARE_TOKEN_STORAGE_KEY = 'tarot_journal_share_tokens';
const COACH_RECOMMENDATION_KEY = 'tarot_coach_recommendation';
const COACH_STATS_SNAPSHOT_KEY = 'tarot_coach_stats_snapshot';
const COACH_RECOMMENDATION_TTL = 24 * 60 * 60 * 1000; // 24 hours

function normalizeCoachRecommendation(recommendation) {
  if (!recommendation || typeof recommendation !== 'object') return recommendation;

  const normalized = { ...recommendation };

  if (typeof normalized.customFocus === 'string') {
    const cleanedFocus = normalizeThemeLabel(normalized.customFocus) || normalized.customFocus.trim();
    normalized.customFocus = cleanedFocus || normalized.customFocus;
  }

  if (typeof normalized.question === 'string') {
    const themeMatch = normalized.question.match(/^How can I explore (?:the theme of )?(.+?) more deeply\??$/i);
    if (themeMatch) {
      const cleanedTheme = normalizeThemeLabel(themeMatch[1]) || themeMatch[1].trim();
      normalized.question = buildThemeQuestion(cleanedTheme);
      if (!normalized.customFocus) {
        normalized.customFocus = cleanedTheme;
      }
      if (cleanedTheme && typeof normalized.source === 'string' && normalized.source.startsWith('theme:')) {
        normalized.source = `theme:${cleanedTheme}`;
      }
    }
  }

  return normalized;
}

export function buildCardInsightPayload(card) {
  if (!card?.name) return null;
  return {
    name: card.name,
    isReversed: REVERSED_PATTERN.test(card?.orientation),
    image: card.image || null
  };
}

export function persistJournalInsights(entries) {
  if (typeof localStorage === 'undefined') return null;
  const stats = computeJournalStats(entries);
  if (!stats) {
    try {
      localStorage.removeItem(JOURNAL_INSIGHTS_STORAGE_KEY);
    } catch (error) {
      console.warn('Unable to clear journal insights cache:', error);
    }
    return null;
  }
  const payload = {
    stats,
    updatedAt: Date.now()
  };
  try {
    localStorage.setItem(JOURNAL_INSIGHTS_STORAGE_KEY, JSON.stringify(payload));
  } catch (error) {
    console.warn('Unable to persist journal insights:', error);
  }
  return payload;
}

export function loadStoredJournalInsights() {
  if (typeof localStorage === 'undefined') return null;
  try {
    const raw = localStorage.getItem(JOURNAL_INSIGHTS_STORAGE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed?.stats) return null;
    return parsed;
  } catch (error) {
    console.warn('Unable to load journal insights cache:', error);
    return null;
  }
}

export function persistCoachStatsSnapshot(stats, meta = {}) {
  if (typeof localStorage === 'undefined') return;
  try {
    if (!stats) {
      localStorage.removeItem(COACH_STATS_SNAPSHOT_KEY);
      return;
    }
    const payload = {
      stats,
      meta: {
        filtersActive: Boolean(meta.filtersActive),
        filterLabel: meta.filterLabel || null,
        entryCount: typeof meta.entryCount === 'number' ? meta.entryCount : null,
        totalEntries: typeof meta.totalEntries === 'number' ? meta.totalEntries : null
      },
      updatedAt: Date.now()
    };
    localStorage.setItem(COACH_STATS_SNAPSHOT_KEY, JSON.stringify(payload));
  } catch (error) {
    console.warn('Unable to persist coach stats snapshot:', error);
  }
}

export function loadCoachStatsSnapshot() {
  if (typeof localStorage === 'undefined') return null;
  try {
    const raw = localStorage.getItem(COACH_STATS_SNAPSHOT_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed?.stats) return null;
    return parsed;
  } catch (error) {
    console.warn('Unable to load coach stats snapshot:', error);
    return null;
  }
}

export function buildJournalCsv(entries) {
  if (!Array.isArray(entries) || entries.length === 0) return '';
  const header = [
    'Timestamp',
    'Spread',
    'Spread Key',
    'Question',
    'Cards',
    'Context',
    'Provider',
    'Deck',
    'Session Seed',
    'Reflections',
    'Themes',
    'Narrative'
  ];

  const escapeCsv = (value) => {
    if (value === null || value === undefined) return '""';
    const str = typeof value === 'string' ? value : JSON.stringify(value);
    return `"${str.replace(/"/g, '""')}"`;
  };

  const formatCards = (cards = []) => {
    if (!Array.isArray(cards) || cards.length === 0) return '';
    return cards
      .map(card => {
        const pos = card?.position || '';
        const name = card?.name || card?.card || '';
        const orientation = card?.orientation || '';
        return `${pos}: ${name}${orientation ? ` (${orientation})` : ''}`;
      })
      .join(' | ');
  };

  const rows = entries.map((entry) => {
    const timestamp = entry?.ts ? new Date(entry.ts).toISOString() : '';
    const spread = entry?.spread || entry?.spreadName || '';
    const spreadKey = entry?.spreadKey || '';
    const question = entry?.question || '';
    const cards = formatCards(entry?.cards);
    const context = entry?.context || '';
    const provider = entry?.provider || '';
    const deck = entry?.deckId || entry?.deckStyle || '';
    const sessionSeed = entry?.sessionSeed || '';
    const reflections = entry?.reflections || '';
    const themes = entry?.themes || '';
    const narrative = entry?.personalReading || '';

    return [
      timestamp,
      spread,
      spreadKey,
      question,
      cards,
      context,
      provider,
      deck,
      sessionSeed,
      reflections,
      themes,
      narrative
    ].map(escapeCsv).join(',');
  });
  return `${header.join(',')}
${rows.join('\n')}`;
}

function generateShareToken() {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return `share_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
}

function persistShareTokenRecord(record) {
  if (typeof localStorage === 'undefined') return;
  try {
    const raw = localStorage.getItem(SHARE_TOKEN_STORAGE_KEY);
    const existing = raw ? JSON.parse(raw) : [];
    const next = [record, ...existing].slice(0, 50);
    localStorage.setItem(SHARE_TOKEN_STORAGE_KEY, JSON.stringify(next));
  } catch (error) {
    console.warn('Unable to persist share token record:', error);
  }
}

function registerShareToken(entries, scope = 'journal', meta = {}) {
  if (!Array.isArray(entries) || entries.length === 0) return null;
  const entryIds = entries.map(entry => entry?.id).filter(Boolean);
  const token = generateShareToken();
  persistShareTokenRecord({
    token,
    scope,
    entryIds,
    count: entries.length,
    createdAt: Date.now(),
    meta
  });
  return token;
}

export function loadShareTokenHistory() {
  if (typeof localStorage === 'undefined') return [];
  try {
    const raw = localStorage.getItem(SHARE_TOKEN_STORAGE_KEY);
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed : [];
  } catch (error) {
    console.warn('Unable to load share tokens:', error);
    return [];
  }
}

export function revokeShareToken(token) {
  if (typeof localStorage === 'undefined') return [];
  try {
    const raw = localStorage.getItem(SHARE_TOKEN_STORAGE_KEY);
    const parsed = raw ? JSON.parse(raw) : [];
    const next = Array.isArray(parsed) ? parsed.filter(record => record.token !== token) : [];
    localStorage.setItem(SHARE_TOKEN_STORAGE_KEY, JSON.stringify(next));
    return next;
  } catch (error) {
    console.warn('Unable to revoke share token:', error);
    return [];
  }
}

export function saveCoachRecommendation(recommendation) {
  if (typeof localStorage === 'undefined') return;
  try {
    if (!recommendation) {
      localStorage.removeItem(COACH_RECOMMENDATION_KEY);
      return;
    }
    const normalized = normalizeCoachRecommendation(recommendation);
    const payload = {
      ...normalized,
      updatedAt: Date.now()
    };
    localStorage.setItem(COACH_RECOMMENDATION_KEY, JSON.stringify(payload));
  } catch (error) {
    console.warn('Unable to save coach recommendation:', error);
  }
}

export function loadCoachRecommendation() {
  if (typeof localStorage === 'undefined') return null;
  try {
    const raw = localStorage.getItem(COACH_RECOMMENDATION_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (parsed?.updatedAt && (Date.now() - parsed.updatedAt) > COACH_RECOMMENDATION_TTL) {
      localStorage.removeItem(COACH_RECOMMENDATION_KEY);
      return null;
    }
    return normalizeCoachRecommendation(parsed);
  } catch (error) {
    console.warn('Unable to load coach recommendation:', error);
    return null;
  }
}

export function exportJournalEntriesToCsv(entries, filename = 'tarot-journal.csv') {
  if (typeof document === 'undefined') return false;
  const csv = buildJournalCsv(entries);
  if (!csv) return false;
  // CSV export is local-only; no share token needed
  const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.setAttribute('download', filename);
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
  return true;
}

export async function copyJournalEntriesToClipboard(entries) {
  if (!Array.isArray(entries) || entries.length === 0) return false;
  const csv = buildJournalCsv(entries);
  if (!csv) return false;
  try {
    if (navigator?.clipboard?.writeText) {
      await navigator.clipboard.writeText(csv);
      return true;
    }
  } catch (error) {
    console.warn('Unable to copy journal CSV to clipboard:', error);
  }
  if (typeof document === 'undefined') return false;
  try {
    const textarea = document.createElement('textarea');
    textarea.value = csv;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    const success = document.execCommand('copy');
    document.body.removeChild(textarea);
    return success;
  } catch (error) {
    console.warn('Unable to copy journal CSV via fallback:', error);
    return false;
  }
}

export async function copyJournalShareSummary(stats) {
  if (!stats) return false;
  const summaryLines = [
    'Mystic Tarot Journal Snapshot',
    `Entries: ${stats.totalReadings}`,
    `Cards logged: ${stats.totalCards}`,
    `Reversal rate: ${stats.reversalRate}%`
  ];

  if (Array.isArray(stats.frequentCards) && stats.frequentCards.length > 0) {
    const top = stats.frequentCards.map(card => `${card.name} (${card.count}×)`).join(', ');
    summaryLines.push(`Top cards: ${top}`);
  }

  if (Array.isArray(stats.recentThemes) && stats.recentThemes.length > 0) {
    summaryLines.push(`Themes: ${stats.recentThemes.join('; ')}`);
  }

  const summary = summaryLines.join('\n');

  try {
    if (navigator?.share) {
      await navigator.share({ text: summary, title: 'Mystic Tarot Journal Snapshot' });
      return true;
    }
    if (navigator?.clipboard?.writeText) {
      await navigator.clipboard.writeText(summary);
      return true;
    }
    const textarea = document.createElement('textarea');
    textarea.value = summary;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    const success = document.execCommand('copy');
    document.body.removeChild(textarea);
    return success;
  } catch (error) {
    console.warn('Unable to share journal summary:', error);
    return false;
  }
}

export async function copyJournalEntrySummary(entry) {
  if (!entry) return false;
  const lines = [
    `Spread: ${entry.spread || entry.spreadName || 'Reading'}`,
    entry.question ? `Question: ${entry.question}` : null,
    `Cards: ${(entry.cards || []).map(card => `${card.name}${card.orientation ? ` (${card.orientation})` : ''}`).join(', ')}`,
    entry.context ? `Context: ${entry.context}` : null,
    entry.ts ? `When: ${new Date(entry.ts).toLocaleString()}` : null
  ].filter(Boolean);
  const text = lines.join('\n');
  try {
    if (navigator?.share) {
      await navigator.share({ text, title: 'Tarot reading snapshot' });
      return true;
    }
    if (navigator?.clipboard?.writeText) {
      await navigator.clipboard.writeText(text);
      return true;
    }
    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.style.position = 'fixed';
    textarea.style.opacity = '0';
    document.body.appendChild(textarea);
    textarea.focus();
    textarea.select();
    const success = document.execCommand('copy');
    document.body.removeChild(textarea);
    return success;
  } catch (error) {
    console.warn('Unable to share entry snapshot:', error);
    return false;
  }
}

// ============================================================================
// Preference Drift Analysis (Phase 5.3)
// ============================================================================
// Compares user's stated focus areas with actual reading contexts
// to surface emerging interests they might want to add to their profile.

/**
 * Map focus areas (from onboarding) to reading context categories.
 * This allows comparing what users said they care about vs what they
 * actually read about.
 */
const FOCUS_TO_CONTEXT = {
  love: 'love',
  career: 'career',
  self_worth: 'self',
  healing: 'wellbeing',
  creativity: 'career', // approximate mapping
  spirituality: 'spiritual'
};

/**
 * Compute preference drift between stated focus areas and actual reading contexts.
 *
 * @param {Array} entries - Journal entries with context field
 * @param {Array} currentFocusAreas - User's stated focus areas from onboarding
 * @returns {Object|null} Drift analysis or null if insufficient data
 */
export function computePreferenceDrift(entries, currentFocusAreas = []) {
  // Guard against empty/invalid inputs
  if (!Array.isArray(entries) || entries.length === 0) return null;
  if (!Array.isArray(currentFocusAreas) || currentFocusAreas.length === 0) return null;

  // Map focus areas to expected contexts
  const expectedContexts = new Set(
    currentFocusAreas
      .map(f => FOCUS_TO_CONTEXT[f])
      .filter(Boolean)
  );

  // Count actual contexts from entries
  const actualContextCounts = {};
  entries.forEach(entry => {
    const ctx = entry?.context;
    if (ctx && typeof ctx === 'string') {
      actualContextCounts[ctx] = (actualContextCounts[ctx] || 0) + 1;
    }
  });

  // Find drift: contexts user reads about but didn't select as focus
  const driftContexts = Object.entries(actualContextCounts)
    .filter(([ctx]) => !expectedContexts.has(ctx))
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3);

  // Get top actual contexts for comparison
  const actualTopContexts = Object.entries(actualContextCounts)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([context, count]) => ({ context, count }));

  return {
    expectedContexts: Array.from(expectedContexts),
    actualTopContexts,
    driftContexts: driftContexts.map(([context, count]) => ({ context, count })),
    hasDrift: driftContexts.length > 0
  };
}

/**
 * Format a context name for display (capitalize first letter).
 * @param {string} context - Raw context string
 * @returns {string} Formatted context name
 */
export function formatContextName(context) {
  if (!context || typeof context !== 'string') return '';
  return context.charAt(0).toUpperCase() + context.slice(1);
}

export {
  JOURNAL_INSIGHTS_STORAGE_KEY,
  SHARE_TOKEN_STORAGE_KEY,
  COACH_RECOMMENDATION_KEY,
  registerShareToken
};
</file>

<file path="src/lib/pdfExport.js">
import { jsPDF } from 'jspdf';

function addWrappedText(doc, text, x, y, maxWidth) {
  const lines = doc.splitTextToSize(text, maxWidth);
  doc.text(lines, x, y);
  return y + lines.length * 14;
}

function drawContextBars(doc, contexts, startX, startY, width) {
  if (!Array.isArray(contexts) || contexts.length === 0) return startY;
  const maxCount = Math.max(...contexts.map((ctx) => ctx.count));
  const barHeight = 12;
  const gap = 10;
  let cursorY = startY;
  contexts.slice(0, 4).forEach((ctx) => {
    const barWidth = maxCount === 0 ? 0 : (ctx.count / maxCount) * width;
    doc.setFillColor(61, 190, 161);
    doc.rect(startX, cursorY, barWidth, barHeight, 'F');
    doc.text(`${ctx.name} (${ctx.count})`, startX + width + 6, cursorY + barHeight - 2);
    cursorY += barHeight + gap;
  });
  return cursorY;
}

export function exportJournalInsightsToPdf(stats, entries = []) {
  if (!stats) return;
  const doc = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'letter' });
  const margin = 48;
  let cursorY = margin;

  doc.setFont('helvetica', 'bold');
  doc.setFontSize(20);
  doc.text('Mystic Tarot · Journal Snapshot', margin, cursorY);
  cursorY += 28;

  doc.setFontSize(11);
  doc.setFont('helvetica', 'normal');
  cursorY = addWrappedText(
    doc,
    `Entries: ${stats.totalReadings} · Cards Logged: ${stats.totalCards} · Reversal Rate: ${stats.reversalRate}%`,
    margin,
    cursorY,
    520
  );
  cursorY += 8;

  if (stats.recentThemes?.length) {
    cursorY = addWrappedText(doc, `Themes whispering lately: ${stats.recentThemes.join(', ')}`, margin, cursorY, 520);
    cursorY += 8;
  }

  doc.setFont('helvetica', 'bold');
  doc.text('Context cadence', margin, cursorY + 16);
  doc.setDrawColor(90, 214, 189);
  doc.rect(margin, cursorY + 24, 250, 90);
  doc.setFont('helvetica', 'normal');
  cursorY = drawContextBars(doc, stats.contextBreakdown, margin + 6, cursorY + 30, 180) + 10;

  const entrySnapshots = entries.slice(0, 4);
  if (entrySnapshots.length) {
    doc.setFont('helvetica', 'bold');
    doc.text('Highlighted entries', margin, cursorY);
    cursorY += 16;
    doc.setFont('helvetica', 'normal');
    entrySnapshots.forEach((entry, index) => {
      const title = `${index + 1}. ${entry.spread} (${entry.context || 'general'}) — ${new Date(entry.ts).toLocaleDateString()}`;
      cursorY = addWrappedText(doc, title, margin, cursorY, 520);
      if (entry.question) {
        cursorY = addWrappedText(doc, `Intention: ${entry.question}`, margin + 12, cursorY, 500);
      }
      const cardLine = (entry.cards || [])
        .slice(0, 5)
        .map((card) => `${card.position || card.name}: ${card.name}${card.orientation ? ` (${card.orientation})` : ''}`)
        .join(' · ');
      if (cardLine) {
        cursorY = addWrappedText(doc, `Cards: ${cardLine}`, margin + 12, cursorY, 500);
      }
      cursorY += 12;
      if (cursorY > 700) {
        doc.addPage();
        cursorY = margin;
      }
    });
  }

  doc.save('mystic-tarot-journal.pdf');
}

function buildSvg(stats) {
  const width = 640;
  const height = 360;
  const barWidth = 40;
  const gap = 20;
  const contexts = stats?.contextBreakdown?.slice(0, 5) || [];
  const maxCount = contexts.length ? Math.max(...contexts.map((ctx) => ctx.count)) : 1;
  const bars = contexts
    .map((ctx, index) => {
      const x = 80 + index * (barWidth + gap);
      const barHeight = maxCount === 0 ? 0 : (ctx.count / maxCount) * 160;
      const y = 260 - barHeight;
      return `
        <rect x="${x}" y="${y}" width="${barWidth}" height="${barHeight}" fill="#50E3C2" rx="6" />
        <text x="${x + barWidth / 2}" y="280" text-anchor="middle" font-size="12" fill="#F9FAFB">${ctx.name}</text>
        <text x="${x + barWidth / 2}" y="${y - 6}" text-anchor="middle" font-size="12" fill="#F9FAFB">${ctx.count}</text>
      `;
    })
    .join('');

  return `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" stop-color="#0f172a" />
      <stop offset="100%" stop-color="#1e1b4b" />
    </linearGradient>
  </defs>
  <rect width="100%" height="100%" fill="url(#bg)" rx="24" />
  <text x="50%" y="48" text-anchor="middle" font-size="24" font-weight="600" fill="#FDE68A">Mystic Tarot · Snapshot</text>
  <text x="50%" y="82" text-anchor="middle" font-size="14" fill="#E2E8F0">Entries: ${stats.totalReadings} · Cards: ${stats.totalCards} · Reversals: ${stats.reversalRate}%</text>
  <g>${bars}</g>
</svg>`;
}

export function downloadInsightsSvg(stats) {
  if (!stats || typeof document === 'undefined') return;
  const svgContent = buildSvg(stats);
  const blob = new Blob([svgContent], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = 'mystic-tarot-visual.svg';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
</file>

<file path="src/lib/questionQuality.js">
/**
 * Question Quality Scoring Utility
 *
 * Analyzes tarot questions and provides quality feedback to help users
 * craft more effective, open-ended questions.
 */

const YES_NO_PATTERNS = [
  /^(will|should|is|are|am|can|does|do)\b.*\?$/i,
  /\b(yes|no)\b.*\?$/i
];

const DETERMINISTIC_PATTERNS = [
  /\b(guaranteed|certain|destined|fated|inevitable|for\s+sure)\b/i,
  /\b(always|never|forever)\b.+\?/i,
  /\b(will|does)\s+(he|she|they|my|the)\s+(love|come back|return|stay|leave)\b/i
];

const VAGUE_WORDS = [
  'thing', 'stuff', 'something', 'someone', 'anything', 'everything',
  'things', 'issue', 'issues', 'situation', 'problem'
];

const CONCRETE_SUBJECTS = [
  'job', 'career', 'project', 'relationship', 'partner', 'friend', 'family',
  'health', 'home', 'study', 'business', 'team', 'work', 'money', 'finances', 'wellbeing'
];

const TIMEFRAME_WORDS = [
  'today', 'tonight', 'this week', 'this month', 'this year',
  'next week', 'next month', 'next year', 'soon', 'immediately',
  'short-term', 'long-term', 'over the next', 'coming weeks', 'coming months'
];

const REFLECTIVE_VERBS = [
  'how', 'what', 'where', 'when', 'which', 'who',
  'understand', 'explore', 'navigate', 'support', 'learn',
  'transform', 'honor', 'cultivate', 'embrace', 'integrate'
];

const AGENCY_VERBS = [
  'choose', 'shape', 'build', 'create', 'align', 'decide', 'strengthen',
  'clarify', 'balance', 'plan', 'adapt', 'respond', 'participate', 'work with'
];

/**
 * Score a question's quality across multiple dimensions
 * @param {string} question - The question to analyze
 * @returns {Object} Quality metrics and overall score
 */
export function scoreQuestion(question) {
  if (!question || typeof question !== 'string') {
    return {
      openEnded: false,
      specific: false,
      actionable: false,
      length: false,
      concreteSubject: false,
      timeframe: false,
      deterministicLanguage: false,
      score: 0,
      feedback: []
    };
  }

  const trimmed = question.trim();
  const wordCount = trimmed.split(/\s+/).length;

  // Check if question is open-ended (not yes/no)
  const isYesNo = YES_NO_PATTERNS.some(pattern => pattern.test(trimmed));
  const deterministicLanguage = DETERMINISTIC_PATTERNS.some(pattern => pattern.test(trimmed));
  const openEnded = !isYesNo && trimmed.endsWith('?');

  // Check specificity (not too vague, sufficient length)
  const hasVagueWords = VAGUE_WORDS.some(word =>
    new RegExp(`\\b${word}\\b`, 'i').test(trimmed)
  );
  const hasConcreteSubject = CONCRETE_SUBJECTS.some(word =>
    new RegExp(`\\b${word}\\b`, 'i').test(trimmed)
  );
  const specific = !hasVagueWords && wordCount >= 5 && wordCount <= 40;

  // Check if actionable (uses reflective verbs)
  const actionable = REFLECTIVE_VERBS.concat(AGENCY_VERBS).some(verb =>
    new RegExp(`\\b${verb}\\b`, 'i').test(trimmed)
  );

  // Check timeframe context
  const timeframe = TIMEFRAME_WORDS.some(word => trimmed.toLowerCase().includes(word));

  // Check length (not too short or too long) using words for softer grading
  const lengthIdeal = wordCount >= 8 && wordCount <= 30;
  const lengthAcceptable = wordCount >= 6 && wordCount <= 40;
  const length = lengthAcceptable;

  // Calculate overall score (0-100)
  const weights = {
    openEnded: 35,
    specific: 25,
    actionable: 25,
    length: 10,
    contextBonus: 5
  };

  const specificityScore = specific
    ? (hasConcreteSubject ? weights.specific : Math.round(weights.specific * 0.7))
    : (hasConcreteSubject ? Math.round(weights.specific * 0.4) : 0);

  const actionableScore = actionable
    ? weights.actionable
    : Math.round(weights.actionable * 0.35);

  const lengthScore = lengthIdeal
    ? weights.length
    : (lengthAcceptable ? Math.round(weights.length * 0.6) : 0);

  const contextBonus = timeframe ? weights.contextBonus : 0;

  const penalty = deterministicLanguage ? 10 : 0;

  const score = Math.max(0, Math.min(100, Math.round(
    (openEnded ? weights.openEnded : Math.round(weights.openEnded * 0.2)) +
    specificityScore +
    actionableScore +
    lengthScore +
    contextBonus -
    penalty
  )));

  // Generate feedback
  const feedback = [];
  if (!openEnded) {
    feedback.push('Try "How" or "What" instead of yes/no questions');
  }
  if (deterministicLanguage) {
    feedback.push('Avoid fate/guarantee wording and focus on guidance you can act on');
  }
  if (!specific && hasVagueWords) {
    feedback.push('Be more specific - what exactly are you exploring?');
  }
  if (specific && !hasConcreteSubject) {
    feedback.push('Name the person, role, or situation to ground the question');
  }
  if (!actionable) {
    feedback.push('Include agency-forward verbs like navigate, align, or cultivate');
  }
  if (!length && wordCount < 6) {
    feedback.push('Add more detail to your question');
  }
  if (!length && wordCount > 40) {
    feedback.push('Try to make your question more concise');
  }
  if (!timeframe) {
    feedback.push('Add a gentle timeframe to focus the reading (e.g., “this month”)');
  }

  return {
    openEnded,
    specific,
    actionable,
    length,
    concreteSubject: hasConcreteSubject,
    timeframe,
    deterministicLanguage,
    score,
    feedback,
    wordCount
  };
}

/**
 * Get a quality level label based on score
 * @param {number} score - Quality score (0-100)
 * @returns {Object} Level info
 */
export function getQualityLevel(score) {
  if (score >= 85) {
    return {
      label: 'Excellent',
      color: 'emerald',
      emoji: '✨'
    };
  }
  if (score >= 65) {
    return {
      label: 'Good',
      color: 'green',
      emoji: '👍'
    };
  }
  if (score >= 40) {
    return {
      label: 'Fair',
      color: 'amber',
      emoji: '💡'
    };
  }
  return {
    label: 'Needs work',
    color: 'orange',
    emoji: '🔧'
  };
}

/**
 * Get example of an improved version of the question
 * @param {string} question - Original question
 * @param {Object} quality - Quality metrics from scoreQuestion()
 * @returns {string|null} Suggested improvement or null
 */
export function suggestImprovement(question, quality) {
  if (!quality || quality.score >= 85) return null;

  const trimmed = question.trim().replace(/\?$/, '');

  // If yes/no, convert to open-ended
  if (!quality.openEnded) {
    if (/^(will|should|is|are|can)/i.test(trimmed)) {
      return `How can I ${trimmed.replace(/^(will|should|is|are|can)\s+/i, '')}?`;
    }
  }

  // If too vague, suggest adding detail
  if (!quality.specific) {
    return 'Try adding specific details about the situation or timeframe';
  }

  return null;
}
</file>

<file path="src/lib/textUtils.js">
/**
 * Text formatting utilities
 */

/**
 * Converts a string to title case, capitalizing the first letter after
 * word boundaries (spaces, hyphens).
 * @param {string} text - The text to convert
 * @returns {string} The text in title case
 * @example
 * titleCase('the high priestess') // 'The High Priestess'
 * titleCase('two-of-wands') // 'Two-Of-Wands'
 */
export const titleCase = (text = '') =>
  text.replace(/(^|\s|-)([a-z])/g, (_, boundary, char) => `${boundary}${char.toUpperCase()}`);
</file>

<file path="src/lib/themeText.js">
/**
 * Utilities for shaping narrative theme strings into concise,
 * user-friendly labels/questions for the intention coach.
 */

/**
 * Normalize verbose theme sentences (e.g., narrative summaries)
 * into short labels that read cleanly inside questions and chips.
 *
 * @param {string} theme - Raw theme text from journal stats or spread analysis
 * @returns {string} Concise label (or empty string if input is invalid)
 */
export function normalizeThemeLabel(theme) {
  if (!theme || typeof theme !== 'string') return '';

  const trimmed = theme.trim().replace(/[。.]+$/, '');
  const lower = trimmed.toLowerCase();

  // Major Arcana density phrases
  if (lower.startsWith('high major arcana')) {
    return 'High Major Arcana (soul-level shifts)';
  }
  if (lower.startsWith('moderate major arcana')) {
    return 'Moderate Major Arcana (archetypal lessons in daily life)';
  }
  if (lower.startsWith('primarily minor arcana')) {
    return 'Primarily Minor Arcana (everyday dynamics)';
  }

  // Suit balance phrasing
  if (/^balanced focus between\s+/i.test(trimmed)) {
    const match = trimmed.match(/^balanced focus between\s+([^,]+),/i);
    const pair = match?.[1]?.replace(/\s+and\s+/i, ' & ');
    return pair ? `Balanced focus: ${pair}` : 'Balanced suit focus';
  }

  // Elemental balance phrasing
  if (/^balanced elemental presence/i.test(trimmed)) {
    return 'Balanced elemental presence';
  }
  if (/^mixed elemental energies/i.test(trimmed)) {
    return 'Mixed elemental energies';
  }

  const strongElementMatch = trimmed.match(/^strong\s+([a-z]+)\s+emphasis dominates/i);
  if (strongElementMatch) {
    return `${strongElementMatch[1]} emphasis`;
  }

  const dominatesMatch = trimmed.match(/^([a-z]+)\s+energy strongly dominates/i);
  if (dominatesMatch) {
    return `${dominatesMatch[1]} energy dominance`;
  }

  const leadsMatch = trimmed.match(/^([a-z]+)\s+leads/i);
  if (leadsMatch) {
    return `${leadsMatch[1]} leads`;
  }

  // Default: return a cleaned-up, unmodified string
  return trimmed;
}

/**
 * Build a concise, human-friendly intention question from a theme.
 *
 * @param {string} theme - Raw or normalized theme text
 * @returns {string} Question text or empty string if no theme provided
 */
export function buildThemeQuestion(theme) {
  const label = normalizeThemeLabel(theme);
  if (!label) return '';
  return ensureQuestionMark(`How can I explore ${label} more deeply`);
}

/**
 * Ensure the text ends with a question mark.
 *
 * @param {string} text
 * @returns {string}
 */
export function ensureQuestionMark(text) {
  if (!text) return '';
  const trimmed = text.trim();
  return trimmed.endsWith('?') ? trimmed : `${trimmed}?`;
}

/**
 * Build an LLM prompt + metadata payload to polish a theme-based question.
 *
 * @param {string} themeLabel - Already-normalized theme label
 * @param {Object} [options]
 * @param {string} [options.draftQuestion] - Current draft question
 * @param {string} [options.spreadName] - Spread suggestion (e.g., Three-Card Story)
 * @param {string} [options.topic] - Topic value (e.g., growth)
 * @param {string} [options.timeframe] - Timeframe value (e.g., month)
 * @param {string} [options.contextHint] - Recent journal context (e.g., love, career)
 * @param {number} [options.entryCount] - Journal entry count (for metadata only)
 * @returns {{prompt: string, metadata: Object}}
 */
export function buildThemePolishPrompt(themeLabel, options = {}) {
  const draft = options.draftQuestion || buildThemeQuestion(themeLabel);
  const spreadName = options.spreadName || 'Three-Card Story';
  const topic = options.topic || 'growth';
  const timeframe = options.timeframe || 'month';
  const contextHint = options.contextHint || null;
  const entryCount = typeof options.entryCount === 'number' ? options.entryCount : null;

  const instructions = [
    'Polish this tarot intention question to feel natural, invitational, and concise (12-18 words).',
    'Keep first-person agency, start with "How can I", avoid filler like "theme of".',
    'Honor the theme wording but make it readable in everyday language.',
    'Return only the final question text.'
  ].join(' ');

  const prompt = [
    instructions,
    `Theme label: "${themeLabel}".`,
    `Draft question: "${draft}".`,
    `Suggested spread: ${spreadName}.`,
    `Topic: ${topic}. Timeframe: ${timeframe}.`,
    contextHint ? `Recent journal context: ${contextHint}.` : '',
    entryCount ? `Journal entries observed: ${entryCount}.` : ''
  ].filter(Boolean).join(' ');

  const metadata = {
    mode: 'journal-theme-polish',
    theme: themeLabel,
    draft,
    spreadName,
    topic,
    timeframe,
    contextHint,
    entryCount
  };

  return { prompt, metadata };
}
</file>

<file path="src/pages/ShareReading.jsx">
import { useCallback, useEffect, useMemo, useState } from 'react';
import { Link, useParams } from 'react-router-dom';
import { SharedSpreadView } from '../components/share/SharedSpreadView.jsx';
import { CollaborativeNotesPanel } from '../components/share/CollaborativeNotesPanel.jsx';

function StatCard({ label, value, helper }) {
  return (
    <div className="rounded-2xl border border-secondary/30 bg-surface p-4 text-center">
      <p className="text-[0.65rem] uppercase tracking-[0.3em] text-primary">{label}</p>
      <p className="mt-2 text-2xl font-semibold text-main">{value}</p>
      {helper && <p className="mt-1 text-xs text-muted">{helper}</p>}
    </div>
  );
}

function MetaChip({ label }) {
  return (
    <span className="inline-flex items-center rounded-full border border-primary/30 px-3 py-2 min-h-[36px] text-xs text-primary">
      {label}
    </span>
  );
}

function deriveDefaultPosition(entry) {
  if (!entry || !Array.isArray(entry.cards) || entry.cards.length === 0) {
    return '';
  }
  return entry.cards[0].position || `Card 1`;
}

export default function ShareReading() {
  const { token } = useParams();
  const [shareData, setShareData] = useState(null);
  const [notes, setNotes] = useState([]);
  const [status, setStatus] = useState('loading');
  const [errorMessage, setErrorMessage] = useState('');
  const [selectedEntryIndex, setSelectedEntryIndex] = useState(0);
  const [activePosition, setActivePosition] = useState('');
  const [noteSubmitting, setNoteSubmitting] = useState(false);
  const [noteError, setNoteError] = useState('');
  const [copyState, setCopyState] = useState('');
  const [lastSyncedAt, setLastSyncedAt] = useState(null);
  const [mobileView, setMobileView] = useState('spread'); // 'spread' | 'notes'

  const fetchShare = useCallback(async () => {
    if (!token) return;
    setStatus('loading');
    setErrorMessage('');
    try {
      const response = await fetch(`/api/share/${token}`);
      if (!response.ok) {
        const payload = await response.json().catch(() => ({}));
        throw new Error(payload.error || 'Unable to load share link');
      }
      const payload = await response.json();
      setShareData(payload);
      setNotes(payload.notes || []);
      setSelectedEntryIndex(0);
      setLastSyncedAt(Date.now());
      setStatus('ready');
    } catch (error) {
      setErrorMessage(error.message || 'Unable to load share link');
      setStatus('error');
    }
  }, [token]);

  useEffect(() => {
    fetchShare();
  }, [fetchShare]);

  const refreshNotes = useCallback(async () => {
    try {
      const response = await fetch(`/api/share-notes/${token}`);
      if (!response.ok) {
        throw new Error('Unable to refresh notes');
      }
      const payload = await response.json();
      setNotes(payload.notes || []);
      setLastSyncedAt(Date.now());
      setNoteError('');
    } catch (error) {
      setNoteError(error.message || 'Unable to refresh notes');
    }
  }, [token]);

  useEffect(() => {
    if (!token) return;
    const interval = setInterval(() => {
      refreshNotes();
    }, 20000);
    return () => clearInterval(interval);
  }, [token, refreshNotes]);

  const activeEntry = useMemo(() => {
    if (!shareData?.entries || shareData.entries.length === 0) return null;
    const index = Math.min(selectedEntryIndex, shareData.entries.length - 1);
    return shareData.entries[index];
  }, [shareData, selectedEntryIndex]);

  useEffect(() => {
    const defaultPosition = deriveDefaultPosition(activeEntry);
    setActivePosition(defaultPosition);
  }, [activeEntry]);

  const stats = shareData?.stats;

  const copyShareLink = async () => {
    if (typeof window === 'undefined' || typeof navigator === 'undefined') return;
    try {
      await navigator.clipboard.writeText(window.location.href);
      setCopyState('Link copied');
    } catch {
      setCopyState('Clipboard unavailable');
    }
    setTimeout(() => setCopyState(''), 2500);
  };

  const handleAddNote = async ({ authorName, body, cardPosition }) => {
    setNoteSubmitting(true);
    setNoteError('');
    try {
      const response = await fetch(`/api/share-notes/${token}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ authorName, body, cardPosition })
      });
      if (!response.ok) {
        const payload = await response.json().catch(() => ({}));
        throw new Error(payload.error || 'Unable to save note');
      }
      const payload = await response.json();
      setNotes((previous) => [...previous, payload.note]);
      setLastSyncedAt(Date.now());
    } catch (error) {
      setNoteError(error.message || 'Unable to save note');
      throw error;
    } finally {
      setNoteSubmitting(false);
    }
  };

  const contexts = shareData?.meta?.contexts || [];
  const collaboration = shareData?.collaboration;

  if (status === 'loading') {
    return (
      <div className="flex min-h-screen items-center justify-center bg-main text-main">
        <div className="text-center">
          <div className="inline-block h-10 w-10 animate-spin rounded-full border-2 border-primary border-t-transparent" />
          <p className="mt-4 text-sm text-muted">Opening sacred space…</p>
        </div>
      </div>
    );
  }

  if (status === 'error') {
    return (
      <div className="flex min-h-screen items-center justify-center bg-main text-main">
        <div className="max-w-md rounded-3xl border border-error/40 bg-surface p-8 text-center shadow-2xl">
          <p className="text-lg font-serif text-error">{errorMessage}</p>
          <Link
            to="/"
            className="mt-5 inline-flex items-center justify-center rounded-full border border-primary/60 px-4 py-2 text-sm text-main hover:bg-primary/10"
          >
            Return to Tableu
          </Link>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-main text-main">
      <main className="mx-auto max-w-6xl px-4 py-8">
        <div className="rounded-3xl border border-secondary/40 bg-surface p-6 shadow-2xl">
          <div className="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
            <div>
              <p className="text-[0.65rem] uppercase tracking-[0.3em] text-primary">Shared reading</p>
              <h1 className="mt-1 text-3xl font-serif text-accent">
                {shareData?.title || (shareData?.scope === 'journal' ? 'Journal snapshot' : 'Reading transmission')}
              </h1>
              <p className="text-sm text-muted">
                Invite trusted friends to add their gentle insights. This page updates as new notes arrive.
              </p>
            </div>
            <div className="flex flex-col items-stretch gap-2 sm:flex-row">
              <button
                type="button"
                onClick={copyShareLink}
                className="inline-flex items-center justify-center rounded-full border border-primary/50 px-4 py-2 min-h-[44px] text-sm text-main hover:bg-primary/10 active:bg-primary/20 touch-manipulation transition"
              >
                Copy link
              </button>
              <button
                type="button"
                onClick={fetchShare}
                className="inline-flex items-center justify-center rounded-full border border-primary/50 px-4 py-2 min-h-[44px] text-sm text-main hover:bg-primary/10 active:bg-primary/20 touch-manipulation transition"
              >
                Refresh reading
              </button>
              <Link
                to="/"
                className="inline-flex items-center justify-center rounded-full border border-primary/50 px-4 py-2 min-h-[44px] text-sm text-main hover:bg-primary/10 active:bg-primary/20 touch-manipulation transition"
              >
                Start your reading
              </Link>
            </div>
          </div>
          {copyState && <p className="mt-2 text-xs text-primary">{copyState}</p>}

          <div className="mt-4 flex flex-wrap gap-2 text-xs text-muted">
            <MetaChip label={`Views ${shareData?.viewCount ?? 0}`} />
            {shareData?.meta?.entryCount && <MetaChip label={`${shareData.meta.entryCount} entries`} />}
            {shareData?.expiresAt && (
              <MetaChip label={`Expires ${new Date(shareData.expiresAt).toLocaleString()}`} />
            )}
            {collaboration?.noteCount ? <MetaChip label={`${collaboration.noteCount} shared notes`} /> : null}
            {contexts?.slice(0, 3).map((context) => (
              <MetaChip key={context.name} label={`${context.name} · ${context.count}`} />
            ))}
          </div>

          {stats && (
            <div className="mt-6 grid gap-3 sm:grid-cols-3">
              <StatCard label="Entries" value={stats.totalReadings} helper="Included in this share" />
              <StatCard label="Cards logged" value={stats.totalCards} helper={`${stats.reversalRate}% reversed`} />
              <StatCard
                label="Top context"
                value={stats.contextBreakdown?.[0]?.name || '—'}
                helper={stats.contextBreakdown?.[0] ? `${stats.contextBreakdown[0].count} pulls` : 'Mix of topics'}
              />
            </div>
          )}

          {shareData?.entries?.length > 1 && (
            <div className="mt-6 flex flex-wrap gap-2">
              {shareData.entries.map((entry, index) => (
                <button
                  key={entry.id}
                  type="button"
                  onClick={() => setSelectedEntryIndex(index)}
                  className={`inline-flex items-center justify-center rounded-full border px-4 py-2 min-h-[44px] text-xs uppercase tracking-[0.15em] touch-manipulation transition ${index === selectedEntryIndex
                    ? 'border-primary bg-primary/10 text-main'
                    : 'border-secondary text-muted hover:border-primary/50 active:bg-primary/5'
                    }`}
                >
                  {entry.spread || 'Reading'}
                </button>
              ))}
            </div>
          )}
        </div>

        {/* Mobile view toggle - only visible below lg breakpoint */}
        <div className="mt-6 lg:hidden" role="tablist" aria-label="View selection">
          <div className="flex rounded-xl bg-surface-muted/60 p-1 border border-secondary/20">
            <button
              type="button"
              role="tab"
              id="mobile-spread-tab"
              aria-selected={mobileView === 'spread'}
              aria-controls="mobile-spread-panel"
              tabIndex={mobileView === 'spread' ? 0 : -1}
              onClick={() => setMobileView('spread')}
              onKeyDown={(e) => {
                if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                  e.preventDefault();
                  setMobileView(mobileView === 'spread' ? 'notes' : 'spread');
                  document.getElementById(mobileView === 'spread' ? 'mobile-notes-tab' : 'mobile-spread-tab')?.focus();
                }
              }}
              className={`flex-1 rounded-lg px-4 py-3 min-h-[44px] text-sm font-semibold transition-all touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/70 ${
                mobileView === 'spread'
                  ? 'bg-surface shadow-sm border border-secondary/30 text-accent'
                  : 'text-muted hover:text-main'
              }`}
            >
              Spread
            </button>
            <button
              type="button"
              role="tab"
              id="mobile-notes-tab"
              aria-selected={mobileView === 'notes'}
              aria-controls="mobile-notes-panel"
              tabIndex={mobileView === 'notes' ? 0 : -1}
              onClick={() => setMobileView('notes')}
              onKeyDown={(e) => {
                if (e.key === 'ArrowRight' || e.key === 'ArrowLeft') {
                  e.preventDefault();
                  setMobileView(mobileView === 'spread' ? 'notes' : 'spread');
                  document.getElementById(mobileView === 'spread' ? 'mobile-notes-tab' : 'mobile-spread-tab')?.focus();
                }
              }}
              className={`flex-1 rounded-lg px-4 py-3 min-h-[44px] text-sm font-semibold transition-all touch-manipulation focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-primary/70 ${
                mobileView === 'notes'
                  ? 'bg-surface shadow-sm border border-secondary/30 text-accent'
                  : 'text-muted hover:text-main'
              }`}
            >
              Notes {notes.length > 0 && <span className="ml-1 text-xs text-primary">({notes.length})</span>}
            </button>
          </div>
        </div>

        {/* Mobile: tabbed panels */}
        <div className="mt-4 lg:hidden">
          <div
            id="mobile-spread-panel"
            role="tabpanel"
            aria-labelledby="mobile-spread-tab"
            hidden={mobileView !== 'spread'}
          >
            {mobileView === 'spread' && (
              <div className="rounded-3xl border border-secondary/30 bg-surface-muted p-5">
                <div className="flex flex-col gap-1">
                  <p className="text-[0.65rem] uppercase tracking-[0.3em] text-primary">Spread overview</p>
                  <h2 className="text-2xl font-serif text-accent">{activeEntry?.spread}</h2>
                  {activeEntry?.question && (
                    <p className="text-sm text-muted">Intention: {activeEntry.question}</p>
                  )}
                  <p className="text-xs text-muted">
                    {activeEntry?.ts ? new Date(activeEntry.ts).toLocaleString() : ''}
                  </p>
                </div>
                <SharedSpreadView
                  entry={activeEntry}
                  notes={notes}
                  selectedPosition={activePosition}
                  onSelectPosition={setActivePosition}
                />
              </div>
            )}
          </div>
          <div
            id="mobile-notes-panel"
            role="tabpanel"
            aria-labelledby="mobile-notes-tab"
            hidden={mobileView !== 'notes'}
          >
            {mobileView === 'notes' && (
              <CollaborativeNotesPanel
                notes={notes}
                cards={activeEntry?.cards || []}
                onSubmit={handleAddNote}
                onRefresh={refreshNotes}
                isSubmitting={noteSubmitting}
                error={noteError}
                selectedPosition={activePosition}
                onSelectedPositionChange={setActivePosition}
                lastSyncedAt={lastSyncedAt}
              />
            )}
          </div>
        </div>

        {/* Desktop: side-by-side grid layout */}
        <div className="mt-8 hidden lg:grid lg:grid-cols-[2fr,1fr] gap-6">
          <div className="space-y-6">
            <div className="rounded-3xl border border-secondary/30 bg-surface-muted p-5">
              <div className="flex flex-col gap-1">
                <p className="text-[0.65rem] uppercase tracking-[0.3em] text-primary">Spread overview</p>
                <h2 className="text-2xl font-serif text-accent">{activeEntry?.spread}</h2>
                {activeEntry?.question && (
                  <p className="text-sm text-muted">Intention: {activeEntry.question}</p>
                )}
                <p className="text-xs text-muted">
                  {activeEntry?.ts ? new Date(activeEntry.ts).toLocaleString() : ''}
                </p>
              </div>
              <SharedSpreadView
                entry={activeEntry}
                notes={notes}
                selectedPosition={activePosition}
                onSelectPosition={setActivePosition}
              />
            </div>
          </div>
          <CollaborativeNotesPanel
            notes={notes}
            cards={activeEntry?.cards || []}
            onSubmit={handleAddNote}
            onRefresh={refreshNotes}
            isSubmitting={noteSubmitting}
            error={noteError}
            selectedPosition={activePosition}
            onSelectedPositionChange={setActivePosition}
            lastSyncedAt={lastSyncedAt}
          />
        </div>
      </main>
    </div>
  );
}
</file>

<file path="src/styles/tailwind.css">
/* Pull Tableu custom styles into the generated bundle */
@import './theme.css';
@import './tarot.css';

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Modern Mystic theme overrides */
body {
  @apply bg-main text-main antialiased;
}

/* Shared surface styling for cards / panels */
.modern-surface {
  @apply bg-surface backdrop-blur-xl border border-secondary rounded-2xl shadow-xl;
}

/* Journal-specific typography helpers */
.journal-page {
  font-feature-settings: 'liga' 1, 'clig' 1, 'kern' 1;
  text-rendering: optimizeLegibility;
}

@supports (text-wrap: balance) {
  .journal-page h1,
  .journal-page h2,
  .journal-page h3,
  .journal-page h4 {
    text-wrap: balance;
  }
}

.journal-prose {
  font-size: clamp(0.95rem, 0.92rem + 0.25vw, 1.05rem);
  line-height: 1.85;
  letter-spacing: 0.01em;
  color: var(--text-muted-high);
  text-wrap: pretty;
}

@supports not (text-wrap: pretty) {
  .journal-prose {
    overflow-wrap: anywhere;
  }
}

.journal-prose strong {
  color: var(--text-main);
}

.journal-quote {
  font-family: 'Ibarra Real Nova', 'Georgia', serif;
  font-size: clamp(1.1rem, 1.02rem + 0.3vw, 1.35rem);
  line-height: 1.9;
  color: var(--text-main);
  font-style: italic;
  text-wrap: balance;
}

.journal-eyebrow {
  font-size: 0.7rem;
  font-weight: 600;
  letter-spacing: 0.3em;
  text-transform: uppercase;
  color: var(--text-muted-high);
}
</file>

<file path="src/styles/tarot.css">
/* ==========================================================================
   TAROT.CSS - Mystic Tarot Application Styles
   ==========================================================================

   This file contains all custom styles for the Mystic Tarot application,
   organized into logical sections. Uses CSS custom properties for theming
   and responsive breakpoints optimized for modern iPhones (15-17 series).

   TABLE OF CONTENTS
   -----------------
   1. CSS Variables Documentation
   2. Global Mobile Optimizations
   3. Header System
   4. Safe Area Support
   5. Spread Patterns Panel
   6. Celtic Cross Grid
   7. Spread Selector Cards
   8. Tarot Card Shell & Faces
   9. Form Controls
   10. Landscape Handling
   11. Deck/Drawer Panels
   12. Deck Ritual Animations
   13. Reduced Motion Support
   14. Utility Classes

   ========================================================================== */

/* ==========================================================================
   1. CSS VARIABLES DOCUMENTATION
   ==========================================================================

   Variables are defined in multiple locations:
   - Theme variables: Tailwind config (tailwind.config.js) → CSS variables
   - Component variables: Defined inline on components
   - Local variables: Defined in :root below

   THEME VARIABLES (from Tailwind/theme)
   -------------------------------------
   These are injected by Tailwind and should be defined in your theme config:

   --brand-primary        : Primary brand color (gold/amber tones)
   --brand-secondary      : Secondary brand color (purple/violet tones)
   --brand-accent         : Accent color for highlights and CTAs

   --bg-main              : Main background color (dark charcoal)
   --bg-surface           : Surface/card background (slightly lighter)
   --bg-surface-muted     : Muted surface for subtle contrast

   --text-main            : Primary text color (off-white/cream)
   --text-muted           : Secondary/muted text color
   --text-accent          : Accent text for emphasis

   --color-wands          : Wands suit color (warm gold)
   --color-cups           : Cups suit color (cool silver-blue)
   --color-swords         : Swords suit color (steel gray)
   --color-pentacles      : Pentacles suit color (muted sage/green)

   --focus-ring-color     : Focus indicator color for accessibility
   --halo-star-color      : Glow effect color for card backs

   --status-success       : Success state color
   --status-error         : Error state color

   LOCAL VARIABLES (defined in :root)
   ----------------------------------
   Panel colors: --panel-dark-1, --panel-dark-2, --panel-dark-3
   Glow effects: --glow-gold, --glow-blue, --glow-pink
   Borders:      --border-warm, --border-warm-light, --border-warm-subtle
   Drawer:       --drawer-gold, --drawer-gold-{70,38,32,28,18,16}
   Color-mix fallbacks: --accent-{25,45,55,65}, --primary-{20,30,60}
                        --surface-{88,92}, --main-45

   ANIMATION TIMING SCALE
   ----------------------
   --duration-fast   : 160ms (hover, focus)
   --duration-normal : 200ms (standard transitions)
   --duration-medium : 260ms (card transforms)
   --duration-slow   : 400ms (complex animations)
   --duration-slower : 600ms (card dealing)
   --ease-out        : cubic-bezier(0.4, 0, 0.2, 1)

   Z-INDEX SCALE
   -------------
   --z-base          : 0  (default)
   --z-content       : 1  (above pseudo-elements)
   --z-dropdown      : 10 (tooltips)
   --z-sticky        : 20 (sticky headers)
   --z-fixed         : 50 (fixed elements)
   --z-modal-backdrop: 60 (backdrops)
   --z-modal         : 70 (modals)
   --z-skip-link     : 80 (skip links)


   BREAKPOINT REFERENCE
   --------------------
   360px  : Very small screens (iPhone SE, older devices)
   400px  : iPhone 15/16 standard (393px viewport)
   440px  : iPhone Plus/Pro Max (430-440px viewport)
   479px  : Small mobile cutoff
   520px  : Mid-mobile threshold
   639px  : Tailwind 'sm' breakpoint boundary
   640px  : Tablet start (Tailwind 'sm')
   768px  : Tailwind 'md' breakpoint
   1024px : Tailwind 'lg' breakpoint (desktop)
   1366px : iPad Pro landscape

   ORIENTATION QUERIES
   -------------------
   (max-height: 500px) + landscape  : Cramped landscape phones
   (501-700px height) + landscape   : Standard landscape tablets

   ========================================================================== */

:root {
  /* -------------------------------------------------------------------------
     LIGHT MODE AMBIENT COLORS
     Used for subtle gradient overlays and ambient lighting effects
     ------------------------------------------------------------------------- */
  --light-ambient-top: #FEF4E9;   /* Warm cream - top of gradients */
  --light-ambient-mid: #F2EEFF;   /* Soft lavender - middle tones */
  --light-ambient-base: #E7FFF5;  /* Cool mint - base/bottom */

  /* -------------------------------------------------------------------------
     SUIT ACCENT COLORS (Minor Arcana)
     Each suit has a primary accent and a soft (25% opacity) variant
     These reference --color-* variables from the theme
     ------------------------------------------------------------------------- */
  --wands-accent: var(--color-wands);           /* Warm gold - fire element */
  --cups-accent: var(--color-cups);             /* Cool silver-blue - water element */
  --swords-accent: var(--color-swords);         /* Steel gray - air element */
  --pentacles-accent: var(--color-pentacles);   /* Muted sage - earth element */

  /* Soft variants - fallbacks for browsers without color-mix() support */
  --wands-accent-soft: rgba(212, 175, 55, 0.25);
  --cups-accent-soft: rgba(176, 196, 222, 0.25);
  --swords-accent-soft: rgba(119, 136, 153, 0.25);
  --pentacles-accent-soft: rgba(143, 188, 143, 0.25);

  /* -------------------------------------------------------------------------
     COMMON COLOR-MIX FALLBACKS
     Pre-computed rgba values for browsers without color-mix() support
     ------------------------------------------------------------------------- */
  --accent-25: rgba(212, 184, 150, 0.25);       /* brand-accent at 25% */
  --accent-45: rgba(212, 184, 150, 0.45);       /* brand-accent at 45% */
  --accent-55: rgba(212, 184, 150, 0.55);       /* brand-accent at 55% */
  --accent-65: rgba(212, 184, 150, 0.65);       /* brand-accent at 65% */
  --primary-20: rgba(212, 184, 150, 0.20);      /* brand-primary at 20% */
  --primary-30: rgba(212, 184, 150, 0.30);      /* brand-primary at 30% */
  --primary-60: rgba(212, 184, 150, 0.60);      /* brand-primary at 60% */
  --surface-88: rgba(21, 18, 31, 0.88);         /* bg-surface at 88% */
  --surface-92: rgba(21, 18, 31, 0.92);         /* bg-surface at 92% */
  --main-45: rgba(13, 10, 20, 0.45);            /* bg-main at 45% */

  /* -------------------------------------------------------------------------
     PANEL BACKGROUND COLORS
     Dark gradient tones used in mystic panels
     ------------------------------------------------------------------------- */
  --panel-dark-1: #0d0a14;                      /* Darkest panel tone */
  --panel-dark-2: #151020;                      /* Mid panel tone */
  --panel-dark-3: #0f0b17;                      /* Alternative dark tone */

  /* -------------------------------------------------------------------------
     MYSTIC GLOW COLORS
     Warm and cool accent overlays for ambient effects
     ------------------------------------------------------------------------- */
  --glow-gold: rgba(244, 207, 150, 0.1);        /* Warm gold glow */
  --glow-blue: rgba(120, 161, 255, 0.08);       /* Cool blue glow */
  --glow-pink: rgba(255, 132, 178, 0.07);       /* Soft pink glow */

  /* -------------------------------------------------------------------------
     BORDER & ACCENT COLORS
     Warm cream/gold border tones
     ------------------------------------------------------------------------- */
  --border-warm: rgba(232, 218, 195, 0.22);     /* Standard warm border */
  --border-warm-light: rgba(232, 218, 195, 0.2); /* Light warm border */
  --border-warm-subtle: rgba(232, 218, 195, 0.06); /* Subtle warm border */

  /* -------------------------------------------------------------------------
     DRAWER/COMPONENT ACCENT
     Gold accent for drawers and interactive elements
     ------------------------------------------------------------------------- */
  --drawer-gold: #e5c48e;                       /* Drawer accent gold */
  --drawer-gold-70: rgba(229, 196, 142, 0.70);  /* 70% drawer gold */
  --drawer-gold-38: rgba(229, 196, 142, 0.38);  /* 38% drawer gold */
  --drawer-gold-32: rgba(229, 196, 142, 0.32);  /* 32% drawer gold */
  --drawer-gold-28: rgba(229, 196, 142, 0.28);  /* 28% drawer gold */
  --drawer-gold-18: rgba(229, 196, 142, 0.18);  /* 18% drawer gold */
  --drawer-gold-16: rgba(229, 196, 142, 0.16);  /* 16% drawer gold */

  /* -------------------------------------------------------------------------
     ANIMATION TIMING SCALE
     Standardized durations for consistent motion design
     ------------------------------------------------------------------------- */
  --duration-fast: 160ms;                       /* Quick interactions (hover, focus) */
  --duration-normal: 200ms;                     /* Standard transitions */
  --duration-medium: 260ms;                     /* Card transforms, reveals */
  --duration-slow: 400ms;                       /* Complex animations */
  --duration-slower: 600ms;                     /* Card dealing, major reveals */

  /* Standard easing functions */
  --ease-out: cubic-bezier(0.4, 0, 0.2, 1);    /* Material Design standard */
  --ease-in-out: ease-in-out;                   /* Symmetric transitions */

  /* -------------------------------------------------------------------------
     Z-INDEX SCALE
     Layering system for consistent stacking contexts
     ------------------------------------------------------------------------- */
  --z-base: 0;                                  /* Default layer */
  --z-content: 1;                               /* Content above pseudo-elements */
  --z-dropdown: 10;                             /* Dropdowns and tooltips */
  --z-sticky: 20;                               /* Sticky headers */
  --z-fixed: 50;                                /* Fixed positioning */
  --z-modal-backdrop: 60;                       /* Modal/drawer backdrops */
  --z-modal: 70;                                /* Modals and drawers */
  --z-skip-link: 80;                            /* Skip links (highest) */
}

/* Override soft variants with color-mix() for modern browsers */
@supports (color: color-mix(in srgb, red 50%, blue)) {
  :root {
    --wands-accent-soft: color-mix(in srgb, var(--wands-accent) 25%, transparent);
    --cups-accent-soft: color-mix(in srgb, var(--cups-accent) 25%, transparent);
    --swords-accent-soft: color-mix(in srgb, var(--swords-accent) 25%, transparent);
    --pentacles-accent-soft: color-mix(in srgb, var(--pentacles-accent) 25%, transparent);
  }
}

/* ==========================================================================
   COMPONENT-SPECIFIC VARIABLES REFERENCE
   ==========================================================================

   These variables are defined inline on components and can be overridden:

   SPREAD CARDS (.spread-card)
   ---------------------------
   --spread-card-height-mobile  : Card height on mobile (default: 18rem)
   --spread-card-height-desktop : Card height on desktop (default: 22rem)
   --spread-background          : Card background color (default: #15121f)
   --spread-border              : Card border color (default: rgba(255,255,255,0.08))
   --spread-accent              : Accent color for glows (default: #d4b896)
   --spread-glow                : Box-shadow glow color

   DECK CARDS (.deck-card)
   -----------------------
   --deck-background            : Card background color
   --deck-border                : Card border color
   --deck-accent                : Accent color for glows
   --deck-glow                  : Box-shadow glow color
   --deck-shadow-color          : Shadow color for deck ritual

   MOBILE DRAWER (.mobile-drawer)
   ------------------------------
   --drawer-accent              : Accent color (default: #e5c48e)
   --drawer-border              : Border color at 28% opacity
   --drawer-border-strong       : Border color at 72% opacity
   --drawer-glow                : Glow effect at 32% opacity

   PREPARE CARD (.prepare-card)
   ----------------------------
   --prepare-accent             : Accent color (default: #e5c48e)

   CARD DEAL ANIMATION
   -------------------
   --deal-x                     : Horizontal deal offset (default: 100px)
   --deal-y                     : Vertical deal offset (default: -50px)
   --deal-end-x                 : Final horizontal position (default: 200px)
   --deal-end-y                 : Final vertical position (default: 100px)

   ========================================================================== */

/* ==========================================================================
   2. GLOBAL MOBILE OPTIMIZATIONS
   ========================================================================== */

/* Global mobile optimizations */
body {
  overflow-x: hidden;
  /* Prevent horizontal scroll on mobile */
}

/* Mobile typography improvements for readability */
@media (max-width: 639px) {
  /* Increase base text size on mobile for better readability */
  body {
    font-size: 1rem; /* 16px base */
  }

  /* Ensure paragraph text is comfortable to read */
  p, li, dd {
    font-size: 0.9375rem; /* 15px */
    line-height: 1.6;
  }

  /* Slightly larger form elements on mobile */
  input, textarea, select {
    font-size: 1rem; /* 16px - prevents iOS zoom on focus */
  }

  /* Larger link/button text for easier tapping */
  button, a {
    font-size: inherit;
  }
}

.app-shell {
  padding-bottom: 1.5rem;
}

.skip-links {
  position: relative;
  z-index: var(--z-skip-link, 80);
  display: flex;
  flex-direction: column;
  gap: 0.35rem;
  padding-left: 0.5rem;
  height: 0;
}

.skip-link {
  position: absolute;
  left: 0;
  top: 0.35rem;
  transform: translateY(-150%);
  opacity: 0;
  padding: 0.7rem 1rem;
  border-radius: 999px;
  border: 2px solid var(--brand-accent);
  background: var(--surface-88, rgba(21, 18, 31, 0.88));
  color: var(--text-main);
  font-weight: 600;
  box-shadow: 0 12px 32px var(--accent-25, rgba(212, 184, 150, 0.25));
  transition: transform var(--duration-fast, 180ms) ease, opacity var(--duration-fast, 180ms) ease;
}

@supports (color: color-mix(in srgb, red 50%, blue)) {
  .skip-link {
    background: color-mix(in srgb, var(--bg-surface) 88%, var(--bg-main));
    box-shadow: 0 12px 32px color-mix(in srgb, var(--brand-accent) 25%, transparent);
  }
}

.skip-link:focus-visible {
  transform: translateY(0);
  opacity: 1;
}

.pb-safe {
  padding-bottom: 1rem;
}

.full-bleed {
  width: 100vw;
  margin-left: calc(50% - 50vw);
  margin-right: calc(50% - 50vw);
}

.header-condensed .mystic-heading-wrap {
  transition: transform 200ms ease, opacity 200ms ease;
}

.header-sticky {
  position: sticky;
  transition: transform 260ms ease, padding 200ms ease, opacity 200ms ease;
}

.header-sticky--compact {
  padding-top: 0.35rem !important;
  padding-bottom: 0.35rem !important;
  box-shadow: 0 10px 20px var(--main-45, rgba(13, 10, 20, 0.45));
}

@supports (color: color-mix(in srgb, red 50%, blue)) {
  .header-sticky--compact {
    box-shadow: 0 10px 20px color-mix(in srgb, var(--bg-main) 45%, transparent);
  }
}

.header-sticky--compact .header-sticky__row {
  gap: 0.75rem;
}

.header-sticky--hidden {
  transform: translateY(-110%);
  opacity: 0;
  pointer-events: none;
}

.header-sticky__row {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1.5rem;
  position: relative;
}

.header-sticky__nav {
  flex: 1;
  display: flex;
  justify-content: center;
  /* Balance padding to keep nav centered while making room for UserMenu */
  /* Reduced for mobile to prevent overflow */
  padding-left: 2.5rem;
  padding-right: 2.5rem;
}

@media (min-width: 400px) {
  .header-sticky__nav {
    padding-left: 4rem;
    padding-right: 4rem;
  }
}

@media (min-width: 640px) {
  .header-sticky__nav {
    padding-left: 6rem;
    padding-right: 6rem;
  }
}

.header-sticky__user {
  transition: opacity 200ms ease, transform 200ms ease;
  position: absolute;
  /* Account for safe area on notched devices */
  right: max(0.25rem, env(safe-area-inset-right, 0px));
  top: 50%;
  transform: translateY(-50%);
}

.header-sticky--compact .header-sticky__user {
  /* Keep user menu accessible in compact mode - UserMenu handles condensed display */
  opacity: 1;
  transform: translateY(-50%);
  pointer-events: auto;
}

.header-sticky__status {
  margin-top: 0.5rem;
}

/* Tableu logo styling */
.tableu-logo {
  display: block;
  color: var(--brand-primary);
  overflow: visible;
}

.tableu-logo--outline .t-fill,
.tableu-logo--outline .t-fill-stroke {
  fill: transparent;
}

.tableu-logo--outline .t-fill-stroke,
.tableu-logo--outline .t-stroke,
.tableu-logo--outline .t-fill {
  stroke: currentColor;
}

.tableu-logo--glow {
  filter:
    drop-shadow(0 0 10px rgba(212, 184, 150, 0.5))
    drop-shadow(0 0 22px rgba(212, 184, 150, 0.3));
}

@supports (color: color-mix(in srgb, red 50%, blue)) {
  .tableu-logo--glow {
    filter:
      drop-shadow(0 0 10px color-mix(in srgb, currentColor 50%, transparent))
      drop-shadow(0 0 22px color-mix(in srgb, currentColor 30%, transparent));
  }
}

/* Light ambient colors defined in main :root block at top of file */

@supports (padding: max(0px)) {
  .app-shell {
    padding-bottom: max(1.5rem, env(safe-area-inset-bottom, 1.5rem));
  }

  .pb-safe {
    padding-bottom: max(1rem, env(safe-area-inset-bottom, 1rem));
  }
}

.mobile-action-bar {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: var(--z-modal-backdrop, 60);
  padding: 0.75rem 1rem 1rem;
  background: var(--bg-surface);
  backdrop-filter: blur(18px);
  border-top: 1px solid var(--accent-65, rgba(212, 184, 150, 0.65));
  transition: bottom var(--duration-fast, 180ms) ease-out;
}

.mobile-action-group {
  padding: 0.5rem 0 0.25rem;
  background: var(--bg-surface);
  border-top: 1px solid rgba(212, 184, 150, 0.20);
  box-shadow: 0 -18px 40px rgba(0, 0, 0, 0.35);
}

.mobile-drawer__footer {
  padding: 0.75rem 1rem 1rem;
  background: var(--surface-92, rgba(21, 18, 31, 0.92));
  border-top: 1px solid rgba(212, 184, 150, 0.22);
  box-shadow: 0 -18px 32px rgba(0, 0, 0, 0.4);
}

@supports (color: color-mix(in srgb, red 50%, blue)) {
  .mobile-action-bar {
    border-top: 1px solid color-mix(in srgb, var(--brand-accent) 65%, transparent);
  }

  .mobile-action-group {
    border-top: 1px solid color-mix(in srgb, var(--brand-accent) 20%, transparent);
  }

  .mobile-drawer__footer {
    background: color-mix(in srgb, var(--bg-surface) 92%, transparent);
    border-top: 1px solid color-mix(in srgb, var(--brand-accent) 22%, transparent);
  }
}

@supports (padding: max(0px)) {
  .mobile-drawer__footer {
    padding-bottom: max(1rem, calc(1rem + env(safe-area-inset-bottom, 0rem)));
  }
}

@supports (padding: max(0px)) {
  .mobile-action-bar {
    padding-bottom: max(1rem, calc(0.75rem + env(safe-area-inset-bottom, 0.5rem)));
  }
}

/* Landscape mode safeguards for small mobile devices */
@media (max-height: 500px) and (orientation: landscape) {
  /* Compact mobile action bar in landscape */
  .mobile-action-bar {
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
  }

  @supports (padding: max(0px)) {
    .mobile-action-bar {
      padding-bottom: max(0.5rem, env(safe-area-inset-bottom, 0.5rem));
    }
  }

  /* Compact header in cramped landscape */
  .header-sticky {
    padding-top: 0.25rem !important;
    padding-bottom: 0.25rem !important;
  }

  .header-sticky__row {
    gap: 0.5rem;
  }

  /* Reduce spacing between content sections */
  .app-shell {
    padding-bottom: 0.75rem;
  }

  /* Smaller deck pile in landscape */
  .deck-pile {
    transform: scale(0.85);
    transform-origin: center;
  }
}

/* Light mode: Additional styles can be added here when implementing light mode support */

.spread-patterns-panel {
  margin-top: 1.5rem;
  background: radial-gradient(circle at top, var(--brand-secondary), transparent) var(--bg-surface);
  border-radius: 1.25rem;
  box-shadow: 0 25px 50px -12px var(--brand-secondary);
}

.spread-patterns-panel .pattern-list {
  display: flex;
  flex-direction: column;
  list-style: none;
  gap: 1rem;
  padding: 0;
  margin: 0;
}

.spread-patterns-panel .pattern {
  display: flex;
  gap: 1rem;
  align-items: flex-start;
}

.spread-patterns-panel .pattern-icon {
  width: 2.75rem;
  height: 2.75rem;
  border-radius: 9999px;
  border: 1px solid var(--brand-accent);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  font-size: 1.25rem;
  background: var(--brand-secondary);
  color: var(--brand-accent);
  opacity: 0.9;
}

.spread-patterns-panel .pattern-text {
  color: var(--text-main);
  line-height: 1.5;
  font-size: 0.95rem;
}

.spread-patterns-panel .pattern-text p {
  margin: 0;
}

/* Celtic Cross grid layout */
.cc-grid {
  display: grid;
  grid-template-areas:
    ". past above ."
    "left present challenge right"
    ". below future ."
    ". advice external ."
    ". hopesfears outcome .";
  grid-template-columns: repeat(4, minmax(0, 1fr));
  gap: 1.5rem;
}

/* Position areas */
.cc-present {
  grid-area: present;
}

.cc-challenge {
  grid-area: challenge;
}

.cc-past {
  grid-area: past;
}

.cc-future {
  grid-area: future;
}

.cc-above {
  grid-area: above;
}

.cc-below {
  grid-area: below;
}

.cc-advice {
  grid-area: advice;
}

.cc-external {
  grid-area: external;
}

.cc-left {
  grid-area: left;
}

.cc-right {
  grid-area: right;
}

/* ==========================================================================
   SHARED PANEL BASE STYLES
   Used by spread-selector-panel, deck-selector-panel, and similar panels
   ========================================================================== */
.panel-mystic {
  --panel-noise-opacity: 0.28;
  position: relative;
  overflow: hidden;
  border-radius: 1.6rem;
  padding: 1rem;
  background:
    radial-gradient(circle at 0% 18%, var(--glow-gold), transparent 40%),
    radial-gradient(circle at 100% 0%, var(--glow-blue), transparent 38%),
    radial-gradient(circle at 52% 115%, var(--glow-pink), transparent 46%),
    linear-gradient(135deg, var(--panel-dark-1), var(--panel-dark-2) 55%, var(--panel-dark-3));
  border: 1px solid var(--border-warm);
  box-shadow: 0 24px 64px -40px rgba(0, 0, 0, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.03);
}

@media (min-width: 640px) {
  .panel-mystic {
    padding: 1.35rem;
  }
}

@media (min-width: 1024px) {
  .panel-mystic {
    padding: 1.6rem;
  }
}

.panel-mystic::before {
  content: '';
  position: absolute;
  inset: 8px;
  border-radius: 1.25rem;
  border: 1px solid rgba(255, 255, 255, 0.03);
  box-shadow:
    0 0 0 1px rgba(255, 255, 255, 0.02),
    inset 0 0 60px var(--border-warm-subtle);
  pointer-events: none;
}

.panel-mystic::after {
  content: '';
  position: absolute;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='200' viewBox='0 0 200 200'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23n)' opacity='0.22'/%3E%3C/svg%3E");
  mix-blend-mode: soft-light;
  opacity: var(--panel-noise-opacity, 0.28);
  pointer-events: none;
}

/* Spread selector - extends .panel-mystic */
.spread-selector-panel {
  /* Inherits all styles from .panel-mystic when used with that class */
  /* Specific overrides can be added here */
}

/* Note: Apply class="panel-mystic spread-selector-panel" in HTML */

.spread-selector-grid {
  scroll-padding-left: 0.5rem;
  scroll-padding-right: 0.5rem;
  align-items: stretch;
}

@media (min-width: 640px) {
  .spread-selector-grid {
    grid-auto-rows: 1fr;
  }
}

.spread-card {
  position: relative;
  overflow: hidden;
  isolation: isolate;
  border-radius: 1.35rem;
  padding: 1rem 1.15rem 1.35rem;
  --spread-card-height-mobile: 18rem;
  --spread-card-height-desktop: 22rem;
  /* Mobile: flexible min-height for carousel - reduced from 23rem for better viewport fit */
  min-height: var(--spread-card-height-mobile, 18rem);
  max-height: calc(100vh - 10rem);
  max-height: calc(100svh - 10rem);
  background: var(--spread-background, #15121f);
  border: 1px solid var(--spread-border, rgba(255, 255, 255, 0.08));
  box-shadow: 0 18px 36px -24px rgba(0, 0, 0, 0.85), inset 0 1px 0 rgba(255, 255, 255, 0.05);
  transition: transform 160ms ease, box-shadow 180ms ease, border-color 160ms ease;
}

@media (min-width: 640px) {
  .spread-card {
    /* Desktop: keep a comfortable baseline height but let content expand to avoid clipping */
    min-height: var(--spread-card-height-desktop);
    height: auto;
    max-height: none;
  }
}

/* iPhone Plus/Pro Max models (430-440px) */
@media (max-width: 440px) {
  .spread-card {
    --spread-card-height-mobile: 17rem;
  }
}

/* iPhone 15/16 standard (393px) and smaller */
@media (max-width: 400px) {
  .spread-card {
    --spread-card-height-mobile: 16rem;
    padding: 0.85rem 0.95rem 1.1rem;
  }

  .spread-card__title {
    font-size: 0.975rem;
  }

  .spread-card__description {
    font-size: 0.875rem;
  }
}

/* Very small screens (iPhone SE, older devices) */
@media (max-width: 360px) {
  .spread-card {
    --spread-card-height-mobile: 15rem;
    padding: 0.75rem 0.85rem 1rem;
  }

  .spread-card__title {
    font-size: 0.95rem;
  }

  .spread-card__description {
    font-size: 0.85rem;
  }

  .spread-card__meta {
    flex-wrap: wrap;
    row-gap: 0.35rem;
  }
}

/* Ultra-compact phones (<= 330px) */
@media (max-width: 330px) {
  .spread-card {
    --spread-card-height-mobile: 14.25rem;
    padding: 0.65rem 0.75rem 0.9rem;
  }

  .spread-card__title {
    font-size: 0.9rem;
  }

  .spread-card__description {
    font-size: 0.8rem;
  }

  .spread-card__meta {
    gap: 0.35rem;
  }
}

@media (max-height: 500px) and (orientation: landscape) {
  .spread-card {
    --spread-card-height-mobile: 12rem;
    max-height: calc(100vh - 6rem);
    max-height: calc(100svh - 6rem);
  }
}

.spread-card::before {
  content: '';
  position: absolute;
  inset: 0;
  background:
    radial-gradient(circle at 20% 18%, rgba(212, 184, 150, 0.35) 0%, transparent 52%),
    radial-gradient(circle at 80% 0%, rgba(212, 184, 150, 0.24) 0%, transparent 50%),
    linear-gradient(165deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0));
  opacity: 0.9;
  pointer-events: none;
  z-index: 0;
}

@supports (color: color-mix(in srgb, red 50%, blue)) {
  .spread-card::before {
    background:
      radial-gradient(circle at 20% 18%, color-mix(in srgb, var(--spread-accent, #d4b896) 35%, transparent) 0%, transparent 52%),
      radial-gradient(circle at 80% 0%, color-mix(in srgb, var(--spread-accent, #d4b896) 24%, transparent) 0%, transparent 50%),
      linear-gradient(165deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0));
  }
}

.spread-card::after {
  content: '';
  position: absolute;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='0.25'/%3E%3C/svg%3E");
  mix-blend-mode: soft-light;
  opacity: 0.25;
  pointer-events: none;
  z-index: 0;
}

.spread-card:hover {
  transform: translateY(-3px);
  border-color: rgba(212, 184, 150, 0.45);
  box-shadow: 0 24px 45px -28px rgba(0, 0, 0, 0.85), 0 8px 22px -18px var(--spread-glow, rgba(212, 184, 150, 0.35));
}

.spread-card--active {
  border-color: rgba(212, 184, 150, 0.65);
  box-shadow:
    0 28px 60px -30px var(--spread-glow, rgba(212, 184, 150, 0.45)),
    0 0 0 1px rgba(255, 255, 255, 0.08),
    inset 0 1px 0 rgba(255, 255, 255, 0.08);
  transform: translateY(-2px);
}

@supports (color: color-mix(in srgb, red 50%, blue)) {
  .spread-card:hover {
    border-color: color-mix(in srgb, var(--spread-accent, #d4b896) 45%, transparent);
  }

  .spread-card--active {
    border-color: color-mix(in srgb, var(--spread-accent, #d4b896) 65%, transparent);
  }
}

.spread-card__body {
  position: relative;
  z-index: 1;
  display: flex;
  flex-direction: column;
  flex: 1;
  min-height: 0;
}

.spread-card__title {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.5rem;
}

.spread-card__title-text {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 2;
  overflow: hidden;
  min-width: 0;
}

.spread-card__description {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 3;
  overflow: hidden;
}

.spread-card__preview {
  position: relative;
  overflow: hidden;
  border-radius: 1rem;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0.01));
  border: 1px solid rgba(255, 255, 255, 0.08);
  box-shadow:
    0 14px 28px -18px rgba(0, 0, 0, 0.55),
    inset 0 0 0 1px rgba(255, 255, 255, 0.02);
}

.spread-card__meta {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.5rem;
  flex-wrap: nowrap;
  margin-top: auto;
  padding-top: 0.75rem;
  border-top: 1px solid rgba(255, 255, 255, 0.05);
}

.spread-card__complexity {
  display: inline-flex;
  align-items: center;
  gap: 0.35rem;
  padding: 0.4rem 0.65rem;
  border-radius: 999px;
  border: 1px solid color-mix(in srgb, var(--spread-accent, #d4b896) 24%, transparent);
  background: rgba(13, 10, 18, 0.65);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
  font-size: 0.68rem;
  flex-shrink: 1;
  min-width: 0;
}

/* Hide "Complexity" label on mobile to save space - keep stars and level label */
@media (max-width: 639px) {
  .spread-card__complexity > span:first-child {
    display: none;
  }
}

.spread-card__count {
  display: flex;
  flex-direction: column;
  text-align: right;
  flex-shrink: 0;
}

/* Hide count label on mobile since it's redundant with the tag */
@media (max-width: 639px) {
  .spread-card__count > span:first-child {
    display: none;
  }
}

.spread-panel-footnote {
  margin-top: 0.6rem;
}

.cc-hopesfears {
  grid-area: hopesfears;
}

.cc-outcome {
  grid-area: outcome;
}

/* Responsive tuning:
 * - 0–639px: stacked single column
 * - 640–1023px (including tablets): balanced 3-column layout
 * - >=1024px: full 4-column desktop layout defined above
 */

/* Small screens: horizontal carousel for better focus */
@media (max-width: 639px) {
  .cc-grid {
    display: flex;
    overflow-x: auto;
    overflow-y: hidden;
    overscroll-behavior-inline: contain;
    scroll-snap-type: x mandatory;
    gap: 0.9rem;
    padding: 0 0.85rem 1.25rem;
    scroll-padding-inline: 0.85rem;
    /* Reset grid properties */
    grid-template-areas: none;
    grid-template-columns: none;
    /* Hide scrollbar for cleaner look but keep functionality */
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .cc-grid::-webkit-scrollbar {
    display: none;
  }

  .cc-grid>* {
    flex: 0 0 min(80vw, 18rem);
    /* Show majority of the card while hinting the next */
    width: min(80vw, 18rem);
    scroll-snap-align: center;
  }
}

/* iPhone Plus/Pro Max (430-440px) - slightly tighter carousel */
@media (max-width: 440px) {
  .cc-grid {
    gap: 0.85rem;
    padding: 0 0.75rem 1.2rem;
    scroll-padding-inline: 0.75rem;
  }

  .cc-grid>* {
    flex-basis: min(78vw, 17rem);
    width: min(78vw, 17rem);
  }
}

/* iPhone 15/16 standard (393px) */
@media (max-width: 400px) {
  .cc-grid {
    gap: 0.75rem;
    padding: 0 0.65rem 1.1rem;
    scroll-padding-inline: 0.65rem;
  }

  .cc-grid>* {
    flex-basis: min(76vw, 15.5rem);
    width: min(76vw, 15.5rem);
  }
}

/* Very small screens (iPhone SE, older devices) */
@media (max-width: 360px) {
  .cc-grid>* {
    flex-basis: min(72vw, 14rem);
    width: min(72vw, 14rem);
  }
}

@media (max-width: 330px) {
  .cc-grid {
    gap: 0.6rem;
    padding: 0 0.55rem 1rem;
    scroll-padding-inline: 0.55rem;
  }

  .cc-grid>* {
    flex-basis: min(70vw, 13.25rem);
    width: min(70vw, 13.25rem);
  }
}

/* Small tablets: balanced 2-column Celtic Cross */
@media (min-width: 640px) and (max-width: 767px) {
  .cc-grid {
    grid-template-columns: repeat(2, minmax(0, 1fr));
    grid-template-areas:
      "past     present"
      "future   challenge"
      "above    below"
      "advice   external"
      "hopesfears outcome";
    gap: 1.25rem;
    padding: 0 0.75rem;
  }
}

/* Large tablets: symmetric 3-column Celtic Cross */
@media (min-width: 768px) and (max-width: 1023px) {
  .cc-grid {
    grid-template-columns: repeat(3, minmax(0, 1fr));
    grid-template-areas:
      "past    present   future"
      "above   challenge below"
      "advice  external  hopesfears"
      "outcome outcome   outcome";
    gap: 1.4rem;
  }
}

/* Desktop / iPad Pro landscape: use full 4-column layout */
@media (min-width: 1024px) {
  .cc-grid {
    grid-template-areas:
      ". past above ."
      "left present challenge right"
      ". below future ."
      ". advice external ."
      ". hopesfears outcome .";
    grid-template-columns: repeat(4, minmax(0, 1fr));
    gap: 1.5rem;
  }
}

/* Focus visibility enhancements for keyboard users */
button:focus-visible,
[role='button']:focus-visible,
a:focus-visible,
input:focus-visible,
textarea:focus-visible {
  outline: 2px solid var(--focus-ring-color);
  /* slightly stronger accent for contrast */
  outline-offset: 3px;
}

/* Authentic tarot card styling inspired by classic decks like Rider–Waite–Smith.
   Uses symbolic backs and richer face layouts while remaining license-safe. */

/* Mobile-first: fluid sizing for cards and fonts */
.tarot-card-shell {
  position: relative;
  /* Fluid mobile-first sizing with consistent 2:3 aspect ratio */
  width: clamp(10.5rem, 60vw, 17rem);
  aspect-ratio: 2 / 3;
  height: auto;
  min-height: 0;
  /* Ensure readable minimum */
  border-radius: 0.9rem;
  border: 1px solid var(--brand-accent);
  background: radial-gradient(circle at 20% 0%, var(--brand-accent) 0, transparent 55%),
    radial-gradient(circle at 80% 100%, var(--brand-secondary) 0, transparent 55%),
    var(--bg-main);
  overflow: hidden;
  transform-origin: center center;
  transition: transform 260ms ease, box-shadow 260ms ease, background 260ms ease;
}

/* iPhone Plus/Pro Max (430-440px) */
@media (max-width: 440px) {
  .tarot-card-shell {
    width: clamp(10rem, 58vw, 14rem);
  }
}

/* iPhone 15/16 standard (393px) */
@media (max-width: 400px) {
  .tarot-card-shell {
    width: clamp(9.5rem, 62vw, 13rem);
  }
}

/* Very small screens (iPhone SE, older devices) */
@media (max-width: 360px) {
  .tarot-card-shell {
    width: clamp(8.75rem, 68vw, 11.5rem);
  }
}

/* Tablet card sizes with max-width cap */
@media (min-width: 640px) and (max-width: 1023px) {
  .tarot-card-shell {
    width: clamp(7rem, 18vw, 9rem);
  }
}

/* Desktop card sizes */
@media (min-width: 1024px) {
  .tarot-card-shell {
    width: 8.5rem;
  }
}

@supports not (aspect-ratio: 2 / 3) {
  .tarot-card-shell {
    height: clamp(15rem, 80vw, 25rem);
  }
}

.tarot-card-shell:hover {
  transform: translateY(-4px) scale(1.03);
  box-shadow:
    0 16px 40px var(--bg-surface),
    0 0 26px var(--brand-accent);
  /* subtle mystic glow */
}

/* Touch-friendly active state */
.tarot-card-shell:active {
  transform: translateY(-1px) scale(1.02);
  box-shadow:
    0 10px 24px var(--bg-surface),
    0 0 18px var(--brand-accent);
}

/* Performance: simplify shadows and backgrounds on mobile */
@media (max-width: 768px) {
  .tarot-card-shell {
    box-shadow: 0 8px 16px var(--bg-surface);
    /* Single shadow */
  }

  .tarot-card-back {
    /* Use simpler background on mobile */
    background: var(--bg-surface-muted);
    /* Solid fallback */
  }

  .tarot-card-shell:hover {
    box-shadow: 0 10px 22px var(--bg-surface);
  }
}

@media (min-width: 768px) {
  .tarot-card-shell {
    box-shadow:
      0 10px 25px var(--bg-surface),
      0 0 18px var(--brand-secondary);
  }

  .tarot-card-shell:hover {
    box-shadow:
      0 16px 40px var(--bg-surface),
      0 0 26px var(--brand-accent);
  }
}


/* Back: ornate mandala + celestial motif evoking traditional deck backs */
.tarot-card-back {
  position: relative;
  width: 100%;
  height: 100%;
  background:
    radial-gradient(circle at 50% 15%, var(--halo-star-color), transparent 60%),
    radial-gradient(circle at 50% 85%, var(--halo-star-color), transparent 60%),
    repeating-radial-gradient(circle at 50% 50%, var(--brand-secondary), var(--brand-secondary) 1px, transparent 1px, transparent 4px),
    radial-gradient(circle at 50% 50%, var(--bg-main), var(--bg-main));
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--brand-accent);
  font-family: "Cormorant Garamond", "Times New Roman", serif;
}

.tarot-card-back-symbol {
  position: relative;
  width: 64%;
  height: 64%;
  border-radius: 999px;
  border: 1px solid var(--brand-accent);
  box-shadow:
    0 0 14px var(--brand-accent),
    inset 0 0 18px var(--bg-main);
  display: flex;
  align-items: center;
  justify-content: center;
}

.tarot-card-back-symbol::before,
.tarot-card-back-symbol::after {
  content: "";
  position: absolute;
  border-radius: 999px;
  border: 1px solid var(--brand-secondary);
}

.tarot-card-back-symbol::before {
  inset: 12%;
  border-style: dotted;
}

.tarot-card-back-symbol::after {
  inset: 26%;
  border-style: solid;
  border-color: var(--brand-accent);
}

/* Simple cross-wand sigil */
.tarot-card-back-glyph {
  position: relative;
  width: 52%;
  height: 52%;
}

.tarot-card-back-glyph::before,
.tarot-card-back-glyph::after {
  content: "";
  position: absolute;
  background-color: var(--brand-accent);
  border-radius: 999px;
  box-shadow: 0 0 8px var(--brand-accent);
}

.tarot-card-back-glyph::before {
  inset: 2px 47%;
}

.tarot-card-back-glyph::after {
  inset: 47% 2px;
}

/* Face: evokes authentic majors with nameplate, Roman numeral, symbolic band */
.tarot-card-face {
  position: relative;
  width: 100%;
  height: 100%;
  padding: 0.45rem 0.35rem 0.55rem;
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
  background: linear-gradient(to bottom, var(--bg-surface-muted), var(--bg-main));
  color: var(--text-main);
}

/* Top label bar with roman numeral like classic decks */
.tarot-card-face-header {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.25rem;
  font-size: clamp(0.6875rem, 2vw, 0.75rem);
  /* Minimum 11px (0.6875rem) for readability */
  letter-spacing: 0.16em;
  text-transform: uppercase;
  color: var(--brand-accent);
}

.tarot-card-face-header span {
  padding: 0.07rem 0.3rem;
  border-radius: 999px;
  border: 1px solid var(--brand-accent);
  background: radial-gradient(circle at 50% 0%, var(--brand-accent), transparent);
}

/* Central band hinting at scene / sigil */
.tarot-card-face-symbol {
  flex: 1;
  border-radius: 0.55rem;
  margin: 0.05rem 0.1rem;
  padding: 0.16rem 0.18rem;
  border: 1px solid var(--brand-secondary);
  background:
    radial-gradient(circle at 15% 10%, var(--brand-secondary), transparent 55%),
    radial-gradient(circle at 85% 90%, var(--brand-accent), transparent 55%),
    radial-gradient(circle at 50% 50%, var(--bg-surface), var(--bg-main));
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

/* Suggestive micro-illustration bars */
.tarot-card-face-symbol-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 0.12rem;
}

.tarot-card-face-symbol-pill {
  flex: 1;
  height: 0.12rem;
  border-radius: 999px;
  background: linear-gradient(to right, var(--brand-accent), var(--brand-secondary));
  opacity: 0.9;
}

.tarot-card-face-symbol-star {
  width: 0.22rem;
  height: 0.22rem;
  border-radius: 999px;
  border: 1px solid var(--brand-accent);
  box-shadow: 0 0 6px var(--brand-accent);
}

/* Nameplate at bottom like traditional cards */
.tarot-card-face-name {
  font-family: "Cormorant Garamond", "Times New Roman", serif;
  font-size: clamp(0.6875rem, 2.2vw, 0.875rem);
  /* Minimum 11px (0.6875rem) for readability */
  letter-spacing: 0.09em;
  text-transform: uppercase;
  text-align: center;
  padding: 0.12rem 0.25rem 0.06rem;
  margin: 0 0.32rem 0.02rem;
  border-radius: 0.4rem;
  background: var(--bg-main);
  color: var(--text-main);
  border: 1px solid var(--brand-secondary);
  overflow-wrap: break-word;
  /* Better wrapping for long card names */
  word-break: break-word;
  hyphens: auto;
}

/* Upright vs reversed nuance */
.tarot-card-face.upright {
  box-shadow: inset 0 0 10px var(--brand-secondary);
}

.tarot-card-face.reversed {
  box-shadow: inset 0 0 10px var(--brand-secondary);
  filter: saturate(0.9);
}

/* Minor Arcana suit accents - variables defined in main :root block at top of file */

.tarot-card-face.minor-wands {
  border-color: var(--wands-accent);
  box-shadow: inset 0 0 8px var(--wands-accent-soft);
}

.tarot-card-face.minor-cups {
  border-color: var(--cups-accent);
  box-shadow: inset 0 0 8px var(--cups-accent-soft);
}

.tarot-card-face.minor-swords {
  border-color: var(--swords-accent);
  box-shadow: inset 0 0 8px var(--swords-accent-soft);
}

.tarot-card-face.minor-pentacles {
  border-color: var(--pentacles-accent);
  box-shadow: inset 0 0 8px var(--pentacles-accent-soft);
}

/* Minor pip dots used for numbered Minors */
.minor-pip {
  box-shadow: 0 0 3px var(--brand-accent);
}

/* Subtle mystic particles around key headers (used via .mystic-heading-wrap) */
.mystic-heading-wrap {
  position: relative;
}

.mystic-heading-wrap::before,
.mystic-heading-wrap::after {
  content: "";
  position: absolute;
  pointer-events: none;
  border-radius: 999px;
  opacity: 0.25;
  background: radial-gradient(circle, var(--brand-accent) 0%, transparent 70%);
  filter: blur(8px);
}

.mystic-heading-wrap::before {
  width: 22px;
  height: 22px;
  top: -6px;
  left: 12%;
}

.mystic-heading-wrap::after {
  width: 18px;
  height: 18px;
  bottom: -8px;
  right: 14%;
}

/* --- TOUCH TARGETS & LANDSCAPE --- */

/* Custom checkbox styling to match tarot aesthetic */
input[type="checkbox"] {
  appearance: none;
  -webkit-appearance: none;
  width: 1.5rem;
  /* 24px - WCAG compliant */
  height: 1.5rem;
  cursor: pointer;
  border-radius: 0.375rem;
  border: 2px solid var(--brand-accent);
  background: var(--bg-surface-muted);
  position: relative;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

input[type="checkbox"]:hover {
  border-color: var(--brand-accent);
  background: var(--bg-surface);
  box-shadow: 0 0 8px var(--brand-accent);
}

input[type="checkbox"]:checked {
  background: linear-gradient(135deg, var(--brand-accent), var(--brand-secondary));
  border-color: var(--brand-secondary);
  box-shadow: 0 0 12px var(--brand-secondary);
}

/* Mystical checkmark using pseudo-element */
input[type="checkbox"]:checked::before {
  content: "✦";
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 0.875rem;
  color: var(--brand-secondary);
  text-shadow: 0 0 6px var(--brand-secondary);
}

input[type="checkbox"]:focus-visible {
  outline: 2px solid var(--focus-ring-color);
  outline-offset: 3px;
}

input[type="range"] {
  height: 3rem;
  /* Increased for better touch */
  cursor: pointer;
  -webkit-appearance: none;
  appearance: none;
  background: transparent;
  width: 100%;
  touch-action: manipulation;
}

input[type="range"]:focus {
  outline: none;
}

/* Track */
input[type="range"]::-webkit-slider-runnable-track {
  width: 100%;
  height: 6px;
  cursor: pointer;
  background: var(--bg-main);
  border-radius: 999px;
  border: 1px solid var(--brand-accent);
}

input[type="range"]::-moz-range-track {
  width: 100%;
  height: 6px;
  cursor: pointer;
  background: var(--bg-main);
  border-radius: 999px;
  border: 1px solid var(--brand-accent);
}

/* Thumb */
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 28px;
  height: 28px;
  background: var(--brand-accent);
  /* amber-300 */
  border-radius: 999px;
  border: 2px solid var(--bg-main);
  cursor: pointer;
  margin-top: -11px;
  transition: transform 0.2s ease;
}

input[type="range"]::-moz-range-thumb {
  width: 28px;
  height: 28px;
  background: var(--brand-accent);
  /* amber-300 */
  border-radius: 999px;
  border: 2px solid var(--bg-main);
  cursor: pointer;
}

input[type="range"]:focus::-webkit-slider-thumb {
  outline: 3px solid var(--focus-ring-color);
  outline-offset: 2px;
}

/* Landscape orientation safeguards */
@media (max-height: 500px) and (orientation: landscape) {
  .tarot-card-shell {
    width: 5.5rem;
    height: 8.5rem;
  }

  .cc-grid {
    grid-template-columns: repeat(2, minmax(0, 1fr));
    grid-template-areas:
      "past       present"
      "challenge  future"
      "above      below"
      "advice     external"
      "hopesfears outcome";
    gap: 0.85rem;
  }
}

@media (min-height: 501px) and (max-height: 700px) and (orientation: landscape) {
  .tarot-card-shell {
    width: 7rem;
    height: 10.5rem;
  }

  .cc-grid {
    grid-template-columns: repeat(2, minmax(0, 1fr));
    grid-template-areas:
      "past       present"
      "challenge  future"
      "above      below"
      "advice     external"
      "hopesfears outcome";
    gap: 1.25rem;
  }
}

@media (min-width: 1024px) and (max-width: 1366px) and (orientation: landscape) {
  .tarot-card-shell {
    width: 8.5rem;
    height: 12.5rem;
  }

  .cc-grid {
    gap: 1.75rem;
  }
}

/* Deck selector - extends .panel-mystic with different noise opacity */
.deck-selector-panel {
  --panel-noise-opacity: 0.32;
  /* Inherits all styles from .panel-mystic when used with that class */
  /* Note: Apply class="panel-mystic deck-selector-panel" in HTML */
}

.deck-panel-footnote {
  border-top: 1px solid var(--border-warm-light);
  padding-top: 0.9rem;
  margin-top: 0.25rem;
}

/* Mobile settings drawer aligns with deck/spread card styling */
.mobile-drawer-overlay {
  background:
    radial-gradient(circle at 18% 12%, var(--drawer-gold-16), transparent 36%),
    radial-gradient(circle at 82% 6%, rgba(126, 170, 255, 0.16), transparent 42%),
    rgba(7, 6, 12, 0.86);
  backdrop-filter: blur(12px);
}

.mobile-drawer {
  --drawer-accent: var(--drawer-gold);
  --drawer-border: var(--drawer-gold-28);
  --drawer-border-strong: var(--drawer-gold-70);
  --drawer-glow: var(--drawer-gold-32);
  position: relative;
  overflow: hidden;
  isolation: isolate;
  border-radius: 1.3rem 1.3rem 0 0;
  background:
    radial-gradient(circle at 16% -8%, var(--drawer-gold-18), transparent 46%),
    radial-gradient(circle at 88% -12%, rgba(124, 164, 255, 0.16), transparent 50%),
    linear-gradient(170deg, rgba(24, 18, 33, 0.96), rgba(10, 8, 16, 0.98));
  border: 1px solid var(--drawer-border);
  box-shadow: 0 -18px 42px -26px rgba(0, 0, 0, 0.86), 0 -8px 24px -18px var(--drawer-glow), inset 0 1px 0 rgba(255, 255, 255, 0.06);
}

.mobile-drawer::before {
  content: '';
  position: absolute;
  inset: 0;
  background:
    radial-gradient(circle at 20% 14%, color-mix(in srgb, var(--drawer-accent) 38%, transparent) 0%, transparent 52%),
    radial-gradient(circle at 80% 0%, color-mix(in srgb, var(--drawer-accent) 18%, transparent) 0%, transparent 48%),
    linear-gradient(180deg, rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0));
  opacity: 0.9;
  pointer-events: none;
  z-index: 0;
}

.mobile-drawer::after {
  content: '';
  position: absolute;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='0.25'/%3E%3C/svg%3E");
  mix-blend-mode: soft-light;
  opacity: 0.25;
  pointer-events: none;
  z-index: 0;
}

.mobile-drawer__handle {
  position: relative;
  z-index: 1;
  width: 3.25rem;
  height: 0.28rem;
  margin: 0.85rem auto 0.35rem;
  border-radius: 999px;
  background: color-mix(in srgb, var(--drawer-accent) 70%, #f8edd6);
  box-shadow: 0 10px 18px -12px var(--drawer-glow), inset 0 0 0 1px rgba(255, 255, 255, 0.2);
  opacity: 0.9;
}

.mobile-drawer__header {
  position: relative;
  z-index: 1;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.06), rgba(255, 255, 255, 0));
  border-bottom: 1px solid rgba(255, 255, 255, 0.06);
}

.mobile-drawer__eyebrow {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  font-size: 0.7rem;
  letter-spacing: 0.22em;
  text-transform: uppercase;
  color: color-mix(in srgb, var(--drawer-accent) 70%, #d4b896);
}

.mobile-drawer__badge {
  display: inline-flex;
  align-items: center;
  gap: 0.45rem;
  padding: 0.45rem 0.9rem;
  border-radius: 999px;
  border: 1px solid color-mix(in srgb, var(--drawer-accent) 32%, transparent);
  background: rgba(12, 10, 16, 0.65);
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
  color: rgba(232, 218, 195, 0.92);
}

.mobile-drawer__close {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  /* WCAG 2.2 SC 2.5.8: Touch target minimum 44x44px */
  height: 2.75rem;
  width: 2.75rem;
  min-height: 44px;
  min-width: 44px;
  border-radius: 999px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  background: rgba(10, 8, 14, 0.65);
  color: rgba(208, 198, 185, 0.9);
  transition: color 160ms ease, border-color 160ms ease, background-color 160ms ease, transform 160ms ease;
  box-shadow: 0 10px 24px -18px rgba(0, 0, 0, 0.8);
  /* Prevent accidental activation on touch */
  touch-action: manipulation;
}

.mobile-drawer__close:hover {
  color: #f4e9d1;
  border-color: color-mix(in srgb, var(--drawer-accent) 55%, transparent);
  background: rgba(18, 14, 20, 0.85);
  transform: translateY(-1px);
}

.mobile-drawer__close:active {
  transform: translateY(0);
  background: rgba(18, 14, 20, 0.95);
}

.mobile-drawer__body {
  position: relative;
  z-index: 1;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0));
}

.deck-card {
  position: relative;
  overflow: hidden;
  isolation: isolate;
  background: var(--deck-background, #15121f);
  border: 1px solid var(--deck-border, rgba(255, 255, 255, 0.08));
  box-shadow: 0 18px 36px -24px rgba(0, 0, 0, 0.85), inset 0 1px 0 rgba(255, 255, 255, 0.05);
  transition: transform 160ms ease, box-shadow 180ms ease, border-color 160ms ease;
}

.deck-card::before {
  content: '';
  position: absolute;
  inset: 0;
  background:
    radial-gradient(circle at 20% 18%, color-mix(in srgb, var(--deck-accent, #d4b896) 35%, transparent) 0%, transparent 52%),
    radial-gradient(circle at 80% 0%, color-mix(in srgb, var(--deck-accent, #d4b896) 24%, transparent) 0%, transparent 50%),
    linear-gradient(165deg, rgba(255, 255, 255, 0.04), rgba(255, 255, 255, 0));
  opacity: 0.9;
  pointer-events: none;
  z-index: 0;
}

.deck-card::after {
  content: '';
  position: absolute;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='0.25'/%3E%3C/svg%3E");
  mix-blend-mode: soft-light;
  opacity: 0.25;
  pointer-events: none;
  z-index: 0;
}

.deck-card:hover {
  transform: translateY(-3px);
  border-color: color-mix(in srgb, var(--deck-accent, #d4b896) 45%, transparent);
  box-shadow: 0 24px 45px -28px rgba(0, 0, 0, 0.85), 0 8px 22px -18px var(--deck-glow, rgba(212, 184, 150, 0.35));
}

.deck-card--active {
  border-color: color-mix(in srgb, var(--deck-accent, #d4b896) 65%, transparent);
  box-shadow:
    0 28px 60px -30px var(--deck-glow, rgba(212, 184, 150, 0.45)),
    0 0 0 1px rgba(255, 255, 255, 0.08),
    inset 0 1px 0 rgba(255, 255, 255, 0.08);
  transform: translateY(-2px);
}

.deck-preview-card {
  background: linear-gradient(145deg, rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.02));
  box-shadow: 0 10px 28px -18px rgba(0, 0, 0, 0.7);
}

.deck-palette-badge {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.35rem;
  font-size: 0.7rem;
  letter-spacing: 0.02em;
  padding: 0.4rem 0.85rem;
  border-radius: 999px;
  border: 1px solid rgba(0, 0, 0, 0.25);
  font-weight: 600;
  text-transform: none;
  backdrop-filter: blur(4px);
}

/* Prepare reading shell + cards reuse deck styling */
.prepare-reading-panel {
  margin-bottom: 1.5rem;
}

.prepare-summary-chip {
  display: inline-flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0.65rem;
  font-size: 0.78rem;
  letter-spacing: 0.04em;
  color: rgba(233, 220, 201, 0.85);
  border: 1px solid rgba(233, 220, 201, 0.25);
  border-radius: 999px;
  padding: 0.45rem 0.9rem;
  background:
    linear-gradient(125deg, rgba(22, 17, 28, 0.68), rgba(34, 26, 46, 0.74));
  backdrop-filter: blur(6px);
  box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.02);
}

.prepare-summary-chip span[aria-hidden='true'] {
  color: rgba(233, 220, 201, 0.45);
}

@media (max-width: 520px) {
  .prepare-summary-chip span[aria-hidden='true'] {
    display: none;
  }
}

.prepare-card {
  --prepare-accent: #e5c48e;
  position: relative;
  overflow: hidden;
  border-radius: 1.35rem;
  padding: 1.2rem 1.35rem 1.4rem;
  background:
    radial-gradient(circle at 4% 14%, color-mix(in srgb, var(--prepare-accent) 14%, transparent) 0%, transparent 42%),
    radial-gradient(circle at 94% -8%, rgba(120, 161, 255, 0.08), transparent 48%),
    radial-gradient(circle at 48% 120%, rgba(255, 163, 205, 0.06), transparent 56%),
    linear-gradient(140deg, #0d0a14, #151020 55%, #0f0b17);
  border: 1px solid rgba(232, 218, 195, 0.18);
  box-shadow: 0 18px 36px -24px rgba(0, 0, 0, 0.85), inset 0 1px 0 rgba(255, 255, 255, 0.05);
  transition: border-color 160ms ease, box-shadow 160ms ease, transform 160ms ease;
}

.prepare-card::before {
  content: '';
  position: absolute;
  inset: 0;
  background:
    radial-gradient(circle at 18% 18%, color-mix(in srgb, var(--prepare-accent) 18%, transparent) 0%, transparent 52%),
    radial-gradient(circle at 78% 0%, color-mix(in srgb, var(--prepare-accent) 10%, transparent) 0%, transparent 50%),
    linear-gradient(165deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0));
  opacity: 0.5;
  pointer-events: none;
  z-index: 0;
}

.prepare-card::after {
  content: '';
  position: absolute;
  inset: 0;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'%3E%3Cfilter id='p'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23p)' opacity='0.25'/%3E%3C/svg%3E");
  mix-blend-mode: soft-light;
  opacity: 0.18;
  pointer-events: none;
  z-index: 0;
}

@media (hover: hover) {
  .prepare-card:hover {
    transform: translateY(-2px);
    border-color: color-mix(in srgb, var(--prepare-accent) 45%, transparent);
    box-shadow: 0 24px 45px -28px rgba(0, 0, 0, 0.85), 0 8px 22px -18px rgba(229, 196, 142, 0.35);
  }
}

.prepare-card--open {
  border-color: color-mix(in srgb, var(--prepare-accent) 55%, transparent);
  box-shadow:
    0 26px 58px -30px rgba(229, 196, 142, 0.35),
    0 0 0 1px rgba(255, 255, 255, 0.08),
    inset 0 1px 0 rgba(255, 255, 255, 0.08);
}

.prepare-card__header {
  position: relative;
  z-index: 1;
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 1rem;
}

.prepare-card__badge {
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.14em;
  color: #120d17;
  background-color: var(--prepare-accent);
  border-radius: 999px;
  padding: 0.35rem 0.9rem;
  border: 1px solid rgba(255, 255, 255, 0.2);
  box-shadow: 0 12px 24px -18px rgba(229, 196, 142, 0.55);
}

.prepare-card__body,
.prepare-card__content {
  position: relative;
  z-index: 1;
  margin-top: 1rem;
}

.prepare-card__toggle {
  width: 100%;
  padding: 0;
  margin: 0;
  border: none;
  background: none;
  color: inherit;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 1rem;
  text-align: left;
  cursor: pointer;
}

.prepare-card__toggle:focus-visible {
  outline: 2px solid color-mix(in srgb, var(--prepare-accent) 65%, transparent);
  outline-offset: 4px;
}

.prepare-card__content {
  padding-top: 0.5rem;
}

.prepare-panel-footnote {
  padding-top: 0.9rem;
}

/* ==========================================================================
   Deck Ritual Interface Styles
   ========================================================================== */

/* Deck ritual container */
.deck-ritual-container {
  --deck-shadow-color: color-mix(in srgb, var(--brand-primary) 20%, transparent);
}

/* Deck stack 3D effect */
.deck-stack {
  transform-style: preserve-3d;
  transition: transform 0.3s ease;
}

.deck-stack:hover {
  transform: rotateX(5deg) rotateY(-3deg);
}

@media (prefers-reduced-motion: reduce) {
  .deck-stack:hover {
    transform: none;
  }
}

/* Card deal animation */
@keyframes cardDeal {
  0% {
    transform: translate(0, 0) rotate(0deg) scale(1);
    opacity: 1;
  }
  50% {
    transform: translate(var(--deal-x, 100px), var(--deal-y, -50px)) rotate(15deg) scale(0.8);
    opacity: 0.8;
  }
  100% {
    transform: translate(var(--deal-end-x, 200px), var(--deal-end-y, 100px)) rotate(0deg) scale(0.6);
    opacity: 1;
  }
}

.card-dealing {
  animation: cardDeal var(--duration-slower, 600ms) var(--ease-out) forwards;
}

/* Knock ripple */
@keyframes knockRipple {
  0% {
    transform: scale(0.9);
    opacity: 0.8;
    border-width: 3px;
  }
  100% {
    transform: scale(1.5);
    opacity: 0;
    border-width: 1px;
  }
}

.knock-ripple {
  animation: knockRipple var(--duration-slow, 400ms) ease-out forwards;
}

/* Spread table layout */
.spread-table {
  touch-action: manipulation;
  user-select: none;
}

/* Card placeholder pulse */
@keyframes placeholderPulse {
  0%, 100% {
    border-color: color-mix(in srgb, var(--brand-primary) 30%, transparent);
    background-color: color-mix(in srgb, var(--brand-primary) 5%, transparent);
  }
  50% {
    border-color: color-mix(in srgb, var(--brand-primary) 60%, transparent);
    background-color: color-mix(in srgb, var(--brand-primary) 15%, transparent);
  }
}

.card-placeholder-next {
  animation: placeholderPulse 1.5s ease-in-out infinite;
}

/* Swipe reveal hint */
@keyframes swipeHint {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-8px); }
  75% { transform: translateX(8px); }
}

.swipe-hint {
  animation: swipeHint 2s ease-in-out infinite;
}

@media (prefers-reduced-motion: reduce) {
  .swipe-hint,
  .card-placeholder-next {
    animation: none;
  }
}

/* Swipe-to-reveal card styles */
.card-swipe-container {
  touch-action: pan-y;
  -webkit-user-select: none;
  user-select: none;
}

.card-swipe-hint {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  opacity: 0.6;
  pointer-events: none;
}

.card-swipe-hint--left {
  left: 0.5rem;
}

.card-swipe-hint--right {
  right: 0.5rem;
}

/* ==========================================================================
   Reduced Motion Support (WCAG 2.3.3 Animation from Interactions)
   ========================================================================== */

@media (prefers-reduced-motion: reduce) {
  /* Disable all animations */
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }

  /* Specifically target common animated classes */
  .animate-pulse,
  .animate-fade-in,
  .animate-slide-up,
  .animate-slide-in-right,
  .animate-pop-in {
    animation: none !important;
    opacity: 1 !important;
    transform: none !important;
  }

  /* Disable card flip and hover transforms */
  .tarot-card-shell:hover,
  .tarot-card-shell:active {
    transform: none;
  }

  /* Disable spread/deck card hover effects */
  .spread-card:hover,
  .deck-card:hover,
  .prepare-card:hover {
    transform: none;
  }

  /* Keep focus indicators visible but remove animation */
  button:focus-visible,
  [role='button']:focus-visible,
  a:focus-visible,
  input:focus-visible,
  textarea:focus-visible {
    outline: 2px solid var(--focus-ring-color);
    outline-offset: 3px;
    transition: none;
  }

  /* Disable carousel snap scrolling momentum */
  .cc-grid,
  .spread-selector-grid,
  .deck-selector-grid {
    scroll-behavior: auto;
    scroll-snap-type: none;
  }
}

/* ==========================================================================
   ADDITIONAL RESPONSIVE UTILITIES
   ========================================================================== */

/* Safe area padding utility class (supplement existing @supports rules) */
.safe-area-padding {
  padding-left: env(safe-area-inset-left, 0);
  padding-right: env(safe-area-inset-right, 0);
  padding-bottom: env(safe-area-inset-bottom, 0);
}

/* Landscape-specific utility classes */
@media (orientation: landscape) and (max-height: 500px) {
  .landscape-compact {
    padding-top: 0.5rem;
    padding-bottom: 0.5rem;
  }

  .landscape-hide {
    display: none;
  }

  .landscape-smaller {
    font-size: 0.875em;
  }
}

/* Improved touch targets */
@media (pointer: coarse) {
  .touch-target {
    min-height: 44px;
    min-width: 44px;
  }
}

/* Generic carousel scroll utility */
.carousel-scroll {
  scroll-behavior: smooth;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: none;
}

.carousel-scroll::-webkit-scrollbar {
  display: none;
}

/* Scrollbar hide utility (used in onboarding progress) */
.scrollbar-none {
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.scrollbar-none::-webkit-scrollbar {
  display: none;
}

/* Card container responsive heights utility */
.card-container-responsive {
  min-height: 40vh;
  max-height: 70vh;
}

@media (orientation: landscape) and (max-height: 500px) {
  .card-container-responsive {
    min-height: 160px;
    max-height: 260px;
  }
}

@media (min-width: 640px) {
  .card-container-responsive {
    min-height: 35vh;
    max-height: 60vh;
  }
}

/* Card height in landscape mode - fallback for CSS-only approach */
@media (orientation: landscape) and (max-height: 500px) {
  .card-swipe-container {
    min-height: 180px;
    max-height: 280px;
  }
}

/* Narrative streaming container refinements */
.narrative-stream {
  width: 100%;
  padding-bottom: clamp(1.25rem, 4vw, 2.5rem);
  padding-left: max(0.25rem, env(safe-area-inset-left, 0px));
  padding-right: max(0.25rem, env(safe-area-inset-right, 0px));
}

.narrative-stream__text {
  font-size: clamp(0.98rem, 0.9rem + 0.4vw, 1.15rem);
  line-height: 1.75;
  letter-spacing: 0.01em;
  text-wrap: pretty;
  hyphens: auto;
  max-width: min(65ch, 100%);
  margin-left: auto;
  margin-right: auto;
  color: var(--text-main);
  scrollbar-gutter: stable both-edges;
}

.narrative-stream__text--plain {
  text-align: left;
}

.narrative-stream__text p + p {
  margin-top: 1.2em;
}

.narrative-stream__actions {
  bottom: max(1rem, env(safe-area-inset-bottom, 1rem));
}

@media (max-width: 520px) {
  .narrative-stream__text {
    padding-left: clamp(0.75rem, 4vw, 1.5rem);
    padding-right: clamp(0.75rem, 4vw, 1.5rem);
    line-height: 1.85;
  }
}

@media (min-width: 640px) {
  .narrative-stream__text {
    padding-left: 0;
    padding-right: 0;
    font-size: 1.05rem;
    line-height: 1.8;
  }
}

/* Optimize narrative reading on mobile */
@media (max-width: 479px) {
  .prose {
    font-size: 0.9375rem; /* 15px - slightly smaller for mobile */
    line-height: 1.7;
  }

  .prose p {
    margin-bottom: 1.25em;
  }
}

@supports (text-wrap: balance) {
  .narrative-stream__text {
    text-wrap: balance;
  }
}

/* Fullscreen onboarding modal support */
.onboarding-modal {
  min-height: 100vh;
}

@supports (min-height: 100svh) {
  .onboarding-modal {
    min-height: 100svh;
  }
}

@supports (min-height: 100dvh) {
  .onboarding-modal {
    min-height: 100dvh;
  }
}

.onboarding-modal__scroll {
  scrollbar-gutter: stable both-edges;
  overscroll-behavior: contain;
}

/* Dropdown text sizing on narrow screens */
@media (max-width: 400px) {
  select option {
    font-size: 0.75rem;
    letter-spacing: 0.03em;
  }
}

@media (max-width: 360px) {
  select option {
    font-size: 0.6875rem;
    letter-spacing: 0.04em;
  }
}

/* Improve carousel scroll behavior */
.spread-selector-grid {
  scroll-padding-inline: 1rem;
  -webkit-overflow-scrolling: touch;
}

.spread-selector-grid > * {
  scroll-snap-stop: always;
}
</file>

<file path="src/styles/theme.css">
:root {
  /*
   * Elegant Minimal Palette
   * Clean, sophisticated, refined
   */

  /* Neutral Foundation (warmer, softer tones) */
  --color-black: #0F0E13;
  --color-charcoal: #1C1A22;
  --color-slate-dark: #2A2730;
  --color-slate-mid: #4A4640;
  --color-slate-light: #6E6760;
  --color-gray-light: #9B9388;
  --color-gray-pale: #CCC5BD;
  --color-white: #E8E6E3;

  /* Refined Accents (warmer golds) */
  --color-gold-champagne: #D4B896;
  --color-gold-muted: #B59976;
  --color-gold-soft: #E8DAC3;
  --color-silver: #A8A39E;

  /* Suit Colors (Subtle & Harmonious) */
  --color-wands: #C9A876;
  /* Warm gold */
  --color-cups: #8B95A5;
  /* Cool silver-blue */
  --color-swords: #6B7280;
  /* Steel gray */
  --color-pentacles: #8A9985;
  /* Muted sage */

  /* Functional Colors */
  --color-success: #6B9E78;
  --color-error: #C97676;

  /*
   * Semantic Tokens (Elegant Minimal Theme)
   */

  /* Backgrounds (warmer, less harsh) */
  --bg-main: #0F0E13;
  /* Deep warm charcoal */
  --bg-surface: #1C1A22;
  /* Warm dark purple-charcoal */
  --bg-surface-muted: #2A2730;
  /* Muted warm gray-purple */

  /* Text (softer, warmer) */
  --text-main: #E8E6E3;
  /* Warm off-white */
  --text-muted: #CCC5B9;
  /* WCAG AA compliant muted tone (5.2:1 on #0F0E13) - improved from #C4BDB0 */
  --text-muted-high: #DDD7CD;
  /* Higher contrast muted for over translucent backgrounds (6.5:1) - improved from #D8D2C8 */
  --text-accent: #D4B896;
  /* Warmer champagne */

  /* Brand / Interactive (warmer) */
  --brand-primary: #D4B896;
  /* Warmer champagne */
  --brand-secondary: #A89D92;
  /* Warm brown-gray updated for WCAG AA contrast (4.5:1) */
  --brand-accent: #E8DAC3;
  /* Lighter accent for differentiation from primary */

  /* Status */
  --status-success: #6B9E78;
  /* Muted green */
  --status-error: #C97676;
  /* Muted red */
  --focus-ring-color: var(--brand-accent);
  --halo-star-color: color-mix(in srgb, var(--text-main) 8%, transparent);
}

/* Light Mode Overrides (elegant minimal light variant) */
:root.light {
  --bg-main: #FAFAFA;
  --bg-surface: #FFFFFF;
  --bg-surface-muted: #F5F5F5;
  --text-main: #1A1A1A;
  --text-muted: #555555; /* WCAG AA compliant: 7:1 contrast on #FAFAFA */
  --brand-primary: #A89166;
  --brand-secondary: #E0E0E0;
  --brand-accent: #A89166;
}
</file>

<file path="src/utils/personalization.js">
import { DEFAULT_SPREAD_KEY } from '../data/spreads';

export function getSpreadFromDepth(depth) {
  switch (depth) {
    case 'short':
      return 'single';
    case 'standard':
      return 'threeCard';
    case 'deep':
      return 'celtic';
    default:
      return DEFAULT_SPREAD_KEY;
  }
}
</file>

<file path="src/worker/index.js">
/**
 * Cloudflare Workers Entry Point
 * 
 * Main router that handles all incoming requests, routing to API handlers
 * or serving static assets via the ASSETS binding.
 * 
 * Migrated from Cloudflare Pages Functions to Workers with Static Assets.
 */

// API Route Handlers (imported from existing functions)
import * as tarotReading from '../../functions/api/tarot-reading.js';
import * as tts from '../../functions/api/tts.js';
import * as ttsHume from '../../functions/api/tts-hume.js';
import * as journal from '../../functions/api/journal.js';
import * as journalById from '../../functions/api/journal/[id].js';
import * as journalSummary from '../../functions/api/journal-summary.js';
import * as feedback from '../../functions/api/feedback.js';
import * as generateQuestion from '../../functions/api/generate-question.js';
import * as share from '../../functions/api/share.js';
import * as shareToken from '../../functions/api/share/[token].js';
import * as shareNotes from '../../functions/api/share-notes/[token].js';
import * as visionProof from '../../functions/api/vision-proof.js';
import * as archetypeJourney from '../../functions/api/archetype-journey.js';
import * as archetypeJourneyBackfill from '../../functions/api/archetype-journey-backfill.js';

// Auth handlers
import * as authLogin from '../../functions/api/auth/login.js';
import * as authLogout from '../../functions/api/auth/logout.js';
import * as authRegister from '../../functions/api/auth/register.js';
import * as authMe from '../../functions/api/auth/me.js';

// API Keys handlers
import * as keysIndex from '../../functions/api/keys/index.js';
import * as keysById from '../../functions/api/keys/[id].js';

// Health check handlers
import * as healthTarotReading from '../../functions/api/health/tarot-reading.js';
import * as healthTts from '../../functions/api/health/tts.js';

// Export handlers
import * as journalExport from '../../functions/api/journal-export.js';

// Scheduled tasks
import { handleScheduled, onRequestPost as adminArchive } from '../../functions/lib/scheduled.js';

// Utility functions
import { jsonResponse } from '../../functions/lib/utils.js';

/**
 * Route definitions mapping URL patterns to handlers
 * Each route can have GET, POST, PUT, DELETE, etc. handlers
 */
const routes = [
  // Main API endpoints
  { pattern: /^\/api\/tarot-reading$/, handlers: tarotReading },
  { pattern: /^\/api\/tts$/, handlers: tts },
  { pattern: /^\/api\/tts-hume$/, handlers: ttsHume },
  { pattern: /^\/api\/journal$/, handlers: journal },
  { pattern: /^\/api\/journal\/([^/]+)$/, handlers: journalById, params: ['id'] },
  { pattern: /^\/api\/journal-summary$/, handlers: journalSummary },
  { pattern: /^\/api\/feedback$/, handlers: feedback },
  { pattern: /^\/api\/generate-question$/, handlers: generateQuestion },
  { pattern: /^\/api\/share$/, handlers: share },
  { pattern: /^\/api\/share\/([^/]+)$/, handlers: shareToken, params: ['token'] },
  { pattern: /^\/api\/share-notes\/([^/]+)$/, handlers: shareNotes, params: ['token'] },
  { pattern: /^\/api\/vision-proof$/, handlers: visionProof },
  { pattern: /^\/api\/archetype-journey$/, handlers: archetypeJourney },
  { pattern: /^\/api\/archetype-journey\/(.*)$/, handlers: archetypeJourney, params: ['path'] },
  { pattern: /^\/api\/archetype-journey-backfill$/, handlers: archetypeJourneyBackfill },

  // Auth endpoints
  { pattern: /^\/api\/auth\/login$/, handlers: authLogin },
  { pattern: /^\/api\/auth\/logout$/, handlers: authLogout },
  { pattern: /^\/api\/auth\/register$/, handlers: authRegister },
  { pattern: /^\/api\/auth\/me$/, handlers: authMe },

  // API Keys management
  { pattern: /^\/api\/keys$/, handlers: keysIndex },
  { pattern: /^\/api\/keys\/([^/]+)$/, handlers: keysById, params: ['id'] },

  // Health check endpoints
  { pattern: /^\/api\/health\/tarot-reading$/, handlers: healthTarotReading },
  { pattern: /^\/api\/health\/tts$/, handlers: healthTts },

  // Export endpoints
  { pattern: /^\/api\/journal-export$/, handlers: journalExport },
  { pattern: /^\/api\/journal-export\/([^/]+)$/, handlers: journalExport, params: ['id'] },

  // Admin endpoints
  { pattern: /^\/api\/admin\/archive$/, handlers: { onRequestPost: adminArchive } },
];

/**
 * Map HTTP method to Pages Functions handler name
 */
function getHandlerName(method) {
  const methodMap = {
    'GET': 'onRequestGet',
    'POST': 'onRequestPost',
    'PUT': 'onRequestPut',
    'DELETE': 'onRequestDelete',
    'PATCH': 'onRequestPatch',
    'OPTIONS': 'onRequestOptions',
    'HEAD': 'onRequestHead',
  };
  return methodMap[method] || 'onRequest';
}

/**
 * Find matching route and extract parameters
 */
function matchRoute(pathname) {
  for (const route of routes) {
    const match = pathname.match(route.pattern);
    if (match) {
      const params = {};
      if (route.params) {
        route.params.forEach((paramName, index) => {
          params[paramName] = match[index + 1];
        });
      }
      return { route, params };
    }
  }
  return null;
}

/**
 * Handle CORS preflight requests
 * Echoes back the request Origin when credentials may be needed
 */
function handleOptions(request) {
  const origin = request.headers.get('Origin') || '*';
  const headers = {
    'Access-Control-Allow-Origin': origin,
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-Requested-With',
    'Access-Control-Allow-Credentials': 'true',
    'Access-Control-Max-Age': '86400',
  };
  return new Response(null, { status: 204, headers });
}

/**
 * Add CORS headers to response if not already set by the handler.
 * Preserves handler-set headers to support credentialed requests
 * (which require echoing the specific Origin, not '*').
 */
function addCorsHeaders(response, request) {
  const newHeaders = new Headers(response.headers);

  // Only add CORS headers if not already present (handler takes precedence)
  if (!newHeaders.has('Access-Control-Allow-Origin')) {
    const origin = request.headers.get('Origin') || '*';
    newHeaders.set('Access-Control-Allow-Origin', origin);
    newHeaders.set('Access-Control-Allow-Credentials', 'true');
  }

  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers: newHeaders,
  });
}

/**
 * Environment type definition for TypeScript-like documentation
 * @typedef {Object} Env
 * @property {Fetcher} ASSETS - Static assets binding
 * @property {D1Database} DB - D1 database for auth
 * @property {KVNamespace} RATELIMIT - Rate limiting KV
 * @property {KVNamespace} METRICS_DB - Metrics storage KV
 * @property {KVNamespace} FEEDBACK_KV - Feedback storage KV
 * @property {R2Bucket} LOGS_BUCKET - R2 bucket for logs, archives, and exports
 * @property {string} AZURE_OPENAI_ENDPOINT - Azure OpenAI endpoint
 * @property {string} AZURE_OPENAI_API_KEY - Azure OpenAI API key
 * @property {string} AZURE_OPENAI_GPT5_MODEL - GPT-5 model deployment name
 * @property {string} ANTHROPIC_API_KEY - Anthropic API key
 * @property {string} VISION_PROOF_SECRET - Vision proof signing secret
 * @property {string} HUME_API_KEY - Hume AI API key
 * @property {string} ADMIN_API_KEY - Admin API key for manual archival
 */

export default {
  /**
   * Scheduled handler for cron triggers
   * @param {ScheduledController} controller - Cron controller
   * @param {Env} env - Environment bindings
   * @param {ExecutionContext} ctx - Execution context
   */
  async scheduled(controller, env, ctx) {
    ctx.waitUntil(handleScheduled(controller, env, ctx));
  },

  /**
   * Main fetch handler for all incoming requests
   * @param {Request} request - Incoming request
   * @param {Env} env - Environment bindings
   * @param {ExecutionContext} ctx - Execution context
   * @returns {Promise<Response>}
   */
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    const pathname = url.pathname;
    const method = request.method;

    // Handle CORS preflight
    if (method === 'OPTIONS') {
      return handleOptions(request);
    }

    // Check if this is an API route
    if (pathname.startsWith('/api/')) {
      try {
        const matched = matchRoute(pathname);
        
        if (!matched) {
          return addCorsHeaders(jsonResponse(
            { error: 'Not found', path: pathname },
            { status: 404 }
          ), request);
        }

        const { route, params } = matched;
        const handlerName = getHandlerName(method);
        
        // Check for method-specific handler first, then fall back to generic onRequest
        const handler = route.handlers[handlerName] || route.handlers.onRequest;
        
        if (!handler) {
          return addCorsHeaders(jsonResponse(
            { error: 'Method not allowed', method, path: pathname },
            { status: 405 }
          ), request);
        }

        // Build context object similar to Pages Functions
        const context = {
          request,
          env,
          params,
          waitUntil: ctx.waitUntil.bind(ctx),
          passThroughOnException: () => {}, // Not applicable in Workers
          next: async () => env.ASSETS.fetch(request), // Fall through to assets
          data: {},
        };

        // Call the handler
        const response = await handler(context);
        return addCorsHeaders(response, request);

      } catch (error) {
        console.error('API Error:', error);
        return addCorsHeaders(jsonResponse(
          { error: 'Internal server error', message: error.message },
          { status: 500 }
        ), request);
      }
    }

    // For non-API routes, serve static assets
    // The ASSETS binding handles SPA fallback via not_found_handling config
    return env.ASSETS.fetch(request);
  },
};
</file>

<file path="src/main.jsx">
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter, Routes, Route } from 'react-router-dom';
import './styles/tailwind.css';
import TarotReading from './TarotReading.jsx';
import Journal from './components/Journal.jsx';
import ShareReading from './pages/ShareReading.jsx';
import { AuthProvider } from './contexts/AuthContext.jsx';
import { PreferencesProvider } from './contexts/PreferencesContext.jsx';
import { ReadingProvider } from './contexts/ReadingContext.jsx';
import { ToastProvider } from './contexts/ToastContext.jsx';

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <AuthProvider>
      <PreferencesProvider>
        <ReadingProvider>
          <ToastProvider>
            <BrowserRouter>
              <Routes>
                <Route path="/" element={<TarotReading />} />
                <Route path="/journal" element={<Journal />} />
                <Route path="/share/:token" element={<ShareReading />} />
                <Route path="*" element={<TarotReading />} />
              </Routes>
            </BrowserRouter>
          </ToastProvider>
        </ReadingProvider>
      </PreferencesProvider>
    </AuthProvider>
  </React.StrictMode>
);

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker
      .register('/sw.js')
      .catch(error => {
        console.error('Service worker registration failed:', error);
      });
  });
}
</file>

<file path="src/TarotReading.jsx">
import { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import { SPREADS } from './data/spreads';
import { EXAMPLE_QUESTIONS } from './data/exampleQuestions';
import { SpreadSelector } from './components/SpreadSelector';
import { ReadingPreparation } from './components/ReadingPreparation';
import { ReadingDisplay } from './components/ReadingDisplay';
import { GuidedIntentionCoach } from './components/GuidedIntentionCoach';
import { loadCoachRecommendation, saveCoachRecommendation } from './lib/journalInsights';
import { DeckSelector } from './components/DeckSelector';
import { MobileSettingsDrawer } from './components/MobileSettingsDrawer';
import { MobileActionBar, MobileActionGroup } from './components/MobileActionBar';
import { Header } from './components/Header';
import { OnboardingWizard } from './components/onboarding';
import { PersonalizationBanner } from './components/PersonalizationBanner';
import { useNavigate, useLocation } from 'react-router-dom';
import './styles/tarot.css';

// Hooks & Contexts
import { usePreferences } from './contexts/PreferencesContext';
import { useReading } from './contexts/ReadingContext';
import { useSaveReading } from './hooks/useSaveReading';
import { useReducedMotion } from './hooks/useReducedMotion';
import { useSmallScreen } from './hooks/useSmallScreen';
import { useLandscape } from './hooks/useLandscape';

const STEP_PROGRESS_STEPS = [
  { id: 'spread', label: 'Spread' },
  { id: 'intention', label: 'Question' },
  { id: 'ritual', label: 'Ritual (optional)' },
  { id: 'reading', label: 'Reading' }
];

export default function TarotReading() {
  // --- 1. Global Preferences (Context) ---
  const {
    // Theme
    theme,
    // Audio
    voiceOn,
    ambienceOn,
    // Deck & Reversals
    deckStyleId,
    setDeckStyleId,
    deckSize,
    minorsDataIncomplete,
    // UI State
    prepareSectionsOpen,
    togglePrepareSection,
    // Onboarding
    onboardingComplete,
    setOnboardingComplete,
    setOnboardingSpreadKey,
    showPersonalizationBanner,
    setShowPersonalizationBanner
  } = usePreferences();

  // Accessibility: reduced motion preference
  const prefersReducedMotion = useReducedMotion();
  const isSmallScreen = useSmallScreen();
  const isLandscape = useLandscape();

  // --- 2. Reading Context ---
  const {
    // Audio
    ttsAnnouncement,
    srAnnouncement,

    // Tarot State
    selectedSpread,
    setSelectedSpread: _setSelectedSpread,
    selectSpread,
    reading,
    isShuffling,
    revealedCards,
    dealIndex,
    hasKnocked,
    knockCount,
    hasCut,
    cutIndex,
    setCutIndex,
    hasConfirmedSpread,
    userQuestion,
    setUserQuestion,
    deckAnnouncement,
    shouldSkipRitual,
    shuffle,
    handleKnock,
    applyCut,
    dealNext,
    revealAll,
    onSpreadConfirm,

    // Vision (only what's needed for deck change)
    resetVisionProof,
    setVisionResults,
    setVisionConflicts,

    // Reading Generation & UI
    personalReading,
    setPersonalReading,
    isGenerating,
    setIsGenerating,
    journalStatus,
    setJournalStatus,
    setReflections,
    setShowAllHighlights,
    generatePersonalReading
  } = useReading();

  // --- 3. Local View State & Wiring ---
  // UI Specifics
  const [apiHealthBanner, setApiHealthBanner] = useState(null);
  // Load coach recommendation from localStorage on initial render
  const [coachRecommendation, setCoachRecommendation] = useState(() => {
    if (typeof window === 'undefined') return null;
    const rec = loadCoachRecommendation();
    return rec?.question ? rec : null;
  });
  const [pendingCoachPrefill, setPendingCoachPrefill] = useState(null);
  const [isIntentionCoachOpen, setIsIntentionCoachOpen] = useState(false);
  const [placeholderIndex, setPlaceholderIndex] = useState(0);
  const [isMobileSettingsOpen, setIsMobileSettingsOpen] = useState(false);
  const [keyboardOffset, setKeyboardOffset] = useState(0);
  const isOnboardingOpen = !onboardingComplete && !showPersonalizationBanner;
  // Only true overlays (modals/drawers) should hide the action bar - not the small personalization banner
  const isMobileOverlayActive = isIntentionCoachOpen || isMobileSettingsOpen || isOnboardingOpen;

  const navigate = useNavigate();
  const location = useLocation();
  const spreadSectionRef = useRef(null);
  const prepareSectionRef = useRef(null);
  const readingSectionRef = useRef(null);
  const hasAutoCompletedRef = useRef(false);
  const pendingFocusSpreadRef = useRef(false);

  // --- Effects & Helpers ---

  // Reset analysis state when Shuffle is triggered
  // (Handled in ReadingContext now, but we might need to clear local UI state if any)
  const handleShuffle = useCallback(() => {
    shuffle(); // Context handles the resets
  }, [shuffle]);

  // Check API health - runs on mount and when tab becomes visible
  useEffect(() => {
    async function checkApiHealth() {
      try {
        const [tarotHealth, ttsHealth] = await Promise.all([
          fetch('/api/health/tarot-reading', { method: 'GET', cache: 'no-store' }).catch(() => null),
          fetch('/api/health/tts', { method: 'GET', cache: 'no-store' }).catch(() => null)
        ]);
        const anthropicAvailable = tarotHealth?.ok ?? false;
        const azureAvailable = ttsHealth?.ok ?? false;
        if (!anthropicAvailable || !azureAvailable) {
          setApiHealthBanner({
            anthropic: anthropicAvailable,
            azure: azureAvailable,
            message: 'Using local services' +
              (!anthropicAvailable ? ' (Claude unavailable)' : '') +
              (!azureAvailable ? ' (Azure TTS unavailable)' : '')
          });
        } else {
          setApiHealthBanner(null);
        }
      } catch (err) {
        console.debug('API health check failed:', err);
      }
    }

    // Initial check
    checkApiHealth();

    // Re-check when tab becomes visible (handles recovery/outage scenarios)
    function handleVisibilityChange() {
      if (document.visibilityState === 'visible') {
        checkApiHealth();
      }
    }

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, []);

  // Process router state for initial question - clean up navigation state after consuming
  useEffect(() => {
    if (typeof window === 'undefined') return;

    if (location.state?.initialQuestion) {
      setUserQuestion(location.state.initialQuestion);
      const nextState = { ...location.state };
      delete nextState.initialQuestion;
      const cleanedState = Object.keys(nextState).length > 0 ? nextState : null;
      navigate(location.pathname, { replace: true, state: cleanedState });
    }
  }, [location.pathname, location.state, navigate, setUserQuestion]);

  // Mobile keyboard avoidance for the bottom action bar
  useEffect(() => {
    if (typeof window === 'undefined' || !window.visualViewport) return;

    const viewport = window.visualViewport;

    const updateKeyboardOffset = () => {
      const heightDiff = window.innerHeight - viewport.height - viewport.offsetTop;
      const isKeyboardOpen = heightDiff > 120;
      setKeyboardOffset(isKeyboardOpen ? Math.max(heightDiff, 0) : 0);
    };

    viewport.addEventListener('resize', updateKeyboardOffset);
    viewport.addEventListener('scroll', updateKeyboardOffset);
    updateKeyboardOffset();

    return () => {
      viewport.removeEventListener('resize', updateKeyboardOffset);
      viewport.removeEventListener('scroll', updateKeyboardOffset);
    };
  }, []);

  // Coach Shortcut
  useEffect(() => {
    function handleCoachShortcut(event) {
      if (event.defaultPrevented) return;
      if (isIntentionCoachOpen) return;
      const target = event.target;
      const tagName = target?.tagName;
      const isTypingTarget =
        tagName === 'INPUT' ||
        tagName === 'TEXTAREA' ||
        target?.isContentEditable;
      if (isTypingTarget) return;

      if ((event.key === 'g' || event.key === 'G') && event.shiftKey) {
        event.preventDefault();
        setPendingCoachPrefill(null);
        setIsIntentionCoachOpen(true);
      }
    }
    window.addEventListener('keydown', handleCoachShortcut);
    return () => {
      window.removeEventListener('keydown', handleCoachShortcut);
    };
  }, [isIntentionCoachOpen, setPendingCoachPrefill]);

  // Placeholder Cycle - cycles example questions when user has no question entered
  useEffect(() => {
    const trimmedQuestion = userQuestion.trim();
    if (trimmedQuestion) {
      return undefined;
    }
    const interval = setInterval(() => {
      setPlaceholderIndex(prev => (prev + 1) % EXAMPLE_QUESTIONS.length);
    }, 4000);
    return () => clearInterval(interval);
  }, [userQuestion]);

  // Clear Journal Status Timeout
  useEffect(() => {
    if (!journalStatus) return;
    const timeout = setTimeout(() => setJournalStatus(null), 5000);
    return () => clearTimeout(timeout);
  }, [journalStatus, setJournalStatus]);

  // Reset Highlights on Spread Change
  useEffect(() => {
    setShowAllHighlights(false);
  }, [selectedSpread, reading, setShowAllHighlights]);

  // --- Handlers ---

  const handleDeckChange = useCallback((newDeckId) => {
    setDeckStyleId(newDeckId);
    setVisionResults([]);
    setVisionConflicts([]);
    resetVisionProof();
  }, [setDeckStyleId, setVisionResults, setVisionConflicts, resetVisionProof]);

  const handleSpreadSelection = useCallback((key) => {
    // Use the centralized selectSpread from useTarotState
    selectSpread(key);
    // Reset narrative/analysis state
    setPersonalReading(null);
    setJournalStatus(null);
    setReflections({});
    setIsGenerating(false);
  }, [selectSpread, setPersonalReading, setJournalStatus, setReflections, setIsGenerating]);

  const handleCoachClose = useCallback(() => {
    setIsIntentionCoachOpen(false);
    setPendingCoachPrefill(null);
  }, []);

  const handleCoachApply = (guidedQuestion) => {
    if (!guidedQuestion) return;
    setUserQuestion(guidedQuestion);
    handleCoachClose();
  };

  const applyCoachRecommendation = useCallback(() => {
    if (!coachRecommendation) return;
    setUserQuestion(coachRecommendation.question || '');
    if (coachRecommendation.spreadKey && SPREADS[coachRecommendation.spreadKey]) {
      selectSpread(coachRecommendation.spreadKey);
    }
    setPendingCoachPrefill(coachRecommendation);
    setIsIntentionCoachOpen(true);
    saveCoachRecommendation(null);
    setCoachRecommendation(null);
  }, [coachRecommendation, selectSpread, setPendingCoachPrefill, setUserQuestion, setCoachRecommendation, setIsIntentionCoachOpen]);

  const dismissCoachRecommendation = useCallback(() => {
    saveCoachRecommendation(null);
    setCoachRecommendation(null);
  }, []);

  const handleStepNav = useCallback((stepId) => {
    // On mobile (< 640px), open the settings drawer for intention/ritual steps
    // since the prep section is hidden on mobile
    const isMobile = typeof window !== 'undefined' && window.innerWidth < 640;

    if (isMobile && (stepId === 'intention' || stepId === 'ritual')) {
      setIsMobileSettingsOpen(true);
      return;
    }

    const refs = {
      spread: spreadSectionRef,
      intention: prepareSectionRef,
      ritual: prepareSectionRef,
      reading: readingSectionRef
    };
    const target = refs[stepId]?.current;
    if (target && typeof target.scrollIntoView === 'function') {
      const behavior = prefersReducedMotion ? 'auto' : 'smooth';
      target.scrollIntoView({
        behavior,
        block: 'start'
      });
    }
  }, [prefersReducedMotion]);

  // Handle navigation requests passed via router state (e.g., from Journal empty state)
  useEffect(() => {
    if (!location.state?.focusSpread) {
      return;
    }

    // Mark that we need to focus spread, then clean up router state
    pendingFocusSpreadRef.current = true;
    navigate(location.pathname, { replace: true, state: null });

    // Schedule the scroll after navigation state is cleaned
    const timeoutId = window.setTimeout(() => {
      if (pendingFocusSpreadRef.current) {
        handleStepNav('spread');
        pendingFocusSpreadRef.current = false;
      }
    }, 40);

    return () => window.clearTimeout(timeoutId);
  }, [location.pathname, location.state, navigate, handleStepNav]);

  useEffect(() => {
    if (
      hasConfirmedSpread &&
      shouldSkipRitual &&
      !hasKnocked &&
      !hasAutoCompletedRef.current
    ) {
      hasAutoCompletedRef.current = true;
      console.warn('Ritual auto-complete fallback triggered - shuffle should handle this.');
    }
  }, [hasConfirmedSpread, shouldSkipRitual, hasKnocked]);

  useEffect(() => {
    if (!hasConfirmedSpread) {
      hasAutoCompletedRef.current = false;
    }
  }, [hasConfirmedSpread]);

  const handleRevealAll = useCallback(() => {
    revealAll();
    const behavior = prefersReducedMotion ? 'auto' : 'smooth';
    readingSectionRef.current?.scrollIntoView({ behavior, block: 'start' });
  }, [prefersReducedMotion, revealAll]);

  const handlePersonalizationBannerDismiss = useCallback(() => {
    setShowPersonalizationBanner(false);
    if (typeof localStorage !== 'undefined') {
      try {
        localStorage.setItem('tarot-personalization-banner', 'dismissed');
      } catch (error) {
        console.debug('Unable to persist personalization banner dismissal', error);
      }
    }
  }, [setShowPersonalizationBanner]);

  const handlePersonalizationBannerPersonalize = useCallback(() => {
    if (typeof localStorage !== 'undefined') {
      try {
        localStorage.removeItem('tarot-personalization-banner');
      } catch (error) {
        console.debug('Unable to reset personalization banner state', error);
      }
    }
    setShowPersonalizationBanner(false);
    setOnboardingComplete(false);
  }, [setShowPersonalizationBanner, setOnboardingComplete]);

  // --- Onboarding Handler ---

  const handleOnboardingComplete = useCallback((selections) => {
    setOnboardingComplete(true);
    if (selections?.selectedSpread) {
      setOnboardingSpreadKey(selections.selectedSpread);
      selectSpread(selections.selectedSpread);
    }
    if (selections?.question) {
      setUserQuestion(selections.question);
    }
  }, [selectSpread, setOnboardingComplete, setOnboardingSpreadKey, setUserQuestion]);

  const handleOnboardingSpreadSelect = useCallback((spreadKey) => {
    setOnboardingSpreadKey(spreadKey);
  }, [setOnboardingSpreadKey]);

  // --- Logic: Journal Saving ---

  const { saveReading } = useSaveReading();

  // --- Logic: UI State Builders ---

  const prepareSummaries = useMemo(() => {
    const trimmedQuestion = userQuestion.trim();
    const questionSummary = trimmedQuestion
      ? `Intention: ${trimmedQuestion.length > 60 ? `${trimmedQuestion.slice(0, 57)}…` : trimmedQuestion}`
      : 'Intention: Blank';
    const knockSummary = knockCount >= 3 ? 'Knocks ready' : `Knocks ${knockCount}/3`;
    const cutSummary = hasCut ? `Cut ${cutIndex}` : 'Cut pending';
    const ritualSummary = shouldSkipRitual
      ? 'Ritual: Personalized off'
      : knockCount === 0 && !hasCut
        ? 'Ritual: Skipped'
        : `Ritual: ${knockSummary} · ${cutSummary}`;
    const deckSummaryLabel = `${deckSize}${minorsDataIncomplete ? ' (Major Arcana only)' : ''}`;
    const audioSummary = `Voice: ${voiceOn ? 'On' : 'Off'} · Ambience: ${ambienceOn ? 'On' : 'Off'}`;
    const experienceSummary = `Theme: ${theme === 'light' ? 'Light' : 'Dark'} · Deck: ${deckSummaryLabel}`;

    return {
      intention: questionSummary,
      audio: audioSummary,
      experience: experienceSummary,
      ritual: ritualSummary
    };
  }, [userQuestion, voiceOn, ambienceOn, theme, deckSize, minorsDataIncomplete, knockCount, hasCut, cutIndex, shouldSkipRitual]);

  const prepareSectionLabels = {
    intention: { title: 'Intention', helper: 'Optional guiding prompt before you draw.' },
    audio: { title: 'Audio', helper: 'Voice narration and ambient soundscape.' },
    experience: { title: 'Experience', helper: 'Theme, deck scope, and reversal interpretation lens.' },
    ritual: { title: 'Ritual (optional)', helper: 'Shape the ritual steps so they match your practice.' }
  };

  // Determine Active Step for StepProgress
  // These are milestone-based flags that represent permanent progress through the flow
  const hasQuestion = Boolean(userQuestion && userQuestion.trim().length > 0);
  const hasReading = Boolean(reading && reading.length > 0);
  const allCardsRevealed = hasReading && revealedCards.size === reading.length;
  const hasNarrative = Boolean(personalReading && !personalReading.isError);
  const narrativeInProgress = isGenerating && !personalReading;
  const needsNarrativeGeneration = allCardsRevealed && (!personalReading || personalReading.isError);
  const _isPersonalReadingError = Boolean(personalReading?.isError);

  // Compute the highest milestone achieved (not affected by which panel user views)
  // This ensures the step indicator stays consistent once progress is made
  const { stepIndicatorLabel, stepIndicatorHint, activeStep } = useMemo(() => {
    // Once we have a reading, we're always in the "reading" phase
    // This prevents the indicator from regressing when users revisit prep panels
    if (hasReading) {
      if (hasNarrative) {
        return {
          stepIndicatorLabel: 'Reflect on your narrative',
          stepIndicatorHint: 'Read through the personalized guidance and save anything that resonates.',
          activeStep: 'reading'
        };
      }
      if (narrativeInProgress) {
        return {
          stepIndicatorLabel: 'Weaving your narrative',
          stepIndicatorHint: 'Hang tight while we compose your personalized reading.',
          activeStep: 'reading'
        };
      }
      if (allCardsRevealed) {
        return {
          stepIndicatorLabel: 'Explore your spread',
          stepIndicatorHint: 'Review the card insights below or generate a personalized narrative.',
          activeStep: 'reading'
        };
      }
      // Cards drawn but not all revealed
      const remainingCards = reading.length - revealedCards.size;
      return {
        stepIndicatorLabel: `Reveal your cards`,
        stepIndicatorHint: `${remainingCards} card${remainingCards === 1 ? '' : 's'} remaining to reveal.`,
        activeStep: 'reading'
      };
    }

    // No reading yet - check preparation milestones
    if (!hasConfirmedSpread) {
      return {
        stepIndicatorLabel: 'Pick a spread',
        stepIndicatorHint: 'Match the layout to the depth of your inquiry.',
        activeStep: 'spread'
      };
    }

    // Spread confirmed - check intention and ritual
    // Show intention step if no question set
    if (!hasQuestion) {
      return {
        stepIndicatorLabel: 'Set your intention',
        stepIndicatorHint: 'A focused question helps guide the narrative (optional but recommended).',
        activeStep: 'intention'
      };
    }

    // Question set - check ritual or ready to draw
    // Note: Ritual is optional, so we show "ready to draw" as soon as question is set
    // unless they've started but not finished the ritual
    if (knockCount > 0 && knockCount < 3 && !hasCut) {
      // User started ritual but hasn't finished - prompt to continue or skip
      return {
        stepIndicatorLabel: 'Complete your ritual',
        stepIndicatorHint: `${3 - knockCount} more knock${3 - knockCount === 1 ? '' : 's'} to clear the deck before drawing.`,
        activeStep: 'ritual'
      };
    }

    // Ready to draw - either ritual complete/skipped or no ritual started
    return {
      stepIndicatorLabel: 'Begin your draw',
      stepIndicatorHint: 'When you feel ready, deal the cards to begin your reading.',
      activeStep: 'reading'
    };
  }, [hasNarrative, narrativeInProgress, hasReading, allCardsRevealed, hasQuestion, hasConfirmedSpread, knockCount, hasCut, reading, revealedCards]);


  // --- Render Helper Wrappers ---

  return (
    <div className="app-shell min-h-screen bg-main text-main">
      <div className="skip-links">
        <a href="#main-content" className="skip-link">Skip to main content</a>
        <a href="#step-spread" className="skip-link">Skip to spreads</a>
        <a href="#step-reading" className="skip-link">Skip to reading</a>
      </div>
      <main id="main-content" tabIndex={-1} className={`max-w-7xl mx-auto px-4 sm:px-5 md:px-6 ${isLandscape ? 'pt-3 pb-24' : 'pt-6 pb-28 sm:py-8 lg:py-10'}`}>
        <div className="sr-only" role="status" aria-live="polite" aria-atomic="true">
          {[ttsAnnouncement, srAnnouncement, journalStatus?.message].filter(Boolean).join(' · ')}
        </div>

        {/* Header */}
        <Header
          steps={STEP_PROGRESS_STEPS}
          activeStep={activeStep}
          onStepSelect={handleStepNav}
          isShuffling={isShuffling}
        />

        {apiHealthBanner && (
          <div className="mb-6 p-4 bg-primary/10 border border-primary/30 rounded-lg backdrop-blur">
            <div className="flex items-center gap-3">
              <div className="w-3 h-3 rounded-full bg-primary animate-pulse"></div>
              <div className="text-accent text-xs sm:text-sm">
                <span className="font-semibold">Service Status:</span>{' '}
                <span className="sm:hidden">Local fallbacks active</span>
                <span className="hidden sm:inline">{apiHealthBanner.message}</span>
              </div>
            </div>
            <div className="mt-2 text-muted text-xs">
              {!apiHealthBanner.anthropic && <div>• Claude AI: Using local composer</div>}
              {!apiHealthBanner.azure && <div>• Azure TTS: Using local audio</div>}
              <div className="mt-1">All readings remain fully functional with local fallbacks.</div>
            </div>
          </div>
        )}

        {minorsDataIncomplete && (
          <div className="mb-6 p-4 bg-error/10 border border-error/40 rounded-lg backdrop-blur">
            <div className="flex items-center gap-3">
              <div className="w-3 h-3 rounded-full bg-error animate-pulse"></div>
              <div className="text-error text-xs sm:text-sm">
                <span className="font-semibold">Deck Data Warning:</span> Minor Arcana data incomplete. Using Major Arcana only.
              </div>
            </div>
            <div className="mt-2 text-muted text-xs">
              <div>• Please check the Minor Arcana dataset for missing or malformed cards</div>
              <div>• Full deck readings will be available once data is restored</div>
            </div>
          </div>
        )}

        {showPersonalizationBanner && (
          <PersonalizationBanner
            onDismiss={handlePersonalizationBannerDismiss}
            onPersonalize={handlePersonalizationBannerPersonalize}
          />
        )}

        {/* Step 1–3: Spread + Prepare */}
        <section aria-label="Reading setup" className={isLandscape ? 'mb-3' : 'mb-6 xl:mb-4'}>
          <div className={isLandscape ? 'mb-2' : 'mb-4 sm:mb-5'}>
            <p className="text-xs-plus sm:text-sm uppercase tracking-[0.12em] text-accent">{stepIndicatorLabel}</p>
            {!isLandscape && <p className="mt-1 text-muted-high text-xs sm:text-sm">{stepIndicatorHint}</p>}
          </div>

          <div className={`max-w-5xl mx-auto ${isLandscape ? 'space-y-3' : 'space-y-6'}`}>
            <div aria-label="Choose your physical deck">
              <DeckSelector selectedDeck={deckStyleId} onDeckChange={handleDeckChange} />
            </div>

            <div aria-label="Spread selection" ref={spreadSectionRef} id="step-spread" tabIndex={-1} className="scroll-mt-[6.5rem] sm:scroll-mt-[7.5rem]">
              <SpreadSelector
                selectedSpread={selectedSpread}
                onSelectSpread={handleSpreadSelection}
                onSpreadConfirm={onSpreadConfirm}
              />
            </div>

            {!isSmallScreen && (
              <ReadingPreparation
                sectionRef={prepareSectionRef}
                userQuestion={userQuestion}
                setUserQuestion={setUserQuestion}
                placeholderIndex={placeholderIndex}
                onPlaceholderRefresh={() => setPlaceholderIndex(prev => (prev + 1) % EXAMPLE_QUESTIONS.length)}
                coachRecommendation={coachRecommendation}
                applyCoachRecommendation={applyCoachRecommendation}
                dismissCoachRecommendation={dismissCoachRecommendation}
                onLaunchCoach={() => {
                  setPendingCoachPrefill(null);
                  setIsIntentionCoachOpen(true);
                }}
                prepareSectionsOpen={prepareSectionsOpen}
                togglePrepareSection={togglePrepareSection}
                prepareSummaries={prepareSummaries}
                prepareSectionLabels={prepareSectionLabels}
                hasKnocked={hasKnocked}
                handleKnock={handleKnock}
                cutIndex={cutIndex}
                setCutIndex={setCutIndex}
                hasCut={hasCut}
                applyCut={applyCut}
                knockCount={knockCount}
                onSkipRitual={handleShuffle}
                deckAnnouncement={deckAnnouncement}
                shouldSkipRitual={shouldSkipRitual}
              />
            )}

            {!isLandscape && (
              <div className="flex justify-center pt-1">
                <button
                  type="button"
                  onClick={() => handleStepNav('reading')}
                  className="text-sm text-secondary hover:text-main underline underline-offset-4"
                >
                  Skip ahead to the reading
                </button>
              </div>
            )}
          </div>
        </section>

        <ReadingDisplay sectionRef={readingSectionRef} />
      </main>

      {/* Mobile Nav - visually obscured when full-screen surfaces are open */}
      <MobileActionBar
        isOverlayActive={isMobileOverlayActive}
        isSettingsOpen={isMobileSettingsOpen}
        isCoachOpen={isIntentionCoachOpen}
        isShuffling={isShuffling}
        reading={reading}
        revealedCards={revealedCards}
        dealIndex={dealIndex}
        isGenerating={isGenerating}
        personalReading={personalReading}
        needsNarrativeGeneration={needsNarrativeGeneration}
        stepIndicatorLabel={stepIndicatorLabel}
        activeStep={activeStep}
        keyboardOffset={keyboardOffset}
        onOpenSettings={() => setIsMobileSettingsOpen(true)}
        onOpenCoach={() => {
          setPendingCoachPrefill(null);
          setIsIntentionCoachOpen(true);
        }}
        onShuffle={handleShuffle}
        onDealNext={dealNext}
        onRevealAll={handleRevealAll}
        onGenerateNarrative={generatePersonalReading}
        onSaveReading={saveReading}
        onNewReading={handleShuffle}
      />

      <MobileSettingsDrawer
        isOpen={isMobileSettingsOpen}
        onClose={() => setIsMobileSettingsOpen(false)}
        footer={(
          <MobileActionGroup
            isShuffling={isShuffling}
            reading={reading}
            revealedCards={revealedCards}
            dealIndex={dealIndex}
            isGenerating={isGenerating}
            personalReading={personalReading}
            needsNarrativeGeneration={needsNarrativeGeneration}
            stepIndicatorLabel={stepIndicatorLabel}
            activeStep={activeStep}
            showUtilityButtons={false}
            onOpenSettings={() => setIsMobileSettingsOpen(false)}
            onOpenCoach={() => {
              setIsMobileSettingsOpen(false);
              setPendingCoachPrefill(null);
              setIsIntentionCoachOpen(true);
            }}
            onShuffle={handleShuffle}
            onDealNext={dealNext}
            onRevealAll={handleRevealAll}
            onGenerateNarrative={generatePersonalReading}
            onSaveReading={saveReading}
            onNewReading={handleShuffle}
          />
        )}
      >
        <ReadingPreparation
          variant="mobile"
          userQuestion={userQuestion}
          setUserQuestion={setUserQuestion}
          placeholderIndex={placeholderIndex}
          onPlaceholderRefresh={() => setPlaceholderIndex(prev => (prev + 1) % EXAMPLE_QUESTIONS.length)}
          coachRecommendation={coachRecommendation}
          applyCoachRecommendation={() => { applyCoachRecommendation(); setIsMobileSettingsOpen(false); }}
          dismissCoachRecommendation={dismissCoachRecommendation}
          onLaunchCoach={() => {
            setIsMobileSettingsOpen(false);
            setPendingCoachPrefill(null);
            setIsIntentionCoachOpen(true);
          }}
          hasKnocked={hasKnocked}
          handleKnock={handleKnock}
          cutIndex={cutIndex}
          setCutIndex={setCutIndex}
          hasCut={hasCut}
          applyCut={applyCut}
          knockCount={knockCount}
          onSkipRitual={() => {
            handleShuffle();
            setIsMobileSettingsOpen(false);
          }}
          deckAnnouncement={deckAnnouncement}
          shouldSkipRitual={shouldSkipRitual}
        />
      </MobileSettingsDrawer>

      {isIntentionCoachOpen && (
        <GuidedIntentionCoach
          isOpen={isIntentionCoachOpen}
          selectedSpread={selectedSpread}
          onClose={handleCoachClose}
          onApply={handleCoachApply}
          prefillRecommendation={pendingCoachPrefill || coachRecommendation}
        />
      )}

      {/* Onboarding wizard for first-time visitors */}
      <OnboardingWizard
        isOpen={!onboardingComplete && !showPersonalizationBanner}
        onComplete={handleOnboardingComplete}
        onSelectSpread={handleOnboardingSpreadSelect}
        initialSpread={selectedSpread}
        initialQuestion={userQuestion}
      />
    </div>
  );
}
</file>

<file path="tests/accessibility/contrast-checker.mjs">
/**
 * Automated Contrast Ratio Checker
 * Validates WCAG AA/AAA compliance for color combinations used in the app
 */

// Color utilities
function hexToRgb(hex) {
  const cleaned = hex.replace('#', '');
  return {
    r: parseInt(cleaned.slice(0, 2), 16),
    g: parseInt(cleaned.slice(2, 4), 16),
    b: parseInt(cleaned.slice(4, 6), 16)
  };
}

function getLuminance(hex) {
  const { r, g, b } = hexToRgb(hex);
  const [rs, gs, bs] = [r, g, b].map(c => {
    const val = c / 255;
    return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
  });
  return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
}

function getContrastRatio(fg, bg) {
  const l1 = getLuminance(fg);
  const l2 = getLuminance(bg);
  const lighter = Math.max(l1, l2);
  const darker = Math.min(l1, l2);
  return (lighter + 0.05) / (darker + 0.05);
}

function applyOpacity(hex, opacity) {
  const { r, g, b } = hexToRgb(hex);
  // Simplified opacity calculation (assumes blending with black background)
  const bgHex = '#0F0E13'; // --bg-main
  const { r: bgR, g: bgG, b: bgB } = hexToRgb(bgHex);
  
  const newR = Math.round(r * opacity + bgR * (1 - opacity));
  const newG = Math.round(g * opacity + bgG * (1 - opacity));
  const newB = Math.round(b * opacity + bgB * (1 - opacity));
  
  return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
}

// Color palette from theme.css
const colors = {
  // Base colors
  'color-black': '#0F0E13',
  'color-charcoal': '#1C1A22',
  'color-slate-dark': '#2A2730',
  'color-gray-light': '#9B9388',
  'color-white': '#E8E6E3',
  'color-gold-champagne': '#D4B896',
  'color-silver': '#A8A39E',
  
  // Semantic tokens
  'bg-main': '#0F0E13',
  'bg-surface': '#1C1A22',
  'bg-surface-muted': '#2A2730',
  'text-main': '#E8E6E3',
  'text-muted': '#B5AFA4', // Updated value from report
  'text-accent': '#D4B896',
  'brand-primary': '#D4B896',
  'brand-secondary': '#92887D',
  'brand-accent': '#E8DAC3',
  'focus-ring-color': '#E8DAC3'
};

// Test cases from the codebase
const testCases = [
  // Base tokens (opaque surfaces)
  {
    name: 'text-muted on bg-surface (opaque)',
    fg: colors['text-muted'],
    bg: colors['bg-surface'],
    location: 'theme.css:52, various components',
    wcagLevel: 'AA',
    isText: true
  },
  {
    name: 'text-muted on bg-surface-muted (opaque)',
    fg: colors['text-muted'],
    bg: colors['bg-surface-muted'],
    location: 'theme.css:52',
    wcagLevel: 'AA',
    isText: true
  },
  {
    name: 'text-main on bg-main',
    fg: colors['text-main'],
    bg: colors['bg-main'],
    location: 'theme.css:50',
    wcagLevel: 'AAA',
    isText: true
  },
  {
    name: 'text-accent on bg-surface',
    fg: colors['text-accent'],
    bg: colors['bg-surface'],
    location: 'theme.css:54',
    wcagLevel: 'AA',
    isText: true
  },
  
  // Translucent surfaces (problematic areas from report)
  {
    name: 'text-muted on bg-surface-muted/60 (ReadingPreparation helper)',
    fg: colors['text-muted'],
    bg: applyOpacity(colors['bg-surface-muted'], 0.60),
    location: 'ReadingPreparation.jsx:104',
    wcagLevel: 'AA',
    isText: true,
    translucent: true
  },
  {
    name: 'text-muted on bg-surface-muted/70 (SpreadSelector cards)',
    fg: colors['text-muted'],
    bg: applyOpacity(colors['bg-surface-muted'], 0.70),
    location: 'SpreadSelector.jsx:146',
    wcagLevel: 'AA',
    isText: true,
    translucent: true
  },
  
  // Focus rings and borders (3:1 for non-text)
  {
    name: 'focus-ring-color on bg-main',
    fg: colors['focus-ring-color'],
    bg: colors['bg-main'],
    location: 'tarot.css:331, theme.css:70',
    wcagLevel: 'AA',
    isText: false
  },
  {
    name: 'border-secondary/60 on bg-surface-muted',
    fg: applyOpacity(colors['brand-secondary'], 0.60),
    bg: colors['bg-surface-muted'],
    location: 'ReadingPreparation.jsx:104, SpreadSelector.jsx complexity badges',
    wcagLevel: 'AA',
    isText: false
  },
  {
    name: 'border-primary/60 on bg-primary/15 (complexity badge)',
    fg: applyOpacity(colors['brand-primary'], 0.60),
    bg: applyOpacity(colors['brand-primary'], 0.15),
    location: 'SpreadSelector.jsx:19 getComplexity',
    wcagLevel: 'AA',
    isText: false
  },
  
  // Button states
  {
    name: 'brand-accent on bg-surface (buttons)',
    fg: colors['brand-accent'],
    bg: colors['bg-surface'],
    location: 'GlobalNav, buttons',
    wcagLevel: 'AA',
    isText: true
  },
  
  // Card elements
  {
    name: 'text-main on bg-surface/85 (card revealed content)',
    fg: colors['text-main'],
    bg: applyOpacity(colors['bg-surface'], 0.85),
    location: 'Card.jsx:301',
    wcagLevel: 'AA',
    isText: true,
    translucent: true
  }
];

function checkWCAG(ratio, isText, level = 'AA') {
  if (isText) {
    // Text contrast requirements
    if (level === 'AAA') {
      return ratio >= 7.0 ? 'PASS' : 'FAIL';
    }
    return ratio >= 4.5 ? 'PASS' : 'FAIL';
  } else {
    // Non-text (UI components, borders, etc.)
    return ratio >= 3.0 ? 'PASS' : 'FAIL';
  }
}

function formatRatio(ratio) {
  return `${ratio.toFixed(2)}:1`;
}

console.log('╔════════════════════════════════════════════════════════════════════╗');
console.log('║          Tableu Tarot - Contrast Ratio Analysis Report            ║');
console.log('║                    WCAG 2.1 AA/AAA Compliance                      ║');
console.log('╚════════════════════════════════════════════════════════════════════╝\n');

console.log('Color Palette:');
console.log('─────────────');
Object.entries(colors).forEach(([name, hex]) => {
  console.log(`  ${name.padEnd(25)} ${hex}`);
});
console.log('\n');

console.log('Contrast Test Results:');
console.log('═════════════════════════════════════════════════════════════════════\n');

let totalTests = 0;
let passedTests = 0;
let failedTests = 0;
const failures = [];

testCases.forEach((test, index) => {
  totalTests++;
  const ratio = getContrastRatio(test.fg, test.bg);
  const status = checkWCAG(ratio, test.isText, test.wcagLevel);
  const passed = status === 'PASS';
  
  if (passed) {
    passedTests++;
  } else {
    failedTests++;
    failures.push({ ...test, ratio });
  }
  
  const statusIcon = passed ? '✅' : '❌';
  const typeLabel = test.isText ? 'Text' : 'UI';
  const translucentFlag = test.translucent ? ' [TRANSLUCENT]' : '';
  
  console.log(`${index + 1}. ${test.name}${translucentFlag}`);
  console.log(`   ${statusIcon} ${status} - ${formatRatio(ratio)} (${typeLabel}, WCAG ${test.wcagLevel})`);
  console.log(`   Location: ${test.location}`);
  console.log(`   FG: ${test.fg} | BG: ${test.bg}`);
  
  if (!passed) {
    const required = test.isText ? (test.wcagLevel === 'AAA' ? 7.0 : 4.5) : 3.0;
    const deficit = (required - ratio).toFixed(2);
    console.log(`   ⚠️  Falls short by ${deficit} (needs ${required}:1)`);
  }
  console.log('');
});

console.log('═════════════════════════════════════════════════════════════════════\n');
console.log('Summary:');
console.log('─────────');
console.log(`  Total Tests:   ${totalTests}`);
console.log(`  ✅ Passed:     ${passedTests} (${((passedTests/totalTests)*100).toFixed(1)}%)`);
console.log(`  ❌ Failed:     ${failedTests} (${((failedTests/totalTests)*100).toFixed(1)}%)`);
console.log('');

if (failures.length > 0) {
  console.log('═════════════════════════════════════════════════════════════════════');
  console.log('FAILED TESTS - Requires Attention:');
  console.log('═════════════════════════════════════════════════════════════════════\n');
  
  failures.forEach((test, index) => {
    const required = test.isText ? (test.wcagLevel === 'AAA' ? 7.0 : 4.5) : 3.0;
    console.log(`${index + 1}. ${test.name}`);
    console.log(`   Current:  ${formatRatio(test.ratio)}`);
    console.log(`   Required: ${required}:1 (WCAG ${test.wcagLevel})`);
    console.log(`   Location: ${test.location}`);
    console.log(`   Type:     ${test.isText ? 'Text' : 'UI Component/Border'}`);
    console.log('');
  });
}

console.log('═════════════════════════════════════════════════════════════════════');
console.log('Recommendations:');
console.log('═════════════════════════════════════════════════════════════════════\n');

console.log('1. ✅ Base tokens meet WCAG AA');
console.log('   - text-muted (#B5AFA4) achieves 7.89:1 on bg-surface');
console.log('   - This confirms the UX report\'s recommendation is working\n');

console.log('2. ⚠️  Translucent surfaces need validation');
console.log('   - Use browser DevTools or axe to measure actual rendered contrast');
console.log('   - Opacity calculations are simplified; real-world may differ\n');

console.log('3. 🔧 For any failures:');
console.log('   - Increase opacity of translucent backgrounds (60% → 80%+)');
console.log('   - Use opaque backgrounds where possible');
console.log('   - Lighten foreground colors or darken backgrounds\n');

console.log('4. 📋 Next Steps:');
console.log('   - Run `npm run dev` and test with axe DevTools browser extension');
console.log('   - Check actual rendered contrast on problematic components');
console.log('   - Validate focus rings with keyboard navigation');
console.log('   - Test on real devices at various brightness levels\n');

console.log('═════════════════════════════════════════════════════════════════════\n');

// Exit with error code if there are failures
process.exit(failedTests > 0 ? 1 : 0);
</file>

<file path="tests/accessibility/README.md">
# Accessibility Testing Guide

This directory contains automated and manual testing tools to validate WCAG 2.1 AA compliance for the Tableu Tarot application.

## Automated Tests

### 1. Contrast Ratio Checker (`contrast-checker.mjs`)

Validates color contrast ratios between foreground and background colors used throughout the application.

**Run:**
```bash
npm run test:contrast
# or
node tests/accessibility/contrast-checker.mjs
```

**What it checks:**
- Text contrast (WCAG AA: 4.5:1, AAA: 7.0:1)
- UI component contrast (WCAG AA: 3.0:1)
- Focus ring visibility
- Translucent surface contrast (with warnings)

**Expected output:**
- Pass/fail status for each color combination
- Contrast ratios with required thresholds
- Specific locations in code where issues occur
- Recommendations for fixes

### 2. WCAG Code Analyzer (`wcag-analyzer.mjs`)

Static code analysis to detect common accessibility issues in JSX/CSS.

**Run:**
```bash
npm run test:wcag
# or
node tests/accessibility/wcag-analyzer.mjs
```

**What it checks:**
- Missing alt attributes on images
- Icon-only buttons without aria-labels
- Inputs without label associations
- Positive tabIndex values
- div elements used as buttons
- Low opacity values that may affect contrast
- Dynamic content without aria-live regions

**Expected output:**
- Error/warning/info severity levels
- File locations and line numbers
- Code snippets showing issues
- Fix suggestions for each issue

### 3. Run All Automated Tests

```bash
npm run test:a11y
```

This runs both the contrast checker and WCAG analyzer sequentially.

---

## Manual Testing Guides

### Browser-Based Testing

#### axe DevTools Extension

**Setup:**
1. Install [axe DevTools](https://www.deque.com/axe/devtools/) for Chrome/Firefox/Edge
2. Run the app: `npm run dev`
3. Open DevTools → axe DevTools tab
4. Click "Scan ALL of my page"

**Focus Areas:**
- ReadingPreparation component (helper chips, summaries)
- SpreadSelector cards (complexity badges, borders)
- Card component (focus states, reveal overlays)
- Mobile action bar
- Modal dialogs
- Form inputs and toggles

**Document:**
- Screenshot violations
- Note contrast ratios shown by axe
- Save HTML/ARIA issues to file

#### Lighthouse Audit

**Run:**
1. Open app in Chrome
2. DevTools → Lighthouse tab
3. Select "Accessibility" category
4. Run audit

**Target Score:** 95+

**Focus on:**
- Contrast ratios
- ARIA attributes
- Keyboard navigation
- Form labels
- Image alt text

**Document:**
- Final score
- Failed audits with screenshots
- Opportunities for improvement

---

### Keyboard Navigation Testing

**Test Plan:**

1. **Tab Through Entire Flow:**
   ```
   ✓ Skip links appear on first Tab
   ✓ Can skip to main content
   ✓ Can skip to spread selector
   ✓ Can skip to reading area
   ✓ Tab order is logical
   ✓ No keyboard traps
   ```

2. **Focus Indicators:**
   ```
   ✓ All interactive elements show focus ring
   ✓ Focus ring contrast ≥ 3:1 against background
   ✓ Focus ring visible on gradients
   ✓ Custom controls (checkboxes, sliders) have visible focus
   ```

3. **Keyboard Shortcuts:**
   ```
   ✓ Enter/Space activates buttons
   ✓ Escape closes modals
   ✓ Arrow keys navigate spread carousel (mobile)
   ✓ Tab navigates between spread cards
   ```

4. **Modal Focus Management:**
   ```
   ✓ Focus moves to modal on open
   ✓ Focus trapped within modal
   ✓ Focus returns to trigger on close
   ✓ Escape key closes modal
   ```

**Test Each:**
- [ ] Global navigation
- [ ] Step progress chips
- [ ] Deck selector
- [ ] Spread selector cards
- [ ] Preparation sections (intention, experience, ritual)
- [ ] Draw cards button
- [ ] Card reveal interaction
- [ ] Card modal open/close
- [ ] Reflection textareas
- [ ] Generate narrative button
- [ ] Save to journal button
- [ ] Journal filters
- [ ] Mobile action bar

**Document:**
- Components without visible focus
- Tab order issues
- Keyboard traps
- Missing keyboard shortcuts

---

### Screen Reader Testing

#### NVDA (Windows)

**Setup:**
1. Install [NVDA](https://www.nvaccess.org/)
2. Press `Insert + N` to open menu
3. Navigate to Tools → Speech Viewer (to see output)

**Test Script:**

1. **Page Load:**
   ```
   ✓ Page title announced
   ✓ Landmark regions identified
   ✓ Skip links announced
   ```

2. **Navigation:**
   ```
   ✓ "Reading" and "Journal" tabs announced
   ✓ Active tab state communicated
   ✓ Step progress chips announce position
   ```

3. **Spread Selection:**
   ```
   ✓ Spread cards announced as radio buttons
   ✓ Spread name, card count, description read
   ✓ Selected state communicated
   ✓ Recommended/complexity badges announced
   ```

4. **Card Reveals:**
   ```
   ✓ Unrevealed card: "Reveal card for [position]"
   ✓ On reveal: "[Position]: [Card Name] [reversed/upright]"
   ✓ Card meaning read
   ✓ Reflection textarea label read
   ```

5. **Narrative Generation:**
   ```
   ✓ "Step 1 of 3: Analyzing spread" announced
   ✓ "Step 2 of 3: Drafting narrative" announced
   ✓ "Step 3 of 3: Final polishing" announced
   ✓ Narrative content read progressively
   ```

6. **Form Controls:**
   ```
   ✓ Checkbox state announced (checked/unchecked)
   ✓ Slider value announced
   ✓ Input labels associated correctly
   ```

#### VoiceOver (macOS/iOS)

**Setup:**
- **macOS:** Cmd + F5 to enable
- **iOS:** Settings → Accessibility → VoiceOver

**Test Same Script as NVDA**

**Additional iOS Gestures:**
- Swipe right: Next item
- Swipe left: Previous item
- Double tap: Activate
- Two-finger swipe up: Read all

**Document:**
- Unlabeled or poorly labeled elements
- Missing live region announcements
- Confusing or verbose announcements
- Elements not reachable with gestures

---

### Reduced Motion Testing

**Enable:**
- **macOS:** System Preferences → Accessibility → Display → Reduce motion
- **Windows:** Settings → Ease of Access → Display → Show animations
- **Browser:** DevTools → Rendering → Emulate CSS media `prefers-reduced-motion`

**Test:**
```
✓ Card flip animations removed or simplified
✓ Particle effects disabled
✓ Modal entrance/exit simplified
✓ Hover effects simplified
✓ Page transitions simplified
```

**Check Files:**
- Card.jsx (flip animation)
- Modal components
- Any CSS animations
- Framer Motion components

**Document:**
- Animations that don't respect reduced motion
- Elements that feel "jumpy" without transition

---

## Testing Checklist

### Priority 1: Critical Issues

- [ ] Run `npm run test:contrast` - all tests pass
- [ ] Run `npm run test:wcag` - no ERROR level issues
- [ ] axe DevTools - no violations
- [ ] Lighthouse accessibility score ≥ 95
- [ ] Keyboard navigation - all elements reachable and focusable
- [ ] Screen reader - all content announced correctly
- [ ] Reduced motion - all animations respect preference

### Priority 2: Important Issues

- [ ] All WARNING level issues from WCAG analyzer addressed
- [ ] Focus indicators visible on all interactive elements
- [ ] Form labels explicitly associated (for/id pairs)
- [ ] aria-live regions working for dynamic content
- [ ] Modal focus management working correctly

### Priority 3: Nice to Have

- [ ] INFO level issues from WCAG analyzer addressed
- [ ] Keyboard shortcuts documented
- [ ] Screen reader instructions added for complex interactions
- [ ] High contrast mode tested
- [ ] Color blind simulation tested

---

## Continuous Integration

Add to `.github/workflows/accessibility.yml`:

```yaml
name: Accessibility Tests

on: [push, pull_request]

jobs:
  a11y:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm ci
      - run: npm run test:a11y
```

---

## Resources

- [WCAG 2.1 Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)
- [axe DevTools Documentation](https://www.deque.com/axe/devtools/)
- [WebAIM Contrast Checker](https://webaim.org/resources/contrastchecker/)
- [Keyboard Accessibility](https://webaim.org/articles/keyboard/)
- [ARIA Authoring Practices](https://www.w3.org/WAI/ARIA/apg/)
- [NVDA User Guide](https://www.nvaccess.org/files/nvda/documentation/userGuide.html)
- [VoiceOver User Guide](https://support.apple.com/guide/voiceover/welcome/mac)

---

## Reporting Issues

When documenting accessibility issues, include:

1. **What:** Description of the issue
2. **Where:** Component/file/line number
3. **Severity:** Critical/High/Medium/Low
4. **WCAG Criterion:** e.g., "1.4.3 Contrast (Minimum)"
5. **Evidence:** Screenshot, screen reader output, code snippet
6. **Fix:** Proposed solution
7. **Testing:** How to verify the fix

---

## Next Steps

1. Run automated tests: `npm run test:a11y`
2. Fix any ERROR level issues
3. Run axe DevTools on live app
4. Conduct keyboard walkthrough
5. Test with one screen reader (NVDA or VoiceOver)
6. Address findings and re-test
7. Document results in UX report
</file>

<file path="tests/accessibility/wcag-analyzer.mjs">
/**
 * WCAG Code Analyzer
 * Static analysis of JSX and CSS for common accessibility issues
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '../..');

// Patterns to check
const checks = {
  missingAlt: {
    pattern: /<img\s+(?![^>]*alt=)[^>]*>/gi,
    description: 'Images missing alt attribute',
    severity: 'ERROR',
    wcag: '1.1.1 Non-text Content'
  },
  emptyAlt: {
    pattern: /<img\s+[^>]*alt=""\s*[^>]*>/gi,
    description: 'Images with empty alt (should be decorative or have aria-hidden)',
    severity: 'WARNING',
    wcag: '1.1.1 Non-text Content'
  },
  buttonWithoutLabel: {
    pattern: /<button(?![^>]*(aria-label|aria-labelledby))[^>]*>\s*<(?:Icon|[A-Z]\w+Icon|Phosphor)[^>]*\/>\s*<\/button>/gi,
    description: 'Icon-only buttons without aria-label',
    severity: 'ERROR',
    wcag: '4.1.2 Name, Role, Value'
  },
  inputWithoutLabel: {
    pattern: /<input(?![^>]*(aria-label|aria-labelledby|id=))[^>]*>/gi,
    description: 'Input without label association',
    severity: 'ERROR',
    wcag: '3.3.2 Labels or Instructions'
  },
  linkWithoutText: {
    pattern: /<a\s+[^>]*href=["'][^"']*["'][^>]*>\s*<\/a>/gi,
    description: 'Empty links',
    severity: 'ERROR',
    wcag: '2.4.4 Link Purpose'
  },
  divAsButton: {
    pattern: /<div[^>]*onClick/gi,
    description: 'div with onClick (should use button or role="button")',
    severity: 'WARNING',
    wcag: '4.1.2 Name, Role, Value'
  },
  missingLang: {
    pattern: /<html(?![^>]*lang=)/gi,
    description: 'HTML missing lang attribute',
    severity: 'ERROR',
    wcag: '3.1.1 Language of Page'
  },
  autoplayVideo: {
    pattern: /<video[^>]*autoplay/gi,
    description: 'Video with autoplay',
    severity: 'WARNING',
    wcag: '2.2.2 Pause, Stop, Hide'
  },
  positiveTabIndex: {
    pattern: /tabIndex=["']?[1-9]\d*["']?/gi,
    description: 'Positive tabIndex (disrupts natural tab order)',
    severity: 'ERROR',
    wcag: '2.4.3 Focus Order'
  },
  textXsPlus: {
    pattern: /text-xs-plus/gi,
    description: 'Custom text-xs-plus class (inconsistent typography scale)',
    severity: 'INFO',
    wcag: 'N/A (Design System)'
  },
  aggressiveOpacity: {
    pattern: /(?:bg|text|border)-[\w-]+\/(?:10|15|20|30|40|50)/gi,
    description: 'Low opacity values that may affect contrast',
    severity: 'WARNING',
    wcag: '1.4.3 Contrast (Minimum)'
  },
  missingAriaLive: {
    pattern: /(?:status|alert|announcement|message|notification)(?![^<]*aria-live)/gi,
    description: 'Status/alert elements without aria-live',
    severity: 'WARNING',
    wcag: '4.1.3 Status Messages'
  }
};

function scanFile(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const relativePath = path.relative(projectRoot, filePath);
  const issues = [];

  Object.entries(checks).forEach(([checkName, check]) => {
    const matches = [...content.matchAll(check.pattern)];
    
    matches.forEach(match => {
      const lines = content.substring(0, match.index).split('\n');
      const lineNumber = lines.length;
      const columnNumber = lines[lines.length - 1].length + 1;
      
      // Get surrounding context
      const allLines = content.split('\n');
      const contextStart = Math.max(0, lineNumber - 2);
      const contextEnd = Math.min(allLines.length, lineNumber + 1);
      const context = allLines.slice(contextStart, contextEnd).join('\n');

      issues.push({
        file: relativePath,
        line: lineNumber,
        column: columnNumber,
        checkName,
        severity: check.severity,
        description: check.description,
        wcag: check.wcag,
        match: match[0].substring(0, 100) + (match[0].length > 100 ? '...' : ''),
        context
      });
    });
  });

  return issues;
}

function scanDirectory(dir, extensions = ['.jsx', '.tsx', '.js', '.ts', '.css']) {
  let allIssues = [];
  const files = fs.readdirSync(dir, { withFileTypes: true });

  files.forEach(file => {
    const fullPath = path.join(dir, file.name);
    
    // Skip node_modules, dist, build, etc.
    if (file.isDirectory()) {
      if (!['node_modules', 'dist', 'build', '.git', 'coverage'].includes(file.name)) {
        allIssues = allIssues.concat(scanDirectory(fullPath, extensions));
      }
    } else if (file.isFile()) {
      const ext = path.extname(file.name);
      if (extensions.includes(ext)) {
        const issues = scanFile(fullPath);
        allIssues = allIssues.concat(issues);
      }
    }
  });

  return allIssues;
}

console.log('╔════════════════════════════════════════════════════════════════════╗');
console.log('║           Tableu Tarot - WCAG Code Analysis Report                ║');
console.log('║                  Static Accessibility Checks                       ║');
console.log('╚════════════════════════════════════════════════════════════════════╝\n');

console.log('Scanning codebase...\n');

const srcDir = path.join(projectRoot, 'src');
const issues = scanDirectory(srcDir);

// Group by severity
const bySeverity = {
  ERROR: issues.filter(i => i.severity === 'ERROR'),
  WARNING: issues.filter(i => i.severity === 'WARNING'),
  INFO: issues.filter(i => i.severity === 'INFO')
};

const total = issues.length;
const errors = bySeverity.ERROR.length;
const warnings = bySeverity.WARNING.length;
const info = bySeverity.INFO.length;

console.log('═════════════════════════════════════════════════════════════════════');
console.log('Summary:');
console.log('─────────');
console.log(`  Total Issues:  ${total}`);
console.log(`  ❌ Errors:     ${errors} (MUST fix)`);
console.log(`  ⚠️  Warnings:   ${warnings} (SHOULD fix)`);
console.log(`  ℹ️  Info:       ${info} (COULD fix)`);
console.log('═════════════════════════════════════════════════════════════════════\n');

// Display issues by severity
['ERROR', 'WARNING', 'INFO'].forEach(severity => {
  const severityIssues = bySeverity[severity];
  if (severityIssues.length === 0) return;

  const icon = severity === 'ERROR' ? '❌' : severity === 'WARNING' ? '⚠️' : 'ℹ️';
  console.log(`\n${icon} ${severity} (${severityIssues.length})`);
  console.log('─────────────────────────────────────────────────────────────────────\n');

  // Group by file
  const byFile = {};
  severityIssues.forEach(issue => {
    if (!byFile[issue.file]) byFile[issue.file] = [];
    byFile[issue.file].push(issue);
  });

  Object.entries(byFile).forEach(([file, fileIssues]) => {
    console.log(`📄 ${file} (${fileIssues.length} ${fileIssues.length === 1 ? 'issue' : 'issues'})`);
    
    fileIssues.forEach((issue, idx) => {
      console.log(`\n  ${idx + 1}. Line ${issue.line}:${issue.column} - ${issue.description}`);
      console.log(`     WCAG: ${issue.wcag}`);
      console.log(`     Found: ${issue.match}`);
    });
    console.log('');
  });
});

console.log('\n═════════════════════════════════════════════════════════════════════');
console.log('Detailed Findings by Check:');
console.log('═════════════════════════════════════════════════════════════════════\n');

// Group by check type
const byCheck = {};
issues.forEach(issue => {
  if (!byCheck[issue.checkName]) byCheck[issue.checkName] = [];
  byCheck[issue.checkName].push(issue);
});

Object.entries(byCheck).forEach(([checkName, checkIssues]) => {
  const check = checks[checkName];
  const icon = check.severity === 'ERROR' ? '❌' : check.severity === 'WARNING' ? '⚠️' : 'ℹ️';
  
  console.log(`${icon} ${checkName} (${checkIssues.length} occurrences)`);
  console.log(`   ${check.description}`);
  console.log(`   WCAG: ${check.wcag}\n`);
});

console.log('═════════════════════════════════════════════════════════════════════');
console.log('Priority Actions:');
console.log('═════════════════════════════════════════════════════════════════════\n');

if (errors > 0) {
  console.log('🔴 CRITICAL - Fix these errors immediately:\n');
  
  // Count unique error types
  const errorTypes = {};
  bySeverity.ERROR.forEach(issue => {
    if (!errorTypes[issue.checkName]) errorTypes[issue.checkName] = 0;
    errorTypes[issue.checkName]++;
  });
  
  Object.entries(errorTypes).forEach(([checkName, count]) => {
    console.log(`   • ${checks[checkName].description} (${count} instances)`);
    console.log(`     Fix: ${getFix(checkName)}\n`);
  });
}

if (warnings > 0) {
  console.log('🟡 IMPORTANT - Address these warnings:\n');
  
  const warningTypes = {};
  bySeverity.WARNING.forEach(issue => {
    if (!warningTypes[issue.checkName]) warningTypes[issue.checkName] = 0;
    warningTypes[issue.checkName]++;
  });
  
  Object.entries(warningTypes).forEach(([checkName, count]) => {
    console.log(`   • ${checks[checkName].description} (${count} instances)`);
    console.log(`     Fix: ${getFix(checkName)}\n`);
  });
}

console.log('═════════════════════════════════════════════════════════════════════');
console.log('Next Steps:');
console.log('═════════════════════════════════════════════════════════════════════\n');

console.log('1. Review all ERROR items and fix before deployment');
console.log('2. Address WARNING items to improve accessibility');
console.log('3. Run axe DevTools on live app to catch runtime issues');
console.log('4. Test with keyboard navigation and screen readers');
console.log('5. Run: npm run test:a11y to re-validate after fixes\n');

console.log('═════════════════════════════════════════════════════════════════════\n');

// Exit with error code if there are errors
process.exit(errors > 0 ? 1 : 0);

function getFix(checkName) {
  const fixes = {
    missingAlt: 'Add alt="" for decorative images or descriptive alt text',
    emptyAlt: 'Add aria-hidden="true" for decorative images',
    buttonWithoutLabel: 'Add aria-label="descriptive text" to icon-only buttons',
    inputWithoutLabel: 'Wrap with <label> or add aria-label/aria-labelledby',
    linkWithoutText: 'Add descriptive text inside <a> tags',
    divAsButton: 'Use <button> or add role="button", tabIndex="0", and keyboard handlers',
    missingLang: 'Add lang="en" to <html> tag',
    autoplayVideo: 'Remove autoplay or add controls',
    positiveTabIndex: 'Use tabIndex="0" or "-1", never positive numbers',
    textXsPlus: 'Use standard Tailwind text- classes',
    aggressiveOpacity: 'Test final contrast ratio with DevTools or increase opacity',
    missingAriaLive: 'Add aria-live="polite" or "assertive" to dynamic status elements'
  };
  return fixes[checkName] || 'Review WCAG guidelines for this issue';
}
</file>

<file path="tests/ambiguous-card-detection.test.mjs">
/**
 * Test for ambiguous card detection patterns
 * Verifies that hasExplicitCardContext correctly identifies card references
 * while avoiding false positives from common vocabulary.
 */

import assert from 'node:assert/strict';
import { describe, it } from 'node:test';

// Import the actual implementation from the shared module
import { hasExplicitCardContext } from '../functions/lib/cardContextDetection.js';

describe('hasExplicitCardContext patterns', () => {
  describe('should detect card references', () => {
    it('detects "Death card"', () => {
      assert.equal(hasExplicitCardContext('The Death card appears in this spread', 'Death'), true);
    });

    it('detects markdown bold **Death**', () => {
      assert.equal(hasExplicitCardContext('Here we see **Death** reversed', 'Death'), true);
    });

    it('detects "Death archetype"', () => {
      assert.equal(hasExplicitCardContext('The Death archetype represents transformation', 'Death'), true);
    });

    it('detects "archetype of Death"', () => {
      assert.equal(hasExplicitCardContext('This speaks to the archetype of Death', 'Death'), true);
    });

    it('detects "Death reversed"', () => {
      assert.equal(hasExplicitCardContext('Death reversed suggests resistance', 'Death'), true);
    });

    it('detects "Justice upright"', () => {
      assert.equal(hasExplicitCardContext('Justice upright brings balance', 'Justice'), true);
    });

    it('detects "Strength (reversed)"', () => {
      assert.equal(hasExplicitCardContext('Strength (reversed) indicates inner work', 'Strength'), true);
    });

    it('detects position label "Present: Death"', () => {
      assert.equal(hasExplicitCardContext('Present: Death shows the core situation', 'Death'), true);
    });

    it('detects position label "Card 1: Justice"', () => {
      assert.equal(hasExplicitCardContext('Card 1: Justice sits at the center', 'Justice'), true);
    });

    it('detects "Outcome — Death"', () => {
      assert.equal(hasExplicitCardContext('Outcome — Death suggests transformation', 'Death'), true);
    });
  });

  describe('should NOT detect common vocabulary', () => {
    it('ignores "a sense of justice"', () => {
      assert.equal(hasExplicitCardContext('Restore a sense of justice in how you negotiate', 'Justice'), false);
    });

    it('ignores "inner strength"', () => {
      assert.equal(hasExplicitCardContext('Find your inner strength and resilience', 'Strength'), false);
    });

    it('ignores "death of old patterns"', () => {
      assert.equal(hasExplicitCardContext('The death of old patterns brings renewal', 'Death'), false);
    });

    it('ignores "practice temperance"', () => {
      assert.equal(hasExplicitCardContext('Practice temperance in your daily habits', 'Temperance'), false);
    });

    it('ignores "exercise judgement"', () => {
      assert.equal(hasExplicitCardContext('You must exercise sound judgement here', 'Judgement'), false);
    });
  });
});
</file>

<file path="tests/api.validatePayload.test.mjs">
import assert from 'node:assert/strict';
import { describe, it } from 'node:test';
import { validatePayload } from '../functions/api/tarot-reading.js';

function card(position) {
  return {
    position,
    card: 'The Fool',
    orientation: 'Upright',
    meaning: 'New beginnings and open horizons.'
  };
}

describe('validatePayload spread count enforcement', () => {
  it('rejects incorrect card counts for known spreads', () => {
    const payload = {
      spreadInfo: { name: 'Relationship Snapshot' },
      cardsInfo: [
        card('You / your energy'),
        card('Them / their energy')
      ]
    };

    const err = validatePayload(payload);
    assert.match(err, /expects 3 cards/);
  });

  it('rejects insufficient cards for larger spreads', () => {
    const payload = {
      spreadInfo: { name: 'Decision / Two-Path' },
      cardsInfo: [
        card('Heart of the decision'),
        card('Path A — energy & likely outcome'),
        card('Path B — energy & likely outcome')
      ]
    };

    const err = validatePayload(payload);
    assert.match(err, /expects 5 cards/);
  });

  it('accepts correct card counts for known spreads', () => {
    const payload = {
      spreadInfo: { name: 'Relationship Snapshot' },
      cardsInfo: [
        card('You / your energy'),
        card('Them / their energy'),
        card('The connection / shared lesson')
      ]
    };

    const err = validatePayload(payload);
    assert.equal(err, null);
  });
});
</file>

<file path="tests/api.vision.test.mjs">
import assert from 'node:assert/strict';
import { describe, it } from 'node:test';

import { onRequestPost } from '../functions/api/tarot-reading.js';
import { buildVisionProofPayload, signVisionProof } from '../functions/lib/visionProof.js';

function makeRequest(payload) {
  return new Request('http://localhost/api/tarot-reading', {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify(payload)
  });
}

const TEST_SECRET = 'test-secret';

async function createVisionProof({ insights, deckStyle = 'rws-1909' }) {
  const payload = buildVisionProofPayload({
    id: `proof-${Math.random().toString(36).slice(2)}`,
    deckStyle,
    insights,
    ttlMs: 10 * 60 * 1000
  });
  const signature = await signVisionProof(payload, TEST_SECRET);
  return { ...payload, signature };
}

const BASE_PAYLOAD = {
  spreadInfo: { name: 'One-Card Insight' },
  cardsInfo: [
    {
      position: 'One-Card Insight',
      card: 'The Fool',
      orientation: 'Upright',
      meaning: 'New beginnings'
    }
  ],
  userQuestion: 'Is the path clear?',
  reflectionsText: ''
};

describe('vision research mode', () => {
  it('allows readings when no vision proof accompanies the request', async () => {
    const request = makeRequest(BASE_PAYLOAD);
    const response = await onRequestPost({ request, env: { VISION_PROOF_SECRET: TEST_SECRET } });

    assert.equal(response.status, 200);
    const payload = await response.json();
    assert.ok(typeof payload.reading === 'string' && payload.reading.length > 0);
  });

  it('collects telemetry without blocking readings when proof cards mismatch', async () => {
    const proof = await createVisionProof({
      insights: [
        { label: 'IMG_001', predictedCard: 'The Magician', confidence: 0.82 }
      ]
    });
    const request = makeRequest({
      ...BASE_PAYLOAD,
      visionProof: proof
    });

    const response = await onRequestPost({ request, env: { VISION_PROOF_SECRET: TEST_SECRET } });
    assert.equal(response.status, 200, 'Telemetry mismatches should not block readings');

    const payload = await response.json();
    assert.ok(typeof payload.reading === 'string' && payload.reading.length > 0);
  });

  it('rejects tampered proofs that fail verification', async () => {
    const proof = await createVisionProof({
      insights: [
        { label: 'IMG_002', predictedCard: 'The Magician', confidence: 0.91 }
      ]
    });
    const tamperedProof = { ...proof, signature: 'invalid-signature' };
    const request = makeRequest({
      ...BASE_PAYLOAD,
      visionProof: tamperedProof
    });

    const response = await onRequestPost({ request, env: { VISION_PROOF_SECRET: TEST_SECRET } });
    assert.equal(response.status, 400);

    const payload = await response.json();
    assert.match(payload.error, /Vision proof/i);
  });
});
</file>

<file path="tests/astroRelevanceGate.test.mjs">
import { describe, it } from 'node:test';
import assert from 'node:assert';
import { shouldIncludeAstroInsights } from '../functions/lib/narrative/prompts.js';

describe('shouldIncludeAstroInsights', () => {
  it('returns true when astro anchor cards appear', () => {
    const cards = [{ card: 'The Sun', number: 19 }, { card: 'Three of Cups', number: null }];
    const themes = { majorRatio: 0.2 };

    assert.strictEqual(shouldIncludeAstroInsights(cards, themes), true);
  });

  it('returns false for grounded spreads with no astro signals', () => {
    const cards = [
      { card: 'Three of Pentacles', number: null },
      { card: 'Eight of Pentacles', number: null },
      { card: 'Page of Pentacles', number: null }
    ];

    const themes = {
      majorRatio: 0,
      knowledgeGraph: { graphKeys: {} },
      timingProfile: { type: 'short' }
    };

    assert.strictEqual(shouldIncludeAstroInsights(cards, themes), false);
  });

  it('returns true when graph combos and timing signals align', () => {
    const cards = [
      { card: 'Knight of Wands', number: null },
      { card: 'Queen of Swords', number: null },
      { card: 'The Lovers', number: 6 }
    ];

    const themes = {
      majorRatio: 0.33,
      knowledgeGraph: { graphKeys: { completeTriadIds: ['lovers-empress-hierophant'] } },
      timingProfile: { type: 'seasonal' }
    };

    assert.strictEqual(shouldIncludeAstroInsights(cards, themes), true);
  });

  it('returns true when user intent is astro-focused even without anchors', () => {
    const cards = [
      { card: 'Three of Pentacles', number: null },
      { card: 'Six of Cups', number: null },
      { card: 'Page of Swords', number: null }
    ];

    const themes = { majorRatio: 0, knowledgeGraph: { graphKeys: {} }, timingProfile: { type: 'short' } };

    const question = 'How do upcoming eclipses and retrogrades affect my career over the next few months?';

    assert.strictEqual(shouldIncludeAstroInsights(cards, themes, question), true);
  });
});
</file>

<file path="tests/deck.test.mjs">
import assert from 'node:assert/strict';
import { describe, it } from 'node:test';

// Import the functions we need to test
import { seededShuffle, cryptoShuffle, computeSeed, getDeckPool, drawSpread, computeRelationships } from '../src/lib/deck.js';
import { MAJOR_ARCANA } from '../src/data/majorArcana.js';
import { MINOR_ARCANA } from '../src/data/minorArcana.js';
import { SPREADS } from '../src/data/spreads.js';

describe('Deck Shuffling and Seeding', () => {
  describe('computeSeed', () => {
    it('should produce deterministic seeds for same inputs', () => {
      const seed1 = computeSeed({
        cutIndex: 5,
        knockTimes: [100, 200, 300],
        userQuestion: 'What is my path?'
      });
      
      const seed2 = computeSeed({
        cutIndex: 5,
        knockTimes: [100, 200, 300],
        userQuestion: 'What is my path?'
      });
      
      assert.strictEqual(seed1, seed2, 'Same inputs should produce same seed');
    });
    
    it('should produce different seeds for different questions', () => {
      const seed1 = computeSeed({
        cutIndex: 5,
        knockTimes: [100, 200, 300],
        userQuestion: 'What is my path?'
      });
      
      const seed2 = computeSeed({
        cutIndex: 5,
        knockTimes: [100, 200, 300],
        userQuestion: 'What should I focus on?'
      });
      
      assert.notStrictEqual(seed1, seed2, 'Different questions should produce different seeds');
    });
    
    it('should incorporate knock count into seed', () => {
      const seed1 = computeSeed({
        cutIndex: 5,
        knockTimes: [100, 200], // 2 knocks
        userQuestion: 'Test'
      });
      
      const seed2 = computeSeed({
        cutIndex: 5,
        knockTimes: [100, 200, 300, 400], // 4 knocks
        userQuestion: 'Test'
      });
      
      assert.notStrictEqual(seed1, seed2, 'Different knock counts should produce different seeds');
    });
    
    it('should incorporate timing patterns into seed', () => {
      const seed1 = computeSeed({
        cutIndex: 5,
        knockTimes: [100, 150, 200], // rapid knocks (50ms intervals)
        userQuestion: 'Test'
      });
      
      const seed2 = computeSeed({
        cutIndex: 5,
        knockTimes: [100, 600, 1100], // slow knocks (500ms intervals)
        userQuestion: 'Test'
      });
      
      assert.notStrictEqual(seed1, seed2, 'Different timing patterns should produce different seeds');
    });
    
    it('should handle empty inputs gracefully', () => {
      const seed = computeSeed({
        cutIndex: 0,
        knockTimes: [],
        userQuestion: ''
      });
      
      assert.strictEqual(typeof seed, 'number', 'Should produce a number even with empty inputs');
      assert.notStrictEqual(seed, 0, 'Should not produce zero seed');
    });
  });
  
  describe('seededShuffle', () => {
    it('should produce reproducible shuffles with same seed', () => {
      const deck = [...MAJOR_ARCANA];
      const seed = 12345;
      
      const shuffle1 = seededShuffle(deck, seed);
      const shuffle2 = seededShuffle(deck, seed);
      
      assert.deepStrictEqual(shuffle1, shuffle2, 'Same seed should produce same shuffle');
    });
    
    it('should produce different shuffles with different seeds', () => {
      const deck = [...MAJOR_ARCANA];
      
      const shuffle1 = seededShuffle(deck, 12345);
      const shuffle2 = seededShuffle(deck, 54321);
      
      // They might occasionally be the same by chance, but very unlikely for 22 cards
      const areDifferent = shuffle1.some((card, i) => card.name !== shuffle2[i].name);
      assert.ok(areDifferent, 'Different seeds should likely produce different shuffles');
    });
    
    it('should not modify original array', () => {
      const deck = [...MAJOR_ARCANA];
      const originalNames = deck.map(c => c.name);
      
      seededShuffle(deck, 12345);
      
      const currentNames = deck.map(c => c.name);
      assert.deepStrictEqual(currentNames, originalNames, 'Original array should not be modified');
    });
    
    it('should maintain all cards in shuffle', () => {
      const deck = [...MAJOR_ARCANA];
      const seed = 12345;
      
      const shuffled = seededShuffle(deck, seed);
      
      assert.strictEqual(shuffled.length, deck.length, 'Shuffled deck should have same length');
      
      const originalNames = new Set(deck.map(c => c.name));
      const shuffledNames = new Set(shuffled.map(c => c.name));
      
      assert.deepStrictEqual(shuffledNames, originalNames, 'All cards should be present in shuffle');
    });
  });
  
  describe('cryptoShuffle', () => {
    it('should produce different shuffles on multiple calls', () => {
      const deck = [...MAJOR_ARCANA];
      
      const shuffle1 = cryptoShuffle(deck);
      const shuffle2 = cryptoShuffle(deck);
      
      // They might occasionally be the same by chance, but very unlikely for 22 cards
      const areDifferent = shuffle1.some((card, i) => card.name !== shuffle2[i].name);
      assert.ok(areDifferent, 'Multiple calls should likely produce different shuffles');
    });
    
    it('should not modify original array', () => {
      const deck = [...MAJOR_ARCANA];
      const originalNames = deck.map(c => c.name);
      
      cryptoShuffle(deck);
      
      const currentNames = deck.map(c => c.name);
      assert.deepStrictEqual(currentNames, originalNames, 'Original array should not be modified');
    });
    
    it('should maintain all cards in shuffle', () => {
      const deck = [...MAJOR_ARCANA];
      
      const shuffled = cryptoShuffle(deck);
      
      assert.strictEqual(shuffled.length, deck.length, 'Shuffled deck should have same length');
      
      const originalNames = new Set(deck.map(c => c.name));
      const shuffledNames = new Set(shuffled.map(c => c.name));
      
      assert.deepStrictEqual(shuffledNames, originalNames, 'All cards should be present in shuffle');
    });
  });
  
  describe('drawSpread', () => {
    it('should draw correct number of cards for each spread', () => {
      Object.entries(SPREADS).forEach(([key, spread]) => {
        const cards = drawSpread({
          spreadKey: key,
          useSeed: false,
          seed: 0,
          includeMinors: false
        });
        
        assert.strictEqual(cards.length, spread.count, 
          `${spread.name} should draw ${spread.count} cards`);
      });
    });
    
    it('should throw error when deck is too small for spread', () => {
      // Create a mock spread that requires more cards than available
      // Temporarily add a problematic spread
      SPREADS.oversized = {
        name: 'Oversized Test Spread',
        positions: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25'],
        count: 25,
        description: 'Test spread that requires too many cards'
      };
      
      try {
        assert.throws(() => {
          drawSpread({
            spreadKey: 'oversized',
            useSeed: false,
            seed: 0,
            includeMinors: false
          });
        }, /Deck too small for spread/);
      } finally {
        // Clean up
        delete SPREADS.oversized;
      }
    });
    
    it('should produce deterministic results with seed', () => {
      const draw1 = drawSpread({
        spreadKey: 'threeCard',
        useSeed: true,
        seed: 12345,
        includeMinors: false
      });
      
      const draw2 = drawSpread({
        spreadKey: 'threeCard',
        useSeed: true,
        seed: 12345,
        includeMinors: false
      });
      
      assert.deepStrictEqual(
        draw1.map(c => ({ name: c.name, isReversed: c.isReversed })),
        draw2.map(c => ({ name: c.name, isReversed: c.isReversed })),
        'Same seed should produce same draw'
      );
    });
    
    it('should include reversals in seeded draws', () => {
      const draw = drawSpread({
        spreadKey: 'celtic',
        useSeed: true,
        seed: 12345,
        includeMinors: false
      });
      
      const reversals = draw.filter(c => c.isReversed);
      assert.ok(reversals.length > 0, 'Seeded draw should include some reversed cards');
    });
    
    it('should work with minors deck', () => {
      const draw = drawSpread({
        spreadKey: 'threeCard',
        useSeed: true,
        seed: 12345,
        includeMinors: true
      });

      assert.strictEqual(draw.length, 3, 'Should draw correct number with minors');

      // Verify the deck pool includes minors (not that a specific seed produces them)
      const pool = getDeckPool(true);
      const poolHasMinors = pool.some(c => c.suit !== undefined);
      assert.ok(poolHasMinors, 'Deck pool with includeMinors=true should contain minor arcana');

      // If any drawn cards are minors, verify they have valid structure
      const drawnMinors = draw.filter(c => c.suit !== undefined);
      drawnMinors.forEach(minor => {
        assert.ok(typeof minor.suit === 'string', 'Minor card should have suit');
        assert.ok(typeof minor.rank === 'string', 'Minor card should have rank');
        assert.ok(typeof minor.rankValue === 'number', 'Minor card should have rankValue');
      });
    });
  });
  
  describe('getDeckPool', () => {
    it('should return majors only when includeMinors is false', () => {
      const pool = getDeckPool(false);
      assert.strictEqual(pool.length, MAJOR_ARCANA.length, 'Should return only majors');
      assert.ok(pool.every(c => c.number !== undefined), 'All cards should have numbers (majors)');
    });
    
    it('should return full deck when includeMinors is true and data is valid', () => {
      const pool = getDeckPool(true);
      assert.strictEqual(pool.length, MAJOR_ARCANA.length + MINOR_ARCANA.length, 'Should return full deck');
    });
    
    it('should validate minor arcana structure', () => {
      // Test with valid minors
      const pool = getDeckPool(true);
      const minorsInPool = pool.filter(c => c.suit !== undefined);
      
      assert.ok(minorsInPool.length > 0, 'Should include minor arcana');
      assert.ok(minorsInPool.every(c => 
        typeof c.name === 'string' &&
        typeof c.suit === 'string' &&
        typeof c.rank === 'string' &&
        typeof c.rankValue === 'number' &&
        c.rankValue >= 1 && c.rankValue <= 14
      ), 'All minor arcana cards should have valid structure');
    });
    
    it('should fall back to majors if minors data is invalid', () => {
      // This test would require mocking the MINOR_ARCANA import
      // For now, we test the fallback logic by checking the function handles errors
      const pool = getDeckPool(true);
      assert.ok(pool.length >= MAJOR_ARCANA.length, 'Should at least return majors');
    });
  });
  
  describe('computeRelationships', () => {
    it('should detect sequences in major arcana', () => {
      const cards = [
        { name: 'The Fool', number: 0, isReversed: false },
        { name: 'The Magician', number: 1, isReversed: false },
        { name: 'The High Priestess', number: 2, isReversed: false }
      ];
      
      const relationships = computeRelationships(cards);
      const hasSequence = relationships.some(r => r.type === 'sequence');
      assert.ok(hasSequence, 'Should detect sequential major arcana cards');
    });
    
    it('should detect reversal patterns', () => {
      const cards = [
        { name: 'The Fool', number: 0, isReversed: true },
        { name: 'The Magician', number: 1, isReversed: true },
        { name: 'The High Priestess', number: 2, isReversed: false },
        { name: 'The Empress', number: 3, isReversed: true },
        { name: 'The Emperor', number: 4, isReversed: true }
      ];
      
      const relationships = computeRelationships(cards);
      const hasHeavyReversals = relationships.some(r => r.type === 'reversal-heavy');
      const hasConsecutive = relationships.some(r => r.type === 'consecutive-reversals');
      
      assert.ok(hasHeavyReversals, 'Should detect heavy reversal pattern');
      assert.ok(hasConsecutive, 'Should detect consecutive reversals');
    });
    
    it('should detect suit runs in minor arcana', () => {
      const cards = [
        { name: 'Two of Wands', suit: 'Wands', rankValue: 2, isReversed: false },
        { name: 'Three of Wands', suit: 'Wands', rankValue: 3, isReversed: false },
        { name: 'Four of Wands', suit: 'Wands', rankValue: 4, isReversed: false }
      ];
      
      const relationships = computeRelationships(cards);
      const hasSuitRun = relationships.some(r => r.type === 'suit-run');
      assert.ok(hasSuitRun, 'Should detect suit runs');
    });
    
    it('should detect suit dominance', () => {
      const cards = [
        { name: 'Two of Wands', suit: 'Wands', rankValue: 2, isReversed: false },
        { name: 'Three of Wands', suit: 'Wands', rankValue: 3, isReversed: false },
        { name: 'Four of Wands', suit: 'Wands', rankValue: 4, isReversed: false },
        { name: 'Five of Cups', suit: 'Cups', rankValue: 5, isReversed: false }
      ];
      
      const relationships = computeRelationships(cards);
      const hasDominance = relationships.some(r => r.type === 'suit-dominance');
      assert.ok(hasDominance, 'Should detect suit dominance');
    });
    
    it('should detect court card clusters', () => {
      const cards = [
        { name: 'Page of Wands', suit: 'Wands', rank: 'Page', rankValue: 11, isReversed: false },
        { name: 'Knight of Cups', suit: 'Cups', rank: 'Knight', rankValue: 12, isReversed: false },
        { name: 'Queen of Swords', suit: 'Swords', rank: 'Queen', rankValue: 13, isReversed: false }
      ];
      
      const relationships = computeRelationships(cards);
      const hasCourtCluster = relationships.some(r => r.type === 'court-cluster');
      assert.ok(hasCourtCluster, 'Should detect court card clusters');
    });
    
    it('should detect reversed court cards', () => {
      const cards = [
        { name: 'Page of Wands', suit: 'Wands', rank: 'Page', rankValue: 11, isReversed: true },
        { name: 'Knight of Cups', suit: 'Cups', rank: 'Knight', rankValue: 12, isReversed: true },
        { name: 'Queen of Swords', suit: 'Swords', rank: 'Queen', rankValue: 13, isReversed: false }
      ];
      
      const relationships = computeRelationships(cards);
      const hasReversedCourts = relationships.some(r => r.type === 'reversed-court-cluster');
      assert.ok(hasReversedCourts, 'Should detect reversed court card clusters');
    });
    
    it('should detect major arcana pairings', () => {
      const cards = [
        { name: 'The Fool', number: 0, isReversed: false },
        { name: 'The Magician', number: 1, isReversed: false },
        { name: 'The High Priestess', number: 2, isReversed: false }
      ];
      
      const relationships = computeRelationships(cards);
      const hasPairing = relationships.some(r => r.type === 'pairing');
      assert.ok(hasPairing, 'Should detect major arcana pairings');
    });
    
    it('should detect growth arcs', () => {
      const cards = [
        { name: 'The Fool', number: 0, isReversed: false },
        { name: 'Card', number: 1, isReversed: false },
        { name: 'Card', number: 2, isReversed: false },
        { name: 'Card', number: 3, isReversed: false },
        { name: 'Card', number: 4, isReversed: false },
        { name: 'Card', number: 5, isReversed: false },
        { name: 'The World', number: 21, isReversed: false }
      ];
      
      const relationships = computeRelationships(cards);
      const hasArc = relationships.some(r => r.type === 'arc');
      assert.ok(hasArc, 'Should detect growth arcs from low to high numbers');
    });
    
    it('should return empty array for empty input', () => {
      const relationships = computeRelationships([]);
      assert.deepStrictEqual(relationships, [], 'Should return empty array for empty input');
    });
    
    it('should return empty array for null input', () => {
      const relationships = computeRelationships(null);
      assert.deepStrictEqual(relationships, [], 'Should return empty array for null input');
    });
  });
});

console.log('Running deck tests...');
</file>

<file path="tests/elementalRemedies.test.mjs">
/**
 * Elemental Remedies Test
 * Verifies that actionable elemental remedies are generated when elements are imbalanced
 */

import { buildElementalRemedies, shouldOfferElementalRemedies } from '../functions/lib/narrative/helpers.js';

console.log('🧪 Testing Elemental Remedies Enhancement...\n');

const tests = [
  {
    name: 'Fire-dominant spread (2/3 Fire)',
    elementCounts: { Fire: 2, Water: 0, Air: 1, Earth: 0 },
    totalCards: 3,
    context: 'self',
    expectRemedies: true,
    expectElements: ['Water', 'Earth']
  },
  {
    name: 'Balanced spread',
    elementCounts: { Fire: 1, Water: 1, Air: 1, Earth: 1 },
    totalCards: 4,
    context: 'general',
    expectRemedies: false,
    expectElements: []
  },
  {
    name: 'Water-only spread (all Water)',
    elementCounts: { Fire: 0, Water: 3, Air: 0, Earth: 0 },
    totalCards: 3,
    context: 'love',
    expectRemedies: true,
    expectElements: ['Fire', 'Air', 'Earth']
  },
  {
    name: 'Sparse elements (Fire + Air only)',
    elementCounts: { Fire: 2, Water: 0, Air: 1, Earth: 0 },
    totalCards: 3,
    context: 'career',
    expectRemedies: true,
    expectElements: ['Water', 'Earth']
  },
  {
    name: 'Single-card spread (no remedies)',
    elementCounts: { Fire: 1, Water: 0, Air: 0, Earth: 0 },
    totalCards: 1,
    context: 'spiritual',
    expectRemedies: false,
    expectElements: []
  },
  {
    name: 'Celtic Cross with moderate Fire dominance',
    elementCounts: { Fire: 5, Water: 2, Air: 2, Earth: 1 },
    totalCards: 10,
    context: 'general',
    expectRemedies: true,
    expectElements: ['Earth'] // Only Earth is < 15% (1/10 = 10%)
  }
];

let passed = 0;
let failed = 0;
let totalTests = tests.length;

tests.forEach((test, index) => {
  console.log(`\n📝 Test ${index + 1}: ${test.name}`);
  console.log(`   Element counts: ${JSON.stringify(test.elementCounts)}`);
  console.log(`   Total cards: ${test.totalCards}`);

  // Test shouldOfferElementalRemedies
  const shouldOffer = shouldOfferElementalRemedies(test.elementCounts, test.totalCards);
  console.log(`   Should offer remedies: ${shouldOffer} (expected: ${test.expectRemedies})`);

  if (shouldOffer !== test.expectRemedies) {
    console.log(`   ❌ FAILED: shouldOfferElementalRemedies returned ${shouldOffer}, expected ${test.expectRemedies}`);
    failed++;
    return;
  }

  // Test buildElementalRemedies
  const remedies = buildElementalRemedies(test.elementCounts, test.totalCards, test.context);

  if (test.expectRemedies) {
    if (!remedies) {
      console.log(`   ❌ FAILED: Expected remedies but got null`);
      failed++;
      return;
    }

    console.log(`   Generated remedies:\n${remedies.split('\n').map(line => `     ${line}`).join('\n')}`);

    // Check that expected elements are present
    const missingElements = test.expectElements.filter(element => !remedies.includes(element));
    if (missingElements.length > 0) {
      console.log(`   ❌ FAILED: Missing expected elements: ${missingElements.join(', ')}`);
      failed++;
      return;
    }

    // Check that remedies contain actionable text (checking for context-aware fragments)
    const hasActionableText = remedies.includes('Move your body') ||
      remedies.includes('Start that creative') ||
      remedies.includes('Journal your feelings') ||
      remedies.includes('Practice self-compassion') ||
      remedies.includes('Discuss your thoughts') ||
      remedies.includes('Write out your thoughts') ||
      remedies.includes('Establish one grounding') ||
      remedies.includes('Tend to your body') ||
      remedies.includes('Share a vulnerable') ||
      remedies.includes('Check in with how you feel') ||
      remedies.includes('Plan a spontaneous date') ||
      remedies.includes('Ask a question') ||
      remedies.includes('Create a small daily ritual') ||
      remedies.includes('Engage in embodied practice');

    if (!hasActionableText) {
      console.log(`   ❌ FAILED: Remedies don't contain actionable guidance`);
      failed++;
      return;
    }

    console.log(`   ✅ PASSED: Remedies generated correctly with expected elements`);
    passed++;
  } else {
    if (remedies) {
      console.log(`   ❌ FAILED: Expected no remedies but got: ${remedies}`);
      failed++;
      return;
    }
    console.log(`   ✅ PASSED: Correctly returned no remedies for balanced spread`);
    passed++;
  }
});

console.log('\n🌀 Rotation variety check');
const rotationCounts = { Fire: 2, Water: 0, Air: 1, Earth: 1 };
const rotationTotalCards = 4;
const firstRemedy = buildElementalRemedies(rotationCounts, rotationTotalCards, 'love', { rotationIndex: 0 });
const secondRemedy = buildElementalRemedies(rotationCounts, rotationTotalCards, 'love', { rotationIndex: 1 });
if (!firstRemedy || !secondRemedy) {
  console.log('   ❌ FAILED: Rotation test could not generate remedies for comparison');
  failed++;
} else if (firstRemedy === secondRemedy) {
  console.log('   ❌ FAILED: Different rotationIndex values returned identical remedies');
  failed++;
} else {
  console.log('   ✅ PASSED: Rotation index surfaces varied remedies');
  passed++;
}
totalTests += 1;

console.log(`\n\n📊 Results: ${passed}/${totalTests} tests passed`);

if (failed === 0) {
  console.log('✨ All elemental remedy tests passed!');
  console.log('Concrete, actionable guidance is being generated for imbalanced spreads.');
  process.exit(0);
} else {
  console.log(`⚠️  ${failed} test(s) failed`);
  process.exit(1);
}
</file>

<file path="tests/elementalRemediesIntegration.test.mjs">
/**
 * Elemental Remedies Integration Test
 * Verifies that elemental remedies appear in all spread builders when appropriate
 */

import { buildThreeCardReading } from '../functions/lib/narrative/spreads/threeCard.js';
import { buildFiveCardReading } from '../functions/lib/narrative/spreads/fiveCard.js';
import { buildDecisionReading } from '../functions/lib/narrative/spreads/decision.js';
import { buildRelationshipReading } from '../functions/lib/narrative/spreads/relationship.js';

console.log('🧪 Testing Elemental Remedies Integration Across All Spreads...\n');

// Mock imbalanced themes (Fire-dominant)
const mockThemes = {
  elementCounts: { Fire: 2, Water: 0, Air: 1, Earth: 0 },
  elementalBalance: 'Fire energy strongly dominates (2/3 cards), requiring attention to balance with other elements.',
  reversalCount: 0,
  reversalFramework: 'none',
  reversalDescription: {
    name: 'All Upright',
    description: 'All cards appear upright.',
    guidance: 'Read traditional upright meanings.'
  },
  deckStyle: 'rws-1909'
};

// Mock card data
const mockCard = (name, number, position) => ({
  card: name,
  number,
  position,
  orientation: 'Upright',
  meaning: 'Test meaning'
});

const tests = [
  {
    name: 'Three-Card Spread',
    builder: buildThreeCardReading,
    cardsInfo: [
      mockCard('Ace of Wands', 1, 'Past'),
      mockCard('Knight of Wands', 12, 'Present'),
      mockCard('The Magician', 1, 'Future')
    ],
    threeCardAnalysis: {
      transitions: {
        firstToSecond: { relationship: 'amplified', elements: ['Fire', 'Fire'] },
        secondToThird: { relationship: 'supportive', elements: ['Fire', 'Air'] }
      }
    }
  },
  {
    name: 'Five-Card Spread',
    builder: buildFiveCardReading,
    cardsInfo: [
      mockCard('Ace of Wands', 1, 'Core'),
      mockCard('Knight of Wands', 12, 'Challenge'),
      mockCard('The Magician', 1, 'Hidden'),
      mockCard('Two of Wands', 2, 'Support'),
      mockCard('Three of Wands', 3, 'Direction')
    ],
    fiveCardAnalysis: {
      coreVsChallenge: { relationship: 'amplified', elements: ['Fire', 'Fire'] },
      synthesis: 'Test synthesis'
    }
  },
  {
    name: 'Decision Spread',
    builder: buildDecisionReading,
    cardsInfo: [
      mockCard('The Fool', 0, 'Heart'),
      mockCard('Ace of Wands', 1, 'Path A'),
      mockCard('Knight of Wands', 12, 'Path B'),
      mockCard('The Magician', 1, 'Clarifier'),
      mockCard('The Chariot', 7, 'Free Will')
    ]
  },
  {
    name: 'Relationship Spread',
    builder: buildRelationshipReading,
    cardsInfo: [
      mockCard('Ace of Wands', 1, 'You'),
      mockCard('Knight of Wands', 12, 'Them'),
      mockCard('The Magician', 1, 'Connection')
    ]
  },
  // Note: Celtic Cross test skipped due to complex cross-check requirements
  // Elemental remedies work the same way as other spreads
];

let passed = 0;
let failed = 0;

for (const test of tests) {
  console.log(`\n📝 Testing ${test.name}...`);

  try {
    const params = {
      cardsInfo: test.cardsInfo,
      userQuestion: 'Test question about growth',
      reflectionsText: null,
      themes: mockThemes,
      context: 'self',
      ...(test.threeCardAnalysis && { threeCardAnalysis: test.threeCardAnalysis }),
      ...(test.fiveCardAnalysis && { fiveCardAnalysis: test.fiveCardAnalysis }),
      ...(test.celticAnalysis && { celticAnalysis: test.celticAnalysis })
    };

    const reading = await test.builder(params);

    // Check for elemental remedies
    const hasElementalBalance = reading.includes('Fire energy strongly dominates');
    const hasWaterRemedy = /Water:\s*[^\n]+/i.test(reading);
    const hasEarthRemedy = /Earth:\s*[^\n]+/i.test(reading);

    if (!hasElementalBalance) {
      console.log(`   ❌ FAILED: Missing elemental balance description`);
      failed++;
      continue;
    }

    if (!hasWaterRemedy || !hasEarthRemedy) {
      console.log(`   ❌ FAILED: Missing elemental remedies`);
      console.log(`      Water remedy present: ${hasWaterRemedy}`);
      console.log(`      Earth remedy present: ${hasEarthRemedy}`);
      failed++;
      continue;
    }

    console.log(`   ✅ PASSED: Elemental remedies correctly integrated`);
    passed++;

  } catch (error) {
    console.log(`   ❌ FAILED: Error building reading - ${error.message}`);
    console.error(error.stack);
    failed++;
  }
}

console.log(`\n\n📊 Results: ${passed}/${tests.length} spread builders passed`);

if (failed === 0) {
  console.log('✨ All spread builders successfully integrate elemental remedies!');
  console.log('Fire-dominant spreads now provide actionable Water and Earth practices.');
  process.exit(0);
} else {
  console.log(`⚠️  ${failed} spread builder(s) failed`);
  process.exit(1);
}
</file>

<file path="tests/embeddings.test.mjs">
// tests/embeddings.test.mjs
// Tests for embeddings utility module
// Run with: npm test -- tests/embeddings.test.mjs

import { test, describe } from 'node:test';
import assert from 'node:assert/strict';
import {
  cosineSimilarity,
  normalizeVector,
  embedText,
  clearEmbeddingCache,
  getEmbeddingCacheStats
} from '../functions/lib/embeddings.js';

describe('cosineSimilarity', () => {
  test('returns 1 for identical vectors', () => {
    const v = [1, 0, 0, 0];
    const similarity = cosineSimilarity(v, v);
    assert.ok(Math.abs(similarity - 1) < 0.001, 'Identical vectors should have similarity 1');
  });

  test('returns 1 for parallel vectors of different magnitude', () => {
    const a = [1, 2, 3];
    const b = [2, 4, 6]; // Same direction, 2x magnitude
    const similarity = cosineSimilarity(a, b);
    assert.ok(Math.abs(similarity - 1) < 0.001, 'Parallel vectors should have similarity 1');
  });

  test('returns 0 for orthogonal vectors', () => {
    const a = [1, 0, 0];
    const b = [0, 1, 0];
    const similarity = cosineSimilarity(a, b);
    assert.ok(Math.abs(similarity) < 0.001, 'Orthogonal vectors should have similarity 0');
  });

  test('returns 0 for mismatched vector lengths', () => {
    const a = [1, 2, 3];
    const b = [1, 2];
    const similarity = cosineSimilarity(a, b);
    assert.strictEqual(similarity, 0, 'Mismatched lengths should return 0');
  });

  test('returns 0 for empty vectors', () => {
    assert.strictEqual(cosineSimilarity([], []), 0);
  });

  test('returns 0 for null/undefined inputs', () => {
    assert.strictEqual(cosineSimilarity(null, [1, 2]), 0);
    assert.strictEqual(cosineSimilarity([1, 2], null), 0);
    assert.strictEqual(cosineSimilarity(undefined, [1, 2]), 0);
  });

  test('returns 0 for zero vectors', () => {
    const zero = [0, 0, 0];
    const nonzero = [1, 2, 3];
    assert.strictEqual(cosineSimilarity(zero, nonzero), 0, 'Zero vector should return 0');
    assert.strictEqual(cosineSimilarity(zero, zero), 0, 'Two zero vectors should return 0');
  });

  test('clamps result to [0, 1] range', () => {
    // Due to floating point, result should never exceed 1
    const a = [0.1, 0.2, 0.3, 0.4, 0.5];
    const b = [0.1, 0.2, 0.3, 0.4, 0.5];
    const similarity = cosineSimilarity(a, b);
    assert.ok(similarity >= 0 && similarity <= 1, 'Should be in [0, 1] range');
  });

  test('handles negative values correctly', () => {
    const a = [1, -1, 1];
    const b = [1, -1, 1];
    const similarity = cosineSimilarity(a, b);
    assert.ok(Math.abs(similarity - 1) < 0.001, 'Identical vectors with negatives should be 1');
  });
});

describe('normalizeVector', () => {
  test('normalizes to unit length', () => {
    const v = [3, 4]; // Length 5
    const normalized = normalizeVector(v);

    // Check unit length
    const length = Math.sqrt(normalized.reduce((sum, x) => sum + x * x, 0));
    assert.ok(Math.abs(length - 1) < 0.001, 'Normalized vector should have length 1');

    // Check direction preserved
    assert.ok(Math.abs(normalized[0] - 0.6) < 0.001);
    assert.ok(Math.abs(normalized[1] - 0.8) < 0.001);
  });

  test('returns empty array for empty input', () => {
    const result = normalizeVector([]);
    assert.deepStrictEqual(result, []);
  });

  test('returns input for null/undefined', () => {
    assert.strictEqual(normalizeVector(null), null);
    assert.strictEqual(normalizeVector(undefined), undefined);
  });

  test('handles zero vector', () => {
    const zero = [0, 0, 0];
    const result = normalizeVector(zero);
    // Should return original (can't normalize zero vector)
    assert.deepStrictEqual(result, zero);
  });

  test('handles single-element vector', () => {
    const v = [5];
    const normalized = normalizeVector(v);
    assert.ok(Math.abs(normalized[0] - 1) < 0.001, 'Single element should normalize to 1');
  });
});

describe('embedText', () => {
  test('returns array for valid text', async () => {
    const embedding = await embedText('test text');
    assert.ok(Array.isArray(embedding), 'Should return array');
    assert.ok(embedding.length > 0, 'Should have dimensions');
  });

  test('returns consistent embedding for same text (cache)', async () => {
    clearEmbeddingCache();

    const text = 'consistent test text';
    const first = await embedText(text);
    const second = await embedText(text);

    assert.deepStrictEqual(first, second, 'Same text should produce same embedding');
  });

  test('returns fallback embedding for empty text', async () => {
    const embedding = await embedText('');
    assert.ok(Array.isArray(embedding), 'Should return array for empty text');
  });

  test('returns fallback embedding for null/undefined', async () => {
    const nullEmbed = await embedText(null);
    const undefEmbed = await embedText(undefined);

    assert.ok(Array.isArray(nullEmbed), 'Should return array for null');
    assert.ok(Array.isArray(undefEmbed), 'Should return array for undefined');
  });

  test('produces different embeddings for different text', async () => {
    const embed1 = await embedText('love and relationships');
    const embed2 = await embedText('career and money');

    // At least some dimensions should differ
    let hasDifference = false;
    for (let i = 0; i < Math.min(embed1.length, embed2.length); i++) {
      if (Math.abs(embed1[i] - embed2[i]) > 0.001) {
        hasDifference = true;
        break;
      }
    }
    assert.ok(hasDifference, 'Different texts should produce different embeddings');
  });

  test('truncates very long text', async () => {
    const longText = 'word '.repeat(5000); // Very long
    const embedding = await embedText(longText);
    assert.ok(Array.isArray(embedding), 'Should handle long text');
    assert.ok(embedding.length > 0, 'Should produce valid embedding');
  });

  test('detects semantic terms in fallback embedding', async () => {
    // Without API, uses fallback which has semantic term detection
    const loveEmbed = await embedText('love relationships emotional connection', { env: null });
    const careerEmbed = await embedText('career work professional opportunity', { env: null });

    // These should have different semantic fingerprints
    const similarity = cosineSimilarity(loveEmbed, careerEmbed);
    assert.ok(similarity < 0.95, 'Different topics should have lower similarity');
  });

  test('detects tarot terms in fallback embedding', async () => {
    const tarotEmbed = await embedText('fool magician death tower transformation', { env: null });
    const genericEmbed = await embedText('random words without meaning here', { env: null });

    // Tarot-specific terms should produce distinct embedding
    const similarity = cosineSimilarity(tarotEmbed, genericEmbed);
    assert.ok(similarity < 0.9, 'Tarot terms should produce distinct embedding');
  });
});

describe('Embedding Cache', () => {
  test('clearEmbeddingCache clears all entries', async () => {
    // Add something to cache
    await embedText('cache test');

    const beforeClear = getEmbeddingCacheStats();
    assert.ok(beforeClear.size > 0 || true, 'May have cached entries');

    clearEmbeddingCache();

    const afterClear = getEmbeddingCacheStats();
    assert.strictEqual(afterClear.size, 0, 'Cache should be empty after clear');
  });

  test('getEmbeddingCacheStats returns valid stats', () => {
    const stats = getEmbeddingCacheStats();

    assert.ok(typeof stats.size === 'number', 'Should have size');
    assert.ok(typeof stats.maxSize === 'number', 'Should have maxSize');
    assert.ok(stats.size >= 0, 'Size should be non-negative');
    assert.ok(stats.maxSize > 0, 'MaxSize should be positive');
  });

  test('cache respects max size limit', async () => {
    clearEmbeddingCache();

    const stats = getEmbeddingCacheStats();
    const maxSize = stats.maxSize;

    // Add more than max entries
    for (let i = 0; i < maxSize + 10; i++) {
      await embedText(`unique text entry number ${i}`);
    }

    const afterStats = getEmbeddingCacheStats();
    assert.ok(afterStats.size <= maxSize, 'Cache size should not exceed max');
  });
});
</file>

<file path="tests/ephemerisForecastHighlights.test.mjs">
import { describe, it } from 'node:test';
import assert from 'node:assert';
import { formatForecastHighlights } from '../functions/lib/ephemerisIntegration.js';

describe('formatForecastHighlights', () => {
  it('returns empty array when forecast unavailable', () => {
    const result = formatForecastHighlights({ available: false });
    assert.deepStrictEqual(result, []);
  });

  it('limits highlights to maxItems and formats offsets', () => {
    const forecast = {
      available: true,
      events: [
        { description: 'New Moon in Leo', dayOffset: 0 },
        { description: 'Mercury stations direct', dayOffset: 5 },
        { description: 'Full Moon in Aquarius', dayOffset: 14 },
        { description: 'Sun enters Virgo', dayOffset: 23 }
      ],
      currentContext: { retrogrades: [] }
    };

    const result = formatForecastHighlights(forecast, 3);
    assert.strictEqual(result.length, 3);
    assert.ok(result[0].includes('today'));
    assert.ok(result[1].includes('in 5 days'));
  });

  it('adds retrograde context when space remains', () => {
    const forecast = {
      available: true,
      events: [{ description: 'Full Moon in Aries', dayOffset: 2 }],
      currentContext: { retrogrades: [{ planet: 'Mercury' }, { planet: 'Saturn' }] }
    };

    const result = formatForecastHighlights(forecast, 4);
    assert.strictEqual(result.length, 2);
    assert.ok(result[1].includes('Retrogrades'));
  });
});
</file>

<file path="tests/graphContext.test.mjs">
import assert from 'node:assert/strict';
import { describe, it } from 'node:test';

import { buildGraphContext } from '../functions/lib/graphContext.js';

// These tests exercise the small graphContext helper as a stable façade over
// the more complex pattern detectors in knowledgeGraph.js. We keep the
// assertions structural so that future extensions to the underlying
// knowledge graph will not require frequent test rewrites.

describe('graphContext.buildGraphContext', () => {
    it('returns null for missing or empty card arrays', () => {
        assert.strictEqual(buildGraphContext(null), null);
        assert.strictEqual(buildGraphContext(undefined), null);
        assert.strictEqual(buildGraphContext([]), null);
    });

    it('builds Fool\'s Journey context when multiple Majors share a stage', () => {
        const cards = [
            { number: 0, card: 'The Fool' },
            { number: 1, card: 'The Magician' },
            { number: 7, card: 'The Chariot' }
        ];

        const ctx = buildGraphContext(cards, { deckStyle: 'rws-1909' });
        assert.ok(ctx, 'graph context should be returned');
        assert.ok(ctx.patterns, 'patterns should be present');
        assert.ok(ctx.patterns.foolsJourney, 'Fool\'s Journey pattern should be detected');
        assert.strictEqual(
            ctx.patterns.foolsJourney.cardCount,
            3,
            'Fool\'s Journey should count all contributing Majors'
        );

        // Graph keys should include a stable journey stage key for retrieval/training.
        assert.ok(ctx.graphKeys, 'graphKeys should be present');
        assert.strictEqual(ctx.graphKeys.foolsJourneyStageKey, 'initiation');
    });

    it('includes complete triads and their narratives when present', () => {
        // This specific triad (Death–Temperance–Star) is documented in
        // knowledgeGraph.js comments and should be present in ARCHETYPAL_TRIADS.
        const cards = [
            { number: 13, card: 'Death' },
            { number: 14, card: 'Temperance' },
            { number: 17, card: 'The Star' }
        ];

        const ctx = buildGraphContext(cards, { deckStyle: 'rws-1909' });
        assert.ok(ctx, 'graph context should be returned for triad cards');
        assert.ok(ctx.patterns?.triads?.length, 'triads collection should be non-empty');

        const completeTriad = ctx.patterns.triads.find((t) => t.isComplete);
        assert.ok(completeTriad, 'at least one complete triad should be detected');
        assert.ok(
            typeof completeTriad.narrative === 'string' && completeTriad.narrative.length > 0,
            'complete triad should include a narrative string'
        );

        // Graph keys should carry stable triad identifiers.
        assert.ok(Array.isArray(ctx.graphKeys.triadIds), 'triadIds should be an array');
        assert.ok(ctx.graphKeys.triadIds.includes('death-temperance-star'));
        assert.ok(
            Array.isArray(ctx.graphKeys.completeTriadIds) &&
                ctx.graphKeys.completeTriadIds.includes('death-temperance-star'),
            'completeTriadIds should include the full Healing Arc triad id'
        );
    });

    it('always returns narrativeHighlights array with length <= 5', () => {
        const cards = [
            { number: 0, card: 'The Fool' },
            { number: 1, card: 'The Magician' },
            { number: 2, card: 'The High Priestess' },
            { number: 3, card: 'The Empress' },
            { number: 4, card: 'The Emperor' },
            { number: 5, card: 'The Hierophant' },
            { number: 6, card: 'The Lovers' },
            { number: 7, card: 'The Chariot' }
        ];

        const ctx = buildGraphContext(cards, { deckStyle: 'rws-1909' });
        assert.ok(ctx, 'graph context should be returned for rich major spread');
        assert.ok(Array.isArray(ctx.narrativeHighlights), 'narrativeHighlights should be an array');
        assert.ok(
            ctx.narrativeHighlights.length <= 5,
            'narrativeHighlights should be bounded to at most 5 entries'
        );

        // graphKeys should always be present when patterns exist, even if
        // some collections are empty.
        assert.ok(ctx.graphKeys, 'graphKeys should be present when patterns exist');
        assert.ok(Array.isArray(ctx.graphKeys.triadIds), 'triadIds should be an array (possibly empty)');
        assert.ok(Array.isArray(ctx.graphKeys.dyadPairs), 'dyadPairs should be an array (possibly empty)');
    });
});
</file>

<file path="tests/graphRAG.test.mjs">
// tests/graphRAG.test.mjs
// Tests for GraphRAG (Graph-Enhanced Retrieval-Augmented Generation)
// Run with: npm test -- tests/graphRAG.test.mjs

import { test, describe } from 'node:test';
import assert from 'node:assert/strict';
import {
  retrievePassages,
  retrievePassagesWithQuality,
  formatPassagesForPrompt,
  buildRetrievalSummary,
  buildQualityRetrievalSummary,
  scorePassageRelevance,
  deduplicatePassages,
  rankPassagesForPrompt,
  isGraphRAGEnabled,
  isSemanticScoringAvailable,
  getKnowledgeBaseInfo,
  getPassageCountForSpread
} from '../functions/lib/graphRAG.js';
import {
  getPassagesForPattern,
  getKnowledgeBaseStats
} from '../functions/lib/knowledgeBase.js';

describe('GraphRAG Knowledge Base', () => {
  test('getKnowledgeBaseStats returns correct counts', () => {
    const stats = getKnowledgeBaseStats();

    assert.ok(stats.triads > 0, 'Should have triad passages');
    assert.ok(stats.foolsJourneyStages > 0, 'Should have Fool\'s Journey passages');
    assert.ok(stats.dyads > 0, 'Should have dyad passages');
    assert.ok(stats.suitProgressions > 0, 'Should have suit progression passages');
    assert.ok(stats.totalPassages > 0, 'Should have total passages');

    // Verify reasonable coverage
    assert.ok(stats.triads >= 5, 'Should have at least 5 major triads');
    assert.strictEqual(stats.foolsJourneyStages, 3, 'Should have 3 Fool\'s Journey stages');
    assert.ok(stats.dyads >= 6, 'Should have at least 6 dyads');
  });

  test('getPassagesForPattern: triad retrieval', () => {
    const entry = getPassagesForPattern('triad', 'death-temperance-star');

    assert.ok(entry, 'Should retrieve Death-Temperance-Star triad');
    assert.strictEqual(entry.title, 'The Healing Arc');
    assert.strictEqual(entry.theme, 'Ending → Integration → Renewal');
    assert.ok(Array.isArray(entry.passages), 'Should have passages array');
    assert.ok(entry.passages.length > 0, 'Should have at least one passage');
    assert.ok(entry.passages[0].text, 'Passage should have text');
    assert.ok(entry.passages[0].source, 'Passage should have source');
    assert.ok(Array.isArray(entry.passages[0].tags), 'Passage should have tags');
  });

  test('getPassagesForPattern: Fool\'s Journey retrieval', () => {
    const entry = getPassagesForPattern('fools-journey', 'integration');

    assert.ok(entry, 'Should retrieve integration stage');
    assert.ok(entry.title.includes('Integration'));
    assert.strictEqual(entry.stage, 'initiation');
    assert.strictEqual(entry.theme, 'Shadow Work & Transformation');
    assert.ok(entry.passages.length > 0);
  });

  test('getPassagesForPattern: dyad retrieval', () => {
    const entry = getPassagesForPattern('dyad', '13-17');

    assert.ok(entry, 'Should retrieve Death + Star dyad');
    assert.deepStrictEqual(entry.cards, [13, 17]);
    assert.deepStrictEqual(entry.names, ['Death', 'The Star']);
    assert.ok(entry.theme.includes('hope') || entry.theme.includes('transformation'));
    assert.ok(entry.passages.length > 0);
  });

  test('getPassagesForPattern: suit progression retrieval', () => {
    const entry = getPassagesForPattern('suit-progression', 'Wands:beginning');

    assert.ok(entry, 'Should retrieve Wands beginning progression');
    assert.ok(entry.title.includes('Wands'));
    assert.ok(entry.passages.length > 0);
  });

  test('getPassagesForPattern: returns null for unknown pattern', () => {
    const entry = getPassagesForPattern('triad', 'nonexistent-triad-id');
    assert.strictEqual(entry, null);
  });
});

describe('GraphRAG Retrieval', () => {
  test('retrievePassages: complete triad (priority 1)', () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star']
    };

    const passages = retrievePassages(graphKeys, { maxPassages: 5 });

    assert.ok(passages.length > 0, 'Should retrieve passages');
    assert.strictEqual(passages[0].type, 'triad', 'First passage should be triad');
    assert.strictEqual(passages[0].patternId, 'death-temperance-star');
    assert.strictEqual(passages[0].priority, 1, 'Triads should have priority 1');
    assert.ok(passages[0].text, 'Should have text');
    assert.ok(passages[0].source, 'Should have source');
  });

  test('retrievePassages: Fool\'s Journey stage (priority 2)', () => {
    const graphKeys = {
      foolsJourneyStageKey: 'integration'
    };

    const passages = retrievePassages(graphKeys, { maxPassages: 5 });

    assert.ok(passages.length > 0);
    assert.strictEqual(passages[0].type, 'fools-journey');
    assert.strictEqual(passages[0].patternId, 'integration');
    assert.strictEqual(passages[0].priority, 2, 'Journey should have priority 2');
    assert.strictEqual(passages[0].stage, 'initiation');
  });

  test('retrievePassages: high-significance dyad (priority 3)', () => {
    const graphKeys = {
      dyadPairs: [
        { cards: [13, 17], category: 'transformation', significance: 'high' }
      ]
    };

    const passages = retrievePassages(graphKeys, { maxPassages: 5 });

    assert.ok(passages.length > 0);
    assert.strictEqual(passages[0].type, 'dyad');
    assert.strictEqual(passages[0].patternId, '13-17');
    assert.strictEqual(passages[0].priority, 3, 'High dyads should have priority 3');
    assert.deepStrictEqual(passages[0].cardNumbers, [13, 17]);
  });

  test('retrievePassages: filters out low-significance dyads', () => {
    const graphKeys = {
      dyadPairs: [
        { cards: [1, 2], category: 'test', significance: 'low' },
        { cards: [13, 17], category: 'transformation', significance: 'high' }
      ]
    };

    const passages = retrievePassages(graphKeys, { maxPassages: 5 });

    // Should only retrieve the high-significance dyad
    const dyadPassages = passages.filter(p => p.type === 'dyad');
    assert.strictEqual(dyadPassages.length, 1);
    assert.strictEqual(dyadPassages[0].patternId, '13-17');
  });

  test('retrievePassages: suit progression (priority 4)', () => {
    const graphKeys = {
      suitProgressions: [
        { suit: 'Wands', stage: 'beginning', significance: 'strong-progression' }
      ]
    };

    const passages = retrievePassages(graphKeys, { maxPassages: 5 });

    assert.ok(passages.length > 0);
    assert.strictEqual(passages[0].type, 'suit-progression');
    assert.strictEqual(passages[0].suit, 'Wands');
    assert.strictEqual(passages[0].stage, 'beginning');
    assert.strictEqual(passages[0].priority, 4, 'Suit progressions should have priority 4');
  });

  test('retrievePassages: priority ordering', () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star'],
      foolsJourneyStageKey: 'integration',
      dyadPairs: [{ cards: [13, 17], significance: 'high' }],
      suitProgressions: [{ suit: 'Wands', stage: 'beginning', significance: 'strong-progression' }]
    };

    const passages = retrievePassages(graphKeys, { maxPassages: 10 });

    // Verify priority ordering: triads (1) < journey (2) < dyads (3) < suits (4)
    let lastPriority = 0;
    passages.forEach(passage => {
      assert.ok(passage.priority >= lastPriority, 'Priorities should be in ascending order');
      lastPriority = passage.priority;
    });

    // First passage should be triad (priority 1)
    assert.strictEqual(passages[0].priority, 1);
    assert.strictEqual(passages[0].type, 'triad');
  });

  test('retrievePassages: respects maxPassages limit', () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star', 'devil-tower-sun'],
      foolsJourneyStageKey: 'culmination',
      dyadPairs: [
        { cards: [13, 17], significance: 'high' },
        { cards: [16, 19], significance: 'high' }
      ]
    };

    const passages = retrievePassages(graphKeys, { maxPassages: 2 });

    assert.strictEqual(passages.length, 2, 'Should limit to maxPassages');
    // Should get highest priority passages (triads)
    assert.strictEqual(passages[0].priority, 1);
    assert.strictEqual(passages[1].priority, 1);
  });

  test('retrievePassages: handles empty graphKeys gracefully', () => {
    const passages = retrievePassages({}, { maxPassages: 5 });
    assert.strictEqual(passages.length, 0, 'Should return empty array for empty graphKeys');
  });

  test('retrievePassages: handles null/undefined graphKeys', () => {
    assert.strictEqual(retrievePassages(null).length, 0);
    assert.strictEqual(retrievePassages(undefined).length, 0);
  });

  test('retrievePassages: includes metadata when requested', () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star']
    };

    const passages = retrievePassages(graphKeys, {
      maxPassages: 5,
      includeMetadata: true
    });

    assert.ok(passages[0].metadata, 'Should include metadata');
    assert.strictEqual(passages[0].metadata.triadId, 'death-temperance-star');
    assert.strictEqual(passages[0].metadata.isComplete, true);
  });

  test('retrievePassages: reorders based on userQuery keywords', () => {
    // Setup: Journey (P2) usually beats Dyad (P3)
    const graphKeys = {
      foolsJourneyStageKey: 'integration', // Priority 2 ("Shadow Work")
      dyadPairs: [
        { cards: [13, 17], significance: 'high' } // Priority 3 ("Death + Star")
      ]
    };

    // Query matching the Dyad passage ("hope", "star") but not the Journey one
    const query = 'I am looking for hope and the star in my life';
    
    const passages = retrievePassages(graphKeys, { 
      maxPassages: 5,
      userQuery: query 
    });

    assert.ok(passages.length >= 2);
    
    // The Dyad (Priority 3) should be boosted above Journey (Priority 2)
    // because it matches 'hope' and 'star'
    assert.strictEqual(passages[0].type, 'dyad', 'Dyad should be boosted to first position');
    assert.strictEqual(passages[1].type, 'fools-journey', 'Journey should be second');
  });
});

describe('GraphRAG Formatting', () => {
  test('formatPassagesForPrompt: formats passages as markdown', () => {
    const passages = [
      {
        priority: 1,
        type: 'triad',
        title: 'The Healing Arc',
        text: 'Death clears away what must die...',
        source: 'Rachel Pollack, Seventy-Eight Degrees of Wisdom'
      }
    ];

    const formatted = formatPassagesForPrompt(passages, {
      includeSource: true,
      markdown: true
    });

    assert.ok(formatted.includes('**Retrieved Wisdom from Tarot Tradition:**'));
    assert.ok(formatted.includes('**The Healing Arc**'));
    assert.ok(formatted.includes('"Death clears away what must die..."'));
    assert.ok(formatted.includes('— Rachel Pollack'));
  });

  test('formatPassagesForPrompt: plain text format', () => {
    const passages = [
      {
        priority: 1,
        type: 'triad',
        title: 'The Healing Arc',
        text: 'Death clears away...',
        source: 'Test Source'
      }
    ];

    const formatted = formatPassagesForPrompt(passages, {
      includeSource: true,
      markdown: false
    });

    assert.ok(formatted.includes('Retrieved Wisdom from Tarot Tradition:'));
    assert.ok(!formatted.includes('**'), 'Should not include markdown formatting');
    assert.ok(formatted.includes('(Source: Test Source)'));
  });

  test('formatPassagesForPrompt: omits source when requested', () => {
    const passages = [
      {
        priority: 1,
        type: 'triad',
        title: 'Test',
        text: 'Test text',
        source: 'Should not appear'
      }
    ];

    const formatted = formatPassagesForPrompt(passages, {
      includeSource: false,
      markdown: true
    });

    assert.ok(!formatted.includes('Should not appear'));
    assert.ok(!formatted.includes('—'));
  });

  test('formatPassagesForPrompt: handles empty array', () => {
    const formatted = formatPassagesForPrompt([]);
    assert.strictEqual(formatted, '', 'Should return empty string for empty array');
  });

  test('formatPassagesForPrompt: numbers passages correctly', () => {
    const passages = [
      { priority: 1, title: 'First', text: 'Text 1' },
      { priority: 2, title: 'Second', text: 'Text 2' },
      { priority: 3, title: 'Third', text: 'Text 3' }
    ];

    const formatted = formatPassagesForPrompt(passages);

    assert.ok(formatted.includes('1. **First**'));
    assert.ok(formatted.includes('2. **Second**'));
    assert.ok(formatted.includes('3. **Third**'));
  });
});

describe('GraphRAG Utilities', () => {
  test('buildRetrievalSummary: creates complete summary', () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star'],
      triadIds: ['death-temperance-star', 'hermit-hangedman-moon'],
      foolsJourneyStageKey: 'integration',
      dyadPairs: [
        { cards: [13, 17], significance: 'high' },
        { cards: [1, 2], significance: 'moderate' }
      ],
      suitProgressions: [
        { suit: 'Wands', significance: 'strong-progression' },
        { suit: 'Cups', significance: 'weak-signal' }
      ]
    };

    const passages = [
      { type: 'triad', priority: 1 },
      { type: 'fools-journey', priority: 2 },
      { type: 'dyad', priority: 3 }
    ];

    const summary = buildRetrievalSummary(graphKeys, passages);

    assert.strictEqual(summary.graphKeysProvided, true);
    assert.strictEqual(summary.patternsDetected.completeTriads, 1);
    assert.strictEqual(summary.patternsDetected.partialTriads, 1);
    assert.strictEqual(summary.patternsDetected.foolsJourneyStage, 'integration');
    assert.strictEqual(summary.patternsDetected.highDyads, 1);
    assert.strictEqual(summary.patternsDetected.strongSuitProgressions, 1);
    assert.strictEqual(summary.passagesRetrieved, 3);
    assert.strictEqual(summary.passagesByType.triad, 1);
    assert.strictEqual(summary.passagesByType['fools-journey'], 1);
    assert.strictEqual(summary.passagesByType.dyad, 1);
  });

  test('buildRetrievalSummary: handles empty inputs', () => {
    const summary = buildRetrievalSummary(null, []);

    assert.strictEqual(summary.graphKeysProvided, false);
    assert.strictEqual(summary.passagesRetrieved, 0);
  });

  test('isGraphRAGEnabled: returns boolean', () => {
    const enabled = isGraphRAGEnabled();
    assert.strictEqual(typeof enabled, 'boolean');
  });

  test('getKnowledgeBaseInfo: returns stats', () => {
    const info = getKnowledgeBaseInfo();
    assert.ok(info.triads > 0);
    assert.ok(info.totalPassages > 0);
  });
});

describe('GraphRAG Passage Ranking', () => {
  test('rankPassagesForPrompt prioritizes semantic relevance scores', () => {
    const passages = [
      { title: 'A', relevanceScore: 0.35, priority: 2 },
      { title: 'B', relevanceScore: 0.91, priority: 3 },
      { title: 'C', relevanceScore: 0.62, priority: 1 }
    ];

    const { passages: ranked, strategy } = rankPassagesForPrompt(passages);

    assert.strictEqual(strategy, 'semantic');
    assert.strictEqual(ranked.length, 3);
    assert.strictEqual(ranked[0].title, 'B', 'Highest semantic score should lead');
    assert.strictEqual(ranked[1].title, 'C');
    assert.strictEqual(ranked[2].title, 'A');
  });

  test('rankPassagesForPrompt falls back to keyword relevance', () => {
    const passages = [
      { title: 'A', relevance: 1, priority: 2 },
      { title: 'B', relevance: 4, priority: 5 },
      { title: 'C', relevance: 3, priority: 1 }
    ];

    const { passages: ranked, strategy } = rankPassagesForPrompt(passages, { limit: 2 });

    assert.strictEqual(strategy, 'keyword');
    assert.strictEqual(ranked.length, 2, 'Limit should be enforced');
    assert.strictEqual(ranked[0].title, 'B');
    assert.strictEqual(ranked[1].title, 'C');
  });

  test('rankPassagesForPrompt uses priority ordering when scores missing', () => {
    const passages = [
      { title: 'A', priority: 3 },
      { title: 'B', priority: 1 },
      { title: 'C', priority: 2 }
    ];

    const { passages: ranked, strategy } = rankPassagesForPrompt(passages);

    assert.strictEqual(strategy, 'priority');
    assert.strictEqual(ranked[0].title, 'B');
    assert.strictEqual(ranked[1].title, 'C');
    assert.strictEqual(ranked[2].title, 'A');
  });
});

describe('GraphRAG Quality Filtering', () => {
  test('scorePassageRelevance: returns neutral score for empty inputs', async () => {
    const score1 = await scorePassageRelevance('', 'test query');
    const score2 = await scorePassageRelevance('test passage', '');
    const score3 = await scorePassageRelevance(null, 'test');
    const score4 = await scorePassageRelevance('test', null);

    assert.strictEqual(score1, 0.5, 'Should return 0.5 for empty passage');
    assert.strictEqual(score2, 0.5, 'Should return 0.5 for empty query');
    assert.strictEqual(score3, 0.5, 'Should return 0.5 for null passage');
    assert.strictEqual(score4, 0.5, 'Should return 0.5 for null query');
  });

  test('scorePassageRelevance: keyword matching increases score', async () => {
    const passage = 'The Fool represents new beginnings, adventure, and taking a leap of faith.';
    const matchingQuery = 'What does this new beginning mean for my adventure?';
    const nonMatchingQuery = 'How can I handle my career finances?';

    const matchScore = await scorePassageRelevance(passage, matchingQuery, {
      enableSemanticScoring: false
    });
    const nonMatchScore = await scorePassageRelevance(passage, nonMatchingQuery, {
      enableSemanticScoring: false
    });

    assert.ok(matchScore > nonMatchScore, 'Matching keywords should produce higher score');
    assert.ok(matchScore > 0, 'Matching query should have positive score');
  });

  test('scorePassageRelevance: respects keyword/semantic weights', async () => {
    const passage = 'Death transformation endings renewal cycle change.';
    const query = 'death endings transformation';

    const keywordHeavy = await scorePassageRelevance(passage, query, {
      keywordWeight: 0.9,
      semanticWeight: 0.1,
      enableSemanticScoring: false
    });

    const balanced = await scorePassageRelevance(passage, query, {
      keywordWeight: 0.5,
      semanticWeight: 0.5,
      enableSemanticScoring: false
    });

    // With semantic scoring disabled, semantic component is 0.5 (neutral)
    // So different weights should produce different total scores
    assert.ok(typeof keywordHeavy === 'number', 'Should return number');
    assert.ok(typeof balanced === 'number', 'Should return number');
    assert.ok(keywordHeavy >= 0 && keywordHeavy <= 1, 'Score should be between 0 and 1');
  });

  test('deduplicatePassages: removes duplicate passages', () => {
    const passages = [
      { text: 'The Fool represents new beginnings and adventure.', title: 'First' },
      { text: 'The Fool represents new beginnings and adventure.', title: 'Duplicate' },
      { text: 'Death signifies transformation and endings.', title: 'Different' }
    ];

    const deduped = deduplicatePassages(passages);

    assert.strictEqual(deduped.length, 2, 'Should remove duplicate');
    assert.strictEqual(deduped[0].title, 'First', 'Should keep first occurrence');
    assert.strictEqual(deduped[1].title, 'Different', 'Should keep unique passage');
  });

  test('deduplicatePassages: handles empty array', () => {
    const deduped = deduplicatePassages([]);
    assert.strictEqual(deduped.length, 0, 'Should return empty array');
  });

  test('deduplicatePassages: handles passages without text', () => {
    const passages = [
      { title: 'No text field' },
      { text: 'Valid text', title: 'Has text' }
    ];

    const deduped = deduplicatePassages(passages);
    assert.strictEqual(deduped.length, 2, 'Should preserve passages without text');
  });

  test('deduplicatePassages: uses configurable fingerprint length', () => {
    const passages = [
      { text: 'Short prefix but different ending one.', title: 'First' },
      { text: 'Short prefix but different ending two.', title: 'Second' }
    ];

    // With short fingerprint (15 chars), these would be considered duplicates
    const shortFingerprint = deduplicatePassages(passages, { fingerprintLength: 15 });
    // With long fingerprint (100 chars), they're unique
    const longFingerprint = deduplicatePassages(passages, { fingerprintLength: 100 });

    assert.strictEqual(shortFingerprint.length, 1, 'Short fingerprint should detect as duplicates');
    assert.strictEqual(longFingerprint.length, 2, 'Long fingerprint should preserve unique passages');
  });

  test('retrievePassagesWithQuality: returns scored passages', async () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star']
    };

    const passages = await retrievePassagesWithQuality(graphKeys, {
      maxPassages: 3,
      userQuery: 'healing and transformation',
      enableSemanticScoring: false,
      minRelevanceScore: 0
    });

    assert.ok(passages.length > 0, 'Should retrieve passages');
    passages.forEach(passage => {
      assert.ok(typeof passage.relevanceScore === 'number', 'Each passage should have relevanceScore');
      assert.ok(passage.relevanceScore >= 0 && passage.relevanceScore <= 1, 'Score should be between 0 and 1');
    });
  });

  test('retrievePassagesWithQuality: filters by minimum score threshold', async () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star'],
      dyadPairs: [{ cards: [13, 17], significance: 'high' }]
    };

    const lowThreshold = await retrievePassagesWithQuality(graphKeys, {
      maxPassages: 10,
      userQuery: 'xyz123 unrelated query',
      enableSemanticScoring: false,
      minRelevanceScore: 0
    });

    const highThreshold = await retrievePassagesWithQuality(graphKeys, {
      maxPassages: 10,
      userQuery: 'xyz123 unrelated query',
      enableSemanticScoring: false,
      minRelevanceScore: 0.9
    });

    // With very high threshold and unrelated query, should filter out more
    assert.ok(lowThreshold.length >= highThreshold.length,
      'Higher threshold should filter out more passages');
  });

  test('retrievePassagesWithQuality: sorts by relevance score', async () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star'],
      foolsJourneyStageKey: 'integration'
    };

    const passages = await retrievePassagesWithQuality(graphKeys, {
      maxPassages: 5,
      userQuery: 'transformation healing shadow work',
      enableSemanticScoring: false,
      minRelevanceScore: 0
    });

    if (passages.length >= 2) {
      for (let i = 0; i < passages.length - 1; i++) {
        assert.ok(
          passages[i].relevanceScore >= passages[i + 1].relevanceScore,
          'Passages should be sorted by relevance score (descending)'
        );
      }
    }
  });

  test('retrievePassagesWithQuality: applies deduplication when enabled', async () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star']
    };

    const withDedup = await retrievePassagesWithQuality(graphKeys, {
      maxPassages: 10,
      userQuery: 'test',
      enableDeduplication: true,
      minRelevanceScore: 0
    });

    const withoutDedup = await retrievePassagesWithQuality(graphKeys, {
      maxPassages: 10,
      userQuery: 'test',
      enableDeduplication: false,
      minRelevanceScore: 0
    });

    // Results should be at least as filtered with dedup enabled
    assert.ok(withDedup.length <= withoutDedup.length + 1,
      'Deduplication should not increase passage count');
  });

  test('retrievePassagesWithQuality: handles empty graphKeys', async () => {
    const passages = await retrievePassagesWithQuality({}, {
      maxPassages: 5,
      userQuery: 'test'
    });

    assert.strictEqual(passages.length, 0, 'Should return empty array for empty graphKeys');
  });

  test('buildQualityRetrievalSummary: includes quality metrics', () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star']
    };

    const passages = [
      { type: 'triad', priority: 1, relevanceScore: 0.8 },
      { type: 'dyad', priority: 3, relevanceScore: 0.6 },
      { type: 'fools-journey', priority: 2, relevanceScore: 0.7 }
    ];

    const summary = buildQualityRetrievalSummary(graphKeys, passages);

    assert.ok(summary.qualityMetrics, 'Summary should include qualityMetrics');
    assert.ok(typeof summary.qualityMetrics.averageRelevance === 'number',
      'Should have averageRelevance');
    assert.ok(typeof summary.qualityMetrics.minRelevance === 'number',
      'Should have minRelevance');
    assert.ok(typeof summary.qualityMetrics.maxRelevance === 'number',
      'Should have maxRelevance');
    
    // Verify calculations
    const expectedAvg = (0.8 + 0.6 + 0.7) / 3;
    assert.ok(Math.abs(summary.qualityMetrics.averageRelevance - expectedAvg) < 0.001,
      'Average relevance should be calculated correctly');
    assert.strictEqual(summary.qualityMetrics.minRelevance, 0.6,
      'Min relevance should be correct');
    assert.strictEqual(summary.qualityMetrics.maxRelevance, 0.8,
      'Max relevance should be correct');
  });

  test('buildQualityRetrievalSummary: handles passages without scores', () => {
    const summary = buildQualityRetrievalSummary({}, [
      { type: 'triad', priority: 1 }, // No relevanceScore
      { type: 'dyad', priority: 3 }
    ]);

    assert.ok(summary.qualityMetrics, 'Should still include qualityMetrics object');
    assert.strictEqual(summary.qualityMetrics.averageRelevance, 0,
      'Average should be 0 when no scores present');
  });

  test('isSemanticScoringAvailable: checks for API configuration', () => {
    // Without env, should return false
    const withoutEnv = isSemanticScoringAvailable(null);
    assert.strictEqual(withoutEnv, false, 'Should return false without env');

    // With partial config, should return false
    const partialConfig = isSemanticScoringAvailable({
      AZURE_OPENAI_ENDPOINT: 'https://test.openai.azure.com'
    });
    assert.strictEqual(partialConfig, false, 'Should return false with partial config');

    // With full config, should return true
    const fullConfig = isSemanticScoringAvailable({
      AZURE_OPENAI_ENDPOINT: 'https://test.openai.azure.com',
      AZURE_OPENAI_API_KEY: 'test-key'
    });
    assert.strictEqual(fullConfig, true, 'Should return true with full config');
  });
});

describe('GraphRAG Integration Test', () => {
  test('Full GraphRAG flow: Death-Temperance-Star spread', () => {
    // Simulate graphKeys from a Death-Temperance-Star spread
    const graphKeys = {
      completeTriadIds: ['death-temperance-star'],
      triadIds: ['death-temperance-star'],
      foolsJourneyStageKey: 'integration',
      foolsJourneyStage: 'initiation',
      dyadPairs: [
        { cards: [13, 17], category: 'transformation', significance: 'high' }
      ],
      suitProgressions: [],
      courtLineages: []
    };

    // Step 1: Retrieve passages
    const passages = retrievePassages(graphKeys, { maxPassages: 3 });

    assert.ok(passages.length > 0, 'Should retrieve passages');
    assert.ok(passages.length <= 3, 'Should respect max limit');

    // Step 2: Verify priority ordering
    assert.strictEqual(passages[0].type, 'triad', 'Highest priority should be triad');
    assert.strictEqual(passages[0].title, 'The Healing Arc');

    // Step 3: Format for prompt
    const formatted = formatPassagesForPrompt(passages);

    assert.ok(formatted.length > 0, 'Should produce formatted output');
    assert.ok(formatted.includes('Retrieved Wisdom'), 'Should include header');
    assert.ok(formatted.includes('Healing Arc'), 'Should include triad title');

    // Step 4: Build summary
    const summary = buildRetrievalSummary(graphKeys, passages);

    assert.strictEqual(summary.patternsDetected.completeTriads, 1);
    assert.ok(summary.passagesRetrieved >= 1);
  });

  test('Full GraphRAG flow: Mixed Major spread (Journey + Dyads)', () => {
    const graphKeys = {
      completeTriadIds: [],
      triadIds: [],
      foolsJourneyStageKey: 'culmination',
      foolsJourneyStage: 'return',
      dyadPairs: [
        { cards: [15, 16], category: 'challenge', significance: 'high' },
        { cards: [16, 19], category: 'transformation', significance: 'high' }
      ],
      suitProgressions: [],
      courtLineages: []
    };

    const passages = retrievePassages(graphKeys, { maxPassages: 5 });

    // Should retrieve Journey + dyads
    assert.ok(passages.length >= 2, 'Should retrieve multiple passage types');

    const journeyPassages = passages.filter(p => p.type === 'fools-journey');
    const dyadPassages = passages.filter(p => p.type === 'dyad');

    assert.ok(journeyPassages.length > 0, 'Should include Journey passages');
    assert.ok(dyadPassages.length > 0, 'Should include dyad passages');

    // Journey should come before dyads (priority 2 < priority 3)
    if (passages.length >= 2) {
      const firstJourney = passages.findIndex(p => p.type === 'fools-journey');
      const firstDyad = passages.findIndex(p => p.type === 'dyad');
      if (firstJourney !== -1 && firstDyad !== -1) {
        assert.ok(firstJourney < firstDyad, 'Journey should precede dyads');
      }
    }
  });

  test('Full GraphRAG flow with quality filtering', async () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star'],
      foolsJourneyStageKey: 'integration',
      dyadPairs: [
        { cards: [13, 17], category: 'transformation', significance: 'high' }
      ]
    };

    // Step 1: Retrieve with quality filtering
    const passages = await retrievePassagesWithQuality(graphKeys, {
      maxPassages: 3,
      userQuery: 'How do I heal from this ending?',
      enableSemanticScoring: false,
      minRelevanceScore: 0.1,
      enableDeduplication: true
    });

    assert.ok(passages.length > 0, 'Should retrieve passages');
    assert.ok(passages.length <= 3, 'Should respect max limit');

    // Verify all passages have relevance scores
    passages.forEach(p => {
      assert.ok(typeof p.relevanceScore === 'number', 'Each passage should have score');
    });

    // Step 2: Verify sorted by relevance
    if (passages.length >= 2) {
      assert.ok(passages[0].relevanceScore >= passages[1].relevanceScore,
        'Should be sorted by relevance');
    }

    // Step 3: Build quality summary
    const summary = buildQualityRetrievalSummary(graphKeys, passages);

    assert.ok(summary.qualityMetrics, 'Summary should have quality metrics');
    assert.ok(summary.passagesRetrieved > 0, 'Should report passages retrieved');
    assert.ok(summary.qualityMetrics.averageRelevance > 0,
      'Should have non-zero average relevance for matching query');
  });
});

// ============================================================================
// GAP COVERAGE: getPassageCountForSpread
// ============================================================================

describe('getPassageCountForSpread', () => {
  test('returns correct count for single spread', () => {
    assert.strictEqual(getPassageCountForSpread('single'), 1);
  });

  test('returns correct count for threeCard spread', () => {
    assert.strictEqual(getPassageCountForSpread('threeCard'), 2);
  });

  test('returns correct count for fiveCard spread', () => {
    assert.strictEqual(getPassageCountForSpread('fiveCard'), 3);
  });

  test('returns correct count for celtic spread', () => {
    assert.strictEqual(getPassageCountForSpread('celtic'), 5);
  });

  test('returns correct count for decision spread', () => {
    assert.strictEqual(getPassageCountForSpread('decision'), 3);
  });

  test('returns correct count for relationship spread', () => {
    assert.strictEqual(getPassageCountForSpread('relationship'), 2);
  });

  test('returns general fallback (3) for unknown spread key', () => {
    assert.strictEqual(getPassageCountForSpread('unknownSpread'), 3);
    assert.strictEqual(getPassageCountForSpread('customSpread'), 3);
  });

  test('returns general fallback (3) for undefined/null', () => {
    assert.strictEqual(getPassageCountForSpread(undefined), 3);
    assert.strictEqual(getPassageCountForSpread(null), 3);
  });

  test('returns general fallback (3) for empty string', () => {
    assert.strictEqual(getPassageCountForSpread(''), 3);
  });
});

// ============================================================================
// GAP COVERAGE: Keyword Boost Edge Cases
// ============================================================================

describe('Keyword Boost Edge Cases', () => {
  test('retrievePassages: handles all-stopword query (no boost applied)', () => {
    const graphKeys = {
      foolsJourneyStageKey: 'integration',
      dyadPairs: [{ cards: [13, 17], significance: 'high' }]
    };

    // All words are stopwords or too short
    const passages = retrievePassages(graphKeys, {
      maxPassages: 5,
      userQuery: 'what is this about?'
    });

    // Should still retrieve, just with no keyword boost
    assert.ok(passages.length >= 2, 'Should retrieve passages without keyword boost');
    // Default priority order should be preserved (journey P2 before dyad P3)
    assert.strictEqual(passages[0].type, 'fools-journey', 'Journey should be first without boost');
  });

  test('retrievePassages: handles short-words-only query', () => {
    const graphKeys = {
      foolsJourneyStageKey: 'initiation',
      completeTriadIds: ['death-temperance-star']
    };

    // All words are 3 chars or less
    const passages = retrievePassages(graphKeys, {
      maxPassages: 5,
      userQuery: 'how can I do it now?'
    });

    assert.ok(passages.length > 0, 'Should retrieve passages');
    // Default priority preserved (triad P1 first)
    assert.strictEqual(passages[0].type, 'triad', 'Triad should be first');
  });

  test('retrievePassages: handles mixed case query', () => {
    const graphKeys = {
      foolsJourneyStageKey: 'integration',
      dyadPairs: [{ cards: [13, 17], significance: 'high' }]
    };

    // Mixed case - should match case-insensitively
    const passagesLower = retrievePassages(graphKeys, {
      maxPassages: 5,
      userQuery: 'transformation hope healing'
    });

    const passagesUpper = retrievePassages(graphKeys, {
      maxPassages: 5,
      userQuery: 'TRANSFORMATION HOPE HEALING'
    });

    // Both should produce same relevance boosting
    assert.strictEqual(passagesLower[0].type, passagesUpper[0].type,
      'Case should not affect ranking');
  });

  test('retrievePassages: handles empty query string', () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star'],
      foolsJourneyStageKey: 'integration'
    };

    const passages = retrievePassages(graphKeys, {
      maxPassages: 5,
      userQuery: ''
    });

    assert.ok(passages.length > 0, 'Should retrieve passages with empty query');
    // Default priority ordering preserved
    assert.strictEqual(passages[0].priority, 1, 'Should maintain priority order');
  });

  test('retrievePassages: filters tarot-specific stopwords', () => {
    const graphKeys = {
      foolsJourneyStageKey: 'integration',
      dyadPairs: [{ cards: [13, 17], significance: 'high' }]
    };

    // "card" and "reading" are filtered as stopwords
    const passages = retrievePassages(graphKeys, {
      maxPassages: 5,
      userQuery: 'card reading interpretation'
    });

    // Only "interpretation" should contribute to boost (if it matches)
    // Journey (P2) should still come before dyad (P3) without strong boost
    assert.ok(passages.length >= 2, 'Should retrieve passages');
  });

  test('retrievePassages: special characters in query handled', () => {
    const graphKeys = {
      completeTriadIds: ['death-temperance-star']
    };

    // Contractions and punctuation
    const passages = retrievePassages(graphKeys, {
      maxPassages: 3,
      userQuery: "what's the meaning? I'm seeking transformation..."
    });

    assert.ok(passages.length > 0, 'Should handle special characters');
    // "meaning", "seeking", "transformation" should be extracted
  });
});

// ============================================================================
// GAP COVERAGE: Malformed Knowledge Base Data Handling
// ============================================================================

describe('Malformed Data Handling', () => {
  test('formatPassagesForPrompt: handles passage without text field', () => {
    const passages = [
      { priority: 1, title: 'Test Title', source: 'Test Source' }
      // Note: no 'text' field
    ];

    const formatted = formatPassagesForPrompt(passages);

    assert.ok(formatted.includes('Test Title'), 'Should include title');
    assert.ok(!formatted.includes('undefined'), 'Should not output "undefined"');
  });

  test('formatPassagesForPrompt: handles passage without source field', () => {
    const passages = [
      { priority: 1, title: 'Test Title', text: 'Test text content' }
      // Note: no 'source' field
    ];

    const formatted = formatPassagesForPrompt(passages, { includeSource: true });

    assert.ok(formatted.includes('Test text content'), 'Should include text');
    assert.ok(!formatted.includes('— null'), 'Should not output "— null"');
    assert.ok(!formatted.includes('— undefined'), 'Should not output "— undefined"');
  });

  test('formatPassagesForPrompt: handles passage without title or theme', () => {
    const passages = [
      { priority: 1, text: 'Just text, no title', source: 'Source' }
    ];

    const formatted = formatPassagesForPrompt(passages);

    // Should not crash, text should still appear
    assert.ok(formatted.includes('Just text, no title'), 'Should include text');
  });

  test('deduplicatePassages: handles null passage in array', () => {
    const passages = [
      { text: 'Valid passage one', title: 'First' },
      null,
      { text: 'Valid passage two', title: 'Second' }
    ];

    const deduped = deduplicatePassages(passages);

    // Should preserve valid passages and handle null gracefully
    assert.ok(deduped.length >= 2, 'Should preserve valid passages');
  });

  test('buildRetrievalSummary: handles graphKeys with undefined arrays', () => {
    const graphKeys = {
      completeTriadIds: undefined,
      triadIds: undefined,
      dyadPairs: undefined,
      suitProgressions: undefined
    };

    const summary = buildRetrievalSummary(graphKeys, []);

    assert.strictEqual(summary.patternsDetected.completeTriads, 0);
    assert.strictEqual(summary.patternsDetected.highDyads, 0);
    assert.strictEqual(summary.patternsDetected.strongSuitProgressions, 0);
  });
});
</file>

<file path="tests/intentionCoach.determinism.test.mjs">
import { describe, it } from 'node:test';
import assert from 'node:assert';
import { buildGuidedQuestion, buildLocalCreativeQuestion } from '../src/lib/intentionCoach.js';

describe('Question Generation Determinism', () => {
  describe('buildGuidedQuestion with seed', () => {
    it('should produce identical output for same inputs with seed', () => {
      const params = {
        topic: 'relationships',
        timeframe: 'week',
        depth: 'guided',
        customFocus: 'my partnership',
        seed: 'test-seed-123'
      };

      const question1 = buildGuidedQuestion(params);
      const question2 = buildGuidedQuestion(params);
      const question3 = buildGuidedQuestion(params);

      assert.strictEqual(question1, question2, 'First and second calls should match');
      assert.strictEqual(question2, question3, 'Second and third calls should match');
      assert.strictEqual(question1, question3, 'First and third calls should match');
    });

    it('should produce different output for different seeds', () => {
      const baseParams = {
        topic: 'relationships',
        timeframe: 'week',
        depth: 'guided',
        customFocus: 'my partnership'
      };

      const question1 = buildGuidedQuestion({ ...baseParams, seed: 'seed-A' });
      const question2 = buildGuidedQuestion({ ...baseParams, seed: 'seed-B' });
      const question3 = buildGuidedQuestion({ ...baseParams, seed: 'seed-C' });

      // With 3 variants in navigate pattern, we have ~89% chance of at least 2 being different
      const uniqueQuestions = new Set([question1, question2, question3]);
      assert.ok(uniqueQuestions.size >= 2, 'Different seeds should produce different questions');
    });

    it('should be reproducible across all depth patterns', () => {
      const depths = ['pulse', 'guided', 'lesson', 'deep'];
      const seed = 'reproducibility-test';

      depths.forEach(depth => {
        const params = {
          topic: 'growth',
          timeframe: 'month',
          depth,
          customFocus: 'my spiritual practice',
          seed
        };

        const question1 = buildGuidedQuestion(params);
        const question2 = buildGuidedQuestion(params);

        assert.strictEqual(
          question1,
          question2,
          `Depth pattern '${depth}' should be reproducible`
        );
      });
    });

    it('should work without seed (backward compatibility)', () => {
      const params = {
        topic: 'career',
        timeframe: 'today',
        depth: 'pulse',
        customFocus: 'my work'
        // No seed provided - should use legacy time-based randomization
      };

      const question1 = buildGuidedQuestion(params);
      const question2 = buildGuidedQuestion(params);

      assert.ok(typeof question1 === 'string', 'Should return a string');
      assert.ok(question1.endsWith('?'), 'Should end with question mark');
      assert.ok(question1.length > 10, 'Should be a reasonable length');

      // Without seed, questions MIGHT be different (time-based)
      // We just verify they're both valid questions
      assert.ok(typeof question2 === 'string', 'Second call should also return a string');
    });

    it('should handle seed as number', () => {
      const params = {
        topic: 'wellbeing',
        timeframe: 'week',
        depth: 'guided',
        customFocus: 'my energy levels'
      };

      const question1 = buildGuidedQuestion({ ...params, seed: 12345 });
      const question2 = buildGuidedQuestion({ ...params, seed: 12345 });

      assert.strictEqual(question1, question2, 'Numeric seeds should work');
    });

    it('should produce valid questions for all topic/depth combinations', () => {
      const topics = ['relationships', 'career', 'wellbeing', 'growth', 'decision', 'abundance'];
      const depths = ['pulse', 'guided', 'lesson', 'deep'];
      const seed = 'comprehensive-test';

      topics.forEach(topic => {
        depths.forEach(depth => {
          const params = {
            topic,
            timeframe: 'week',
            depth,
            seed
          };

          const question = buildGuidedQuestion(params);

          assert.ok(typeof question === 'string', `${topic}/${depth} should return string`);
          assert.ok(question.endsWith('?'), `${topic}/${depth} should end with ?`);
          assert.ok(question.length > 15, `${topic}/${depth} should be meaningful length`);
          assert.ok(!question.includes('undefined'), `${topic}/${depth} should not contain undefined`);
        });
      });
    });

    it('should integrate customFocus into seed for variant selection', () => {
      const baseParams = {
        topic: 'relationships',
        timeframe: 'week',
        depth: 'guided',
        seed: 'same-seed'
      };

      const question1 = buildGuidedQuestion({ ...baseParams, customFocus: 'my partner' });
      const question2 = buildGuidedQuestion({ ...baseParams, customFocus: 'my family' });

      // Different customFocus may produce different variants even with same seed
      // (because focus is mixed into the seed hash)
      assert.ok(typeof question1 === 'string', 'Question1 should be valid');
      assert.ok(typeof question2 === 'string', 'Question2 should be valid');
    });
  });

  describe('Determinism verification', () => {
    it('should produce same question 100 times with same seed', () => {
      const params = {
        topic: 'growth',
        timeframe: 'season',
        depth: 'deep',
        customFocus: 'my transformation',
        seed: 'consistency-test'
      };

      const firstQuestion = buildGuidedQuestion(params);
      const questions = Array.from({ length: 100 }, () => buildGuidedQuestion(params));

      assert.ok(questions.every(q => q === firstQuestion), 'All 100 calls should produce identical output');
    });

    it('should respect grammar fixes in navigate pattern', () => {
      const params = {
        topic: 'career',
        timeframe: 'month',
        depth: 'guided',  // navigate pattern
        seed: 'grammar-test'
      };

      const question = buildGuidedQuestion(params);

      // After grammar fix, should not have awkward "navigate stay aligned" phrasing
      assert.ok(
        !question.includes('navigate stay aligned'),
        'Should not have old awkward grammar'
      );

      // Should have proper grammar (either variant works)
      const hasProperGrammar =
        question.includes('How can I navigate') ||
        question.includes('How can I stay aligned') ||
        question.includes('How can I make progress') ||
        question.includes('What next step would move') ||
        question.includes('What should I prioritize');

      assert.ok(hasProperGrammar, 'Should use proper grammar construction');
    });
  });

  describe('Creative fallback templates', () => {
    it('should include timeframe and closing when using creative fallback templates', () => {
      const question = buildLocalCreativeQuestion({
        focus: 'my career pivot',
        timeframePhrase: 'over the next month',
        depthLabel: 'Deep dive',
        pattern: 'transform',
        closing: 'honor my growth',
        topicLabel: 'Career & Purpose',
        seed: 'creative-tone-check'
      });

      assert.ok(question.includes('over the next month'), 'Should include timeframe phrasing');
      assert.ok(question.includes('honor my growth'), 'Should include depth-based closing');
      assert.ok(question.endsWith('?'), 'Should end with a question mark');
    });

    it('should remain deterministic yet vary across different seeds', () => {
      const baseParams = {
        focus: 'my relationships',
        timeframePhrase: 'this week',
        depthLabel: 'Focused guidance',
        pattern: 'navigate',
        closing: 'with confidence',
        topicLabel: 'Love & Relationships'
      };

      const sameSeedQuestionA = buildLocalCreativeQuestion({ ...baseParams, seed: 'seed-creative-A' });
      const sameSeedQuestionB = buildLocalCreativeQuestion({ ...baseParams, seed: 'seed-creative-A' });
      const differentSeedQuestion1 = buildLocalCreativeQuestion({ ...baseParams, seed: 'seed-creative-B' });
      const differentSeedQuestion2 = buildLocalCreativeQuestion({ ...baseParams, seed: 'seed-creative-C' });

      assert.strictEqual(sameSeedQuestionA, sameSeedQuestionB, 'Same seed should be deterministic');
      const uniqueVariants = new Set([sameSeedQuestionA, differentSeedQuestion1, differentSeedQuestion2]);
      assert.ok(uniqueVariants.size >= 2, 'Different seeds should produce variety');
    });
  });
});
</file>

<file path="tests/intentionCoach.journalIntegration.test.mjs">
import { describe, it } from 'node:test';
import assert from 'node:assert';
import { buildGuidedQuestion } from '../src/lib/intentionCoach.js';
import { buildThemeQuestion, normalizeThemeLabel } from '../src/lib/themeText.js';

describe('Journal Integration with Deterministic Question Generation', () => {
  describe('Coach Recommendations from Journal', () => {
    it('should generate deterministic questions from context-based recommendations', () => {
      // Simulating a recommendation from JournalInsightsPanel
      // Based on user's most common context (e.g., "love")
      const recommendation = {
        topicValue: 'relationships',
        timeframeValue: 'week',
        depthValue: 'guided',
        customFocus: 'my closest relationships and connections',
        source: 'context:love'
      };

      // Create seed from recommendation source for reproducibility
      const seed = `journal-rec|${recommendation.source}`;

      const params = {
        topic: recommendation.topicValue,
        timeframe: recommendation.timeframeValue,
        depth: recommendation.depthValue,
        customFocus: recommendation.customFocus,
        seed
      };

      const question1 = buildGuidedQuestion(params);
      const question2 = buildGuidedQuestion(params);
      const question3 = buildGuidedQuestion(params);

      assert.strictEqual(question1, question2, 'Should produce identical questions');
      assert.strictEqual(question2, question3, 'Should remain consistent');
      assert.ok(question1.length > 20, 'Should produce meaningful question');
    });

    it('should generate deterministic questions from theme-based recommendations', () => {
      // Simulating a theme-based recommendation
      // Based on user's recent journal themes
      const theme = 'transformation';
      const normalized = normalizeThemeLabel(theme);
      const recommendation = {
        question: buildThemeQuestion(theme),
        topicValue: 'growth',
        timeframeValue: 'month',
        depthValue: 'guided',
        customFocus: normalized,
        source: `theme:${normalized}`
      };

      const seed = `journal-rec|${recommendation.source}`;

      const params = {
        topic: recommendation.topicValue,
        timeframe: recommendation.timeframeValue,
        depth: recommendation.depthValue,
        customFocus: recommendation.customFocus,
        seed
      };

      const question1 = buildGuidedQuestion(params);
      const question2 = buildGuidedQuestion(params);

      assert.strictEqual(question1, question2, 'Theme-based questions should be reproducible');
      assert.ok(question1.includes(theme), 'Should incorporate the theme');
    });

    it('should normalize verbose theme sentences for readable questions', () => {
      const rawTheme = 'Moderate Major Arcana suggests important archetypal lessons woven through everyday matters.';
      const label = normalizeThemeLabel(rawTheme);
      assert.strictEqual(label, 'Moderate Major Arcana (archetypal lessons in daily life)');
      const question = buildThemeQuestion(rawTheme);
      assert.strictEqual(question, 'How can I explore Moderate Major Arcana (archetypal lessons in daily life) more deeply?');
    });

    it('should generate deterministic questions from card-based recommendations', () => {
      // Simulating a frequent card recommendation
      const cardName = 'The Tower';
      const recommendation = {
        question: `What is ${cardName} inviting me to embody next?`,
        topicValue: 'growth',
        timeframeValue: 'open',
        depthValue: 'lesson',
        customFocus: `${cardName} recurring energy`,
        source: `card:${cardName}`,
        cardName
      };

      const seed = `journal-rec|${recommendation.source}`;

      const params = {
        topic: recommendation.topicValue,
        timeframe: recommendation.timeframeValue,
        depth: recommendation.depthValue,
        customFocus: recommendation.customFocus,
        seed
      };

      const question1 = buildGuidedQuestion(params);
      const question2 = buildGuidedQuestion(params);

      assert.strictEqual(question1, question2, 'Card-based questions should be reproducible');
      assert.ok(question1.includes(cardName), 'Should reference the card');
    });

    it('should produce different questions for different journal insights', () => {
      const contexts = ['love', 'career', 'spiritual'];
      const questions = [];

      contexts.forEach(context => {
        const recommendation = {
          topicValue: context === 'love' ? 'relationships' : context === 'career' ? 'career' : 'growth',
          timeframeValue: 'week',
          depthValue: 'guided',
          source: `context:${context}`
        };

        const seed = `journal-rec|${recommendation.source}`;
        const params = {
          topic: recommendation.topicValue,
          timeframe: recommendation.timeframeValue,
          depth: recommendation.depthValue,
          seed
        };

        questions.push(buildGuidedQuestion(params));
      });

      // Different contexts should produce different questions
      const uniqueQuestions = new Set(questions);
      assert.ok(uniqueQuestions.size >= 2, 'Different contexts should produce varied questions');
    });
  });

  describe('Personalized Suggestions Determinism', () => {
    it('should produce consistent questions from buildPersonalizedSuggestions parameters', () => {
      // Simulating a personalized suggestion from buildPersonalizedSuggestions
      const suggestion = {
        id: 'card-The Fool-0',
        label: 'Recurring card: The Fool',
        question: 'What is The Fool inviting me to embody next?',
        topic: 'growth',
        timeframe: 'open',
        depth: 'lesson',
        customFocus: 'The Fool recurring energy'
      };

      // User applies this suggestion
      const seed = `suggestion|${suggestion.id}`;

      const params = {
        topic: suggestion.topic,
        timeframe: suggestion.timeframe,
        depth: suggestion.depth,
        customFocus: suggestion.customFocus,
        seed
      };

      const question1 = buildGuidedQuestion(params);
      const question2 = buildGuidedQuestion(params);

      assert.strictEqual(question1, question2, 'Suggestion-based questions should be reproducible');
    });

    it('should handle context hint suggestions with determinism', () => {
      // Simulating a context hint from CONTEXT_HINTS
      const contextHint = {
        label: 'Relationship reciprocity',
        topic: 'relationships',
        timeframe: 'week',
        depth: 'guided',
        customFocus: 'my closest relationships and how I can nurture reciprocity'
      };

      const seed = 'context-hint|love';

      const params = {
        topic: contextHint.topic,
        timeframe: contextHint.timeframe,
        depth: contextHint.depth,
        customFocus: contextHint.customFocus,
        seed
      };

      const question1 = buildGuidedQuestion(params);
      const question2 = buildGuidedQuestion(params);

      assert.strictEqual(question1, question2, 'Context hint questions should be reproducible');
    });

    it('should handle history-based suggestions', () => {
      // Simulating revisiting a previous question
      const historyItem = {
        id: 'question_123',
        question: 'How can I navigate my career transition with confidence?'
      };

      // When user applies history item, they might regenerate or use exact text
      // If regenerating from saved parameters:
      const seed = `history|${historyItem.id}`;

      const params = {
        topic: 'career',
        timeframe: 'month',
        depth: 'guided',
        customFocus: 'my career transition',
        seed
      };

      const question1 = buildGuidedQuestion(params);
      const question2 = buildGuidedQuestion(params);

      assert.strictEqual(question1, question2, 'History-based regenerations should be deterministic');
    });
  });

  describe('Journal Stats Impact on Creative Mode', () => {
    it('should maintain determinism despite journal personalization data', () => {
      // When buildCreativeQuestion is called, it loads journal insights
      // But the seed should still ensure determinism

      const params = {
        topic: 'relationships',
        timeframe: 'week',
        depth: 'guided',
        customFocus: 'my partnership',
        seed: 'test-with-journal-context'
      };

      // Even though buildCreativeQuestion loads journal insights,
      // the seed should make the backend's variant selection deterministic

      // We can't test buildCreativeQuestion here (it's async and calls API),
      // but we can verify the principle with buildGuidedQuestion
      const question1 = buildGuidedQuestion(params);
      const question2 = buildGuidedQuestion(params);

      assert.strictEqual(question1, question2, 'Determinism should be independent of loaded journal data');
    });
  });

  describe('Seed Strategy for Journal Integration', () => {
    it('should support composite seeds from journal metadata', () => {
      // Best practice: create seeds that capture the journal context
      const journalContext = {
        topCard: 'The Star',
        topTheme: 'healing',
        topContext: 'wellbeing',
        reversalRate: 42
      };

      const seed = `journal|${journalContext.topCard}|${journalContext.topTheme}|${journalContext.topContext}`;

      const params = {
        topic: 'wellbeing',
        timeframe: 'month',
        depth: 'guided',
        customFocus: journalContext.topTheme,
        seed
      };

      const question1 = buildGuidedQuestion(params);
      const question2 = buildGuidedQuestion(params);

      assert.strictEqual(question1, question2, 'Composite journal seeds should work');
    });

    it('should demonstrate seed uniqueness for different journal states', () => {
      const journalState1 = { topCard: 'The Moon', topTheme: 'intuition' };
      const journalState2 = { topCard: 'The Sun', topTheme: 'joy' };

      const seed1 = `journal|${journalState1.topCard}|${journalState1.topTheme}`;
      const seed2 = `journal|${journalState2.topCard}|${journalState2.topTheme}`;

      const baseParams = {
        topic: 'growth',
        timeframe: 'week',
        depth: 'lesson'
      };

      const question1 = buildGuidedQuestion({ ...baseParams, seed: seed1 });
      const question2 = buildGuidedQuestion({ ...baseParams, seed: seed2 });

      // Different journal states produce different seeds, thus different questions
      // (with high probability due to variant selection)
      assert.ok(typeof question1 === 'string', 'Should produce valid question');
      assert.ok(typeof question2 === 'string', 'Should produce valid question');
    });
  });
});
</file>

<file path="tests/journal-export.test.mjs">
import assert from 'node:assert';
import test from 'node:test';

import { generatePDF } from '../functions/api/journal-export.js';

test('generatePDF does not flag truncation at exact page limit', () => {
  const linesPerPage = 50; // Derived from PDF_TOP_Y, PDF_BOTTOM_Y, and PDF_LINE_HEIGHT
  const totalLines = linesPerPage * 20;

  const content = Array.from({ length: totalLines }, (_, i) => `Line ${i + 1}`).join('\n');
  const { pageCount, truncated, pdf } = generatePDF(content);

  assert.strictEqual(pageCount, 20);
  assert.strictEqual(truncated, false);
  assert.ok(pdf.startsWith('%PDF-1.4'));
});

test('generatePDF flags truncation when content exceeds page limit', () => {
  const linesPerPage = 50;
  const content = Array.from({ length: linesPerPage * 20 + 1 }, (_, i) => `Line ${i + 1}`).join('\n');

  const { pageCount, truncated } = generatePDF(content);

  assert.strictEqual(pageCount, 20);
  assert.strictEqual(truncated, true);
});
</file>

<file path="tests/journalInsights.test.mjs">
import assert from 'node:assert/strict';
import { describe, it } from 'node:test';

import { buildJournalCsv } from '../src/lib/journalInsights.js';

describe('journal CSV export', () => {
  it('includes all reading details per entry', () => {
    const entry = {
      ts: Date.parse('2024-09-01T12:00:00Z'),
      spread: 'Three-Card Story',
      spreadKey: 'threeCard',
      question: 'How can I navigate this career transition this month?',
      cards: [
        { position: 'Past', name: 'Two of Wands', orientation: 'Upright' },
        { position: 'Present', name: 'Three of Cups', orientation: 'Reversed' },
        { position: 'Future', name: 'Six of Swords', orientation: 'Upright' }
      ],
      context: 'career',
      provider: 'local-composer',
      deckId: 'rws-1909',
      sessionSeed: 'seed123',
      reflections: { notes: 'Felt accurate' },
      themes: { suitFocus: 'Cups & Swords', reversalFramework: 'blocked' },
      personalReading: 'Sample narrative'
    };

    const csv = buildJournalCsv([entry]);
    const lines = csv.trim().split('\n');
    assert.equal(lines.length, 2, 'CSV should include header and one row');

    const headers = lines[0].split(',');
    assert.deepEqual(headers, [
      'Timestamp',
      'Spread',
      'Spread Key',
      'Question',
      'Cards',
      'Context',
      'Provider',
      'Deck',
      'Session Seed',
      'Reflections',
      'Themes',
      'Narrative'
    ]);

    const row = lines[1];
    assert.match(row, /Three-Card Story/);
    assert.match(row, /threeCard/);
    assert.match(row, /career transition/);
    assert.match(row, /Past: Two of Wands/);
    assert.match(row, /local-composer/);
    assert.match(row, /rws-1909/);
    assert.match(row, /seed123/);
    assert.match(row, /"{""notes"":""Felt accurate""}"/);
    assert.match(row, /"{""suitFocus"":""Cups & Swords"",""reversalFramework"":""blocked""}"/);
    assert.match(row, /Sample narrative/);
  });
});
</file>

<file path="tests/narrativeBuilder.promptCompliance.test.mjs">
import assert from 'node:assert/strict';
import { describe, it } from 'node:test';

import {
  buildCelticCrossReading,
  buildThreeCardReading,
  buildFiveCardReading,
  buildRelationshipReading,
  buildDecisionReading,
  buildSingleCardReading,
  buildEnhancedClaudePrompt
} from '../functions/lib/narrativeBuilder.js';
import { formatVisionLabelForPrompt } from '../functions/lib/visionLabels.js';
import {
  analyzeCelticCross,
  analyzeThreeCard,
  analyzeFiveCard,
  analyzeSpreadThemes
} from '../functions/lib/spreadAnalysis.js';
import { validateReadingNarrative } from '../functions/lib/narrativeSpine.js';

// Minimal helper to fabricate a Major Arcana-like card
function major(name, number, position, orientation = 'Upright', meaning = 'Meaningful transformation and growth.') {
  return {
    card: name,
    name,
    number,
    position,
    orientation,
    meaning
  };
}

// Minimal helper to fabricate a Minor Arcana-like card
function minor(name, suit, rank, rankValue, position, orientation = 'Upright', meaning = 'Embodied lesson in this area.') {
  return {
    card: name,
    name,
    suit,
    rank,
    rankValue,
    position,
    orientation,
    meaning
  };
}

async function buildThemes(cardsInfo, reversalFramework = 'blocked') {
  const base = await analyzeSpreadThemes(cardsInfo);
  // Force a specific, deterministic reversal lens so assertions are stable.
  if (reversalFramework === 'blocked') {
    base.reversalFramework = 'blocked';
    base.reversalDescription = {
      name: 'Blocked Energy',
      description: 'Reversals show the energy is present yet meeting resistance.',
      guidance: 'Interpret reversals as energies encountering resistance that must be consciously released.'
    };
  } else if (reversalFramework === 'internalized') {
    base.reversalFramework = 'internalized';
    base.reversalDescription = {
      name: 'Internalized Energy',
      description: 'Reversals point inward to private, internalized processes.',
      guidance: 'Describe reversals as invitations to reflect and integrate within.'
    };
  }
  return base;
}

// Generic assertion helpers

function assertAgencyForward(text) {
  const lowered = text.toLowerCase();
  assert.ok(
    lowered.includes('trajectory') ||
    lowered.includes('path') ||
    lowered.includes('if the current path continues') ||
    lowered.includes('if current path continues'),
    'Reading/prompt should frame outcomes as trajectories, not fixed fate'
  );
  assert.ok(
    lowered.includes('free will') ||
    lowered.includes('choice') ||
    lowered.includes('agency') ||
    lowered.includes('you remain the one who chooses') ||
    lowered.includes('you are co-creating this path'),
    'Reading/prompt should emphasize free will and agency-forward framing'
  );
}

function assertNoBannedDeterminism(text) {
  const lowered = text.toLowerCase();
  assert.ok(
    !lowered.includes('guaranteed') &&
    !lowered.includes('will definitely') &&
    !lowered.includes('100% certain') &&
    !lowered.includes('fate demands'),
    'Reading/prompt should not contain deterministic guarantee language'
  );
}

function assertUsesCardsAndPositions(text, cardsInfo) {
  for (const c of cardsInfo) {
    if (!c || !c.card) continue;
    assert.ok(
      text.includes(c.card),
      `Reading/prompt should reference card ${c.card}`
    );
    if (c.position) {
      assert.ok(
        text.includes(c.position.split('(')[0].trim()),
        `Reading/prompt should reference position lens for ${c.card}`
      );
    }
  }
}

function assertReversalLensConsistency(text, themes) {
  if (!themes || !themes.reversalDescription) return;
  const label = themes.reversalDescription.name;
  // If there are any reversed cards expected, the lens name should appear.
  assert.ok(
    text.includes(label),
    `Reversal framework "${label}" should be surfaced in narrative/prompt`
  );
}

function hasStoryConnectors(text) {
  // We only require presence of at least one key connector to avoid over-constraining.
  return (
    text.includes('Because') ||
    text.includes('Therefore') ||
    text.includes('However') ||
    text.includes('And so') ||
    text.includes('Meanwhile') ||
    text.includes('This sets the stage for') ||
    text.includes('Yet beneath the surface')
  );
}

function assertStorySpineSignals(text) {
  assert.ok(
    hasStoryConnectors(text),
    'Narrative/prompt should use connective phrases aligned with WHAT → WHY → WHAT\'S NEXT story spine'
  );
}

// 1. CELTIC CROSS COMPLIANCE

describe('Celtic Cross narrative + Claude prompt compliance', () => {
  it('buildCelticCrossReading and buildEnhancedClaudePrompt follow narrative guide', async () => {
    const cardsInfo = [
      major('The Fool', 0, 'Present — core situation (Card 1)', 'Upright'),
      major('The Magician', 1, 'Challenge — crossing / tension (Card 2)', 'Upright'),
      major('The High Priestess', 2, 'Past — what lies behind (Card 3)', 'Upright'),
      major('The Empress', 3, 'Near Future — what lies before (Card 4)', 'Reversed'),
      major('The Emperor', 4, 'Conscious — goals & focus (Card 5)', 'Upright'),
      major('The Hierophant', 5, 'Subconscious — roots / hidden forces (Card 6)', 'Upright'),
      major('The Lovers', 6, 'Self / Advice — how to meet this (Card 7)', 'Upright'),
      major('The Chariot', 7, 'External Influences — people & environment (Card 8)', 'Upright'),
      major('Strength', 8, 'Hopes & Fears — deepest wishes & worries (Card 9)', 'Upright'),
      major('The Hermit', 9, 'Outcome — likely path if unchanged (Card 10)', 'Upright')
    ];

    const themes = await buildThemes(cardsInfo, 'blocked');
    const celticAnalysis = analyzeCelticCross(cardsInfo);

    const reading = await buildCelticCrossReading({
      cardsInfo,
      userQuestion: 'How can I work with these changes?',
      reflectionsText: 'I feel a big transition approaching.',
      celticAnalysis,
      themes
    });

    // Headings & structure
    [
      ['### The Heart of the Matter (Nucleus)'],
      ['### The Timeline (Horizontal Axis)'],
      ['### Consciousness Flow (Vertical Axis)'],
      ['### The Staff (Context & Trajectory)'],
      ['### Key Relationships'],
      ['### Synthesis & Guidance', '### Synthesis &amp; Guidance'] // tolerate either HTML-escaped or raw ampersand
    ].forEach(headings => {
      assert.ok(
        headings.some(heading => reading.includes(heading)),
        `Celtic Cross reading should include section heading: ${headings[0]}`
      );
    });

    assertAgencyForward(reading);
    assertNoBannedDeterminism(reading);
    assertUsesCardsAndPositions(reading, cardsInfo);
    assertReversalLensConsistency(reading, themes);
    assertStorySpineSignals(reading);

    const { systemPrompt, userPrompt } = buildEnhancedClaudePrompt({
      spreadInfo: { name: 'Celtic Cross (Classic 10-Card)' },
      cardsInfo,
      userQuestion: 'How can I work with these changes?',
      reflectionsText: 'I feel a big transition approaching.',
      themes,
      spreadAnalysis: celticAnalysis
    });

    const readingValidation = validateReadingNarrative(reading);
    assert.ok(
      readingValidation.isValid,
      'Celtic Cross reading should satisfy narrative spine validation'
    );

    // System prompt: ethics + structure + reversal + minors guidance (high level).
    assert.ok(
      systemPrompt.includes('agency-forward') && systemPrompt.includes('storyteller'),
      'System prompt should set agency-forward tarot storyteller persona'
    );
    assert.ok(
      systemPrompt.includes('WHAT') && systemPrompt.includes('WHY') && systemPrompt.includes('WHAT’S NEXT'),
      'System prompt should encode story spine guidance'
    );
    assert.ok(
      systemPrompt.includes('CORE PRINCIPLES') && systemPrompt.includes('FORMATTING'),
      'System prompt should highlight narrative guidelines section'
    );
    assert.ok(
      systemPrompt.includes(themes.reversalDescription.name),
      'System prompt should surface selected reversal framework'
    );

    assertAgencyForward(systemPrompt);
    assertNoBannedDeterminism(systemPrompt);
    assertStorySpineSignals(systemPrompt);

    // User prompt: must enumerate key cross-check labels and reversal framework.
    ['Goal vs Outcome', 'Advice vs Outcome', 'Near Future vs Outcome', 'Subconscious vs Hopes/Fears'].forEach(label => {
      assert.ok(
        userPrompt.includes(label),
        `User prompt should surface cross-check label: ${label}`
      );
    });

    assert.ok(
      userPrompt.includes('Reversal framework:') ||
      userPrompt.toLowerCase().includes('reversal framework') ||
      userPrompt.includes('reversal lens'),
      'User prompt should mention reversal framework'
    );
    // Ethics and Minor Arcana rules are now in system prompt to reduce redundancy
    // User prompt just references system prompt guidelines
    assert.ok(
      userPrompt.includes('system prompt') || userPrompt.includes('guidelines'),
      'User prompt should reference system prompt guidelines'
    );

    assertAgencyForward(userPrompt);
    assertNoBannedDeterminism(userPrompt);
    assertUsesCardsAndPositions(userPrompt, cardsInfo);
    assertStorySpineSignals(userPrompt);

  });
});

describe('Vision validation prompt context', () => {
  it('embeds vision validation summary when insights are provided', async () => {
    const cardsInfo = [
      major('The Fool', 0, 'One-Card Insight', 'Upright')
    ];
    const themes = await buildThemes(cardsInfo, 'blocked');

    const { userPrompt } = buildEnhancedClaudePrompt({
      spreadInfo: { name: 'One-Card Insight' },
      cardsInfo,
      userQuestion: 'Can I trust this start?',
      reflectionsText: '',
      themes,
      spreadAnalysis: null,
      context: 'general',
      visionInsights: [
        {
          label: 'IMG_101',
          predictedCard: 'The Fool',
          confidence: 0.94,
          basis: 'image',
          matchesDrawnCard: true
        }
      ]
    });

    assert.match(userPrompt, /Vision Validation/);
    const sanitizedLabel = formatVisionLabelForPrompt('IMG_101');
    assert.ok(
      userPrompt.includes(sanitizedLabel),
      `Vision validation block should include sanitized label: ${sanitizedLabel}`
    );
    assert.match(userPrompt, /The Fool/);
  });

  it('embeds visual profile (tone/emotion) when available', async () => {
    const cardsInfo = [
      major('The Moon', 18, 'One-Card Insight', 'Upright')
    ];
    const themes = await buildThemes(cardsInfo, 'blocked');

    const { userPrompt } = buildEnhancedClaudePrompt({
      spreadInfo: { name: 'One-Card Insight' },
      cardsInfo,
      userQuestion: 'What is hidden?',
      reflectionsText: '',
      themes,
      spreadAnalysis: null,
      context: 'general',
      visionInsights: [
        {
          label: 'IMG_DARK_MOON',
          predictedCard: 'The Moon',
          confidence: 0.98,
          basis: 'image',
          matchesDrawnCard: true,
          visualProfile: {
            tone: ['shadowy', 'muted'],
            emotion: ['mysterious', 'melancholic']
          }
        }
      ]
    });

    assert.match(userPrompt, /Visual Profile:/);
    assert.match(userPrompt, /Tone: \[shadowy, muted\]/);
    assert.match(userPrompt, /Emotion: \[mysterious, melancholic\]/);
  });
});

// 2. THREE-CARD COMPLIANCE

describe('Three-Card narrative + Claude prompt compliance', () => {
  it('buildThreeCardReading and prompt respect causal story + ethics', async () => {
    const cardsInfo = [
      minor('Two of Wands', 'Wands', 'Two', 2, 'Past — influences that led here', 'Upright'),
      minor('Three of Cups', 'Cups', 'Three', 3, 'Present — where you stand now', 'Upright'),
      minor('Six of Swords', 'Swords', 'Six', 6, 'Future — trajectory if nothing shifts', 'Reversed')
    ];

    const themes = await buildThemes(cardsInfo, 'internalized');
    const threeCardAnalysis = analyzeThreeCard(cardsInfo);

    const reading = await buildThreeCardReading({
      cardsInfo,
      userQuestion: 'What is unfolding in this chapter?',
      reflectionsText: '',
      threeCardAnalysis,
      themes
    });

    assert.ok(
      reading.includes('### The Story'),
      'Three-card reading should include The Story section'
    );
    assert.ok(
      reading.includes('### Guidance'),
      'Three-card reading should include Guidance section'
    );

    assertAgencyForward(reading);
    assertNoBannedDeterminism(reading);
    assertUsesCardsAndPositions(reading, cardsInfo);
    assertReversalLensConsistency(reading, themes);
    assertStorySpineSignals(reading);
    const threeCardValidation = validateReadingNarrative(reading);
    assert.ok(
      threeCardValidation.isValid,
      'Three-card reading should satisfy narrative spine validation'
    );

    const { systemPrompt, userPrompt } = buildEnhancedClaudePrompt({
      spreadInfo: { name: 'Three-Card Story (Past · Present · Future)' },
      cardsInfo,
      userQuestion: 'What is unfolding in this chapter?',
      reflectionsText: '',
      themes,
      spreadAnalysis: threeCardAnalysis
    });

    assertAgencyForward(systemPrompt);
    assertNoBannedDeterminism(systemPrompt);
    assertStorySpineSignals(systemPrompt);
    assertAgencyForward(userPrompt);
    assertNoBannedDeterminism(userPrompt);
    assertUsesCardsAndPositions(userPrompt, cardsInfo);
    assertStorySpineSignals(userPrompt);

  });
});

// 3. FIVE-CARD / RELATIONSHIP / DECISION / SINGLE-CARD smoke + ethics + spine

describe('Other spread builders prompt-engineering compliance', () => {
  it('Five-Card Clarity respects narrative rules', async () => {
    const cardsInfo = [
      major('The Fool', 0, 'Core of the matter', 'Upright'),
      major('The Magician', 1, 'Challenge or tension', 'Reversed'),
      minor('Two of Cups', 'Cups', 'Two', 2, 'Hidden / subconscious influence', 'Upright'),
      minor('Nine of Pentacles', 'Pentacles', 'Nine', 9, 'Support / helpful energy', 'Upright'),
      major('The World', 21, 'Likely direction on current path', 'Upright')
    ];

    const themes = await buildThemes(cardsInfo, 'blocked');
    const fiveCardAnalysis = analyzeFiveCard(cardsInfo);

    const reading = await buildFiveCardReading({
      cardsInfo,
      userQuestion: 'How can I best navigate this?',
      reflectionsText: '',
      fiveCardAnalysis,
      themes
    });

    assertAgencyForward(reading);
    assertNoBannedDeterminism(reading);
    assertUsesCardsAndPositions(reading, cardsInfo);
    assertReversalLensConsistency(reading, themes);
    assertStorySpineSignals(reading);
    const relationshipValidation = validateReadingNarrative(reading);
    assert.ok(
      relationshipValidation.isValid,
      'Relationship reading should satisfy narrative spine validation'
    );
  });

  it('Relationship Snapshot respects narrative rules', async () => {
    const cardsInfo = [
      minor('Knight of Cups', 'Cups', 'Knight', 12, 'You / your energy', 'Upright'),
      minor('Queen of Swords', 'Swords', 'Queen', 13, 'Them / their energy', 'Upright'),
      major('The Lovers', 6, 'The connection / shared lesson', 'Upright')
    ];

    const themes = await buildThemes(cardsInfo, 'internalized');

    const reading = await buildRelationshipReading({
      cardsInfo,
      userQuestion: 'What is the energy of this connection?',
      reflectionsText: '',
      themes
    });

    assertAgencyForward(reading);
    assertNoBannedDeterminism(reading);
    assertUsesCardsAndPositions(reading, cardsInfo);
    assertReversalLensConsistency(reading, themes);
    assertStorySpineSignals(reading);
    const relationshipValidation = validateReadingNarrative(reading);
    assert.ok(
      relationshipValidation.isValid,
      'Relationship reading should satisfy narrative spine validation'
    );
  });

  it('Decision / Two-Path respects narrative rules', async () => {
    const cardsInfo = [
      major('The High Priestess', 2, 'Heart of the decision', 'Upright'),
      major('The Sun', 19, 'Path A — energy & likely outcome', 'Upright'),
      major('The Moon', 18, 'Path B — energy & likely outcome', 'Reversed'),
      minor('Page of Pentacles', 'Pentacles', 'Page', 11, 'What clarifies the best path', 'Upright'),
      major('Justice', 11, 'What to remember about your free will', 'Upright')
    ];

    const themes = await buildThemes(cardsInfo, 'blocked');

    const reading = await buildDecisionReading({
      cardsInfo,
      userQuestion: 'Which path aligns with me?',
      reflectionsText: '',
      themes
    });

    assertAgencyForward(reading);
    assertNoBannedDeterminism(reading);
    assertUsesCardsAndPositions(reading, cardsInfo);
    assertReversalLensConsistency(reading, themes);
    assertStorySpineSignals(reading);
    const decisionValidation = validateReadingNarrative(reading);
    assert.ok(
      decisionValidation.isValid,
      'Decision reading should satisfy narrative spine validation'
    );
  });

  it('Decision builder surfaces helpful guidance when spread is incomplete', async () => {
    const cardsInfo = [
      major('The High Priestess', 2, 'Heart of the decision', 'Upright'),
      major('The Sun', 19, 'Path A — energy & likely outcome', 'Upright')
    ];

    const themes = await buildThemes(cardsInfo, 'blocked');

    const reading = await buildDecisionReading({
      cardsInfo,
      userQuestion: 'Which path aligns with me?',
      reflectionsText: '',
      themes
    });

    assert.match(
      reading,
      /needs all five cards/i,
      'Decision builder should warn when fewer than five cards are supplied'
    );
  });

  it('Single-Card Insight respects narrative rules', async () => {
    const cardsInfo = [
      major('The Star', 17, 'Theme / Guidance of the Moment', 'Upright')
    ];

    const themes = await buildThemes(cardsInfo, 'internalized');

    const reading = await buildSingleCardReading({
      cardsInfo,
      userQuestion: 'What do I most need to hear?',
      reflectionsText: '',
      themes
    });

    assertAgencyForward(reading);
    assertNoBannedDeterminism(reading);
    assertUsesCardsAndPositions(reading, cardsInfo);
    assertReversalLensConsistency(reading, themes);
    assertStorySpineSignals(reading);
    const singleValidation = validateReadingNarrative(reading);
    assert.ok(
      singleValidation.isValid,
      'Single-card reading should satisfy narrative spine validation'
    );
  });

  it('surfaces amplified elemental imagery when elements repeat', async () => {
    const cardsInfo = [
      minor('Two of Wands', 'Wands', 'Two', 2, 'Past — influences that led here', 'Upright'),
      minor('Four of Wands', 'Wands', 'Four', 4, 'Present — where you stand now', 'Upright'),
      minor('Six of Wands', 'Wands', 'Six', 6, 'Future — trajectory if nothing shifts', 'Upright')
    ];

    const themes = await buildThemes(cardsInfo, 'blocked');
    const threeCardAnalysis = analyzeThreeCard(cardsInfo);

    const reading = await buildThreeCardReading({
      cardsInfo,
      userQuestion: 'How is this momentum building?',
      reflectionsText: '',
      threeCardAnalysis,
      themes
    });

    assert.ok(
      reading.includes('Flame meeting flame'),
      'Reading should reference amplified fire imagery when elemental dignity repeats'
    );

    // Prompt imagery handled in spread-specific builders (e.g., Celtic Cross). Reading check suffices here.
  });

  it('enriches Minor pip cards with rank-specific imagery hooks', async () => {
    const cardsInfo = [
      minor('Ace of Cups', 'Cups', 'Ace', 1, 'Theme / Guidance of the Moment', 'Upright')
    ];

    const themes = await buildThemes(cardsInfo, 'internalized');

    const { userPrompt } = buildEnhancedClaudePrompt({
      spreadInfo: { name: 'One-Card Insight' },
      cardsInfo,
      userQuestion: 'What emotion should I honor?',
      reflectionsText: '',
      themes,
      spreadAnalysis: null
    });

    assert.ok(
      userPrompt.toLowerCase().includes('picture hand emerging from a cloud presenting an overflowing chalice'),
      'Minor pip cards should include rank-and-suit specific imagery text in prompts'
    );
  });
});

describe('Prompt budget telemetry', () => {
  it('returns estimated tokens and applies budget from env', async () => {
    const originalBudget = process.env.PROMPT_BUDGET_CLAUDE;
    process.env.PROMPT_BUDGET_CLAUDE = '90';

    const cardsInfo = [
      major('The Fool', 0, 'Past — influences that led here', 'Upright'),
      major('The Magician', 1, 'Present — where you stand now', 'Upright'),
      major('The High Priestess', 2, 'Future — trajectory if nothing shifts', 'Upright')
    ];

    const themes = await buildThemes(cardsInfo, 'blocked');

    const { promptMeta } = buildEnhancedClaudePrompt({
      spreadInfo: { name: 'Three-Card Story (Past · Present · Future)' },
      cardsInfo,
      userQuestion: 'How do I keep momentum?',
      reflectionsText: '',
      themes,
      spreadAnalysis: null,
      context: 'general'
    });

    assert.equal(promptMeta.estimatedTokens.budget, 90);
    assert.ok(promptMeta.estimatedTokens.total > 0);
    assert.ok(Array.isArray(promptMeta.slimmingSteps));

    process.env.PROMPT_BUDGET_CLAUDE = originalBudget;
  });
});
</file>

<file path="tests/narrativeBuilder.reversal.test.mjs">
import assert from 'node:assert/strict';

import {
  analyzeCelticCross,
  analyzeSpreadThemes
} from '../functions/lib/spreadAnalysis.js';

import {
  buildCelticCrossReading,
  buildEnhancedClaudePrompt,
  buildThreeCardReading,
  buildPositionCardText
} from '../functions/lib/narrativeBuilder.js';

function buildReversedCelticCards() {
  const majors = [
    { num: 0, name: 'The Fool', meaning: 'New beginnings and leaps of faith.' },
    { num: 1, name: 'The Magician', meaning: 'Personal power and focused will.' },
    { num: 2, name: 'The High Priestess', meaning: 'Intuition and mystery.' },
    { num: 3, name: 'The Empress', meaning: 'Nurturing abundance.' },
    { num: 4, name: 'The Emperor', meaning: 'Structure and authority.' },
    { num: 5, name: 'The Hierophant', meaning: 'Tradition and spiritual mentorship.' },
    { num: 6, name: 'The Lovers', meaning: 'Aligned choices from the heart.' },
    { num: 7, name: 'The Chariot', meaning: 'Determined progress.' },
    { num: 8, name: 'Strength', meaning: 'Inner resilience and compassion.' },
    { num: 9, name: 'The Hermit', meaning: 'Introspective guidance.' }
  ];

  const positions = [
    'Present — core situation (Card 1)',
    'Challenge — crossing / tension (Card 2)',
    'Past — what lies behind (Card 3)',
    'Near Future — what lies before (Card 4)',
    'Conscious — goals & focus (Card 5)',
    'Subconscious — roots / hidden forces (Card 6)',
    'Self / Advice — how to meet this (Card 7)',
    'External Influences — people & environment (Card 8)',
    'Hopes & Fears — deepest wishes & worries (Card 9)',
    'Outcome — likely path if unchanged (Card 10)'
  ];

  return majors.map((major, index) => ({
    position: positions[index],
    card: major.name,
    orientation: 'Reversed',
    meaning: major.meaning,
    number: major.num
  }));
}

function buildReversedThreeCards() {
  return [
    {
      position: 'Past — influences that led here',
      card: 'Five of Wands',
      orientation: 'Reversed',
      meaning: 'Conflict and competition surface around you.',
      number: null
    },
    {
      position: 'Present — where you stand now',
      card: 'Two of Cups',
      orientation: 'Reversed',
      meaning: 'Partnership asks for renewed trust.',
      number: null
    },
    {
      position: 'Future — trajectory if nothing shifts',
      card: 'Six of Swords',
      orientation: 'Reversed',
      meaning: 'Transition requires deliberate effort.',
      number: null
    }
  ];
}

async function buildBlockedThemes(cardsInfo) {
  const themes = await analyzeSpreadThemes(cardsInfo);
  // Force framework to blocked for predictable assertions
  themes.reversalFramework = 'blocked';
  themes.reversalDescription = {
    name: 'Blocked Energy',
    description: 'Reversals show the energy is present yet meeting resistance.',
    guidance: 'Interpret reversals as energies encountering resistance that must be consciously released.'
  };
  return themes;
}

(async () => {
  const cardsInfo = buildReversedCelticCards();
  const themes = await buildBlockedThemes(cardsInfo);
  const celticAnalysis = analyzeCelticCross(cardsInfo);

  const reading = await buildCelticCrossReading({
    cardsInfo,
    userQuestion: 'How can I navigate this turning point?',
    reflectionsText: '',
    celticAnalysis,
    themes
  });

  const expectedReminder = `*Reversal lens reminder: Within the ${themes.reversalDescription.name} lens, ${themes.reversalDescription.guidance}*`;
  assert.ok(
    reading.trim().endsWith(expectedReminder),
    'Celtic Cross reading should append a single reversal reminder note at the end'
  );

  const { userPrompt } = buildEnhancedClaudePrompt({
    spreadInfo: { name: 'Celtic Cross (Classic 10-Card)' },
    cardsInfo,
    userQuestion: 'How can I navigate this turning point?',
    reflectionsText: '',
    themes,
    spreadAnalysis: celticAnalysis
  });

  ['Goal vs Outcome', 'Advice vs Outcome', 'Near Future vs Outcome', 'Subconscious vs Hopes/Fears'].forEach(label => {
    assert.ok(
      userPrompt.includes(label),
      `Claude prompt should surface the ${label} cross-check data`
    );
  });

  assert.ok(
    userPrompt.includes('Within the Blocked Energy lens'),
    'Claude prompt should reinforce the selected reversal framework'
  );
})();

(async () => {
  const cardsInfo = buildReversedThreeCards();
  const themes = await buildBlockedThemes(cardsInfo);
  const threeCardAnalysis = null;

  const reading = await buildThreeCardReading({
    cardsInfo,
    userQuestion: 'What is unfolding right now?',
    reflectionsText: '',
    threeCardAnalysis,
    themes
  });

  assert.ok(
    reading.includes('Within the Blocked Energy lens'),
    'Three-card readings should propagate reversal guidance'
  );

  // Spot-check Minor metadata enrichment via buildPositionCardText for a representative Minor
  const sample = {
    position: 'Present — where you stand now',
    card: 'Two of Cups',
    orientation: 'Upright',
    meaning: 'Connection, partnership, mutual respect, heartfelt unity',
    suit: 'Cups',
    rank: 'Two',
    rankValue: 2
  };

  const text = buildPositionCardText(sample, sample.position, { reversalDescription: themes.reversalDescription });

  assert.ok(
    text.includes('As a Cups card, this speaks to'),
    'Minor summary should include suit-level theme'
  );
  assert.ok(
    /At this rank, it marks/.test(text),
    'Minor summary should include pip-level numerology for non-court ranks'
  );
})();

console.log('narrativeBuilder reversal tests passed');
</file>

<file path="tests/narrativeSpine.test.mjs">
import assert from 'node:assert/strict';
import { describe, it } from 'node:test';

import {
  analyzeSpineCompleteness,
  enhanceSection,
  validateReadingNarrative
} from '../functions/lib/narrativeSpine.js';

describe('narrative spine helper heuristics', () => {
  it('detects story spine clauses with varied phrasing', () => {
    const text = [
      'Anchor: The Sun upright bathes the scene in unapologetic clarity.',
      'That gentle burn steadies your nervous system, which in turn dissolves hesitation.',
      'From here, lean into the conversations that are beckoning next.'
    ].join(' ');

    const analysis = analyzeSpineCompleteness(text);

    assert.equal(analysis.missing.length, 0, 'Should not report missing elements');
    assert.ok(analysis.present.what, 'Should detect WHAT clause');
    assert.ok(analysis.present.why, 'Should detect WHY connector');
    assert.ok(analysis.present.whatsNext, 'Should detect forward-looking guidance');
  });

  it('honors explicit spine hints when builders provide overrides', () => {
    const analysis = analyzeSpineCompleteness('Freestyle reflection without cues.', {
      spineHints: { what: true, why: true, whatsNext: false }
    });

    assert.ok(analysis.present.what, 'Hint should mark WHAT as present');
    assert.ok(analysis.present.why, 'Hint should mark WHY as present');
    assert.strictEqual(analysis.present.whatsNext, false, 'Unset hint should leave detection result');
    assert.deepEqual(analysis.missing, ['whatsNext'], 'Only WHAT\'S NEXT should be missing');
  });

  it('avoids duplicate enhancements when clauses already exist upstream', () => {
    const section = 'Because these energies already harmonize, relief begins to return.';
    const metadata = {
      type: 'future',
      cards: [
        { position: 'Anchor', card: 'The Sun', orientation: 'Upright' },
        { position: 'Bridge', card: 'The Empress', orientation: 'Upright' }
      ],
      relationships: {
        elementalRelationship: { relationship: 'supportive' }
      }
    };

    const result = enhanceSection(section, metadata);
    const becauseCount = (result.text.match(/Because/gi) || []).length;

    assert.ok(result.text.startsWith('Anchor: The Sun Upright.'), 'Should prepend card identification');
    assert.equal(becauseCount, 1, 'Should not add duplicate causal connector');
    assert.ok(
      result.text.includes('Consider what this trajectory invites you to do next.'),
      'Future sections should receive guidance prompt'
    );
    assert.deepEqual(
      result.validation.enhancements,
      ['Added card identification', 'Added forward-looking guidance'],
      'Only card ID and guidance should be injected'
    );
  });

  it('validates markdown heading sections that use ### syntax', () => {
    const reading = [
      '### Anchor',
      'Anchor: The Sun steadies your confidence and frames this moment.',
      '### Bridge',
      'Bridge: The Moon contrasts that warmth, so you can witness nuance. From here, choose the conversations you will tend next.'
    ].join('\n');

    const validation = validateReadingNarrative(reading);

    assert.equal(validation.totalSections, 2, 'Should capture both markdown sections');
    assert.strictEqual(validation.sectionAnalyses[0].header, 'Anchor');
    assert.ok(validation.sectionAnalyses[0].analysis.present.what, 'Anchor section should have WHAT clause');
    assert.ok(validation.sectionAnalyses[1].analysis.present.why, 'Bridge section should capture WHY clause');
    assert.ok(validation.isValid, 'Reading should pass required spine checks');
  });
});
</file>

<file path="tests/promptEngineering.test.mjs">
// tests/promptEngineering.test.mjs
// Tests for prompt engineering helpers

import { describe, test } from 'node:test';
import assert from 'node:assert/strict';
import { redactPII, stripUserContent } from '../functions/lib/promptEngineering.js';

describe('redactPII', () => {
  test('redacts display name tokens without overmatching inside other words', () => {
    const text = 'We saw Ana in the analysis today.';
    const result = redactPII(text, { displayName: 'Ana' });

    assert.strictEqual(result, 'We saw [NAME] in the analysis today.');
  });

  test('handles names with diacritics using Unicode-aware boundaries', () => {
    const text = 'Ana María shared feedback about the spread.';
    const result = redactPII(text, { displayName: 'Ana María' });

    assert.strictEqual(result, '[NAME] shared feedback about the spread.');
  });

  test('redacts possessive forms for ASCII and curly apostrophes', () => {
    const text = "Ana's insight and Ana\u2019s path were both logged.";
    const result = redactPII(text, { displayName: 'Ana' });

    assert.strictEqual(result, "[NAME] insight and [NAME] path were both logged.");
  });
});

describe('stripUserContent', () => {
  describe('multiline question handling', () => {
    test('strips single-line **Question** format', () => {
      const text = '**Question**: What should I do about my career?\n\n**Cards**:';
      const result = stripUserContent(text);

      assert.ok(result.includes('[USER_QUESTION_REDACTED]'), 'Question should be redacted');
      assert.ok(!result.includes('career'), 'Question content should not remain');
    });

    test('strips multiline **Question** format with backstory', () => {
      const text = `**Question**: What should I do about my career?
I have been working at this company for 5 years.
My boss John Smith has been difficult lately.
I'm considering leaving but my salary is $150,000.

**Cards**:`;
      const result = stripUserContent(text);

      assert.ok(result.includes('[USER_QUESTION_REDACTED]'), 'Question should be redacted');
      assert.ok(!result.includes('career'), 'First line should be redacted');
      assert.ok(!result.includes('5 years'), 'Backstory line 1 should be redacted');
      assert.ok(!result.includes('John Smith'), 'PII in backstory should be redacted');
      assert.ok(!result.includes('$150,000'), 'Financial info should be redacted');
      assert.ok(result.includes('**Cards**:'), 'Next section should remain');
    });

    test('strips plain question: format with multiline content', () => {
      const text = `Some intro text.
question: How can I improve my relationship with Sarah?
She has been distant since our argument about money.
We have two children together.

**Thematic Context**:`;
      const result = stripUserContent(text);

      assert.ok(result.includes('[USER_QUESTION_REDACTED]'), 'Question should be redacted');
      assert.ok(!result.includes('Sarah'), 'Name should be redacted');
      assert.ok(!result.includes('money'), 'Content should be redacted');
      assert.ok(!result.includes('children'), 'Personal details should be redacted');
      assert.ok(result.includes('**Thematic Context**:'), 'Next section should remain');
    });
  });

  describe('reflections handling', () => {
    test('strips inline **Querent\'s Reflections** format', () => {
      const text = '**Querent\'s Reflections**: I feel anxious about the Tower card.\n\n**Next**:';
      const result = stripUserContent(text);

      assert.ok(result.includes('[USER_REFLECTIONS_REDACTED]'), 'Reflections should be redacted');
      assert.ok(!result.includes('anxious'), 'Reflection content should not remain');
    });

    test('strips newline-separated **Querent\'s Reflections** format', () => {
      const text = `**Querent's Reflections**:
I see myself in the Hermit card.
This reminds me of my divorce from Michael.
The isolation period was so difficult.

**Vision Validation**:`;
      const result = stripUserContent(text);

      assert.ok(result.includes('[USER_REFLECTIONS_REDACTED]'), 'Reflections should be redacted');
      assert.ok(!result.includes('Hermit'), 'Card reflection should be redacted');
      assert.ok(!result.includes('Michael'), 'PII should be redacted');
      assert.ok(!result.includes('divorce'), 'Personal content should be redacted');
      assert.ok(result.includes('**Vision Validation**:'), 'Next section should remain');
    });

    test('strips *Querent\'s Reflection: "..."* inline format', () => {
      const text = 'Some text *Querent\'s Reflection: "This card reminds me of my mother\'s death"* more text';
      const result = stripUserContent(text);

      assert.ok(result.includes('[USER_REFLECTION_REDACTED]'), 'Reflection should be redacted');
      assert.ok(!result.includes('mother'), 'Personal content should not remain');
    });
  });

  describe('card label question embedding', () => {
    test('strips question from Outcome position label', () => {
      const text = 'Outcome — likely path for "What should I do about my marriage?" if unchanged (Card 10)';
      const result = stripUserContent(text);

      assert.ok(result.includes('[USER_QUESTION_REDACTED]'), 'Question should be redacted');
      assert.ok(!result.includes('marriage'), 'Question content should not remain');
      assert.ok(result.includes('if unchanged'), 'Label suffix should remain');
    });

    test('strips question from Future position label with en-dash', () => {
      const text = 'Future – likely trajectory for "How will my startup perform?" if nothing shifts';
      const result = stripUserContent(text);

      assert.ok(result.includes('[USER_QUESTION_REDACTED]'), 'Question should be redacted');
      assert.ok(!result.includes('startup'), 'Question content should not remain');
    });

    test('strips question from Future position label with em-dash', () => {
      const text = 'Future — likely trajectory for "Should I accept the job offer from Google?" if nothing shifts';
      const result = stripUserContent(text);

      assert.ok(result.includes('[USER_QUESTION_REDACTED]'), 'Question should be redacted');
      assert.ok(!result.includes('Google'), 'Company name should not remain');
      assert.ok(!result.includes('job offer'), 'Question content should not remain');
    });
  });

  describe('displayName-prefixed questions', () => {
    test('strips personalized question format', () => {
      const text = '**Question**: Sarah, you asked: What should I do about my relationship with Tom?\n\n**Cards**:';
      const result = stripUserContent(text);

      assert.ok(result.includes('[USER_QUESTION_REDACTED]'), 'Question should be redacted');
      assert.ok(!result.includes('Tom'), 'Name in question should not remain');
      assert.ok(!result.includes('relationship'), 'Question content should not remain');
    });

    test('strips "you asked:" pattern mid-line', () => {
      const text = 'Name, you asked: How can I heal from my trauma after the accident?\n\nMore content.';
      const result = stripUserContent(text);

      assert.ok(result.includes('[USER_QUESTION_REDACTED]'), 'Question should be redacted');
      assert.ok(!result.includes('trauma'), 'Question content should not remain');
      assert.ok(!result.includes('accident'), 'Personal detail should not remain');
    });
  });

  describe('edge cases', () => {
    test('handles empty string', () => {
      assert.strictEqual(stripUserContent(''), '');
    });

    test('handles null/undefined', () => {
      assert.strictEqual(stripUserContent(null), '');
      assert.strictEqual(stripUserContent(undefined), '');
    });

    test('handles text with no user content', () => {
      const text = '**Cards**: The Fool, The Magician\n\n**Analysis**: These cards suggest...';
      const result = stripUserContent(text);

      assert.strictEqual(result, text, 'Text without user content should remain unchanged');
    });

    test('handles multiple user content sections', () => {
      const text = `**Question**: What about my career?

**Cards**: The Tower

**Querent's Reflections**:
This card scares me.

**Outcome**: Outcome — likely path for "career question" if unchanged`;
      const result = stripUserContent(text);

      // All three user content areas should be redacted
      assert.ok(!result.includes('What about my career'), 'Question should be redacted');
      assert.ok(!result.includes('scares me'), 'Reflection should be redacted');
      assert.ok(!result.includes('career question'), 'Outcome label question should be redacted');
      assert.ok(result.includes('**Cards**: The Tower'), 'Non-user content should remain');
    });
  });
});
</file>

<file path="tests/questionQuality.test.mjs">
import assert from 'node:assert/strict';
import { describe, it } from 'node:test';

import { scoreQuestion, getQualityLevel } from '../src/lib/questionQuality.js';

describe('Question quality scoring', () => {
  it('rewards open, specific, time-bound, agency-forward questions', () => {
    const result = scoreQuestion('How can I navigate my career transition over the next six months?');
    assert.ok(result.openEnded);
    assert.ok(result.specific);
    assert.ok(result.actionable);
    assert.ok(result.timeframe);
    assert.ok(result.concreteSubject);
    assert.ok(result.score >= 85);
    assert.equal(getQualityLevel(result.score).label, 'Excellent');
  });

  it('penalizes deterministic yes/no phrasing', () => {
    const result = scoreQuestion('Will he come back to me?');
    assert.ok(result.deterministicLanguage);
    assert.ok(!result.openEnded);
    assert.ok(result.score < 40);
    assert.ok(result.feedback.some(tip => /avoid fate|avoid/.test(tip.toLowerCase())));
  });

  it('asks for more detail on short, vague prompts', () => {
    const result = scoreQuestion('What should I do?');
    assert.ok(result.score < 70);
    assert.ok(result.feedback.some(tip => /more detail/i.test(tip)));
  });

  it('rewards agency verbs and timeframe grounding', () => {
    const result = scoreQuestion('How do I build healthier boundaries at work this month?');
    assert.ok(result.actionable);
    assert.ok(result.timeframe);
    assert.ok(result.score >= 75);
  });
});
</file>

<file path="tests/readingSchema.test.mjs">
import test from 'node:test';
import assert from 'node:assert/strict';

import { safeParseReadingRequest } from '../shared/contracts/readingSchema.js';

const basePayload = {
  spreadInfo: {
    name: 'Three-Card Story (Past · Present · Future)',
    key: 'threeCard',
    deckStyle: 'rws-1909'
  },
  cardsInfo: [
    {
      position: ' Past ',
      card: ' The Fool ',
      canonicalName: 'The Fool',
      canonicalKey: 'major-00',
      aliases: [],
      orientation: 'Upright',
      meaning: 'Fresh starts and boundless curiosity.',
      number: 0,
      suit: null,
      rank: null,
      rankValue: 0,
      userReflection: null
    },
    {
      position: 'Present',
      card: 'The Magician',
      canonicalName: 'The Magician',
      canonicalKey: 'major-01',
      aliases: [],
      orientation: 'Reversed',
      meaning: 'Paused manifestation momentum.',
      number: 1,
      suit: null,
      rank: null,
      rankValue: 1,
      userReflection: null
    },
    {
      position: 'Future',
      card: 'The High Priestess',
      canonicalName: 'The High Priestess',
      canonicalKey: 'major-02',
      aliases: [],
      orientation: 'Upright',
      meaning: 'Deep intuition moments',
      number: 2,
      suit: null,
      rank: null,
      rankValue: 2,
      userReflection: null
    }
  ],
  userQuestion: 'What should I focus on next?',
  reflectionsText: 'Past: leaned into the unknown',
  deckStyle: 'rws-1909'
};

test('safeParseReadingRequest trims and validates core payloads', () => {
  const result = safeParseReadingRequest(basePayload);
  assert.equal(result.success, true, result.error || 'payload should be valid');

  assert.equal(result.data.spreadInfo.name, 'Three-Card Story (Past · Present · Future)');
  assert.equal(result.data.cardsInfo[0].position, 'Past'); // trimmed
  assert.equal(result.data.cardsInfo[0].card, 'The Fool');
});

test('safeParseReadingRequest surfaces orientation errors', () => {
  const invalid = {
    ...basePayload,
    cardsInfo: [
      {
        ...basePayload.cardsInfo[0],
        orientation: 'Sideways'
      }
    ]
  };

  const result = safeParseReadingRequest(invalid);
  assert.equal(result.success, false, 'orientation mismatch should fail');
  assert.match(result.error, /orientation/i);
});
</file>

<file path="tests/scheduled.test.mjs">
import assert from 'node:assert';
import test from 'node:test';

import { handleScheduled } from '../functions/lib/scheduled.js';

class FakeKV {
  constructor(entries) {
    this.map = new Map(entries);
  }

  async list({ prefix, limit = 100, cursor }) {
    const keys = Array.from(this.map.keys()).filter(key => key.startsWith(prefix));
    const start = cursor ? Number(cursor) : 0;
    const slice = keys.slice(start, start + limit);
    const nextCursor = start + limit < keys.length ? String(start + limit) : undefined;

    return {
      keys: slice.map(name => ({ name, metadata: { dummy: true } })),
      list_complete: nextCursor === undefined,
      cursor: nextCursor
    };
  }

  async get(name) {
    return this.map.get(name);
  }

  async delete(name) {
    this.map.delete(name);
  }
}

class FakeBucket {
  constructor() {
    this.objects = [];
  }

  async put(key, value, options) {
    this.objects.push({ key, value, options });
  }
}

class FakeDB {
  constructor(deleted = 0) {
    this.deleted = deleted;
  }

  prepare() {
    const self = this;
    return {
      bind() {
        return {
          run() {
            return { meta: { changes: self.deleted } };
          }
        };
      }
    };
  }
}

const RealDate = global.Date;
const fixedNow = new Date('2025-02-01T03:04:05Z');

function mockDate() {
  global.Date = class extends RealDate {
    constructor(...args) {
      if (args.length === 0) {
        return new RealDate(fixedNow);
      }
      return new RealDate(...args);
    }

    static now() {
      return fixedNow.getTime();
    }

    static parse(value) {
      return RealDate.parse(value);
    }

    static UTC(...args) {
      return RealDate.UTC(...args);
    }
  };
}

test('handleScheduled archives KV data and writes summary', async (t) => {
  mockDate();
  t.after(() => {
    global.Date = RealDate;
  });

  const metricsKV = new FakeKV([
    ['reading:1', { requestId: 'r1' }],
    ['reading:2', { requestId: 'r2' }]
  ]);
  const feedbackKV = new FakeKV([
    ['feedback:1', { message: 'Great' }]
  ]);
  const bucket = new FakeBucket();
  const db = new FakeDB(2);

  await handleScheduled(
    { cron: '0 3 * * *' },
    { METRICS_DB: metricsKV, FEEDBACK_KV: feedbackKV, LOGS_BUCKET: bucket, DB: db },
    { waitUntil: (promise) => promise }
  );

  assert.strictEqual(metricsKV.map.size, 0, 'metrics KV keys should be deleted');
  assert.strictEqual(feedbackKV.map.size, 0, 'feedback KV keys should be deleted');

  const keys = bucket.objects.map(obj => obj.key);
  assert.ok(keys.some(key => key.startsWith('archives/metrics/2025-02-01/')));
  assert.ok(keys.some(key => key.startsWith('archives/feedback/2025-02-01/')));
  assert.ok(keys.includes('archives/summaries/2025-02-01.json'));

  const summaryObj = bucket.objects.find(obj => obj.key === 'archives/summaries/2025-02-01.json');
  const summary = JSON.parse(summaryObj.value);

  assert.strictEqual(summary.totalArchived, 3);
  assert.strictEqual(summary.sessions.deleted, 2);
});
</file>

<file path="tests/tts-hume.test.mjs">
import assert from 'node:assert/strict';
import { describe, it, before, after, beforeEach, afterEach, mock } from 'node:test';

import { getActingInstructions } from '../src/data/emotionMapping.js';
import { audioCache } from '../src/lib/audioCache.js';
import { speakWithHume, stopHumeAudio, resetGenerationId } from '../src/lib/audioHume.js';

// Shared fetch mock for both API and client tests
const mockFetch = mock.fn();
global.fetch = mockFetch;

// Simple Audio stub for client-side tests
const OriginalAudio = global.Audio;
class MockAudio {
  constructor(src) {
    this.src = src;
    this.paused = true;
    this.currentTime = 0;
    this.onended = null;
    this.onerror = null;
  }

  play() {
    this.paused = false;
    return Promise.resolve();
  }

  pause() {
    this.paused = true;
  }
}

function createMockRequest(url, options = {}) {
  const fullUrl = url.startsWith('http') ? url : `https://example.com${url}`;
  const headers = new Map(Object.entries(options.headers || {}));

  return {
    url: fullUrl,
    method: options.method || 'GET',
    headers: {
      get: (key) => headers.get(key.toLowerCase()) || null,
      set: (key, value) => headers.set(key.toLowerCase(), value),
      has: (key) => headers.has(key.toLowerCase())
    },
    json: async () => options.body || {},
    text: async () => JSON.stringify(options.body || {})
  };
}

function createMockEnv(overrides = {}) {
  return {
    HUME_API_KEY: 'test-hume-key',
    ...overrides
  };
}

describe('Hume TTS API (functions/api/tts-hume.js)', () => {
  const originalConsoleError = console.error;
  const originalConsoleWarn = console.warn;

  beforeEach(() => {
    mockFetch.mock.resetCalls();
    console.error = () => {};
    console.warn = () => {};
  });

  afterEach(() => {
    console.error = originalConsoleError;
    console.warn = originalConsoleWarn;
  });

  it('returns health status based on API key presence', async () => {
    const { onRequestGet } = await import('../functions/api/tts-hume.js');

    const responseWithKey = await onRequestGet({ env: createMockEnv() });
    const dataWithKey = await responseWithKey.json();
    assert.strictEqual(dataWithKey.provider, 'hume-ai');

    const responseNoKey = await onRequestGet({ env: createMockEnv({ HUME_API_KEY: undefined }) });
    const dataNoKey = await responseNoKey.json();
    assert.strictEqual(dataNoKey.provider, 'unavailable');
  });

  it('rejects requests without text', async () => {
    const { onRequestPost } = await import('../functions/api/tts-hume.js');

    const request = createMockRequest('/api/tts-hume', {
      method: 'POST',
      body: {}
    });

    const response = await onRequestPost({ request, env: createMockEnv() });
    const data = await response.json();

    assert.strictEqual(response.status, 400);
    assert.match(data.error, /text.*required/i);
  });

  it('returns 503 when Hume is not configured', async () => {
    const { onRequestPost } = await import('../functions/api/tts-hume.js');

    const request = createMockRequest('/api/tts-hume', {
      method: 'POST',
      body: { text: 'Hello' }
    });

    const response = await onRequestPost({ request, env: createMockEnv({ HUME_API_KEY: undefined }) });
    const data = await response.json();

    assert.strictEqual(response.status, 503);
    assert.match(data.error, /not configured/i);
  });

  it('builds payload with acting instructions and clamps values', async () => {
    const actingInstructions = getActingInstructions('hopeful-transformative');

    mockFetch.mock.mockImplementation(() =>
      Promise.resolve({
        ok: true,
        json: async () => ({
          generations: [
            {
              audio: 'YmFzZTY0LWF1ZGlv',
              context: { generationId: 'gen-xyz' }
            }
          ]
        })
      })
    );

    const { onRequestPost } = await import('../functions/api/tts-hume.js');

    const request = createMockRequest('/api/tts-hume', {
      method: 'POST',
      body: {
        text: 'Mystical guidance',
        context: 'synthesis',
        voiceName: 'KORA',
        emotion: 'hopeful-transformative',
        speed: 3.5,
        trailingSilence: 10,
        previousGenerationId: 'prev-123'
      }
    });

    const response = await onRequestPost({ request, env: createMockEnv() });
    const data = await response.json();
    assert.strictEqual(response.status, 200);
    assert.strictEqual(data.provider, 'hume-ai');
    assert.strictEqual(data.generationId, 'gen-xyz');

    const call = mockFetch.mock.calls[0];
    const options = call.arguments[1];
    const payload = JSON.parse(options.body);
    const utterance = payload.utterances[0];

    assert.strictEqual(payload.context.generationId, 'prev-123');
    assert.strictEqual(utterance.voice.name, 'KORA');
    assert.strictEqual(utterance.description, actingInstructions);
    assert.strictEqual(utterance.speed, 2); // clamped to max 2.0
    assert.strictEqual(utterance.trailing_silence, 5); // clamped to max 5 seconds
  });

  it('propagates rate limit errors from Hume', async () => {
    mockFetch.mock.mockImplementation(() =>
      Promise.resolve({
        ok: false,
        status: 429,
        text: async () => JSON.stringify({ error: 'Rate limit' })
      })
    );

    const { onRequestPost } = await import('../functions/api/tts-hume.js');

    const request = createMockRequest('/api/tts-hume', {
      method: 'POST',
      body: { text: 'Too many requests' }
    });

    const response = await onRequestPost({ request, env: createMockEnv() });
    const data = await response.json();

    assert.strictEqual(response.status, 429);
    assert.match(data.error, /rate limit/i);
  });
});

describe('Hume TTS Client (audioHume.js)', () => {
  before(() => {
    global.Audio = MockAudio;
  });

  after(() => {
    global.Audio = OriginalAudio;
  });

  beforeEach(() => {
    audioCache.clear();
    resetGenerationId();
    stopHumeAudio();
    mockFetch.mock.resetCalls();
  });

  it('requests /api/tts-hume and returns generation info', async () => {
    mockFetch.mock.mockImplementation(() =>
      Promise.resolve({
        ok: true,
        json: async () => ({
          audio: 'data:audio/mpeg;base64,AAA',
          generationId: 'gen-123',
          voiceUsed: 'ITO'
        })
      })
    );

    const result = await speakWithHume('Tarot reading time', {
      context: 'full-reading',
      voiceName: 'ITO',
      speed: 1.0
    });

    assert.strictEqual(mockFetch.mock.calls[0].arguments[0], '/api/tts-hume');
    const body = JSON.parse(mockFetch.mock.calls[0].arguments[1].body);
    assert.strictEqual(body.text, 'Tarot reading time');
    assert.strictEqual(body.context, 'full-reading');
    assert.strictEqual(result.generationId, 'gen-123');
    assert.strictEqual(result.voiceUsed, 'ITO');
    await result.play();
  });

  it('uses cached audio for short repeated phrases', async () => {
    mockFetch.mock.mockImplementation(() =>
      Promise.resolve({
        ok: true,
        json: async () => ({
          audio: 'data:audio/mpeg;base64,AAA',
          generationId: 'cache-gen'
        })
      })
    );

    await speakWithHume('Hi', { emotion: 'hopeful-transformative' });
    mockFetch.mock.resetCalls();

    const result = await speakWithHume('Hi', { emotion: 'hopeful-transformative' });

    assert.strictEqual(mockFetch.mock.calls.length, 0);
    assert.strictEqual(result.cached, true);
    await result.play();
  });

  it('sends previousGenerationId when continuing a voice', async () => {
    mockFetch.mock.mockImplementation(() =>
      Promise.resolve({
        ok: true,
        json: async () => ({
          audio: 'data:audio/mpeg;base64,AAA',
          generationId: 'first-gen',
          voiceUsed: 'ITO'
        })
      })
    );

    await speakWithHume('First segment');

    mockFetch.mock.resetCalls();
    mockFetch.mock.mockImplementation(() =>
      Promise.resolve({
        ok: true,
        json: async () => ({
          audio: 'data:audio/mpeg;base64,BBB',
          generationId: 'second-gen',
          voiceUsed: 'ITO'
        })
      })
    );

    await speakWithHume('Second segment', { continuePrevious: true });

    const body = JSON.parse(mockFetch.mock.calls[0].arguments[1].body);
    assert.strictEqual(body.previousGenerationId, 'first-gen');
  });

  it('throws when the API responds with an error', async () => {
    mockFetch.mock.mockImplementation(() =>
      Promise.resolve({
        ok: false,
        status: 500,
        text: async () => 'boom'
      })
    );

    await assert.rejects(() => speakWithHume('Failing request'), /TTS request failed/);
  });

  it('stops playback and resets the current audio', async () => {
    mockFetch.mock.mockImplementation(() =>
      Promise.resolve({
        ok: true,
        json: async () => ({
          audio: 'data:audio/mpeg;base64,AAA',
          generationId: 'gen-stop'
        })
      })
    );

    const result = await speakWithHume('Stop the audio');
    await result.play();

    stopHumeAudio();

    assert.strictEqual(result.audio.paused, true);
    assert.strictEqual(result.audio.currentTime, 0);
  });
});
</file>

<file path="tests/tts.test.mjs">
import assert from 'node:assert/strict';
import { describe, it, beforeEach, mock } from 'node:test';

/**
 * TTS (Text-to-Speech) API Tests
 *
 * Tests for functions/api/tts.js covering:
 * - Health check endpoint (GET)
 * - Request validation
 * - Text sanitization
 * - Rate limiting
 * - Voice and speed validation
 * - Azure TTS integration
 * - Fallback audio generation
 * - Streaming mode
 * - Environment variable resolution
 */

// Mock dependencies
const mockFetch = mock.fn();
global.fetch = mockFetch;

// Mock console to suppress logs during tests
const originalConsoleLog = console.log;
const originalConsoleError = console.error;
const originalConsoleWarn = console.warn;

// Helper to create a mock Request object
function createMockRequest(url, options = {}) {
  const fullUrl = url.startsWith('http') ? url : `https://example.com${url}`;
  const headers = new Map(Object.entries(options.headers || {}));

  return {
    url: fullUrl,
    method: options.method || 'GET',
    headers: {
      get: (key) => headers.get(key.toLowerCase()) || null,
      set: (key, value) => headers.set(key.toLowerCase(), value),
      has: (key) => headers.has(key.toLowerCase())
    },
    json: async () => options.body || {},
    text: async () => JSON.stringify(options.body || {})
  };
}

// Helper to create mock environment
function createMockEnv(overrides = {}) {
  return {
    AZURE_OPENAI_ENDPOINT: 'https://test.openai.azure.com',
    AZURE_OPENAI_API_KEY: 'test-key',
    AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT: 'gpt-audio-mini',
    AZURE_OPENAI_API_VERSION: '2025-04-01-preview',
    AZURE_OPENAI_GPT_AUDIO_MINI_FORMAT: 'mp3',
    RATELIMIT: null, // No rate limiting by default in tests
    ...overrides
  };
}

// Mock KV store for rate limiting tests
class MockKVStore {
  constructor() {
    this.store = new Map();
  }

  async get(key) {
    return this.store.get(key) || null;
  }

  async put(key, value, options = {}) {
    this.store.set(key, value);
    if (options.expirationTtl) {
      setTimeout(() => this.store.delete(key), options.expirationTtl * 1000);
    }
  }

  clear() {
    this.store.clear();
  }
}

describe('TTS API - Health Check (GET)', () => {
  it('should return ok status with azure-openai provider when credentials are present', async () => {
    // Dynamically import to get fresh module
    const { onRequestGet } = await import('../functions/api/tts.js');

    const env = createMockEnv();
    const response = await onRequestGet({ env });
    const data = await response.json();

    assert.strictEqual(response.status, 200);
    assert.strictEqual(data.status, 'ok');
    assert.strictEqual(data.provider, 'azure-openai');
    assert.ok(data.timestamp);
  });

  it('should return ok status with local provider when credentials are missing', async () => {
    const { onRequestGet } = await import('../functions/api/tts.js');

    // Clear process.env credentials temporarily
    const originalEndpoint = process.env.AZURE_OPENAI_ENDPOINT;
    const originalKey = process.env.AZURE_OPENAI_API_KEY;
    const originalDeployment = process.env.AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT;

    delete process.env.AZURE_OPENAI_ENDPOINT;
    delete process.env.AZURE_OPENAI_API_KEY;
    delete process.env.AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT;
    delete process.env.AZURE_OPENAI_TTS_ENDPOINT;
    delete process.env.AZURE_OPENAI_TTS_API_KEY;

    const env = {};
    const response = await onRequestGet({ env });
    const data = await response.json();

    // Restore process.env
    if (originalEndpoint) process.env.AZURE_OPENAI_ENDPOINT = originalEndpoint;
    if (originalKey) process.env.AZURE_OPENAI_API_KEY = originalKey;
    if (originalDeployment) process.env.AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT = originalDeployment;

    assert.strictEqual(response.status, 200);
    assert.strictEqual(data.status, 'ok');
    assert.strictEqual(data.provider, 'local');
    assert.ok(data.timestamp);
  });

  it('should use TTS-specific credentials when available', async () => {
    const { onRequestGet } = await import('../functions/api/tts.js');

    const env = createMockEnv({
      AZURE_OPENAI_TTS_ENDPOINT: 'https://tts-specific.openai.azure.com',
      AZURE_OPENAI_TTS_API_KEY: 'tts-specific-key'
    });

    const response = await onRequestGet({ env });
    const data = await response.json();

    assert.strictEqual(data.provider, 'azure-openai');
  });
});

describe('TTS API - Request Validation (POST)', () => {
  beforeEach(() => {
    console.log = () => {}; // Suppress logs
    console.error = () => {};
    console.warn = () => {};
  });

  it('should reject requests without text field', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: {}
    });
    const env = createMockEnv();

    const response = await onRequestPost({ request, env });
    const data = await response.json();

    assert.strictEqual(response.status, 400);
    assert.ok(data.error);
    assert.match(data.error, /text.*required/i);
  });

  it('should reject requests with empty text', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: '   ' }
    });
    const env = createMockEnv();

    const response = await onRequestPost({ request, env });
    const data = await response.json();

    assert.strictEqual(response.status, 400);
    assert.ok(data.error);
  });

  it('should accept requests with valid text', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'The Fool card represents new beginnings.' }
    });
    const env = createMockEnv({
      RATELIMIT: null,
      // No Azure credentials, will use fallback
      AZURE_OPENAI_ENDPOINT: null
    });

    const response = await onRequestPost({ request, env });
    const data = await response.json();

    assert.strictEqual(response.status, 200);
    assert.ok(data.audio);
    assert.strictEqual(data.provider, 'fallback');
  });
});

describe('TTS API - Text Sanitization', () => {
  it('should trim whitespace from text', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: '   test   ' }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null // Use fallback
    });

    const response = await onRequestPost({ request, env });
    const data = await response.json();

    assert.strictEqual(response.status, 200);
    // Fallback should still work with trimmed text
    assert.ok(data.audio);
  });

  it('should limit text to 4000 characters', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const longText = 'a'.repeat(5000);
    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: longText }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null // Use fallback
    });

    const response = await onRequestPost({ request, env });
    const data = await response.json();

    assert.strictEqual(response.status, 200);
    // Should succeed with truncated text
    assert.ok(data.audio);
  });

  it('should handle non-string text input', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 12345 }
    });
    const env = createMockEnv();

    const response = await onRequestPost({ request, env });
    const data = await response.json();

    assert.strictEqual(response.status, 400);
    assert.ok(data.error);
  });
});

describe('TTS API - Rate Limiting', () => {
  beforeEach(() => {
    console.warn = () => {}; // Suppress warnings
  });

  it('should allow requests when under rate limit', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const kvStore = new MockKVStore();
    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' },
      headers: { 'cf-connecting-ip': '192.168.1.1' }
    });
    const env = createMockEnv({
      RATELIMIT: kvStore,
      AZURE_OPENAI_ENDPOINT: null, // Use fallback
      TTS_RATE_LIMIT_MAX: 5,
      TTS_RATE_LIMIT_WINDOW: 60
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);
  });

  it('should reject requests when rate limit exceeded', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const kvStore = new MockKVStore();
    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' },
      headers: { 'cf-connecting-ip': '192.168.1.1' }
    });
    const env = createMockEnv({
      RATELIMIT: kvStore,
      AZURE_OPENAI_ENDPOINT: null,
      TTS_RATE_LIMIT_MAX: 2,
      TTS_RATE_LIMIT_WINDOW: 60
    });

    // Make requests up to the limit
    await onRequestPost({ request, env });
    await onRequestPost({ request, env });

    // This one should be rate limited
    const response = await onRequestPost({ request, env });
    const data = await response.json();

    assert.strictEqual(response.status, 429);
    assert.ok(data.error);
    assert.match(data.error, /too many.*requests/i);
    assert.ok(response.headers.get('retry-after'));
  });

  it('should use client IP from cf-connecting-ip header', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const kvStore = new MockKVStore();
    const request1 = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' },
      headers: { 'cf-connecting-ip': '192.168.1.1' }
    });
    const request2 = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' },
      headers: { 'cf-connecting-ip': '192.168.1.2' }
    });
    const env = createMockEnv({
      RATELIMIT: kvStore,
      AZURE_OPENAI_ENDPOINT: null,
      TTS_RATE_LIMIT_MAX: 1,
      TTS_RATE_LIMIT_WINDOW: 60
    });

    // Different IPs should have separate rate limits
    const response1 = await onRequestPost({ request: request1, env });
    const response2 = await onRequestPost({ request: request2, env });

    assert.strictEqual(response1.status, 200);
    assert.strictEqual(response2.status, 200);
  });

  it('should handle x-forwarded-for header with multiple IPs', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const kvStore = new MockKVStore();
    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' },
      headers: { 'x-forwarded-for': '192.168.1.1, 10.0.0.1, 172.16.0.1' }
    });
    const env = createMockEnv({
      RATELIMIT: kvStore,
      AZURE_OPENAI_ENDPOINT: null
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);

    // Should use first IP
    const keys = Array.from(kvStore.store.keys());
    assert.ok(keys.some(k => k.includes('192.168.1.1')));
  });

  it('should use "anonymous" when no IP headers present', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const kvStore = new MockKVStore();
    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' }
    });
    const env = createMockEnv({
      RATELIMIT: kvStore,
      AZURE_OPENAI_ENDPOINT: null
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);

    const keys = Array.from(kvStore.store.keys());
    assert.ok(keys.some(k => k.includes('anonymous')));
  });
});

describe('TTS API - Voice and Speed Validation', () => {
  beforeEach(() => {
    console.log = () => {};
    console.error = () => {};
  });

  it('should use default voice "nova" when no voice specified', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null // Use fallback
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);
  });

  it('should use default speed 1.1 when no speed specified', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null // Use fallback
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);
  });

  it('should clamp speed to minimum 0.25', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test', speed: 0.1 }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null // Use fallback
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);
  });

  it('should clamp speed to maximum 4.0', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test', speed: 5.0 }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null // Use fallback
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);
  });
});

describe('TTS API - Context Templates', () => {
  it('should accept card-reveal context', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'The Fool', context: 'card-reveal' }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);
  });

  it('should accept full-reading context', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'Your reading shows...', context: 'full-reading' }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);
  });

  it('should accept synthesis context', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'To synthesize...', context: 'synthesis' }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);
  });

  it('should use default context for unknown contexts', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test', context: 'unknown-context' }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);
  });
});

describe('TTS API - Fallback Audio Generation', () => {
  beforeEach(() => {
    console.error = () => {}; // Suppress error logs
  });

  it('should return fallback audio when Azure is not configured', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' }
    });
    const env = {
      // No Azure credentials
    };

    const response = await onRequestPost({ request, env });
    const data = await response.json();

    assert.strictEqual(response.status, 200);
    assert.ok(data.audio);
    assert.ok(data.audio.startsWith('data:audio/wav;base64,'));
    assert.strictEqual(data.provider, 'fallback');
  });

  it('should return fallback audio when Azure fails', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    // Mock fetch to fail
    mockFetch.mock.mockImplementation(() => {
      throw new Error('Azure API failed');
    });

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' }
    });
    const env = createMockEnv();

    const response = await onRequestPost({ request, env });
    const data = await response.json();

    assert.strictEqual(response.status, 200);
    assert.strictEqual(data.provider, 'fallback');

    mockFetch.mock.resetCalls();
  });
});

describe('TTS API - Streaming Mode', () => {
  beforeEach(() => {
    console.log = () => {};
    console.error = () => {};
  });

  it('should detect streaming mode from query parameter', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts?stream=true', {
      method: 'POST',
      body: { text: 'test' }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null // Use fallback
    });

    const response = await onRequestPost({ request, env });

    assert.strictEqual(response.status, 200);
    assert.ok(response.headers.get('content-type').includes('audio/'));
    // Streaming mode returns binary audio directly, not JSON with base64
    // Note: transfer-encoding: chunked is only set when streaming unknown-length data;
    // the fallback audio returns a fixed-size Uint8Array so no chunked encoding is used
    const body = await response.arrayBuffer();
    assert.ok(body.byteLength > 0, 'Should return binary audio data');
  });

  it('should return non-streaming response when stream=false', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts?stream=false', {
      method: 'POST',
      body: { text: 'test' }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null
    });

    const response = await onRequestPost({ request, env });
    const data = await response.json();

    assert.strictEqual(response.status, 200);
    assert.ok(data.audio);
    assert.ok(data.provider);
  });
});

describe('TTS API - Environment Resolution', () => {
  it('should resolve environment variables from env object', async () => {
    const { onRequestGet } = await import('../functions/api/tts.js');

    const env = {
      AZURE_OPENAI_ENDPOINT: 'https://from-env.openai.azure.com',
      AZURE_OPENAI_API_KEY: 'key-from-env',
      AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT: 'deployment-from-env'
    };

    const response = await onRequestGet({ env });
    const data = await response.json();

    assert.strictEqual(data.provider, 'azure-openai');
  });

  it('should prefer TTS-specific credentials over shared credentials', async () => {
    const { onRequestGet } = await import('../functions/api/tts.js');

    const env = {
      AZURE_OPENAI_ENDPOINT: 'https://shared.openai.azure.com',
      AZURE_OPENAI_API_KEY: 'shared-key',
      AZURE_OPENAI_TTS_ENDPOINT: 'https://tts.openai.azure.com',
      AZURE_OPENAI_TTS_API_KEY: 'tts-key',
      AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT: 'deployment'
    };

    const response = await onRequestGet({ env });
    const data = await response.json();

    assert.strictEqual(data.provider, 'azure-openai');
  });
});

describe('TTS API - Debug Logging', () => {
  it('should enable debug logging in non-production NODE_ENV', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const originalEnv = process.env.NODE_ENV;
    process.env.NODE_ENV = 'development';

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);

    process.env.NODE_ENV = originalEnv;
  });

  it('should respect explicit ENABLE_TTS_DEBUG_LOGGING flag', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' }
    });
    const env = createMockEnv({
      AZURE_OPENAI_ENDPOINT: null,
      ENABLE_TTS_DEBUG_LOGGING: 'true'
    });

    const response = await onRequestPost({ request, env });
    assert.strictEqual(response.status, 200);
  });
});

describe('TTS API - Error Handling', () => {
  beforeEach(() => {
    console.error = () => {}; // Suppress error logs
  });

  it('should handle Azure TTS failures gracefully with fallback', async () => {
    const { onRequestPost } = await import('../functions/api/tts.js');

    // Mock fetch to simulate Azure failure
    mockFetch.mock.mockImplementation(() =>
      Promise.resolve({
        ok: false,
        status: 500,
        statusText: 'Internal Server Error',
        text: async () => 'Azure service error',
        headers: new Map()
      })
    );

    const request = createMockRequest('/api/tts', {
      method: 'POST',
      body: { text: 'test' }
    });
    const env = createMockEnv();

    const response = await onRequestPost({ request, env });
    const data = await response.json();

    // Should fallback gracefully instead of returning error
    assert.strictEqual(response.status, 200);
    assert.ok(data.audio);
    assert.strictEqual(data.provider, 'fallback');

    mockFetch.mock.resetCalls();
  });
});

// Restore console after all tests
describe('Cleanup', () => {
  it('should restore console functions', () => {
    console.log = originalConsoleLog;
    console.error = originalConsoleError;
    console.warn = originalConsoleWarn;
    assert.ok(true);
  });
});
</file>

<file path="tests/visionWeaving.test.mjs">
/**
 * Vision Weaving Integration Test
 * Verifies that vision-detected tone/emotion are injected into narrative prompts
 */

import { buildEnhancedClaudePrompt } from '../functions/lib/narrativeBuilder.js';

// Mock card data with vision insights
const mockCardsInfo = [
  {
    card: 'The Fool',
    number: 0,
    position: 'Past — influences that led here',
    orientation: 'Upright',
    meaning: 'New beginnings, innocence, spontaneity'
  },
  {
    card: 'The Magician',
    number: 1,
    position: 'Present — where you stand now',
    orientation: 'Upright',
    meaning: 'Manifestation, resourcefulness, power'
  },
  {
    card: 'The High Priestess',
    number: 2,
    position: 'Future — trajectory if nothing shifts',
    orientation: 'Reversed',
    meaning: 'Hidden agendas, need to listen to inner voice'
  }
];

// Mock vision insights with visual profiles
const mockVisionInsights = [
  {
    label: 'fool-upload',
    predictedCard: 'The Fool',
    confidence: 0.92,
    basis: 'image',
    visualProfile: {
      tone: ['mystical', 'ethereal'],
      emotion: ['joyful', 'carefree']
    }
  },
  {
    label: 'magician-upload',
    predictedCard: 'The Magician',
    confidence: 0.88,
    basis: 'text',
    visualProfile: {
      tone: ['vibrant', 'bold'],
      emotion: ['confident', 'focused']
    }
  },
  {
    label: 'priestess-upload',
    predictedCard: 'The High Priestess',
    confidence: 0.85,
    basis: 'adapter',
    visualProfile: {
      tone: ['dark', 'mysterious'],
      emotion: ['contemplative', 'introspective']
    }
  }
];

const mockSpreadInfo = {
  name: 'Three-Card Story (Past · Present · Future)',
  deckStyle: 'rws-1909'
};

const mockThemes = {
  reversalCount: 1,
  reversalFramework: 'contextual',
  reversalDescription: {
    name: 'Context-Dependent',
    description: 'Reversed cards interpreted based on position and context',
    guidance: 'Read each reversal in light of its position'
  },
  elementalBalance: 'Mixed elemental energies: Air (3)',
  deckStyle: 'rws-1909'
};

console.log('🧪 Testing Vision Weaving Enhancement...\n');

try {
  const { systemPrompt: _systemPrompt, userPrompt } = buildEnhancedClaudePrompt({
    spreadInfo: mockSpreadInfo,
    cardsInfo: mockCardsInfo,
    userQuestion: 'How can I navigate this new phase?',
    reflectionsText: null,
    themes: mockThemes,
    spreadAnalysis: {
      transitions: {
        firstToSecond: { relationship: 'supportive', elements: ['Air', 'Air'] },
        secondToThird: { relationship: 'tension', elements: ['Air', 'Water'] }
      }
    },
    context: 'self',
    visionInsights: mockVisionInsights,
    deckStyle: 'rws-1909'
  });

  console.log('✅ buildEnhancedClaudePrompt executed successfully\n');

  // Check that vision tone/emotion appear in user prompt
  const checks = [
    {
      name: 'Fool mystical tone',
      pattern: /mystical.*ethereal/i,
      context: 'The Fool card'
    },
    {
      name: 'Fool joyful emotion',
      pattern: /joyful.*carefree/i,
      context: 'The Fool card'
    },
    {
      name: 'Magician vibrant tone',
      pattern: /vibrant.*bold/i,
      context: 'The Magician card'
    },
    {
      name: 'Magician confident emotion',
      pattern: /confident.*focused/i,
      context: 'The Magician card'
    },
    {
      name: 'High Priestess dark tone',
      pattern: /dark.*mysterious/i,
      context: 'The High Priestess card'
    },
    {
      name: 'High Priestess contemplative emotion',
      pattern: /contemplative.*introspective/i,
      context: 'The High Priestess card'
    },
    {
      name: 'Vision-detected tone indicator',
      pattern: /vision-detected tone/i,
      context: 'User prompt formatting'
    }
  ];

  let passed = 0;
  let failed = 0;

  checks.forEach(check => {
    const found = check.pattern.test(userPrompt);
    if (found) {
      console.log(`✅ ${check.name}`);
      passed++;
    } else {
      console.log(`❌ ${check.name} - not found in prompt`);
      failed++;
    }
  });

  console.log(`\n📊 Results: ${passed}/${checks.length} checks passed`);

  if (failed === 0) {
    console.log('\n✨ Vision weaving is working correctly!');
    console.log('Visual profiles (tone/emotion) are being injected into card prompts.');
    process.exit(0);
  } else {
    console.log('\n⚠️  Some vision data was not woven into prompts.');
    console.log('This may indicate an issue with the vision weaving logic.');

    // Output snippet of user prompt for debugging
    console.log('\n📝 Sample from user prompt (first 1000 chars):');
    console.log(userPrompt.substring(0, 1000));
    console.log('...\n');

    process.exit(1);
  }

} catch (error) {
  console.error('❌ Test failed with error:', error.message);
  console.error(error.stack);
  process.exit(1);
}
</file>

<file path=".assetsignore">
# Prevent worker code from being served as static assets
_worker.js
_worker.js/**
</file>

<file path=".dev.vars.example">
# Copy this file to .dev.vars and populate each value before running dev.sh
# Secrets never belong in git. The example exists solely as a checklist.

AZURE_OPENAI_ENDPOINT="https://your-azure-resource.openai.azure.com"
AZURE_OPENAI_API_KEY="sk-your-key"
AZURE_OPENAI_GPT5_MODEL="gpt-5.1"
AZURE_OPENAI_TTS_ENDPOINT="https://your-azure-resource.openai.azure.com"
AZURE_OPENAI_TTS_API_KEY="sk-your-tts-key"
AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT="gpt-4o-mini-tts"
AZURE_OPENAI_GPT_AUDIO_MINI_FORMAT="mp3"
AZURE_OPENAI_USE_V1_FORMAT="true"

VISION_PROOF_SECRET="replace-me"
ANTHROPIC_API_KEY="sk-ant-your-key" # Required for Claude fallbacks

# Optional feature flags / diagnostics
VITE_ENABLE_VISION_RESEARCH="false"
LOG_LLM_PROMPTS="false"
LOG_ENHANCEMENT_TELEMETRY="false"
PROMPT_BUDGET_AZURE=""   # Approx token cap for Azure prompts (chars/4 heuristic)
PROMPT_BUDGET_CLAUDE=""  # Approx token cap for Claude prompts (chars/4 heuristic)
PROMPT_BUDGET_DEFAULT="" # Fallback budget if backend-specific values are unset
</file>

<file path=".env.example">
# Azure OpenAI TTS Configuration
# Copy this file to .env.local and fill in your values

# Your Azure OpenAI endpoint
# Get from: Azure Portal → Azure OpenAI → Your Resource → Keys and Endpoint
# Format: https://your-resource-name.openai.azure.com
AZURE_OPENAI_ENDPOINT=

# Your Azure OpenAI API key
# Get from: Azure Portal → Azure OpenAI → Your Resource → Keys and Endpoint
AZURE_OPENAI_API_KEY=

# The deployment name you created in Azure Portal (NOT the model name!)
# Get from: Azure Portal → Azure OpenAI → Your Resource → Deployments
#
# This is the custom name YOU chose when deploying the model.
# Common examples: "tts", "tts-1-hd", "my-tts-deployment"
#
# Supported base models:
#   - tts-1 or tts-1-hd (standard, available in North Central US or Sweden Central)
#   - gpt-4o-mini-tts (advanced with steerable instructions, available in East US2)
#
# Note: The deployment name can be different from the model name!
#       e.g., you might name your deployment "tts" even though it uses "tts-1-hd" model
AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT=

# Optional: API version (defaults to 2025-04-01-preview if not set)
AZURE_OPENAI_API_VERSION=2025-04-01-preview

# Optional: Output format (defaults to mp3 if not set)
AZURE_OPENAI_GPT_AUDIO_MINI_FORMAT=mp3

# Azure OpenAI GPT-5 (Responses API) for tarot reading generation
# These values enable GPT-5 via the Responses API in `functions/api/tarot-reading.js`.
# Use your Azure OpenAI resource + deployment names.
# Example endpoint: https://YOUR-RESOURCE-NAME.openai.azure.com
AZURE_OPENAI_ENDPOINT=
AZURE_OPENAI_API_KEY=
AZURE_OPENAI_GPT5_MODEL=

# GraphRAG (Graph-Enhanced Retrieval-Augmented Generation)
# Enables retrieval of curated tarot wisdom passages based on detected archetypal patterns
# (triads, dyads, Fool's Journey stages, suit progressions)
# When enabled, readings are enriched with traditional wisdom from respected sources:
# - Rachel Pollack, Seventy-Eight Degrees of Wisdom
# - Mary K. Greer, Tarot for Your Self
# - Robert Place, The Tarot: History, Symbolism, and Divination
# Default: true (opt-out rather than opt-in)
# Set to 'false' to disable pattern detection and passage retrieval
GRAPHRAG_ENABLED=true

# Vision Research Mode (experimental physical card recognition)
# When enabled, shows a research panel for testing card detection from photos
# Requires user authentication. Default: false (hidden)
# VITE_ENABLE_VISION_RESEARCH=true
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
/lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# Virtual environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Python testing/coverage
.coverage
.pytest_cache/
.tox/
.nox/
htmlcov/
.coverage.*
coverage.xml
*.cover
.hypothesis/

# Build output
dist/

# Environment variables
.env.local
.env*.local

# Wrangler secrets (DO NOT COMMIT!)
.wrangler/
wrangler.toml.local
.dev.vars
.dev.vars.*
!.dev.vars.example

# MCP configuration with credentials
.mcp.json

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Testing
coverage/

# Misc
.cache/
azure_reasoning.md
azure_responses.md
MysticTarot2.png
.env

# Design reference dumps (local-only large binaries)
/IMG_*.PNG
/IMG_*.HEIC
/IMG_*.heic
/Tableu*.heic
/Tableu*.HEIC
/Tableu*.jpg
/Tableu*.JPG
/Tableu*.png
/Tableu*.PNG

# Screenshots and temporary uploads
*.HEIC
Cloudflareworkerbindings.png
_shellfish_uploading_*
</file>

<file path=".mcp.example.json">
{
  "mcpServers": {
    "cloudflare-docs": {
      "type": "http",
      "url": "https://docs.mcp.cloudflare.com/mcp"
    },
    "cloudflare-observability": {
      "type": "http",
      "url": "https://observability.mcp.cloudflare.com/mcp"
    },
    "cloudflare-bindings": {
      "type": "http",
      "url": "https://bindings.mcp.cloudflare.com/mcp",
      "headers": {
        "Authorization": "Bearer ${CLOUDFLARE_BINDINGS_TOKEN}"
      }
    }
  }
}
</file>

<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Module Organization
- Frontend (React + Vite) lives in `src/`: `components/`, `pages/`, `contexts/`, `hooks/`, `styles/tailwind.css` for Tailwind setup.
- Cloudflare Worker entrypoint is `src/worker/index.js`; route handlers live in `functions/api/`, shared logic in `functions/lib/`, with tests under `tests/*.test.mjs` (plus any `__tests__/`).
- Static decks/data live in `public/` and `data/`; build output lands in `dist/`.

## Build, Test, and Development Commands
- `npm run dev` — runs `dev.sh`; starts Vite HMR (5173/5174) and Wrangler Workers dev on 8787.
- `npm run dev:frontend` for UI-only work; `npm run dev:wrangler`/`dev:workers` to run the Worker dev server.
- `npm run build` → `dist/`; `npm run preview` serves the built bundle locally; `npm run deploy` publishes the Worker (`tableau`) via wrangler.
- `npm test` executes Node tests. Quality gates for ML flows: `npm run gate:vision` and `npm run gate:narrative` when touching vision or narrative code.

## Coding Style & Naming Conventions
- ESM and functional React components throughout; 2-space indent, single quotes, and terminal semicolons.
- Components/pages use PascalCase filenames; hooks start with `use`; Pages Functions stay kebab-case.
- Prefer Tailwind utilities; share tokens in `styles/tailwind.css` or `tailwind.config.js`. Keep inline styles rare and justified.
- Keep side effects in hooks/context or `functions/lib/`; UI components stay presentational.

## Testing Guidelines
- Mirror file names in tests (`graphRAG.test.mjs`, etc.). New modules should gain matching tests under `tests/` or `__tests__/`.
- Stub external services in server tests; for hooks, mock context/provider wrappers. Cover edge cases and error paths, not only the happy path.
- Run `npm test` before pushing; if vision/narrative logic changes, also run the relevant `gate:*` command and record results.

## Commit & Pull Request Guidelines
- Prefer Conventional Commit prefixes (`feat:`, `fix:`, `chore:`, `docs:`, `test:`); imperative subject; avoid placeholders like `up`.
- PRs: concise summary, linked issue, tests run, and screenshots/recordings for UI changes; note any config/env steps needed post-merge.

## Security & Configuration Tips
- Keep secrets out of the repo. Local values go in `.dev.vars`; set production/preview secrets with `wrangler pages secret put` (see `wrangler.toml` for required `AZURE_OPENAI_*`, `VISION_PROOF_SECRET`, etc.).
- Do not log keys or PII; rotate credentials immediately if leaked.

## Narrative & Prompt Engineering Notes
- Prompt metadata now surfaces GraphRAG state: `semanticScoringRequested/Used/Fallback`, `passagesProvided`, `passagesUsedInPrompt`, `truncatedPassages`, and `includedInPrompt`. Use these to warn when GraphRAG was dropped for budget or trimmed.
- GraphRAG slimming steps can remove the block; check `promptMeta.graphRAG.includedInPrompt` before assuming passages were injected.
- PII redaction covers ISO dates, US phone numbers with extensions, and possessive display names; it is still US-centric for phone formats. Prompt persistence stays opt-in via `PERSIST_PROMPTS=true`.
</file>

<file path="CLAUDE.md">
# CLAUDE.md

Guidance for Claude Code when working with this repository.

## Project Overview

**Tableu** — React + Vite tarot reading app deployed to Cloudflare Workers. Designed to feel like sitting with a practiced reader, not a generic card widget.

| Layer | Tech | Location |
|-------|------|----------|
| Frontend | React + Vite | `src/` |
| Backend | Cloudflare Workers | `src/worker/index.js` → `functions/api/` |
| AI | Claude Sonnet 4.5 (fallback: local composer) | `functions/api/tarot-reading.js` |
| Database | Cloudflare D1 | `migrations/*.sql` |
| Storage | Cloudflare KV + R2 | Metrics, feedback, exports, archives |

**Deck**: 78 cards (22 Major + 56 Minor Arcana) with 1909 Rider-Waite public domain images.

## Commands

```bash
npm run dev      # Vite dev server at localhost:5173
npm run build    # Production build to dist/
npm run deploy   # Deploy to Cloudflare Workers
```

## Architecture

### Three `lib/` Folders (Important!)

| Path | Environment | Access |
|------|-------------|--------|
| `src/lib/` | Browser | DOM, window APIs |
| `functions/lib/` | Cloudflare Workers | env, D1, KV, R2, secrets |
| `scripts/evaluation/lib/` | Node.js | Development tooling |

### Key Files

**Frontend (`src/`)**
- `TarotReading.jsx` — Main orchestration (ritual → spread → draw → reading)
- `data/spreads.js` — Spread definitions (source of truth for positions)
- `data/majorArcana.js`, `data/minorArcana.js` — Card data with meanings
- `lib/deck.js` — Seeded shuffle, `drawSpread()`, `computeSeed()`

**Backend (`functions/`)**
- `api/tarot-reading.js` — Main endpoint: validates payload, calls Claude or local composer
- `api/tts.js` — Azure TTS with rate limiting
- `api/journal.js` — Reading history (dedup by `session_seed`)
- `api/journal-export.js` — PDF/text export of readings (stores in R2)
- `api/feedback.js` — User feedback (stored in KV)
- `lib/narrative/` — Spread-specific narrative builders
- `lib/spreadAnalysis.js` — Card relationship detection
- `lib/knowledgeGraph.js` — Archetypal relationships
- `lib/scheduled.js` — Cron tasks: KV→R2 archival, session cleanup

**Shared (`shared/`)**
- `vision/` — Physical deck recognition pipeline
- `symbols/symbolAnnotations.js` — Symbol meanings database

### Components (`src/components/`)

Core: `Card.jsx`, `ReadingGrid.jsx`, `SpreadSelector.jsx`, `RitualControls.jsx`, `QuestionInput.jsx`
Settings: `AudioControls.jsx`, `ExperienceSettings.jsx`
Journal: `Journal.jsx`, `JournalEntryCard.jsx`, `JournalInsightsPanel.jsx`
Vision: `PhotoInputModal.jsx`, `VisionValidationPanel.jsx`, `CameraCapture.jsx`
Auth: `AuthModal.jsx`, `GlobalNav.jsx`, `UserMenu.jsx`

## Spreads (from `src/data/spreads.js`)

| Key | Name | Cards | Positions |
|-----|------|-------|-----------|
| `single` | One-Card Insight | 1 | Theme/Guidance |
| `threeCard` | Three-Card Story | 3 | Past → Present → Future |
| `fiveCard` | Five-Card Clarity | 5 | Core, Challenge, Hidden, Support, Direction |
| `decision` | Decision/Two-Path | 5 | Heart, Path A, Path B, Clarity, Free Will |
| `relationship` | Relationship Snapshot | 3 | You, Them, Connection |
| `celtic` | Celtic Cross | 10 | Present, Challenge, Past, Near Future, Conscious, Subconscious, Advice, External, Hopes/Fears, Outcome |

**Constraint**: Position meanings are used by `buildCardsSection` and frontend text. Don't change casually.

## Reading Flow

1. **Question** — Open-ended prompts ("How can I...?", "What influences...?"). Avoid yes/no.
2. **Ritual** — Knocks + cut position + question → `computeSeed()`
3. **Draw** — `drawSpread()` uses seeded shuffle, assigns upright/reversed
4. **Reveal** — Card flip animation, user reflections per card
5. **Narrative** — Claude Sonnet 4.5 via API, or local `composeReading()` fallback

## Interpretation Rules

**Position-first**: Same card reads differently in "Challenge" vs "Advice" vs "Outcome"

**Reversals** (pick ONE model per reading):
- Blocked/delayed expression
- Excess or deficiency
- Internalized process
- Opposite meaning (when narrative supports)

**Synthesis**: Identify tension → map causes → offer practical steps

## Ethics (Non-Negotiable)

- Tarot = guidance, NOT replacement for medical/legal/financial/mental health professionals
- Emphasize agency: "likely path if unchanged", not determinism
- No hallucinated cards — only reference actual `cardsInfo`
- Trauma-informed, empowering language
- Include disclaimers for sensitive topics

## Card Images

- Source: 1909 Rider-Waite "Roses & Lilies" (Wikimedia Commons, public domain)
- Location: `public/images/cards/RWS1909_-_*.jpeg`
- Naming: `RWS1909_-_XX_Name.jpeg` (Major), `RWS1909_-_Suit_XX.jpeg` (Minor)
- Also: `marseille/*.jpg`, `thoth/*.png`

## Database Schema

Key tables (see `migrations/`):
- `users`, `sessions` — Auth
- `journal_entries` — Saved readings (dedup index on `user_id, session_seed`)
- `share_tokens` — Reading sharing
- `archetype_journey` — User's card history tracking

## Cloudflare Bindings

Configured in `wrangler.jsonc`:

| Binding | Type | Purpose |
|---------|------|---------|
| `DB` | D1 | Main database (users, sessions, journal, etc.) |
| `RATELIMIT` | KV | Rate limiting counters (auto-expires) |
| `METRICS_DB` | KV | Reading metrics (archived to R2 daily) |
| `FEEDBACK_KV` | KV | User feedback (archived to R2 daily) |
| `LOGS_BUCKET` | R2 | Archives, exports, logs storage |
| `ASSETS` | Assets | Static frontend files |

### R2 Bucket Structure (`tarot-logs`)

```
tarot-logs/
├── archives/
│   ├── metrics/{date}/{timestamp}.json    # Archived from METRICS_DB
│   ├── feedback/{date}/{timestamp}.json   # Archived from FEEDBACK_KV
│   └── summaries/{date}.json              # Daily archival summary
└── exports/
    ├── readings/{userId}/{entryId}.pdf    # Single reading exports
    └── journals/{userId}/{timestamp}.pdf  # Full journal exports
```

### Scheduled Tasks (Cron)

Daily at 3 AM UTC (`0 3 * * *`):
1. Archive `METRICS_DB` keys to R2 and delete from KV
2. Archive `FEEDBACK_KV` keys to R2 and delete from KV
3. Clean up expired sessions from D1
4. Store archival summary in R2

## Tests

```bash
npm test  # Runs tests in tests/
```

Key test files: `deck.test.mjs`, `narrativeBuilder.*.test.mjs`, `narrativeSpine.test.mjs`

## Working with This Repo

1. **Spreads/cards** in `src/data/` are the source of truth
2. **Narratives** must derive from actual `cardsInfo` — never invent cards
3. **New spreads** need: position definitions, narrative builder in `functions/lib/narrative/spreads/`
4. **Visual changes** must preserve A11y (labels, focus, ARIA)
5. Keep the authentic tarot feel — this isn't a generic card app

## API Endpoints

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/api/tarot-reading` | POST | Generate a reading |
| `/api/tts` | POST | Text-to-speech |
| `/api/journal` | GET/POST | List/save journal entries |
| `/api/journal/:id` | GET/DELETE | Get/delete single entry |
| `/api/journal-export` | GET | Export journal as PDF/txt/json |
| `/api/journal-export/:id` | GET | Export single reading |
| `/api/share` | POST | Create share link |
| `/api/share/:token` | GET/DELETE | View/revoke share |
| `/api/feedback` | POST | Submit feedback |
| `/api/archetype-journey` | GET/POST/PUT | Analytics: GET data, POST track cards, PUT preferences |
| `/api/archetype-journey-backfill` | POST | Backfill card_appearances from existing journal entries |
| `/api/auth/*` | Various | Login, logout, register, me |
| `/api/keys` | GET/POST | API key management |
| `/api/admin/archive` | POST | Manual archival trigger (requires ADMIN_API_KEY) |

## Secrets (via `wrangler secret put`)

- `AZURE_OPENAI_ENDPOINT`, `AZURE_OPENAI_API_KEY`, `AZURE_OPENAI_GPT5_MODEL`
- `AZURE_ANTHROPIC_ENDPOINT`, `AZURE_ANTHROPIC_API_KEY`, `AZURE_ANTHROPIC_MODEL`
- `AZURE_OPENAI_TTS_ENDPOINT`, `AZURE_OPENAI_TTS_API_KEY`, `AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT`
- `VISION_PROOF_SECRET`
- `ADMIN_API_KEY` — For manual archival trigger
</file>

<file path="dev.sh">
#!/bin/bash
# Development server startup script for Tableau
# This starts both Vite (frontend) and Wrangler Workers (API) together
#
# MIGRATION NOTE: Updated from Pages Functions to Workers with Static Assets

set -e

ENV_FILE=".dev.vars"
if [ -f "$ENV_FILE" ]; then
  echo "🔐 Loading environment variables from $ENV_FILE"
  set -a
  # shellcheck disable=SC1090
  source "$ENV_FILE"
  set +a
else
  echo "⚠️  $ENV_FILE not found. API-powered features will fall back to local generators."
fi

echo "🔮 Starting Tableau development environment (Workers mode)..."
echo ""

# Kill any existing processes on our ports
echo "Cleaning up any existing processes..."
lsof -ti:5173,5174,8787 2>/dev/null | xargs kill -9 2>/dev/null || true
sleep 1

# Start Vite in background for frontend HMR
echo "📦 Starting Vite frontend server..."
npm run dev:frontend &
VITE_PID=$!

# Wait for Vite to be ready
echo "⏳ Waiting for Vite to start..."
for i in {1..30}; do
  if curl -s http://localhost:5173 >/dev/null 2>&1 || curl -s http://localhost:5174 >/dev/null 2>&1; then
    echo "✅ Vite is ready!"
    break
  fi
  sleep 1
  if [ $i -eq 30 ]; then
    echo "❌ Vite failed to start"
    kill $VITE_PID 2>/dev/null || true
    exit 1
  fi
done

# Detect which port Vite is using
VITE_PORT=5173
if ! curl -s http://localhost:5173 >/dev/null 2>&1; then
  VITE_PORT=5174
fi

echo "📍 Vite running on port $VITE_PORT"

# Build frontend assets first for Workers to serve
echo "🏗️  Building frontend assets for Workers..."
npm run build

# Start Wrangler Workers dev server
echo "⚡ Starting Wrangler Workers dev server..."
wrangler dev --config wrangler.jsonc --live-reload &
WRANGLER_PID=$!

# Cleanup function
cleanup() {
  echo ""
  echo "🛑 Shutting down development servers..."
  kill $VITE_PID 2>/dev/null || true
  kill $WRANGLER_PID 2>/dev/null || true
  lsof -ti:5173,5174,8787 2>/dev/null | xargs kill -9 2>/dev/null || true
  echo "✅ Cleanup complete"
  exit 0
}

trap cleanup EXIT INT TERM

# Wait for Wrangler Workers to be ready
echo "⏳ Waiting for Workers..."
for i in {1..30}; do
  if curl -s http://localhost:8787 >/dev/null 2>&1; then
    echo "✅ Workers dev server is ready!"
    break
  fi
  sleep 1
  if [ $i -eq 30 ]; then
    echo "❌ Workers dev server failed to start"
    cleanup
  fi
done

echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "🎉 Development environment ready! (Workers mode)"
echo ""
echo "🌐 Access your app at: http://localhost:$VITE_PORT"
echo ""
echo "📝 Notes:"
echo "  - Frontend HMR (Vite): http://localhost:$VITE_PORT (USE THIS!)"
echo "  - Full app with API: http://localhost:8787 (API backend)"
echo "  - Workers serve static assets from dist/"
echo "  - API routes handled by src/worker/index.js"
echo "  - Press Ctrl+C to stop all servers"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""

# Keep the script running
wait
</file>

<file path="eslint.config.js">
import js from '@eslint/js';
import globals from 'globals';
import react from 'eslint-plugin-react';
import reactHooks from 'eslint-plugin-react-hooks';
import reactRefresh from 'eslint-plugin-react-refresh';

export default [
  // Ignore patterns
  {
    ignores: [
      'dist/**',
      'node_modules/**',
      '.wrangler/**',
      '.worker/**',
      'public/**',
      'data/**',
      'venv/**',
      'migrations/**',
      '*.config.js',
      '*.config.mjs',
      '.env*',
      '.dev.vars*',
    ],
  },

  // Base configuration for all JS files
  {
    files: ['**/*.{js,jsx,mjs}'],
    languageOptions: {
      ecmaVersion: 2024,
      sourceType: 'module',
      parserOptions: {
        ecmaFeatures: {
          jsx: true,
        },
      },
    },
    rules: {
      ...js.configs.recommended.rules,
      'no-unused-vars': ['warn', {
        argsIgnorePattern: '^_',
        varsIgnorePattern: '^_',
      }],
      'no-console': 'off', // Allow console for debugging
      'prefer-const': 'warn',
      'no-var': 'error',
    },
  },

  // React components in src/
  {
    files: ['src/**/*.{js,jsx}'],
    plugins: {
      react,
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    languageOptions: {
      globals: {
        ...globals.browser,
      },
    },
    settings: {
      react: {
        version: 'detect',
      },
    },
    rules: {
      ...react.configs.recommended.rules,
      ...react.configs['jsx-runtime'].rules,
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
      'react/prop-types': 'off', // We're not using PropTypes
      'react/jsx-uses-react': 'off', // Not needed with new JSX transform
      'react/react-in-jsx-scope': 'off', // Not needed with new JSX transform
    },
  },

  // Cloudflare Workers Functions in functions/
  {
    files: ['functions/**/*.js'],
    languageOptions: {
      globals: {
        ...globals.serviceworker, // Cloudflare Workers use Service Worker API
        // Add Cloudflare-specific globals
        Request: 'readonly',
        Response: 'readonly',
        Headers: 'readonly',
        URL: 'readonly',
        URLSearchParams: 'readonly',
        fetch: 'readonly',
        crypto: 'readonly',
        caches: 'readonly',
        // Node.js compatibility APIs available in Cloudflare Workers with nodejs_compat flag
        Buffer: 'readonly',
        process: 'readonly',
        // Wrangler-specific globals
        uint8ToBase64: 'readonly',
      },
    },
    rules: {
      'no-restricted-globals': 'off', // Allow Workers globals
    },
  },

  // Node.js scripts
  {
    files: ['scripts/**/*.{js,mjs}', '*.config.{js,mjs}', 'test-telemetry.js'],
    languageOptions: {
      globals: {
        ...globals.node,
      },
    },
  },

  // Plugins directory (Node.js environment)
  {
    files: ['plugins/**/*.{js,mjs}'],
    languageOptions: {
      globals: {
        ...globals.node,
      },
    },
  },

  // Test files
  {
    files: ['tests/**/*.{js,mjs}', '**/*.test.{js,mjs}', '**/__tests__/**/*.{js,mjs}'],
    languageOptions: {
      globals: {
        ...globals.node,
      },
    },
    rules: {
      'no-unused-expressions': 'off', // Allow assertions
    },
  },

  // Shared utilities that work in both browser and Workers
  {
    files: ['shared/**/*.js'],
    languageOptions: {
      globals: {
        // Minimal shared globals
        console: 'readonly',
        fetch: 'readonly',
        Request: 'readonly',
        Response: 'readonly',
        URL: 'readonly',
        // Node.js compatibility for cross-environment utilities
        Buffer: 'readonly',
        process: 'readonly',
        btoa: 'readonly',
      },
    },
  },
];
</file>

<file path="GEMINI.md">
# Mystic Tarot - Gemini Context

## Project Overview
**Mystic Tarot** is an advanced AI-powered tarot reading application. It combines traditional tarot symbolism with modern Large Language Models (LLMs) to generate context-aware, empathetic, and structured readings. It features a React frontend and a serverless backend hosted on Cloudflare Pages.

## Key Technologies
*   **Frontend:** React 18, Vite, Tailwind CSS
*   **Backend:** Cloudflare Pages Functions (Node.js compatibility mode)
*   **Database:** Cloudflare D1 (SQLite)
*   **Key-Value Store:** Cloudflare KV (Rate limiting, Caching)
*   **AI Providers:** Azure OpenAI (GPT-5.1 for text, GPT-4o-mini for TTS), Anthropic (Claude Sonnet 4.5)
*   **Testing:** Node.js Native Test Runner (`node --test`)

## Architecture
*   **`src/`:** React client application.
    *   `components/`: UI components.
    *   `pages/`: Route handlers.
    *   `hooks/`: Custom React hooks.
    *   `contexts/`: State management.
    *   `lib/`: Frontend domain logic.
*   **`functions/`:** Cloudflare Pages Functions (API).
    *   `api/`: API endpoints (e.g., `tarot-reading`, `tts`).
    *   `lib/`: Shared backend logic and knowledge graph.
*   **`scripts/`:** Utility scripts for evaluation, training, and deployment.
*   **`docs/`:** Extensive documentation on architecture, vision pipeline, and esoteric models.

## Building and Running
*   **Install Dependencies:** `npm install`
*   **Development Server:** `npm run dev` (Starts Vite and Wrangler proxy)
*   **Frontend Only:** `npm run dev:frontend`
*   **Build for Production:** `npm run build`
*   **Deploy:** `npm run deploy`
*   **Run Tests:** `npm test` (Runs `tests/*.test.mjs`)
*   **Vision Evaluation:** `npm run eval:vision:all`
*   **Narrative Evaluation:** `npm run eval:narrative`

## Development Conventions
*   **Code Style:**
    *   Use 2-space indentation.
    *   React components in `PascalCase`.
    *   Hooks in `camelCase` (prefixed with `use`).
    *   Constants in `SCREAMING_SNAKE_CASE`.
    *   Prefer Tailwind CSS for styling.
*   **Testing:**
    *   Tests are located in `tests/` and use the `.test.mjs` extension.
    *   Run tests before pushing changes.
    *   Use `npm run ci:vision-check` and `npm run ci:narrative-check` for quality gates.
*   **Commits:**
    *   Follow Conventional Commits (`feat:`, `fix:`, `chore:`).
    *   Imperative mood.

## Key Files
*   `package.json`: Dependency and script management.
*   `wrangler.toml`: Cloudflare configuration (bindings, environment variables).
*   `SYSTEM_ARCHITECTURE.md`: Comprehensive architectural overview.
*   `AGENTS.md`: Specific instructions for AI agents (persona, tone).
*   `src/main.jsx`: Frontend entry point.
*   `functions/api/tarot-reading.js`: Main logic for generating readings.

## AI Persona (from AGENTS.md)
*   **Tone:** Professional, direct, concise ("respect through momentum").
*   **Output:** Minimal pleasantries, focus on action/result.
*   **Format:** Markdown, max 2-5 sentences for small changes.
</file>

<file path="HUME_INTEGRATION.md">
# Hume AI Octave TTS Integration for Mystic Tarot

This document describes the integration of Hume AI's Octave text-to-speech technology into the Mystic Tarot application.

## Overview

Hume AI Octave TTS is an LLM-powered text-to-speech system that understands text both emotionally and semantically. Unlike traditional TTS systems, Octave knows when to whisper secrets, shout in triumph, and calmly state facts—making it perfect for tarot readings where tone, emotion, and mystical atmosphere are essential.

## Features

- **Emotionally Intelligent**: Understands context and emotional nuance
- **Context-Aware Voices**: Different voice selections for card reveals, full readings, synthesis, questions, and reflections
- **Voice Continuity**: Maintains consistent voice characteristics across multiple utterances via generation IDs
- **Acting Instructions**: Natural language descriptions guide tone, pacing, and emotional quality
- **Preset Voice Library**: Access to Hume's curated voices optimized for different contexts
- **Speed Control**: Adjustable speech rate (0.5x - 2.0x)
- **Trailing Silence**: Configurable pauses after utterances for contemplation
- **High Quality**: Professional-grade audio output (WAV format)

## Architecture

### Backend (Cloudflare Pages Functions)

**`functions/api/tts-hume.js`** - Hume Octave TTS endpoint

- Accepts text, context, voice preferences, and continuation parameters
- Maps tarot reading contexts to appropriate voices and acting instructions
- Calls Hume AI TTS API (`POST https://api.hume.ai/v0/tts`)
- Returns audio as base64-encoded data URI
- Tracks generation IDs for voice continuity

### Frontend (React)

**`src/lib/audioHume.js`** - Client-side Hume TTS utilities

Core functions:
- `speakWithHume(text, options)` - Main TTS function with full control
- `speakCardReveal(cardName, orientation, meaning)` - Specialized for card reveals
- `speakFullReading(readingText, options)` - For complete readings
- `speakSynthesis(synthesisText, options)` - For reading summaries
- `speakSequence(segments, options)` - Multiple segments with voice continuity
- `stopHumeAudio()` - Stop current playback
- `isHumeTTSAvailable()` - Check if Hume is configured

**`src/components/HumeAudioControls.jsx`** - React UI component

Provides:
- Voice selection dropdown (organized by category)
- Speed control slider
- Play/Pause/Stop buttons
- Availability detection
- Error handling and user feedback

## Setup

### 1. Get API Key

1. Visit [Hume AI Platform](https://platform.hume.ai/)
2. Sign up or log in
3. Navigate to [Settings > API Keys](https://platform.hume.ai/settings/keys)
4. Create a new API key
5. Copy the key

### 2. Environment Variables

Add to your Cloudflare Pages environment variables:

```bash
HUME_API_KEY=your_hume_api_key_here
```

Or for local development, add to `.dev.vars`:

```bash
HUME_API_KEY=your_hume_api_key_here
```

### 3. Test the Endpoint

```bash
curl -X POST https://your-app.pages.dev/api/tts-hume \
  -H "Content-Type: application/json" \
  -d '{
    "text": "Welcome, seeker. The cards reveal The Fool, upright.",
    "context": "card-reveal"
  }'
```

### 4. Integration into Components

Add the Hume audio controls to your reading display:

```jsx
import HumeAudioControls from './components/HumeAudioControls';

function ReadingDisplay({ reading }) {
  return (
    <div>
      {/* Your existing reading display */}
      <div className="reading-text">{reading}</div>
      
      {/* Add Hume audio controls */}
      <HumeAudioControls 
        readingText={reading}
        context="full-reading"
        onPlaybackStart={() => console.log('Started reading')}
        onPlaybackEnd={() => console.log('Finished reading')}
      />
    </div>
  );
}
```

## Usage Examples

### Basic Card Reveal

```javascript
import { speakCardReveal } from '../lib/audioHume';

// Speak a card reveal with mystical tone
await speakCardReveal('The Fool', 'upright', 'New beginnings await');
```

### Full Reading with Custom Voice

```javascript
import { speakFullReading } from '../lib/audioHume';

const reading = "The cards reveal a journey of transformation...";

await speakFullReading(reading, {
  voiceName: 'KORA',
  speed: 0.95
});
```

### Sequential Reading with Voice Continuity

```javascript
import { speakSequence, resetGenerationId } from '../lib/audioHume';

// Reset for new reading
resetGenerationId();

// Speak multiple segments with consistent voice
const segments = [
  "In the past position, we see The Tower...",
  "The present shows The Star...",
  "And in the future, The Sun emerges..."
];

await speakSequence(segments, {
  context: 'full-reading',
  voiceName: 'ITO',
  speed: 1.0,
  autoPlay: true // Automatically play each segment in sequence
});
```

### Custom Acting Instructions

```javascript
import { speakWithHume } from '../lib/audioHume';

await speakWithHume("The Magician appears before you", {
  voiceName: 'ITO',
  description: "mystical and ancient, with deep resonance and slow, deliberate pacing",
  speed: 0.85,
  trailingSilence: 2.0
});
```

## Available Voices

Hume's Voice Library includes many expressive voices. Here are recommended voices for tarot readings:

### Mystical Voices (Recommended for Tarot)
- **ITO** - Warm, contemplative - excellent for readings
- **KORA** - Smooth, storytelling quality - great for synthesis
- **DACHER** - Gentle, supportive - perfect for reflections
- **STELLA** - Clear, inviting - good for questions
- **WHIMSY** - Playful yet wise

### Narrator Voices
- **HANK** - Deep, authoritative narrator
- **RAMONA** - Warm, engaging storyteller
- **LIVIA** - Elegant, refined narrator

### Conversational Voices
- **AURA** - Friendly, approachable
- **FINN** - Casual, relatable
- **ORION** - Calm, measured

### Dramatic Voices
- **LUNA** - Mysterious, dramatic
- **COVE** - Rich, theatrical
- **EMBER** - Intense, passionate

Browse the full library: [Hume Voice Library](https://platform.hume.ai/tts/voice-library)

## Context Types

The system recognizes these contexts and applies appropriate voice characteristics:

- **`card-reveal`** - Gentle, reverent, slower pace with pauses (Voice: ITO)
- **`full-reading`** - Thoughtful, contemplative, natural pauses (Voice: ITO)
- **`synthesis`** - Flowing, storytelling cadence (Voice: KORA)
- **`question`** - Warm, inviting, respectful (Voice: STELLA)
- **`reflection`** - Soft, affirming, supportive (Voice: DACHER)
- **`default`** - Mystical yet grounded (Voice: ITO)

## API Reference

### POST /api/tts-hume

**Request Body:**
```json
{
  "text": "The text to speak (required, max 5000 chars)",
  "context": "card-reveal | full-reading | synthesis | question | reflection | default",
  "voiceName": "ITO",
  "description": "Optional acting instructions",
  "speed": 1.0,
  "previousGenerationId": "generation-id-from-previous-call",
  "trailingSilence": 1.5
}
```

**Response:**
```json
{
  "audio": "data:audio/wav;base64,...",
  "provider": "hume-ai",
  "generationId": "uuid",
  "voiceUsed": "ITO"
}
```

**Error Responses:**
- `400` - Missing or invalid text
- `429` - Rate limit exceeded
- `500` - TTS generation failed
- `503` - Hume API not configured

## Best Practices

### 1. Voice Continuity
When reading multiple cards or segments, use `previousGenerationId` to maintain voice consistency:

```javascript
let lastId = null;

for (const card of cards) {
  const result = await speakWithHume(card.interpretation, {
    previousGenerationId: lastId
  });
  lastId = result.generationId;
}
```

### 2. Context Selection
Choose the appropriate context for the best results:
- Use `card-reveal` for individual cards
- Use `full-reading` for complete interpretations
- Use `synthesis` for summaries and conclusions

### 3. Speed Adjustment
- **0.8-0.9x**: Deep contemplation, meditation
- **1.0x**: Natural, conversational
- **1.1-1.2x**: Engaging, slightly faster

### 4. Acting Instructions
Use natural language to guide emotional delivery:
- "shocked and disappointed, speaking slowly with emphasis"
- "warm and reassuring, with gentle pauses"
- "mystical and reverent, as if revealing ancient wisdom"

### 5. Error Handling
Always handle potential errors gracefully:

```javascript
try {
  await speakWithHume(text, options);
} catch (error) {
  console.error('TTS failed:', error);
  // Fall back to text display or alternative TTS
}
```

## Comparison with Azure OpenAI TTS

| Feature | Hume AI Octave | Azure OpenAI |
|---------|----------------|--------------|
| **Emotional Intelligence** | ⭐⭐⭐⭐⭐ LLM-powered understanding | ⭐⭐⭐ Via instructions |
| **Voice Continuity** | ⭐⭐⭐⭐⭐ Built-in via generation IDs | ⭐⭐⭐ Manual management |
| **Voice Library** | Curated expressive voices | 11 base voices |
| **Acting Instructions** | Natural language descriptions | Instruction-based |
| **Audio Format** | WAV (high quality) | MP3 (configurable) |
| **Latency** | ~200ms (Octave 1) | Variable |
| **Mystical Voices** | Purpose-built options | Generic voices |
| **Context Understanding** | Native semantic understanding | Instruction parsing |

## Technical Details

### API Endpoint
```
POST https://api.hume.ai/v0/tts
```

### Request Format
```json
{
  "utterances": [
    {
      "text": "The text to speak",
      "voice": {
        "name": "ITO",
        "provider": "HUME_AI"
      },
      "description": "Optional acting instructions",
      "speed": 1.0,
      "trailingsilence": 1.5
    }
  ],
  "context": {
    "generationId": "previous-generation-id"
  }
}
```

### Response Format
```json
{
  "generations": [
    {
      "audio": "base64-encoded-audio-data",
      "generationId": "unique-generation-id"
    }
  ]
}
```

### Rate Limits
- Defined by your [subscription tier](https://www.hume.ai/pricing)
- Max text length: 5,000 characters per utterance
- Max description length: 1,000 characters per utterance

## Troubleshooting

### "Hume AI is not configured"
- Ensure `HUME_API_KEY` is set in your environment variables
- Redeploy your Cloudflare Pages application after adding the key
- Verify the key is valid at [platform.hume.ai/settings/keys](https://platform.hume.ai/settings/keys)

### Audio Not Playing
- Check browser console for errors
- Verify the audio data URI is properly formatted
- Ensure browser autoplay policies allow audio
- Try user-initiated playback (button click)

### Voice Continuity Not Working
- Verify you're passing the correct `generationId` from previous calls
- Check that `previousGenerationId` is included in subsequent requests
- Ensure you're using the same voice across continuations

### Rate Limiting (429 Error)
- Implement client-side throttling
- Consider caching generated audio for repeated text
- Upgrade your subscription tier if needed

### Poor Voice Quality
- Try different voices from the library
- Adjust speed (slower often sounds better)
- Use acting instructions to guide emotional delivery
- Ensure text is well-formatted (proper punctuation, etc.)

## Future Enhancements

- [ ] Audio caching layer for repeated readings
- [ ] Batch generation for multi-card spreads
- [ ] Voice customization UI with preview
- [ ] Save favorite voice configurations per user
- [ ] Integration with journal feature (replay past readings)
- [ ] Background ambient music mixing
- [ ] Export readings as downloadable audio files
- [ ] Streaming support for real-time generation
- [ ] Voice cloning for personalized readings

## Resources

- [Hume AI Documentation](https://dev.hume.ai/)
- [Octave TTS API Reference](https://dev.hume.ai/reference/text-to-speech-tts)
- [Voice Library](https://platform.hume.ai/tts/voice-library)
- [API Keys Management](https://platform.hume.ai/settings/keys)
- [TypeScript SDK](https://github.com/humeai/hume-typescript-sdk)
- [Sample Code](https://github.com/HumeAI/hume-api-examples/tree/main/tts)
- [MCP Integration](https://dev.hume.ai/docs/integrations/mcp)
- [Pricing & Limits](https://www.hume.ai/pricing)

## Support

For issues or questions about the Hume integration:
1. Check the console logs for detailed error messages
2. Verify your API key is valid and has TTS permissions
3. Review the [Hume AI status page](https://status.hume.ai/) for service issues
4. Check the [Hume documentation](https://dev.hume.ai/) for API updates
5. Contact Hume AI support for API-specific problems

---

**Integration completed by:** Manus AI  
**Date:** November 25, 2025  
**Version:** 2.0.0 (Updated with correct Octave TTS API)  
**API Documentation:** https://dev.hume.ai/reference/text-to-speech-tts
</file>

<file path="HUME_QUICKSTART.md">
# Hume AI Octave TTS Quick Start Guide

## 🚀 Get Started in 3 Steps

### Step 1: Get Your API Key
1. Visit https://platform.hume.ai/
2. Sign up or log in
3. Go to [Settings > API Keys](https://platform.hume.ai/settings/keys)
4. Create a new API key
5. Copy the key

### Step 2: Configure Environment
Add to your Cloudflare Pages environment variables:
```bash
HUME_API_KEY=your_api_key_here
```

Or add to `.dev.vars` for local development:
```bash
HUME_API_KEY=your_api_key_here
```

### Step 3: Use in Your Components

#### Option A: Use the React Component (Easiest)
```jsx
import HumeAudioControls from './components/HumeAudioControls';

function ReadingDisplay({ reading }) {
  return (
    <div>
      <div className="reading-text">{reading}</div>
      
      <HumeAudioControls 
        readingText={reading}
        context="full-reading"
      />
    </div>
  );
}
```

#### Option B: Use the Library Functions (More Control)
```javascript
import { speakFullReading } from '../lib/audioHume';

async function handleReadReading(text) {
  const result = await speakFullReading(text, {
    voiceName: 'ITO',
    speed: 0.95
  });
  
  // Audio plays automatically
  console.log('Generation ID:', result.generationId);
}
```

## 🎭 Recommended Voices for Tarot

- **ITO** - Warm, contemplative - best for full readings
- **KORA** - Smooth storytelling - great for synthesis/summaries
- **DACHER** - Gentle, supportive - perfect for reflections
- **STELLA** - Clear, inviting - good for questions

Browse all voices: [Hume Voice Library](https://platform.hume.ai/tts/voice-library)

## 📝 Quick Examples

### Card Reveal
```javascript
import { speakCardReveal } from '../lib/audioHume';

await speakCardReveal(
  'The Fool', 
  'upright', 
  'New beginnings and fresh starts'
);
```

### Full Reading
```javascript
import { speakFullReading } from '../lib/audioHume';

await speakFullReading(readingText, {
  voiceName: 'ITO',
  speed: 1.0
});
```

### Multiple Cards with Voice Continuity
```javascript
import { speakSequence, resetGenerationId } from '../lib/audioHume';

// Reset for new reading
resetGenerationId();

const cardInterpretations = [
  "In the past, The Tower reveals...",
  "The present shows The Star...",
  "And The Sun emerges in the future..."
];

await speakSequence(cardInterpretations, {
  context: 'full-reading',
  voiceName: 'ITO',
  autoPlay: true
});
```

### Custom Acting Instructions
```javascript
import { speakWithHume } from '../lib/audioHume';

await speakWithHume("The Magician appears before you", {
  voiceName: 'ITO',
  description: "mystical and ancient, with deep resonance and slow pacing",
  speed: 0.85,
  trailingSilence: 2.0
});
```

## 🧪 Test the Integration

### Test the API Endpoint
```bash
curl -X POST http://localhost:5173/api/tts-hume \
  -H "Content-Type: application/json" \
  -d '{
    "text": "The Fool appears before you",
    "context": "card-reveal"
  }'
```

### Test in Browser Console
```javascript
// Import the library
import { speakWithHume, isHumeTTSAvailable } from './lib/audioHume';

// Check if available
const available = await isHumeTTSAvailable();
console.log('Hume TTS available:', available);

// Generate speech
const result = await speakWithHume('The cards reveal wisdom', {
  voiceName: 'ITO'
});

// Play audio
result.play();
```

## 🎨 Customization

### Context Types
The system automatically selects appropriate voices based on context:

- **`card-reveal`** - Single card reveals (Voice: ITO)
- **`full-reading`** - Complete interpretations (Voice: ITO)
- **`synthesis`** - Summaries and conclusions (Voice: KORA)
- **`question`** - Question acknowledgments (Voice: STELLA)
- **`reflection`** - User reflection validation (Voice: DACHER)

### Speed Control
- **0.8-0.9x** - Deep contemplation, meditation
- **1.0x** - Natural, conversational
- **1.1-1.2x** - Engaging, slightly faster

### Acting Instructions
Use natural language to guide emotional delivery:

```javascript
await speakWithHume(text, {
  voiceName: 'ITO',
  description: "shocked and disappointed, speaking slowly with emphasis"
});
```

## 📚 Full Documentation

See `HUME_INTEGRATION.md` for complete documentation including:
- Full API reference
- All available voices
- Best practices
- Troubleshooting
- Advanced features

## 🆘 Troubleshooting

**"Hume AI is not configured"**
- Check that `HUME_API_KEY` is set in environment variables
- Redeploy after adding the key
- Verify key at [platform.hume.ai/settings/keys](https://platform.hume.ai/settings/keys)

**Audio not playing**
- Check browser console for errors
- Verify autoplay permissions
- Try user-initiated playback (button click)

**Rate limit errors (429)**
- Wait a moment and try again
- Check your [subscription tier](https://www.hume.ai/pricing)
- Consider caching audio for repeated text

**Need help?**
- Check the console logs
- Review `HUME_INTEGRATION.md`
- Visit [Hume documentation](https://dev.hume.ai/)

## 🎯 Key Features

✅ **Emotionally Intelligent** - LLM-powered understanding of context  
✅ **Voice Continuity** - Seamless multi-part readings  
✅ **Acting Instructions** - Natural language voice control  
✅ **Context-Aware** - Automatic voice selection  
✅ **High Quality** - Professional-grade audio  
✅ **Easy Integration** - Drop-in component or flexible library  

## 🔗 Resources

- [API Documentation](https://dev.hume.ai/reference/text-to-speech-tts)
- [Voice Library](https://platform.hume.ai/tts/voice-library)
- [API Keys](https://platform.hume.ai/settings/keys)
- [TypeScript SDK](https://github.com/humeai/hume-typescript-sdk)
- [Sample Code](https://github.com/HumeAI/hume-api-examples/tree/main/tts)

## 🎉 You're Ready!

The integration is complete and ready to use. Start by adding the `HumeAudioControls` component to your reading display, or use the library functions directly for more control.

The Hume Octave TTS system understands your tarot readings emotionally and semantically, delivering expressive, mystical narration that enhances the reading experience.

Happy reading! 🔮✨

---

**Version:** 2.0.0 (Updated with correct Octave TTS API)  
**Last Updated:** November 25, 2025
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Tableu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#022c22" />
  <link rel="manifest" href="/manifest.webmanifest" />
  <link rel="icon" href="/icons/icon-192.svg" type="image/svg+xml" />
  <!-- Vite will bundle CSS imports from your React entry.
         For dev: styles are injected automatically.
         For production: /dist/assets/*.css is auto-linked in the built index.html. -->
</head>

<body class="bg-slate-950 text-amber-50">
  <!-- Inline SVG Sprite for Tableu Logo -->
  <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
    <defs>
      <!-- ===========================
           STYLE DEFINITIONS
           =========================== -->
      <style>
        /* Base stroke/fill classes */
        .t-stroke {
          fill: none;
          stroke: var(--stroke, currentColor);
          stroke-width: var(--sw, 6);
          stroke-linecap: round;
          stroke-linejoin: round;
        }
        .t-fill {
          fill: var(--fill, currentColor);
          stroke: none;
        }
        .t-fill-stroke {
          fill: var(--fill, currentColor);
          stroke: var(--stroke, currentColor);
          stroke-width: var(--sw, 3);
          stroke-linecap: round;
          stroke-linejoin: round;
        }

        /* Theme variants */
        .theme-primary {
          --fill: #C9B36E;
          --stroke: #C9B36E;
          --sw: 6;
        }
        .theme-mono {
          --fill: #000000;
          --stroke: #000000;
          --sw: 6;
        }
        .theme-dark {
          --fill: #FFFFFF;
          --stroke: #FFFFFF;
          --sw: 6;
        }
      </style>

      <!-- ===========================
           REUSABLE SYMBOL ELEMENTS
           =========================== -->

      <!-- Crescent Moon -->
      <symbol id="t-moon" viewBox="0 0 100 100">
        <path class="t-fill" d="
          M35 20
          C20 24 10 38 12 52
          C14 66 26 76 40 75
          C30 72 24 62 24 50
          C24 38 30 28 40 25
          C38 22 36 21 35 20 Z" />
      </symbol>

      <!-- 4-Point Star -->
      <symbol id="t-star-4" viewBox="0 0 100 100">
        <path class="t-fill" d="
          M50 10
          C48 30 48 30 28 32
          C48 34 48 34 50 54
          C52 34 52 34 72 32
          C52 30 52 30 50 10 Z" />
      </symbol>

      <!-- 6-Point Sparkle (smaller) -->
      <symbol id="t-sparkle" viewBox="0 0 100 100">
        <path class="t-fill" d="
          M50 20
          C48 35 48 35 33 37
          C48 39 48 39 50 54
          C52 39 52 39 67 37
          C52 35 52 35 50 20 Z" />
      </symbol>

      <!-- Eye -->
      <symbol id="t-eye" viewBox="0 0 100 100">
        <path class="t-stroke" d="
          M50 25
          C70 35 75 50 65 65
          C55 75 45 75 35 65
          C25 50 30 35 50 25 Z" />
        <circle class="t-stroke" cx="50" cy="50" r="12" />
        <circle class="t-fill" cx="50" cy="50" r="5" />
      </symbol>

      <!-- Octopus Head -->
      <symbol id="t-octopus-head" viewBox="0 0 200 200">
        <ellipse class="t-fill" cx="100" cy="90" rx="65" ry="70" />
        <!-- Eyes (arcs) -->
        <path class="t-stroke" d="M70 80 Q75 88 80 80" />
        <path class="t-stroke" d="M130 80 Q125 88 120 80" />
        <!-- Smile -->
        <path class="t-stroke" d="M85 105 Q100 112 115 105" />
      </symbol>

      <!-- Single Tentacle -->
      <symbol id="t-tentacle" viewBox="0 0 50 150">
        <path class="t-fill" d="
          M25 10
          C20 40 15 80 18 110
          C20 130 28 145 35 142
          C40 138 38 120 35 100
          C32 70 28 40 25 10 Z" />
      </symbol>
    </defs>

    <!-- ===========================
         MAIN LOGO MARK (no wordmark)
         =========================== -->
    <symbol id="tableu-mark" viewBox="-12 -12 456 600" overflow="visible">
      <g class="theme-primary">
        <!-- Card Frame -->
        <rect class="t-stroke" x="10" y="10" width="412" height="556" rx="48" />

        <!-- Center Divider Line -->
        <line class="t-stroke" x1="216" y1="18" x2="216" y2="110" />

        <!-- Bottom Curved Baseline -->
        <path class="t-stroke" d="M40 490 Q216 470 392 490" />

        <!-- Moon (top left) -->
        <g transform="translate(70, 45) scale(0.9)">
          <use href="#t-moon" />
        </g>

        <!-- Star (top right) -->
        <g transform="translate(310, 40) scale(1.1)">
          <use href="#t-star-4" />
        </g>

        <!-- Wand with sparkle -->
        <path class="t-stroke" d="M320 170 Q300 200 280 230" />
        <g transform="translate(275, 145) scale(0.6)">
          <use href="#t-sparkle" />
        </g>

        <!-- Eye (right side) -->
        <g transform="translate(330, 240) scale(0.85)">
          <use href="#t-eye" />
        </g>

        <!-- Bottom left sparkle -->
        <g transform="translate(50, 360) scale(0.7)">
          <use href="#t-sparkle" />
        </g>

        <!-- Octopus -->
        <g transform="translate(116, 180)">
          <use href="#t-octopus-head" />

          <!-- 6 Tentacles spreading downward -->
          <!-- Far left -->
          <g transform="translate(15, 150) scale(0.95) rotate(-25 25 10)">
            <use href="#t-tentacle" />
          </g>

          <!-- Mid left -->
          <g transform="translate(35, 155) scale(1.0) rotate(-10 25 10)">
            <use href="#t-tentacle" />
          </g>

          <!-- Center left -->
          <g transform="translate(60, 160) scale(1.05) rotate(0 25 10)">
            <use href="#t-tentacle" />
          </g>

          <!-- Center right -->
          <g transform="translate(85, 160) scale(1.05) rotate(0 25 10)">
            <use href="#t-tentacle" />
          </g>

          <!-- Mid right -->
          <g transform="translate(110, 155) scale(1.0) rotate(10 25 10)">
            <use href="#t-tentacle" />
          </g>

          <!-- Far right -->
          <g transform="translate(130, 150) scale(0.95) rotate(25 25 10)">
            <use href="#t-tentacle" />
          </g>
        </g>
      </g>
    </symbol>

    <!-- ===========================
         VARIANT 1: PRIMARY LOGO
         =========================== -->
    <symbol id="tableu-primary" viewBox="-12 -12 456 600" overflow="visible">
      <use href="#tableu-mark" />
    </symbol>

    <!-- ===========================
         VARIANT 2: ICON (simplified)
         Remove: eye, wand, bottom sparkle
         =========================== -->
    <symbol id="tableu-icon" viewBox="-12 -12 456 600" overflow="visible">
      <g class="theme-primary">
        <rect class="t-stroke" x="10" y="10" width="412" height="556" rx="48" />
        <line class="t-stroke" x1="216" y1="18" x2="216" y2="110" />
        <path class="t-stroke" d="M40 490 Q216 470 392 490" />

        <g transform="translate(70, 45) scale(0.9)">
          <use href="#t-moon" />
        </g>

        <g transform="translate(310, 40) scale(1.1)">
          <use href="#t-star-4" />
        </g>

        <!-- Octopus with tentacles -->
        <g transform="translate(116, 180)">
          <use href="#t-octopus-head" />
          <g transform="translate(15, 150) scale(0.95) rotate(-25 25 10)">
            <use href="#t-tentacle" />
          </g>
          <g transform="translate(35, 155) scale(1.0) rotate(-10 25 10)">
            <use href="#t-tentacle" />
          </g>
          <g transform="translate(60, 160) scale(1.05) rotate(0 25 10)">
            <use href="#t-tentacle" />
          </g>
          <g transform="translate(85, 160) scale(1.05) rotate(0 25 10)">
            <use href="#t-tentacle" />
          </g>
          <g transform="translate(110, 155) scale(1.0) rotate(10 25 10)">
            <use href="#t-tentacle" />
          </g>
          <g transform="translate(130, 150) scale(0.95) rotate(25 25 10)">
            <use href="#t-tentacle" />
          </g>
        </g>
      </g>
    </symbol>

    <!-- ===========================
         VARIANT 3: MONOCHROME
         =========================== -->
    <symbol id="tableu-mono" viewBox="-12 -12 456 600" overflow="visible">
      <g class="theme-mono">
        <use href="#tableu-mark" />
      </g>
    </symbol>

    <!-- ===========================
         VARIANT 4: DARK MODE
         =========================== -->
    <symbol id="tableu-dark" viewBox="-12 -12 456 600" overflow="visible">
      <g class="theme-dark">
        <use href="#tableu-mark" />
      </g>
    </symbol>

    <!-- ===========================
         VARIANT 5: FAVICON (octopus only)
         =========================== -->
    <symbol id="tableu-favicon" viewBox="-10 -10 220 270" overflow="visible">
      <g class="theme-primary">
        <g transform="translate(0, 10)">
          <use href="#t-octopus-head" />

          <!-- Simplified 4 tentacles -->
          <g transform="translate(25, 150) scale(0.9) rotate(-20 25 10)">
            <use href="#t-tentacle" />
          </g>
          <g transform="translate(55, 155) scale(1.0) rotate(-5 25 10)">
            <use href="#t-tentacle" />
          </g>
          <g transform="translate(90, 155) scale(1.0) rotate(5 25 10)">
            <use href="#t-tentacle" />
          </g>
          <g transform="translate(120, 150) scale(0.9) rotate(20 25 10)">
            <use href="#t-tentacle" />
          </g>
        </g>
      </g>
    </symbol>

    <!-- ===========================
         VARIANT 6: WITH WORDMARK
         =========================== -->
    <symbol id="tableu-full" viewBox="-12 -12 456 744" overflow="visible">
      <!-- Logo mark -->
      <use href="#tableu-mark" />

      <!-- TABLEU Wordmark -->
      <g class="theme-primary" transform="translate(0, 600)">
        <text
          x="216"
          y="80"
          text-anchor="middle"
          font-family="serif"
          font-size="72"
          font-weight="300"
          letter-spacing="12"
          fill="var(--fill, #C9B36E)">
          TABLEU
        </text>
      </g>
    </symbol>
  </svg>

  <div id="root"></div>
  <script type="module" src="/src/main.jsx"></script>
</body>

</html>
</file>

<file path="JOURNAL_IMPROVEMENTS_TODO.md">
# Journal Feature Improvements - Implementation Plan

## Prioritized Next Steps

### 1. Inline Status Feedback Refactor (High Priority - ~1 day)
- [ ] Analyze current ToastContext dependencies in JournalEntryCard
- [ ] Create reusable inline status components with role="status"
- [ ] Replace toast-only flows in JournalEntryCard handlers
- [ ] Replace toast-only flows in JournalInsightsPanel
- [ ] Test accessibility of new inline feedback

### 2. Mobile Rail Accordion Overhaul (High Priority - ~2-3 days)
- [ ] Examine current mobile rail implementation in Journal.jsx
- [ ] Design accordion pattern for filters, insights, and archetype journey
- [ ] Implement independent accordion panels for mobile
- [ ] Preserve sticky behavior above lg breakpoint
- [ ] Test responsive behavior and accessibility

### 3. Saved Filters + Token Harmonization (Medium Priority - ~2 days)
- [ ] Analyze current outline token inconsistencies
- [ ] Centralize outline/fill tokens across components
- [ ] Implement minimal saved-filter functionality
- [ ] Apply consistent tokens in JournalFilters, JournalEntryCard, and JournalInsightsPanel
- [ ] Update design tokens configuration

### 4. Archetype Run Metadata Persistence (Low Priority - ~0.5 day)
- [ ] Examine current backfill metadata handling
- [ ] Store lastBackfillAt/entriesProcessed in analytics payload
- [ ] Update ArchetypeJourneySection header rendering
- [ ] Test metadata persistence after analytics load

### 5. Comprehensive QA/Accessibility Sweep (Low Priority - ~0.5 day)
- [ ] Keyboard navigation testing
- [ ] Screen reader testing with aria-live regions
- [ ] Focus ring validation
- [ ] Responsive behavior verification
- [ ] Journal checklist acceptance criteria validation

## Current Issues Identified

### Inline Status Feedback
- `JournalEntryCard` handlers exclusively use `showToast` with no inline state
- `JournalInsightsPanel` duplicates toast dependency
- No aria-live regions or status announcements

### Mobile Rail Behavior
- Sub-lg breakpoints use segmented swap instead of accordions
- Users cannot expand filters, insights, and archetype journey independently
- Lost parity with desktop sticky rail

### Saved Filters & Tokens
- "Saved filters coming soon" disabled placeholder
- Inconsistent outline tokens (`border-secondary/60` vs `/40` vs `/30`)
- Visual inconsistency across components

### Archetype Run Metadata
- Header relies on absent `analytics.stats?.lastAnalyzedAt`
- `runCaption` never persists timestamp after analytics load
- Metadata disappears post-backfill

## Files Referenced
- `src/components/JournalEntryCard.jsx` (lines 133-150, 152-188, 395-492)
- `src/components/JournalInsightsPanel.jsx` (lines 212-345, 685-729)
- `src/components/Journal.jsx` (lines 605-748)
- `src/components/JournalFilters.jsx` (lines 182-189, 182-244)
- `src/components/ArchetypeJourneySection.jsx` (lines 81-149, 424-435)
- `docs/journal-gap-assessment.md` (lines 5-62, 36-41, 45, 61-62)
- `docs/journal-redesign.md` (lines 64-84)
</file>

<file path="package.json">
{
  "name": "tableau",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "./dev.sh",
    "dev:wrangler": "wrangler dev --config wrangler.jsonc",
    "dev:frontend": "vite",
    "dev:workers": "wrangler dev --config wrangler.jsonc --live-reload",
    "build": "vite build",
    "build:all": "vite build",
    "build:frontend": "vite build",
    "build:functions": "echo 'Functions are now part of the worker build'",
    "preview": "vite preview",
    "preview:worker": "npm run build && wrangler dev --config wrangler.jsonc",
    "preview:workers": "npm run build && wrangler dev --config wrangler.jsonc --local",
    "deploy": "npm run build && wrangler deploy --config wrangler.jsonc",
    "deploy:workers": "npm run build && wrangler deploy --config wrangler.jsonc",
    "deploy:dry-run": "npm run build && wrangler deploy --config wrangler.jsonc --dry-run",
    "test": "node --test tests/*.test.mjs",
    "test:contrast": "node tests/accessibility/contrast-checker.mjs",
    "test:wcag": "node tests/accessibility/wcag-analyzer.mjs",
    "test:a11y": "npm run test:contrast && npm run test:wcag",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix",
    "config:check": "node scripts/checkEnv.js",
    "vision:prototype": "node scripts/vision/runVisionPrototype.js",
    "eval:vision": "node scripts/evaluation/runVisionConfidence.js",
    "eval:vision:rws": "node scripts/evaluation/runVisionConfidence.js --deck-style rws-1909 --out data/evaluations/vision-confidence.rws.json",
    "eval:vision:thoth": "node scripts/evaluation/runVisionConfidence.js --deck-style thoth-a1 --out data/evaluations/vision-confidence.thoth.json",
    "eval:vision:marseille": "node scripts/evaluation/runVisionConfidence.js --deck-style marseille-classic --out data/evaluations/vision-confidence.marseille.json",
    "eval:vision:all": "npm run eval:vision:rws && npm run eval:vision:thoth && npm run eval:vision:marseille",
    "metrics:vision:rws": "node scripts/evaluation/computeVisionMetrics.js --in data/evaluations/vision-confidence.rws.json --deck-style rws-1909 --review-out data/evaluations/vision-review-queue.rws.csv --metrics-out data/evaluations/vision-metrics.json",
    "metrics:vision:thoth": "node scripts/evaluation/computeVisionMetrics.js --in data/evaluations/vision-confidence.thoth.json --deck-style thoth-a1 --review-out data/evaluations/vision-review-queue.thoth.csv --metrics-out data/evaluations/vision-metrics.json",
    "metrics:vision:marseille": "node scripts/evaluation/computeVisionMetrics.js --in data/evaluations/vision-confidence.marseille.json --deck-style marseille-classic --review-out data/evaluations/vision-review-queue.marseille.csv --metrics-out data/evaluations/vision-metrics.json",
    "eval:vision:metrics": "npm run metrics:vision:rws && npm run metrics:vision:thoth && npm run metrics:vision:marseille",
    "gate:vision": "node scripts/evaluation/verifyVisionGate.js --deck-style rws-1909 && node scripts/evaluation/verifyVisionGate.js --deck-style thoth-a1 && node scripts/evaluation/verifyVisionGate.js --deck-style marseille-classic",
    "ci:vision-check": "npm run eval:vision:all && npm run eval:vision:metrics && npm run gate:vision",
    "review:vision": "node scripts/evaluation/processVisionReviews.js",
    "eval:narrative": "node scripts/evaluation/runNarrativeSamples.js && node scripts/evaluation/computeNarrativeMetrics.js",
    "gate:narrative": "node scripts/evaluation/verifyNarrativeGate.js",
    "ci:narrative-check": "npm run eval:narrative && npm run gate:narrative",
    "review:narrative": "node scripts/evaluation/processNarrativeReviews.js",
    "training:export": "node scripts/training/exportReadings.js",
    "training:fine-tune-vision": "node scripts/training/fineTuneVision.js",
    "prompts:view": "node scripts/viewPrompts.js",
    "prompts:stats": "node scripts/viewPrompts.js --stats",
    "prompts:export": "node scripts/viewPrompts.js --export"
  },
  "dependencies": {
    "@phosphor-icons/react": "^2.1.10",
    "@xenova/transformers": "^2.17.2",
    "astronomy-engine": "^2.1.19",
    "focus-trap-react": "^11.0.4",
    "framer-motion": "^12.23.24",
    "jspdf": "^3.0.3",
    "prop-types": "^15.8.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-markdown": "^10.1.0",
    "react-router-dom": "^7.9.6",
    "remark-breaks": "^4.0.0",
    "remark-gfm": "^4.0.1",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@tailwindcss/forms": "^0.5.7",
    "@tailwindcss/typography": "^0.5.15",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.39.1",
    "eslint-plugin-react": "^7.37.5",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.10",
    "vite": "^7.2.4",
    "wrangler": "^4.50.0"
  }
}
</file>

<file path="postcss.config.cjs">
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};
</file>

<file path="README.md">
# Tableu

**Tableu** is a sophisticated AI-powered tarot reading application that bridges traditional cartomancy with modern generative AI. Unlike simple database-lookup tarot apps, it uses advanced Large Language Models to synthesize complex card relationships, positional meanings, and user context into cohesive, human-like narratives.

> 🔮 Designed to feel like sitting with a practiced reader, not a generic card widget.

## ✨ Features

- **Multiple Spread Types**: One-Card Insight, Three-Card Story, Five-Card Clarity, Decision/Two-Path, Relationship Snapshot, and Celtic Cross (10-card)
- **AI-Generated Narratives**: Context-aware readings powered by Azure OpenAI GPT-5.1 with Claude fallback
- **Knowledge Graph Analysis**: Advanced pattern detection including elemental dignities, suit progressions, and archetypal triads
- **Text-to-Speech**: Listen to readings with Azure GPT-4o-mini TTS
- **Personal Journal**: Save and reflect on readings (cloud sync for authenticated users, localStorage for anonymous)
- **Shareable Readings**: Generate links to share readings with others
- **Ritual Experience**: Authentic tarot feel with knocks, deck cutting, and card reveal animations
- **Accessibility**: WCAG-compliant with keyboard navigation, ARIA labels, and reduced-motion support
- **PWA Support**: Installable progressive web app with offline capabilities

## 🛠 Tech Stack

| Layer | Technology |
|-------|------------|
| Frontend | React 18, Vite, Tailwind CSS |
| Backend | Cloudflare Workers (serverless) |
| AI | Azure OpenAI (GPT-5.1, GPT-4o-mini TTS), Anthropic Claude |
| Database | Cloudflare D1 (SQLite) |
| Caching/Rate Limiting | Cloudflare KV |
| Storage | Cloudflare R2 |

## 📁 Project Structure

```
├── src/                    # React frontend
│   ├── components/         # UI components (Card, ReadingGrid, etc.)
│   ├── contexts/           # React contexts (Auth, Preferences, Reading)
│   ├── data/               # Card data and spread definitions
│   ├── hooks/              # Custom React hooks
│   ├── lib/                # Frontend utilities (audio, deck, formatting)
│   ├── pages/              # Route pages
│   ├── styles/             # CSS files (Tailwind + custom)
│   ├── worker/             # Cloudflare Worker entry point
│   └── TarotReading.jsx    # Main orchestration component
├── functions/              # Cloudflare Pages Functions (API)
│   ├── api/                # API endpoints
│   └── lib/                # Backend logic and narrative generation
├── public/                 # Static assets (images, sounds, icons)
├── tests/                  # Test files (*.test.mjs)
├── scripts/                # Utility scripts (evaluation, training)
├── docs/                   # Documentation
└── migrations/             # Database migrations (D1)
```

## 🚀 Getting Started

### Prerequisites

- Node.js 18.0.0 or later
- npm (included with Node.js)
- Cloudflare account (for deployment)

### Installation

```bash
# Clone the repository
git clone https://github.com/henryperkins/tarot.git
cd tarot

# Install dependencies
npm install
```

### Environment Setup

1. Copy the example environment file:
   ```bash
   cp .dev.vars.example .dev.vars
   ```

2. Fill in the required secrets in `.dev.vars`:
   ```bash
   # Azure OpenAI (required for AI-generated readings)
   AZURE_OPENAI_ENDPOINT=https://your-resource.openai.azure.com
   AZURE_OPENAI_API_KEY=your-api-key
   AZURE_OPENAI_GPT5_MODEL=gpt-5.1

   # Azure TTS (optional, for voice readings)
   AZURE_OPENAI_TTS_ENDPOINT=https://your-resource.openai.azure.com
   AZURE_OPENAI_TTS_API_KEY=your-tts-api-key
   AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT=gpt-4o-mini-tts

   # Anthropic (optional, for Claude fallback)
   ANTHROPIC_API_KEY=sk-ant-your-key

   # Vision research mode (optional)
   VISION_PROOF_SECRET=your-secret-key
   ```

3. Verify your configuration:
   ```bash
   npm run config:check
   ```

> ⚠️ Never commit `.dev.vars` to version control. It's already in `.gitignore`.

## 💻 Development

### Quick Start

```bash
npm run dev
```

This starts both the Vite dev server and Wrangler proxy. Access the app at **http://localhost:8788**.

### Available Scripts

| Command | Description |
|---------|-------------|
| `npm run dev` | Start full-stack development server |
| `npm run dev:frontend` | Start Vite dev server only (no API) |
| `npm run dev:wrangler` | Start Wrangler Workers dev server |
| `npm run build` | Build for production |
| `npm run preview` | Preview production build |
| `npm test` | Run tests |
| `npm run lint` | Run ESLint |
| `npm run lint:fix` | Fix linting issues |

### Important URLs During Development

| URL | Purpose |
|-----|---------|
| http://localhost:8788 | Full app with API ✅ |
| http://localhost:5173 | Frontend only (no API) |

## 🧪 Testing

```bash
# Run all tests
npm test

# Accessibility tests
npm run test:a11y

# Vision quality gates
npm run gate:vision

# Narrative quality gates
npm run gate:narrative
```

Tests use Node.js native test runner with `.test.mjs` files in the `tests/` directory.

## 🚢 Deployment

### Deploy to Cloudflare

```bash
# Build and deploy
npm run build && npm run deploy

# Or use the combined script
npm run deploy
```

### Set Production Secrets

```bash
wrangler pages secret put AZURE_OPENAI_ENDPOINT --project-name=tableau
wrangler pages secret put AZURE_OPENAI_API_KEY --project-name=tableau
wrangler pages secret put AZURE_OPENAI_GPT5_MODEL --project-name=tableau
# ... add other secrets as needed
```

### Deployment URLs

- **Production**: https://tableau-8xz.pages.dev
- **Branch Previews**: https://\<branch-name\>.tableau-8xz.pages.dev

## 📖 Documentation

Detailed documentation is available in the `docs/` directory:

- [Developer Onboarding](docs/DEVELOPER_ONBOARDING.md) - Getting started guide
- [Development Setup](docs/DEV_SETUP.md) - Local development instructions
- [Deployment Guide](docs/DEPLOYMENT.md) - Production deployment
- [System Architecture](docs/SYSTEM_ARCHITECTURE.md) - Technical architecture
- [Vision Pipeline](docs/VISION_PIPELINE.md) - Physical card recognition
- [Knowledge Graph](docs/knowledge-graph/) - Tarot pattern documentation

## 🤝 Contributing

1. Follow [Conventional Commits](https://www.conventionalcommits.org/): `feat:`, `fix:`, `chore:`, `docs:`, `test:`
2. Run `npm test` before pushing changes
3. Run `npm run lint` to check code style
4. Include screenshots for UI changes in PR descriptions
5. Keep PRs focused; avoid bundling unrelated changes

## 🃏 Spreads

| Spread | Cards | Description |
|--------|-------|-------------|
| One-Card Insight | 1 | Quick guidance for a focused question |
| Three-Card Story | 3 | Past, Present, Future narrative |
| Five-Card Clarity | 5 | Core, Challenge, Hidden, Support, Direction |
| Decision/Two-Path | 5 | Compare two options with clarity |
| Relationship Snapshot | 3 | You, Them, Connection dynamic |
| Celtic Cross | 10 | Classic deep dive for complex questions |

## ⚖️ Ethics

- Tarot readings are for **guidance and reflection**, not replacement for professional advice
- Emphasizes user **agency and free will** over deterministic predictions
- No medical, legal, or financial advice
- Trauma-informed, empowering language
- Cards are never invented or hallucinated by the AI

## 📜 Card Images

The app uses public domain 1909 Rider-Waite "Roses & Lilies" deck images from Wikimedia Commons.

---

Built with 🔮 by the Tableu team
</file>

<file path="rename.py">
import os
import sys
import argparse
import shutil
import subprocess
import tempfile
from pathlib import Path
import fnmatch

EXTENSION_LANGS = {
    '.py': 'python',
    '.ts': 'typescript',
    '.tsx': 'typescript',
    '.js': 'javascript',
    '.jsx': 'javascript',
    '.cjs': 'javascript',
    '.json': 'json',
    '.html': 'html',
    '.css': 'css',
    '.sh': 'bash',
    '.toml': 'toml',
    '.sql': 'sql',
    '.log': 'text',
}

def parse_gitignore(gitignore_path):
    """
    Parses a .gitignore file and returns a list of patterns to ignore.
    """
    patterns = []
    try:
        with open(gitignore_path, 'r', encoding='utf-8') as file:
            for line in file:
                stripped_line = line.strip()
                if stripped_line and not stripped_line.startswith('#'):
                    patterns.append(stripped_line)
    except FileNotFoundError:
        pass
    return patterns

def should_ignore(path, ignore_patterns):
    """
    Determines if a given file or directory should be ignored based on the ignore patterns.
    """
    for pattern in ignore_patterns:
        if fnmatch.fnmatch(path, pattern) or fnmatch.fnmatch(os.path.basename(path), pattern):
            return True
    return False

def rename_and_modify_files_to_md(directory, recursive=False, dry_run=False, log_callback=None):
    """
    Renames all supported files in the specified directory to .md
    and wraps their contents in Markdown code fences, while respecting .gitignore.
    """
    if not os.path.isdir(directory):
        msg = f"Error: The path '{directory}' is not a valid directory."
        if log_callback:
            log_callback(msg)
        else:
            print(msg)
        return

    gitignore_path = os.path.join(directory, '.gitignore')
    ignore_patterns = parse_gitignore(gitignore_path)

    if recursive:
        walker = os.walk(directory)
    else:
        try:
            files = os.listdir(directory)
        except OSError as e:
            msg = f"Error accessing directory '{directory}': {e}"
            if log_callback:
                log_callback(msg)
            else:
                print(msg)
            return
        walker = [(directory, [], files)]

    for root, dirs, files in walker:
        dirs[:] = [d for d in dirs if not should_ignore(os.path.join(root, d), ignore_patterns)]

        for filename in files:
            file_ext = os.path.splitext(filename)[1].lower()
            file_path = os.path.join(root, filename)

            if should_ignore(file_path, ignore_patterns):
                msg = f"Ignoring '{file_path}' due to .gitignore rules."
                if log_callback:
                    log_callback(msg)
                else:
                    print(msg)
                continue

            if file_ext in EXTENSION_LANGS:
                old_path = os.path.join(root, filename)
                new_filename = os.path.splitext(filename)[0] + '.md'
                new_path = os.path.join(root, new_filename)

                if os.path.exists(new_path):
                    msg = f"Skipping '{old_path}': '{new_filename}' already exists."
                    if log_callback:
                        log_callback(msg)
                    else:
                        print(msg)
                    continue

                if dry_run:
                    msg = f"[Dry Run] Would rename: '{old_path}' -> '{new_path}' and modify contents."
                    if log_callback:
                        log_callback(msg)
                    else:
                        print(msg)
                else:
                    try:
                        os.rename(old_path, new_path)
                        msg = f"Renamed: '{old_path}' -> '{new_path}'"
                        if log_callback:
                            log_callback(msg)
                        else:
                            print(msg)

                        with open(new_path, 'r', encoding='utf-8') as file:
                            content = file.read()

                        language = EXTENSION_LANGS[file_ext]
                        wrapped_content = f"```{language}\n{content}\n```"

                        with open(new_path, 'w', encoding='utf-8') as file:
                            file.write(wrapped_content)

                        msg = f"Modified contents of '{new_path}' to include Markdown code fences."
                        if log_callback:
                            log_callback(msg)
                        else:
                            print(msg)
                    except OSError as e:
                        msg = f"Error processing '{old_path}': {e}"
                        if log_callback:
                            log_callback(msg)
                        else:
                            print(msg)

def clone_github_repo(repo_url, destination, log_callback=None):
    """
    Clones a GitHub repository to the specified destination using GitHub CLI.
    """
    try:
        subprocess.run(["gh", "--version"], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        msg = f"Cloning repository '{repo_url}' into '{destination}'..."
        if log_callback:
            log_callback(msg)
        else:
            print(msg)

        subprocess.run(["gh", "repo", "clone", repo_url, destination], check=True)

        msg = f"Successfully cloned '{repo_url}'."
        if log_callback:
            log_callback(msg)
        else:
            print(msg)
        return True
    except subprocess.CalledProcessError as e:
        msg = f"Error cloning repository '{repo_url}': {e}"
        if log_callback:
            log_callback(msg)
        else:
            print(msg)
        return False
    except FileNotFoundError:
        msg = "GitHub CLI ('gh') is not installed or not found in PATH."
        if log_callback:
            log_callback(msg)
        else:
            print(msg)
        return False

def create_directory_copy(original_dir, output_dir=None, log_callback=None):
    """
    Creates a copy of the specified directory. If output_dir is provided, copies to that location.
    Otherwise, appends '_renamed' to the original directory name.
    """
    if output_dir:
        copy_dir = os.path.abspath(output_dir)
    else:
        parent_dir, dir_name = os.path.split(os.path.abspath(original_dir))
        copy_dir_name = f"{dir_name}_renamed"
        copy_dir = os.path.join(parent_dir, copy_dir_name)

    if os.path.exists(copy_dir):
        msg = f"Copy directory '{copy_dir}' already exists. Removing it first."
        if log_callback:
            log_callback(msg)
        else:
            print(msg)
        shutil.rmtree(copy_dir)

    try:
        shutil.copytree(original_dir, copy_dir)
        msg = f"Created a copy of '{original_dir}' at '{copy_dir}'."
        if log_callback:
            log_callback(msg)
        else:
            print(msg)
        return copy_dir
    except Exception as e:
        msg = f"Error copying directory '{original_dir}' to '{copy_dir}': {e}"
        if log_callback:
            log_callback(msg)
        else:
            print(msg)
        return None

def process_input(input_path_or_url, is_url, output_dir=None, log_callback=None):
    """
    Processes the input, cloning if it's a GitHub URL or using the local directory.
    """
    if is_url:
        temp_dir = tempfile.mkdtemp()
        success = clone_github_repo(input_path_or_url, temp_dir, log_callback)
        if not success:
            return None
        original_dir = temp_dir
    else:
        original_dir = input_path_or_url
        if not os.path.isdir(original_dir):
            msg = f"Error: The path '{original_dir}' is not a valid directory."
            if log_callback:
                log_callback(msg)
            else:
                print(msg)
            return None

    copied_dir = create_directory_copy(original_dir, output_dir, log_callback)
    return copied_dir

def run_cli(args):
    """
    Executes the CLI functionality based on parsed arguments.
    """
    if args.directory:
        input_path_or_url = args.directory
        is_url = False
    elif args.url:
        input_path_or_url = args.url
        is_url = True
    else:
        print("Error: Please provide either a directory or a GitHub URL.")
        sys.exit(1)

    output_dir = args.output

    directory_to_process = process_input(input_path_or_url, is_url, output_dir, log_callback=print)
    if directory_to_process is None:
        print("Processing aborted due to errors.")
        sys.exit(1)

    rename_and_modify_files_to_md(
        directory=directory_to_process,
        recursive=args.recursive,
        dry_run=args.dry_run,
        log_callback=print
    )

def build_supported_extensions_description():
    extensions_list = ', '.join(sorted(EXTENSION_LANGS.keys()))
    return f"Rename all {extensions_list} files in a directory or GitHub repo to .md and modify contents, respecting .gitignore."

def main():
    parser = argparse.ArgumentParser(description=build_supported_extensions_description())
    group = parser.add_mutually_exclusive_group()
    group.add_argument("-d", "--directory", help="Path to the target local directory")
    group.add_argument("-u", "--url", help="GitHub repository URL to clone and process")
    parser.add_argument("-o", "--output", help="Destination directory for the copied and renamed contents")
    parser.add_argument("-r", "--recursive", action="store_true",
                        help="Recursively rename supported files in subdirectories")
    parser.add_argument("--dry-run", action="store_true",
                        help="Show what would be renamed and modified without making any changes")

    args = parser.parse_args()

    if not args.directory and not args.url:
        parser.print_help()
        sys.exit(1)

    run_cli(args)

if __name__ == "__main__":
    main()
</file>

<file path="tailwind.config.js">
const defaultTheme = require('tailwindcss/defaultTheme')

/**
 * Tailwind configuration for Tableau (Vite + React + Cloudflare Pages).
 *
 * This replaces the previous cdn.tailwindcss.com usage.
 * Vite will use this during `npm run dev` and `npm run build` to generate the utilities.
 */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,jsx,ts,tsx}"
  ],
  theme: {
    screens: {
      'xxs': '320px',
      'xs': '375px',
      ...defaultTheme.screens,
    },
    extend: {
      screens: {
        // Landscape detection (for short landscape viewports)
        'landscape': { 'raw': '(orientation: landscape) and (max-height: 500px)' },
        'portrait': { 'raw': '(orientation: portrait)' },
        // Short viewport (useful for foldables and small tablets in landscape)
        'short': { 'raw': '(max-height: 600px)' },
      },
      colors: {
        // Elegant Minimal Palette
        charcoal: 'var(--color-charcoal)',
        slate: {
          dark: 'var(--color-slate-dark)',
          mid: 'var(--color-slate-mid)',
          light: 'var(--color-slate-light)',
        },
        gray: {
          light: 'var(--color-gray-light)',
          pale: 'var(--color-gray-pale)',
        },
        gold: {
          DEFAULT: 'var(--color-gold-champagne)',
          muted: 'var(--color-gold-muted)',
          soft: 'var(--color-gold-soft)',
        },
        silver: 'var(--color-silver)',

        // Suit Colors
        wands: 'var(--color-wands)',
        cups: 'var(--color-cups)',
        swords: 'var(--color-swords)',
        pentacles: 'var(--color-pentacles)',

        // Semantic Brand Colors
        primary: 'var(--brand-primary)',
        secondary: 'var(--brand-secondary)',
        accent: 'var(--brand-accent)',
        success: 'var(--status-success)',
        error: 'var(--status-error)',
      },
      backgroundColor: {
        main: 'var(--bg-main)',
        surface: 'var(--bg-surface)',
        'surface-muted': 'var(--bg-surface-muted)',
      },
      textColor: {
        main: 'var(--text-main)',
        muted: 'var(--text-muted)',
        'muted-high': 'var(--text-muted-high)', // Higher contrast muted for translucent backgrounds
        accent: 'var(--text-accent)',
        surface: 'var(--color-charcoal)', // high-contrast text for light CTA backgrounds
      },
      fontSize: {
        'xs-plus': ['0.875rem', { lineHeight: '1.4' }], // 14px - improved mobile readability
        'sm-mobile': ['0.9375rem', { lineHeight: '1.5' }], // 15px - comfortable mobile body text
      },
      fontFamily: {
        serif: ["serif"],
        sans: ["system-ui", "sans-serif"]
      },
      backdropBlur: {
        xs: "2px"
      },
      // Safe area utilities for modern mobile devices
      padding: {
        'safe-top': 'env(safe-area-inset-top, 0px)',
        'safe-bottom': 'env(safe-area-inset-bottom, 0px)',
        'safe-left': 'env(safe-area-inset-left, 0px)',
        'safe-right': 'env(safe-area-inset-right, 0px)',
      },
      margin: {
        'safe-top': 'env(safe-area-inset-top, 0px)',
        'safe-bottom': 'env(safe-area-inset-bottom, 0px)',
        'safe-left': 'env(safe-area-inset-left, 0px)',
        'safe-right': 'env(safe-area-inset-right, 0px)',
      },
      keyframes: {
        fadeIn: {
          '0%': { opacity: '0' },
          '100%': { opacity: '1' },
        },
        slideUp: {
          '0%': { transform: 'translateY(100%)' },
          '100%': { transform: 'translateY(0)' },
        },
        popIn: {
          '0%': { opacity: '0', transform: 'scale(0.95)' },
          '100%': { opacity: '1', transform: 'scale(1)' },
        },
        slideInRight: {
          '0%': { transform: 'translateX(100%)' },
          '100%': { transform: 'translateX(0)' },
        },
        fadeInUp: {
          '0%': { opacity: '0', transform: 'translateY(1rem)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
        inkSpread: {
          '0%': {
            opacity: '0',
            filter: 'blur(12px)',
            transform: 'scale(0.95)',
          },
          '40%': {
            opacity: '0.5',
            filter: 'blur(6px)',
            transform: 'scale(0.98)',
          },
          '100%': {
            opacity: '1',
            filter: 'blur(0px)',
            transform: 'scale(1)',
          },
        },
        slideDown: {
          '0%': { opacity: '0', transform: 'translateY(-0.5rem)' },
          '100%': { opacity: '1', transform: 'translateY(0)' },
        },
      },
      animation: {
        'fade-in': 'fadeIn 0.2s ease-out',
        'slide-up': 'slideUp 0.3s ease-out',
        'slide-down': 'slideDown 0.2s ease-out',
        'pop-in': 'popIn 0.2s ease-out',
        'slide-in-right': 'slideInRight 0.3s ease-out',
        'fade-in-up': 'fadeInUp 0.6s ease-out forwards',
        'ink-spread': 'inkSpread 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards',
      }
    }
  },
  plugins: [
    require("@tailwindcss/forms"),
    require("@tailwindcss/typography")
  ]
};
</file>

<file path="test-telemetry.js">
#!/usr/bin/env node

/**
 * Test script to verify telemetry persistence to METRICS_DB KV namespace
 *
 * This script:
 * 1. Generates a mock vision proof (bypassing actual image upload for testing)
 * 2. Makes a test reading request with the proof
 * 3. Verifies the telemetry was written to KV
 */

import crypto from 'crypto';

const BASE_URL = process.env.TEST_URL || 'https://dcc090f5.mystic-tarot.pages.dev';
const VISION_SECRET = 'Tf+FtRtWcEK8dlNgst7Eq2P6YP+G9J6sV9fD56azA70=';

/**
 * Sign a vision proof payload with HMAC-SHA256
 */
async function signProof(payload, secret) {
  const message = JSON.stringify(payload);
  const hmac = crypto.createHmac('sha256', secret);
  hmac.update(message);
  return hmac.digest('base64');
}

/**
 * Create a test vision proof
 */
async function createTestProof() {
  const now = new Date();
  const expiresAt = new Date(now.getTime() + 3600000); // 1 hour from now

  const payload = {
    id: crypto.randomUUID(),
    deckStyle: 'rws-1909',
    createdAt: now.toISOString(),
    expiresAt: expiresAt.toISOString(),
    insights: [
      {
        label: 'test-card-1',
        predictedCard: 'The Fool',
        confidence: 0.95,
        basis: 'test',
        matches: [],
        attention: null,
        symbolVerification: null
      },
      {
        label: 'test-card-2',
        predictedCard: 'The Magician',
        confidence: 0.92,
        basis: 'test',
        matches: [],
        attention: null,
        symbolVerification: null
      },
      {
        label: 'test-card-3',
        predictedCard: 'The High Priestess',
        confidence: 0.88,
        basis: 'test',
        matches: [],
        attention: null,
        symbolVerification: null
      }
    ]
  };

  const signature = await signProof(payload, VISION_SECRET);

  return {
    ...payload,
    signature
  };
}

/**
 * Make a test tarot reading request
 */
async function testReading() {
  console.log('🔮 Testing telemetry persistence...\n');

  // Create vision proof
  console.log('1️⃣  Creating test vision proof...');
  const visionProof = await createTestProof();
  console.log(`   ✓ Proof ID: ${visionProof.id}\n`);

  // Prepare test reading payload
  const payload = {
    spreadInfo: {
      name: 'Three-Card Story (Past · Present · Future)',
      description: 'Test spread for telemetry'
    },
    cardsInfo: [
      {
        position: 'Past',
        card: 'The Fool',
        orientation: 'upright',
        meaning: 'New beginnings, innocence, spontaneity'
      },
      {
        position: 'Present',
        card: 'The Magician',
        orientation: 'upright',
        meaning: 'Manifestation, resourcefulness, power'
      },
      {
        position: 'Future',
        card: 'The High Priestess',
        orientation: 'reversed',
        meaning: 'Hidden agendas, need for patience'
      }
    ],
    userQuestion: 'What guidance do I need right now?',
    reflectionsText: 'Testing telemetry persistence',
    visionProof,
    deckStyle: 'rws-1909'
  };

  // Make request
  console.log('2️⃣  Making reading request...');
  const response = await fetch(`${BASE_URL}/api/tarot-reading`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(payload)
  });

  console.log(`   Status: ${response.status} ${response.statusText}`);

  if (!response.ok) {
    const error = await response.text();
    console.error(`   ✗ Request failed:`, error);
    process.exit(1);
  }

  const result = await response.json();
  console.log(`   ✓ Provider: ${result.provider}`);
  console.log(`   ✓ Reading length: ${result.reading?.length || 0} chars\n`);

  return result;
}

// Run test
testReading()
  .then(() => {
    console.log('✅ Telemetry test completed successfully!');
    console.log('\n📊 To verify persistence, run:');
    console.log('   wrangler kv key list --namespace-id=2510ac5ac91e4a2fac375190a3dfc128 --prefix="reading:"\n');
  })
  .catch(error => {
    console.error('❌ Test failed:', error);
    process.exit(1);
  });
</file>

<file path="test-tts-now.sh">
#!/bin/bash

echo "🔍 Quick TTS Configuration Check"
echo "================================"
echo ""

# Check if .env.local exists
if [ ! -f ".env.local" ]; then
    echo "❌ .env.local file not found"
    echo "   Please create it first"
    exit 1
fi

# Load variables
export $(grep -v '^#' .env.local | xargs)

# Check required variables
echo "📋 Checking configuration..."
echo ""

if [ -z "$AZURE_OPENAI_ENDPOINT" ]; then
    echo "❌ AZURE_OPENAI_ENDPOINT is not set in .env.local"
    echo "   Add: AZURE_OPENAI_ENDPOINT=https://your-resource.openai.azure.com"
    exit 1
else
    echo "✅ AZURE_OPENAI_ENDPOINT: $AZURE_OPENAI_ENDPOINT"
fi

if [ -z "$AZURE_OPENAI_API_KEY" ]; then
    echo "❌ AZURE_OPENAI_API_KEY is not set"
    exit 1
else
    echo "✅ AZURE_OPENAI_API_KEY: ${AZURE_OPENAI_API_KEY:0:10}...${AZURE_OPENAI_API_KEY: -10}"
fi

if [ -z "$AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT" ]; then
    echo "❌ AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT is not set in .env.local"
    echo "   Add: AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT=your-deployment-name"
    exit 1
else
    echo "✅ AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT: $AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT"
fi

echo ""
echo "🎉 All required variables are set!"
echo ""
echo "Next: Run the full test:"
echo "  ./scripts/test-azure-tts-simple.sh"
</file>

<file path="vite.config.js">
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
  plugins: [react()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8787',
        changeOrigin: true,
      }
    },
    fs: {
      deny: ['venv/**', '.git/**']
    }
  },
  optimizeDeps: {
    // Explicitly specify entry points to avoid scanning venv
    entries: ['index.html', 'src/**/*.{js,jsx}']
  },
  build: {
    rollupOptions: {
      external: [
        /^node:/  // Exclude all Node.js built-in modules
      ],
      output: {
        manualChunks: {
          // Split vendor chunks to reduce bundle size
          vision: ['@xenova/transformers'],
          react: ['react', 'react-dom', 'react-router-dom'],
          markdown: ['react-markdown', 'remark-gfm']
        }
      }
    },
    chunkSizeWarningLimit: 1000  // Increase limit for vision models
  },
  resolve: {
    alias: {
      // Polyfill Node.js modules for browser
      'node:fs/promises': false,
      'node:path': false,
      'node:fs': false
    }
  }
});
</file>

<file path="wrangler.jsonc">
{
  // ============================================================================
  // Cloudflare Workers Configuration - Tableau (Mystic Tarot)
  // ============================================================================
  // Migrated from Pages to Workers for full Logpush support
  // Ref: https://developers.cloudflare.com/workers/wrangler/configuration/

  "name": "tableau",
  // TODO: Add your Cloudflare account ID here (required for Workers deploy)
  // Find it at: https://dash.cloudflare.com/ → select your account → copy from URL
  "account_id": "a77e479f6736120eadd99973dbeb705e",
  "compatibility_date": "2025-11-24",
  "compatibility_flags": ["nodejs_compat"],

  // Routes - uncomment and configure if you have a custom domain
  // For now, the worker will be accessible at <name>.<account>.workers.dev
  // "routes": [
  //   {
  //     "pattern": "tarot.yourdomain.com/*",
  //     "zone_name": "yourdomain.com"
  //   }
  // ],

  // Main worker entry point (unified router)
  "main": "./src/worker/index.js",

  // Static assets configuration (SPA fallback enabled)
  "assets": {
    "directory": "./dist",
    "binding": "ASSETS",
    "not_found_handling": "single-page-application"
  },

  // Enable Logpush for Workers trace events
  "logpush": true,

  // Observability
  "observability": {
    "enabled": true
  },

  // ============================================================================
  // Environment Variables (Non-Secret)
  // ============================================================================
  "vars": {
    "AZURE_OPENAI_GPT_AUDIO_MINI_FORMAT": "mp3",
    "AZURE_OPENAI_USE_V1_FORMAT": "true",
    "AZURE_OPENAI_API_VERSION": "preview",
    "AZURE_OPENAI_RESPONSES_API_VERSION": "v1"
  },

  // ============================================================================
  // D1 Database
  // ============================================================================
  "d1_databases": [
    {
      "binding": "DB",
      "database_id": "ede622bd-5845-4da9-9031-839cb26ae7be",
      "database_name": "mystic-tarot-db"
    }
  ],

  // ============================================================================
  // KV Namespaces
  // ============================================================================
  "kv_namespaces": [
    {
      "binding": "RATELIMIT",
      "id": "893bd9a5206d4719817c6c5dc0f1a409",
      "preview_id": "785db8a0b1824eb092b2a9107f9e48f3"
    },
    {
      "binding": "FEEDBACK_KV",
      "id": "ff4fb140d62a44e9bb4f5af0630bb154",
      "preview_id": "ead919e83f114ec0abd0ac1592d3e9d3"
    },
    {
      "binding": "METRICS_DB",
      "id": "2510ac5ac91e4a2fac375190a3dfc128",
      "preview_id": "8e820de09f9c459ea0e149bf55644c81"
    }
  ],

  // ============================================================================
  // R2 Buckets (for log storage and exports)
  // ============================================================================
  "r2_buckets": [
    {
      "binding": "LOGS_BUCKET",
      "bucket_name": "tarot-logs"
    }
  ],

  // ============================================================================
  // Cron Triggers (Scheduled Tasks)
  // ============================================================================
  // Archive metrics/feedback from KV to R2 and cleanup expired sessions
  "triggers": {
    "crons": [
      "0 3 * * *"
    ]
  }

  // ============================================================================
  // Secrets (set via CLI, not in config)
  // ============================================================================
  // Azure OpenAI (GPT-5 narrative generation)
  // wrangler secret put AZURE_OPENAI_ENDPOINT
  // wrangler secret put AZURE_OPENAI_API_KEY
  // wrangler secret put AZURE_OPENAI_GPT5_MODEL
  //
  // Azure AI Foundry Anthropic (Claude fallback)
  // wrangler secret put AZURE_ANTHROPIC_ENDPOINT  (e.g., https://<resource>.services.ai.azure.com/anthropic)
  // wrangler secret put AZURE_ANTHROPIC_API_KEY   (from Foundry Keys & endpoint, or falls back to AZURE_OPENAI_API_KEY)
  // wrangler secret put AZURE_ANTHROPIC_MODEL     (deployment name, default: claude-opus-4-5)
  //
  // Azure TTS
  // wrangler secret put AZURE_OPENAI_TTS_ENDPOINT
  // wrangler secret put AZURE_OPENAI_TTS_API_KEY
  // wrangler secret put AZURE_OPENAI_GPT_AUDIO_MINI_DEPLOYMENT
  //
  // Other
  // wrangler secret put VISION_PROOF_SECRET
  //
  // Admin (for manual archival trigger)
  // wrangler secret put ADMIN_API_KEY
}
</file>

</files>
