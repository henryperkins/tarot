<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Anime.js V4.3.4 - Actual API Tests</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: #1a1a2e;
      color: #eee;
      padding: 20px;
      line-height: 1.6;
    }
    h1 { color: #8b5cf6; margin-bottom: 10px; }
    .version { color: #a78bfa; margin-bottom: 30px; font-size: 14px; }
    h2 { color: #a78bfa; margin-top: 40px; border-bottom: 1px solid #333; padding-bottom: 8px; }

    .test-section {
      background: #16213e;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .test-section h3 {
      margin-top: 0;
      color: #c4b5fd;
    }
    .api-note {
      background: #1e1e3f;
      border-left: 3px solid #8b5cf6;
      padding: 10px 15px;
      margin: 10px 0;
      font-family: monospace;
      font-size: 13px;
      white-space: pre-wrap;
    }

    .test-area {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
      min-height: 120px;
      background: #0f0f23;
      border-radius: 8px;
      padding: 20px;
      margin: 15px 0;
    }

    .box {
      width: 60px;
      height: 60px;
      background: linear-gradient(135deg, #8b5cf6, #6366f1);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      color: white;
    }

    .card {
      width: 70px;
      height: 105px;
      background: linear-gradient(145deg, #1e3a5f, #0d1b2a);
      border: 2px solid #8b5cf6;
      border-radius: 8px;
      position: absolute;
      left: 50%;
      bottom: 20px;
      transform-origin: center bottom;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      text-align: center;
      color: #a78bfa;
    }

    .card-container {
      position: relative;
      width: 100%;
      height: 160px;
    }

    .text-container {
      font-size: 18px;
      color: #e2e8f0;
    }

    button {
      background: #8b5cf6;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.2s;
    }
    button:hover { background: #7c3aed; }
    button:disabled { background: #4c4c6d; cursor: not-allowed; }

    .result {
      margin-top: 10px;
      padding: 10px;
      background: #0d1b2a;
      border-radius: 6px;
      font-family: monospace;
      font-size: 13px;
      white-space: pre-wrap;
      max-height: 200px;
      overflow-y: auto;
    }
    .result.success { border-left: 3px solid #22c55e; }
    .result.error { border-left: 3px solid #ef4444; }
    .result.pending { border-left: 3px solid #eab308; }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }
  </style>
</head>
<body>
  <h1>Anime.js V4.3.4 - Actual API Tests</h1>
  <div class="version">Testing the real V4 API (different from V3 docs!)</div>

  <!-- API Discovery -->
  <div class="test-section">
    <h3>Discovered V4 API (from npm install animejs@4.3.4)</h3>
    <div class="api-note">// Correct V4 imports:
import {
  animate,           // Main animation function
  createTimeline,    // NOT 'timeline'
  createSpring,      // Spring easing factory
  stagger,           // Stagger utility
  splitText,         // Text splitting (top-level!)
  set,               // Instant property setter
  utils,             // Utility functions
  eases,             // Easing presets object
  svg,               // SVG utilities: morphTo, createDrawable
  waapi,             // Web Animations API wrapper
} from 'animejs';

// Easing names (no 'ease' prefix!):
// eases.outQuad, eases.inOutCubic, etc.
// OR use string: 'outQuad', 'inOutCubic'</div>
  </div>

  <!-- Test 1: Basic animate with V4 syntax -->
  <div class="test-section">
    <h3>Test 1: animate() - Basic transforms</h3>
    <div class="api-note">animate(targets, {
  translateX: 250,
  rotate: '1turn',
  duration: 800,
  ease: 'outQuad'  // V4: no 'easing' prefix in string
});</div>
    <div class="controls">
      <button onclick="runTest1()">Run Test</button>
      <button onclick="resetTest1()">Reset</button>
    </div>
    <div class="test-area">
      <div class="box" id="test1-box">1</div>
    </div>
    <div class="result pending" id="test1-result">Pending...</div>
  </div>

  <!-- Test 2: CSS filter -->
  <div class="test-section">
    <h3>Test 2: CSS filter property</h3>
    <div class="api-note">animate(target, {
  filter: ['blur(0px)', 'blur(10px)', 'blur(0px)'],
  duration: 1500
});</div>
    <div class="controls">
      <button onclick="runTest2()">Run Test</button>
      <button onclick="resetTest2()">Reset</button>
    </div>
    <div class="test-area">
      <div class="box" id="test2-box">2</div>
    </div>
    <div class="result pending" id="test2-result">Pending...</div>
  </div>

  <!-- Test 3: createSpring -->
  <div class="test-section">
    <h3>Test 3: createSpring() - Spring physics</h3>
    <div class="api-note">import { createSpring } from 'animejs';

const springEase = createSpring({ stiffness: 100, damping: 10, mass: 1 });

animate(target, {
  translateX: 200,
  ease: springEase
});</div>
    <div class="controls">
      <button onclick="runTest3()">Run Test</button>
      <button onclick="resetTest3()">Reset</button>
    </div>
    <div class="test-area">
      <div class="box" id="test3-box">3</div>
    </div>
    <div class="result pending" id="test3-result">Pending...</div>
  </div>

  <!-- Test 4: stagger -->
  <div class="test-section">
    <h3>Test 4: stagger() - Staggered delays</h3>
    <div class="api-note">import { stagger } from 'animejs';

animate(targets, {
  translateY: [-30, 0],
  opacity: [0, 1],
  delay: stagger(100),            // Simple stagger
  // OR
  delay: stagger(100, { from: 'center' })
});</div>
    <div class="controls">
      <button onclick="runTest4()">Run Test</button>
      <button onclick="resetTest4()">Reset</button>
    </div>
    <div class="test-area">
      <div class="box test4-box">1</div>
      <div class="box test4-box">2</div>
      <div class="box test4-box">3</div>
      <div class="box test4-box">4</div>
      <div class="box test4-box">5</div>
    </div>
    <div class="result pending" id="test4-result">Pending...</div>
  </div>

  <!-- Test 5: createTimeline -->
  <div class="test-section">
    <h3>Test 5: createTimeline() - Sequencing</h3>
    <div class="api-note">import { createTimeline } from 'animejs';

const tl = createTimeline({
  defaults: { duration: 500, ease: 'outExpo' }
});

tl.add(target1, { translateX: 150 })
  .add(target2, { translateX: 150 }, '-=300')  // Overlap
  .add(target3, { translateX: 150 }, '+=100'); // Delay</div>
    <div class="controls">
      <button onclick="runTest5()">Run Test</button>
      <button onclick="resetTest5()">Reset</button>
    </div>
    <div class="test-area">
      <div class="box test5-box" data-idx="1">A</div>
      <div class="box test5-box" data-idx="2">B</div>
      <div class="box test5-box" data-idx="3">C</div>
    </div>
    <div class="result pending" id="test5-result">Pending...</div>
  </div>

  <!-- Test 6: Completion handling -->
  <div class="test-section">
    <h3>Test 6: Completion - callbacks and promises</h3>
    <div class="api-note">// Callback style
animate(target, {
  translateX: 100,
  onComplete: (anim) => console.log('Done!')
});

// Promise style (if available)
const anim = animate(target, { translateX: 100 });
await anim.finished;  // or anim.then()</div>
    <div class="controls">
      <button onclick="runTest6()">Run Test</button>
      <button onclick="resetTest6()">Reset</button>
    </div>
    <div class="test-area">
      <div class="box" id="test6-box">6</div>
    </div>
    <div class="result pending" id="test6-result">Pending...</div>
  </div>

  <!-- Test 7: Function values for card fan -->
  <div class="test-section">
    <h3>Test 7: Function values - Card fan effect</h3>
    <div class="api-note">animate(cards, {
  translateX: (el, i, total) => {
    const normalized = (2 * i / (total - 1)) - 1;
    return normalized * 120;
  },
  translateY: (el, i, total) => {
    const normalized = (2 * i / (total - 1)) - 1;
    return -Math.abs(normalized) * 20;
  },
  rotate: (el, i, total) => {
    const normalized = (2 * i / (total - 1)) - 1;
    return normalized * 15;
  },
  delay: stagger(50)
});</div>
    <div class="controls">
      <button onclick="runTest7()">Run Test</button>
      <button onclick="resetTest7()">Reset</button>
    </div>
    <div class="test-area">
      <div class="card-container" id="test7-container">
        <div class="card test7-card">Card 1</div>
        <div class="card test7-card">Card 2</div>
        <div class="card test7-card">Card 3</div>
        <div class="card test7-card">Card 4</div>
        <div class="card test7-card">Card 5</div>
      </div>
    </div>
    <div class="result pending" id="test7-result">Pending...</div>
  </div>

  <!-- Test 8: splitText -->
  <div class="test-section">
    <h3>Test 8: splitText() - Text animation</h3>
    <div class="api-note">import { splitText, animate, stagger } from 'animejs';

// V4: splitText is a top-level export
const chars = splitText(element, { by: 'char' });
const words = splitText(element, { by: 'word' });

animate(words, {
  opacity: [0, 1],
  translateY: [20, 0],
  delay: stagger(80)
});</div>
    <div class="controls">
      <button onclick="runTest8()">Run Test</button>
      <button onclick="resetTest8()">Reset</button>
    </div>
    <div class="test-area">
      <div class="text-container" id="test8-text">The cards reveal your path forward.</div>
    </div>
    <div class="result pending" id="test8-result">Pending...</div>
  </div>

  <!-- Test 9: set() -->
  <div class="test-section">
    <h3>Test 9: set() - Instant properties</h3>
    <div class="api-note">import { set } from 'animejs';

// Set properties without animation
set(target, {
  translateX: 100,
  rotate: 45,
  opacity: 0.5
});</div>
    <div class="controls">
      <button onclick="runTest9()">Run Test</button>
      <button onclick="resetTest9()">Reset</button>
    </div>
    <div class="test-area">
      <div class="box" id="test9-box">9</div>
    </div>
    <div class="result pending" id="test9-result">Pending...</div>
  </div>

  <!-- Test 10: Ink-spread reveal (Card.jsx pattern) -->
  <div class="test-section">
    <h3>Test 10: Card reveal animation (ink-spread)</h3>
    <div class="api-note">const tl = createTimeline();

// Phase 1: Blur out
tl.add(card, {
  rotateY: 90,
  opacity: 0.6,
  scale: 0.95,
  filter: 'blur(8px)',
  duration: 350,
  ease: 'inQuad'
});

// Phase 2: Content swap + spread in
tl.add(card, {
  rotateY: 0,
  opacity: 1,
  scale: 1,
  filter: 'blur(0px)',
  duration: 400,
  ease: 'outQuart',
  onBegin: () => swapContent()
});</div>
    <div class="controls">
      <button onclick="runTest10()">Run Test</button>
      <button onclick="resetTest10()">Reset</button>
    </div>
    <div class="test-area">
      <div class="box" id="test10-box" style="width: 80px; height: 120px; background: #2d1b4e;">
        <span id="test10-content">Back</span>
      </div>
    </div>
    <div class="result pending" id="test10-result">Pending...</div>
  </div>

  <!-- Test 11: Playback controls -->
  <div class="test-section">
    <h3>Test 11: Playback controls</h3>
    <div class="api-note">const anim = animate(target, { translateX: 300, duration: 3000 });

anim.play();      // Start/resume
anim.pause();     // Pause
anim.restart();   // Restart
anim.reverse();   // Reverse direction
anim.seek(1500);  // Seek to time (ms)
anim.seek('50%'); // Seek to percentage</div>
    <div class="controls">
      <button onclick="runTest11()">Start</button>
      <button onclick="test11Pause()">Pause</button>
      <button onclick="test11Play()">Play</button>
      <button onclick="test11Reverse()">Reverse</button>
      <button onclick="test11Seek()">Seek 50%</button>
      <button onclick="test11Restart()">Restart</button>
    </div>
    <div class="test-area">
      <div class="box" id="test11-box">11</div>
    </div>
    <div class="result pending" id="test11-result">Pending...</div>
  </div>

  <!-- Load Anime.js V4 via Vite -->
  <script type="module">
    // Import via Vite's module resolution
    import * as anime from 'animejs';

    // Log all exports for debugging
    console.log('Anime.js V4 exports:', Object.keys(anime));

    // Make available globally
    window.anime = anime;
    window.testAnimations = {};

    // Helper
    window.setResult = (id, status, message) => {
      const el = document.getElementById(id);
      el.className = `result ${status}`;
      el.textContent = message;
    };

    // ========== TEST 1: Basic animate ==========
    window.runTest1 = () => {
      try {
        anime.animate('#test1-box', {
          translateX: 250,
          rotate: '1turn',
          scale: 1.2,
          opacity: [1, 0.5, 1],
          duration: 1000,
          ease: 'outQuad'
        });
        setResult('test1-result', 'success', 'SUCCESS: animate() works\nUsed ease: "outQuad" (not "easeOutQuad")');
      } catch (e) {
        setResult('test1-result', 'error', `ERROR: ${e.message}\n${e.stack}`);
      }
    };
    window.resetTest1 = () => {
      anime.set('#test1-box', { translateX: 0, rotate: 0, scale: 1, opacity: 1 });
      setResult('test1-result', 'pending', 'Reset');
    };

    // ========== TEST 2: CSS filter ==========
    window.runTest2 = () => {
      try {
        const anim = anime.animate('#test2-box', {
          filter: ['blur(0px)', 'blur(10px)', 'blur(0px)'],
          duration: 1500,
          ease: 'inOutQuad',
          onComplete: () => {
            setResult('test2-result', 'success', 'SUCCESS: CSS filter animation works!\nfilter: ["blur(0px)", "blur(10px)", "blur(0px)"]');
          }
        });
        setResult('test2-result', 'pending', 'Running filter animation...');
      } catch (e) {
        setResult('test2-result', 'error', `ERROR: ${e.message}`);
      }
    };
    window.resetTest2 = () => {
      anime.set('#test2-box', { filter: 'blur(0px)' });
      setResult('test2-result', 'pending', 'Reset');
    };

    // ========== TEST 3: createSpring ==========
    window.runTest3 = () => {
      try {
        const springEase = anime.createSpring({ stiffness: 100, damping: 10, mass: 1 });
        console.log('Spring ease:', springEase);

        anime.animate('#test3-box', {
          translateX: 200,
          ease: springEase,
          onComplete: () => {
            setResult('test3-result', 'success', 'SUCCESS: createSpring() works!\ncreateSpring({ stiffness: 100, damping: 10, mass: 1 })');
          }
        });
        setResult('test3-result', 'pending', 'Running spring animation...');
      } catch (e) {
        setResult('test3-result', 'error', `ERROR: ${e.message}\n${e.stack}`);
      }
    };
    window.resetTest3 = () => {
      anime.set('#test3-box', { translateX: 0 });
      setResult('test3-result', 'pending', 'Reset');
    };

    // ========== TEST 4: stagger ==========
    window.runTest4 = () => {
      try {
        // First set initial state
        anime.set('.test4-box', { translateY: -30, opacity: 0, scale: 0.5 });

        anime.animate('.test4-box', {
          translateY: 0,
          opacity: 1,
          scale: 1,
          delay: anime.stagger(100, { from: 'center' }),
          duration: 600,
          ease: 'outElastic(1, 0.5)',
          onComplete: () => {
            setResult('test4-result', 'success', 'SUCCESS: stagger() works!\ndelay: stagger(100, { from: "center" })');
          }
        });
        setResult('test4-result', 'pending', 'Running stagger animation...');
      } catch (e) {
        setResult('test4-result', 'error', `ERROR: ${e.message}`);
      }
    };
    window.resetTest4 = () => {
      anime.set('.test4-box', { translateY: 0, opacity: 1, scale: 1 });
      setResult('test4-result', 'pending', 'Reset');
    };

    // ========== TEST 5: createTimeline ==========
    window.runTest5 = () => {
      try {
        const tl = anime.createTimeline({
          defaults: {
            duration: 500,
            ease: 'outExpo'
          },
          onComplete: () => {
            setResult('test5-result', 'success', 'SUCCESS: createTimeline() works!\nUsed .add() with "-=300" offset');
          }
        });

        const boxes = document.querySelectorAll('.test5-box');

        tl.add(boxes[0], { translateX: 150, backgroundColor: '#22c55e' })
          .add(boxes[1], { translateX: 150, backgroundColor: '#eab308' }, '-=300')
          .add(boxes[2], { translateX: 150, backgroundColor: '#ef4444' }, '-=300');

        setResult('test5-result', 'pending', 'Running timeline...');
      } catch (e) {
        setResult('test5-result', 'error', `ERROR: ${e.message}\n${e.stack}`);
      }
    };
    window.resetTest5 = () => {
      anime.set('.test5-box', { translateX: 0, backgroundColor: '' });
      setResult('test5-result', 'pending', 'Reset');
    };

    // ========== TEST 6: Promise ==========
    window.runTest6 = async () => {
      try {
        setResult('test6-result', 'pending', 'Testing completion methods...');
        const logs = [];

        // Test callback
        const anim1 = anime.animate('#test6-box', {
          translateX: 100,
          duration: 400,
          ease: 'outQuad',
          onComplete: () => logs.push('onComplete callback fired')
        });

        // Check what completion API exists
        logs.push(`anim.finished exists: ${!!anim1.finished}`);
        logs.push(`anim.then exists: ${typeof anim1.then === 'function'}`);
        logs.push(`anim.promise exists: ${!!anim1.promise}`);

        // Try to await
        if (anim1.finished) {
          await anim1.finished;
          logs.push('await anim.finished succeeded');
        } else if (typeof anim1.then === 'function') {
          await anim1;
          logs.push('await anim (thenable) succeeded');
        }

        // Second animation
        const anim2 = anime.animate('#test6-box', {
          translateY: 30,
          duration: 400,
          ease: 'outQuad'
        });

        if (anim2.finished) {
          await anim2.finished;
        }

        setResult('test6-result', 'success', 'SUCCESS: Completion handling works!\n\n' + logs.join('\n'));
      } catch (e) {
        setResult('test6-result', 'error', `ERROR: ${e.message}\n${e.stack}`);
      }
    };
    window.resetTest6 = () => {
      anime.set('#test6-box', { translateX: 0, translateY: 0 });
      setResult('test6-result', 'pending', 'Reset');
    };

    // ========== TEST 7: Function values - Card fan ==========
    window.runTest7 = () => {
      try {
        const cards = document.querySelectorAll('.test7-card');
        const total = cards.length;

        // Set initial stacked position
        anime.set('.test7-card', {
          translateX: '-50%',
          translateY: 0,
          rotate: 0,
          scale: 1,
          opacity: 1
        });

        anime.animate('.test7-card', {
          translateX: (el, i) => {
            const normalized = (2 * i / (total - 1)) - 1;
            return `calc(-50% + ${normalized * 100}px)`;
          },
          translateY: (el, i) => {
            const normalized = (2 * i / (total - 1)) - 1;
            return -Math.abs(normalized) * 25;
          },
          rotate: (el, i) => {
            const normalized = (2 * i / (total - 1)) - 1;
            return normalized * 12;
          },
          scale: (el, i) => {
            const normalized = (2 * i / (total - 1)) - 1;
            return 1 - Math.abs(normalized) * 0.05;
          },
          delay: anime.stagger(60, { start: 100 }),
          duration: 400,
          ease: 'outQuart',
          onComplete: () => {
            setResult('test7-result', 'success', 'SUCCESS: Function values work!\nCreated card fan with per-element transforms');
          }
        });
        setResult('test7-result', 'pending', 'Running card fan animation...');
      } catch (e) {
        setResult('test7-result', 'error', `ERROR: ${e.message}\n${e.stack}`);
      }
    };
    window.resetTest7 = () => {
      anime.set('.test7-card', {
        translateX: '-50%',
        translateY: 0,
        rotate: 0,
        scale: 1
      });
      setResult('test7-result', 'pending', 'Reset');
    };

    // ========== TEST 8: splitText ==========
    window.runTest8 = () => {
      try {
        const container = document.getElementById('test8-text');
        const logs = [];

        // Check if splitText exists
        logs.push(`splitText exists: ${typeof anime.splitText === 'function'}`);

        if (typeof anime.splitText === 'function') {
          // Reset content first
          container.textContent = 'The cards reveal your path forward.';

          const result = anime.splitText(container, { by: 'word' });
          logs.push(`splitText returned: ${typeof result}`);
          logs.push(`Result is array: ${Array.isArray(result)}`);
          logs.push(`Result length: ${result?.length || 'N/A'}`);

          // Set initial state
          anime.set(result, { opacity: 0, translateY: 20 });

          anime.animate(result, {
            opacity: 1,
            translateY: 0,
            delay: anime.stagger(80),
            duration: 400,
            ease: 'outQuad',
            onComplete: () => {
              setResult('test8-result', 'success', 'SUCCESS: splitText() works!\n\n' + logs.join('\n'));
            }
          });
        } else {
          // Manual fallback
          logs.push('splitText not found, using manual split');
          const text = container.textContent;
          // Escape HTML to prevent XSS
          const escapeHtml = (str) => str.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[c]);
          container.innerHTML = text.split(' ').map(word =>
            `<span style="display:inline-block;opacity:0;transform:translateY(20px)">${escapeHtml(word)}&nbsp;</span>`
          ).join('');

          anime.animate('#test8-text span', {
            opacity: 1,
            translateY: 0,
            delay: anime.stagger(80),
            duration: 400,
            ease: 'outQuad',
            onComplete: () => {
              setResult('test8-result', 'success', 'Manual text split fallback worked\n\n' + logs.join('\n'));
            }
          });
        }
        setResult('test8-result', 'pending', 'Testing splitText...\n' + logs.join('\n'));
      } catch (e) {
        setResult('test8-result', 'error', `ERROR: ${e.message}\n${e.stack}`);
      }
    };
    window.resetTest8 = () => {
      document.getElementById('test8-text').textContent = 'The cards reveal your path forward.';
      setResult('test8-result', 'pending', 'Reset');
    };

    // ========== TEST 9: set() ==========
    window.runTest9 = () => {
      try {
        anime.set('#test9-box', {
          translateX: 100,
          rotate: 45,
          scale: 1.3,
          backgroundColor: '#22c55e'
        });
        setResult('test9-result', 'success', 'SUCCESS: set() works!\nInstantly applied transforms and color');
      } catch (e) {
        setResult('test9-result', 'error', `ERROR: ${e.message}`);
      }
    };
    window.resetTest9 = () => {
      anime.set('#test9-box', { translateX: 0, rotate: 0, scale: 1, backgroundColor: '' });
      setResult('test9-result', 'pending', 'Reset');
    };

    // ========== TEST 10: Ink-spread reveal ==========
    window.runTest10 = () => {
      try {
        const box = document.getElementById('test10-box');
        const content = document.getElementById('test10-content');
        content.textContent = 'Back';
        box.style.background = '#2d1b4e';

        const tl = anime.createTimeline({
          onComplete: () => {
            setResult('test10-result', 'success', 'SUCCESS: Ink-spread reveal works!\nTimeline with filter, rotateY, scale');
          }
        });

        // Phase 1: Blur out
        tl.add(box, {
          rotateY: 90,
          opacity: 0.6,
          scale: 0.95,
          filter: 'blur(8px)',
          duration: 350,
          ease: 'inQuad'
        });

        // Phase 2: Swap content and spread in
        tl.add(box, {
          rotateY: 0,
          opacity: 1,
          scale: 1,
          filter: 'blur(0px)',
          duration: 400,
          ease: 'outQuart',
          onBegin: () => {
            content.textContent = 'Front!';
            box.style.background = 'linear-gradient(135deg, #8b5cf6, #6366f1)';
          }
        });

        setResult('test10-result', 'pending', 'Running ink-spread reveal...');
      } catch (e) {
        setResult('test10-result', 'error', `ERROR: ${e.message}\n${e.stack}`);
      }
    };
    window.resetTest10 = () => {
      const box = document.getElementById('test10-box');
      const content = document.getElementById('test10-content');
      anime.set(box, { rotateY: 0, opacity: 1, scale: 1, filter: 'blur(0px)' });
      content.textContent = 'Back';
      box.style.background = '#2d1b4e';
      setResult('test10-result', 'pending', 'Reset');
    };

    // ========== TEST 11: Playback controls ==========
    window.runTest11 = () => {
      try {
        window.testAnimations.test11 = anime.animate('#test11-box', {
          translateX: 300,
          duration: 3000,
          ease: 'linear',
          autoplay: true,
          onUpdate: (anim) => {
            const progress = anim.progress !== undefined ? anim.progress : 'N/A';
            setResult('test11-result', 'pending', `Progress: ${typeof progress === 'number' ? Math.round(progress * 100) + '%' : progress}`);
          },
          onComplete: () => {
            setResult('test11-result', 'success', 'Animation complete!');
          }
        });

        // Log available methods
        const methods = ['play', 'pause', 'restart', 'reverse', 'seek'];
        console.log('Available playback methods:');
        methods.forEach(m => console.log(`  ${m}: ${typeof window.testAnimations.test11[m]}`));
      } catch (e) {
        setResult('test11-result', 'error', `ERROR: ${e.message}`);
      }
    };
    window.test11Pause = () => {
      window.testAnimations.test11?.pause();
      setResult('test11-result', 'pending', 'Paused');
    };
    window.test11Play = () => {
      window.testAnimations.test11?.play();
    };
    window.test11Reverse = () => {
      window.testAnimations.test11?.reverse();
      setResult('test11-result', 'pending', 'Reversed');
    };
    window.test11Seek = () => {
      window.testAnimations.test11?.seek(1500);
      setResult('test11-result', 'pending', 'Seeked to 1500ms');
    };
    window.test11Restart = () => {
      window.testAnimations.test11?.restart();
    };

    // Initial log
    console.log('Tests loaded. Anime.js V4 detected.');
    console.log('Available exports:', Object.keys(anime).join(', '));
  </script>
</body>
</html>
